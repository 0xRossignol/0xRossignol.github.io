<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>分类: OS - MyBlog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="MyBlog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="MyBlog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="MyBlog"><meta property="og:url" content="http://example.com/"><meta property="og:site_name" content="MyBlog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:author" content="Rossignol"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"MyBlog","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"Rossignol"},"publisher":{"@type":"Organization","name":"MyBlog","logo":{"@type":"ImageObject","url":"http://example.com/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="MyBlog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/0xRossignol"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories/">分类</a></li><li class="is-active"><a href="#" aria-current="page">OS</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-02-24T08:24:55.000Z" title="2025/2/24 16:24:55">2025-02-24</time>发表</span><span class="level-item"><time dateTime="2025-02-25T09:29:17.389Z" title="2025/2/25 17:29:17">2025-02-25</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/OS/">OS</a><span> / </span><a class="link-muted" href="/categories/Linux/">Linux</a><span> / </span><a class="link-muted" href="/categories/Linux/Arch-Linux/">Arch Linux</a></span><span class="level-item">41 分钟读完 (大约6212个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/02/24/Arch%20Linux/arch-install/">Arch Install</a></p><div class="content"><h1 id="1-安装前的准备"><a href="#1-安装前的准备" class="headerlink" title="1. 安装前的准备"></a>1. 安装前的准备</h1><p>根据 <strong>Arch Wiki</strong> 和 <strong>ChatGPT</strong> 所给的内容安装 <strong>Arch Linux</strong></p>
<h2 id="1-1-配置控制台键盘布局和字体"><a href="#1-1-配置控制台键盘布局和字体" class="headerlink" title="1.1 配置控制台键盘布局和字体"></a>1.1 配置控制台键盘布局和字体</h2><p>由于默认字体太小，本次安装使用适合 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/HiDPI#Linux_console_(tty)">HiDPI 屏幕</a>[^hdpi]的最大字体之一 —— <code>ter-132b</code> 进行安装</p>
<p>[^hdpi]:HiDPI（High Dots Per Inch）显示器，指的是在较小尺寸下却拥有较高分辨率的显示器。Apple 将其称作“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Retina_Display">视网膜屏幕</a>”，这项技术主要存在于高端笔记本电脑和显示器中。</p>
<p>要修改控制台字体，只需运行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">setfont ter-132b</span></span><br></pre></td></tr></table></figure>

<p>命令即可。</p>
<h2 id="1-2-切换UEFI模式安装"><a href="#1-2-切换UEFI模式安装" class="headerlink" title="1.2 切换UEFI模式安装"></a>1.2 切换UEFI模式安装</h2><p>VMware默认安装模式为 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/BIOS"><em>Legacy BIOS</em></a> ，与Arch Wiki不符，故改为 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%B5%B1%E4%B8%80%E5%8F%AF%E5%BB%B6%E4%BC%B8%E9%9F%8C%E9%AB%94%E4%BB%8B%E9%9D%A2"><em>UEFI模式</em></a> 进行安装。</p>
<p>只需在VMware设置中修改即可。</p>
<p>以下内容由ChatGPT提供：</p>
<h3 id="如何确认引导模式？"><a href="#如何确认引导模式？" class="headerlink" title="如何确认引导模式？"></a><strong>如何确认引导模式？</strong></h3><p>你可以使用以下方法确认系统是以 <strong>BIOS</strong> 还是 <strong>UEFI</strong> 启动的：</p>
<h4 id="方法-1：检查-sys-firmware-efi"><a href="#方法-1：检查-sys-firmware-efi" class="headerlink" title="方法 1：检查 /sys/firmware/efi/"></a><strong>方法 1：检查 <code>/sys/firmware/efi/</code></strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /sys/firmware/efi</span><br></pre></td></tr></table></figure>

<p>如果目录不存在，就说明是 <strong>Legacy BIOS 模式</strong>。</p>
<h4 id="方法-2：使用-efivar-命令（仅适用于-UEFI）"><a href="#方法-2：使用-efivar-命令（仅适用于-UEFI）" class="headerlink" title="方法 2：使用 efivar 命令（仅适用于 UEFI）"></a><strong>方法 2：使用 <code>efivar</code> 命令（仅适用于 UEFI）</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">efivar -l</span><br></pre></td></tr></table></figure>

<p>如果 <code>efivar</code> 命令不可用，或者返回 **”No such file or directory”**，说明系统是 <strong>Legacy BIOS 模式</strong>。</p>
<h4 id="方法-3：使用-dmesg-命令"><a href="#方法-3：使用-dmesg-命令" class="headerlink" title="方法 3：使用 dmesg 命令"></a><strong>方法 3：使用 <code>dmesg</code> 命令</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | grep -i efi</span><br></pre></td></tr></table></figure>

<p>如果系统是 <strong>UEFI</strong>，会输出一些 EFI 相关的日志。如果没有任何输出，则是 <strong>Legacy BIOS</strong>。</p>
<h2 id="1-3-验证引导模式"><a href="#1-3-验证引导模式" class="headerlink" title="1.3 验证引导模式"></a>1.3 验证引导模式</h2><p>要验证系统目前的引导模式，请检查 UEFI 位数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> /sys/firmware/efi/fw_platform_size</span></span><br></pre></td></tr></table></figure>

<p>如果命令结果为 <code>64</code>，则系统是以 UEFI 模式引导且使用 64 位 x64 UEFI。如果命令结果为 <code>32</code>，则系统是以 UEFI 模式引导且使用 32 位 IA32 UEFI，虽然其受支持，但引导加载程序只能使用 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Systemd-boot">systemd-boot</a>和<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/GRUB">GRUB</a>。如果文件不存在，则系统可能是以<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/BIOS">BIOS</a>模式（或 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Compatibility_Support_Module">CSM</a> 模式）(这两种模式通常出现在<strong>老旧</strong>的电脑或<strong>未经配置的虚拟机</strong>上）引导。如果系统没有以您想要的模式（UEFI 或 BIOS）引导启动，请您参考自己的计算机或主板说明书。</p>
<h2 id="1-4-连接到互联网"><a href="#1-4-连接到互联网" class="headerlink" title="1.4 连接到互联网"></a>1.4 连接到互联网</h2><p>要在 Live 环境中配置网络连接，请遵循以下步骤：</p>
<ol>
<li><p>确保系统已经列出并启用了</p>
<p>网络接口，用 <a target="_blank" rel="noopener" href="https://man.archlinux.org/man/ip-link.8">ip-link(8) </a>检查：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ip <span class="built_in">link</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对于无线局域网（Wi-Fi）和无线广域网（WWAN），请确保网卡未被 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Rfkill">rfkill</a> 禁用。</p>
</li>
<li><p>连接到网络：</p>
<ul>
<li>有线以太网——连接网线。</li>
<li>WiFi——使用 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Iwd#iwctl">iwctl</a> 认证无线网络。</li>
<li>移动宽带调制解调器（移动网卡） - 使用 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wzh/index.php?title=Mmcli&action=edit&redlink=1">mmcli</a> 连接到移动网络。</li>
</ul>
</li>
<li><p>配置网络连接：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE#DHCP">DHCP</a>：对于有线以太网、无线局域网（WLAN）和无线广域网（WWAN）网络接口来说，动态 IP 地址和 DNS 服务器分配（由 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Systemd-networkd">systemd-networkd</a> 和 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Systemd-resolved">systemd-resolved</a> 提供功能）能够开箱即用。</li>
<li>静态 IP 地址：按照<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE#%E9%9D%99%E6%80%81_IP_%E5%9C%B0%E5%9D%80">网络配置#静态 IP 地址</a>进行操作。</li>
</ul>
</li>
<li><p>用 <strong>ping</strong> 检查网络连接：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ping archlinux.org</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>由于是通过VMware安装，网络连接已经配置好了。</p>
<h2 id="1-5-更新系统时间"><a href="#1-5-更新系统时间" class="headerlink" title="1.5 更新系统时间"></a>1.5 更新系统时间</h2><p>在 Live 环境中 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Systemd-timesyncd">systemd-timesyncd</a> 默认启用，也就是说当系统已经创建互联网连接后，系统时间将自动同步。</p>
<p>使用 <a target="_blank" rel="noopener" href="https://man.archlinux.org/man/timedatectl.1">timedatectl(1)</a> 确保系统时间是同步的，建议提前执行 <code>timedatectl set-timezone *地区/城市*</code>（中国用户可以使用 <code>timedatectl set-timezone Asia/Shanghai</code> 以设置北京时间）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">timedatectl</span></span><br></pre></td></tr></table></figure>

<h2 id="1-6-创建硬盘分区"><a href="#1-6-创建硬盘分区" class="headerlink" title="1.6 创建硬盘分区"></a>1.6 创建硬盘分区</h2><p>在 Arch Linux 安装过程中，你需要先对硬盘进行分区。你可以使用 <code>fdisk</code> 或 <code>cfdisk</code> 等工具。</p>
<h3 id="方法-1：使用-fdisk（推荐）"><a href="#方法-1：使用-fdisk（推荐）" class="headerlink" title="方法 1：使用 fdisk（推荐）"></a><strong>方法 1：使用 <code>fdisk</code>（推荐）</strong></h3><p><code>fdisk</code> 是命令行工具，适合对磁盘进行精确控制。</p>
<h4 id="1-查看磁盘"><a href="#1-查看磁盘" class="headerlink" title="1. 查看磁盘"></a><strong>1. 查看磁盘</strong></h4><p>先列出所有磁盘：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsblk</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l</span><br></pre></td></tr></table></figure>

<p>找到你的目标磁盘，例如 <code>/dev/sda</code>（注意：<strong>不要选错磁盘</strong>）。</p>
<h4 id="2-进入-fdisk"><a href="#2-进入-fdisk" class="headerlink" title="2. 进入 fdisk"></a><strong>2. 进入 <code>fdisk</code></strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk /dev/sda</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li><code>/dev/sda</code> 是你的目标磁盘，可能需要改成 <code>/dev/nvme0n1</code> 或 <code>/dev/vda</code>，根据实际情况调整。</li>
</ul>
<h4 id="3-删除现有分区（如果需要）"><a href="#3-删除现有分区（如果需要）" class="headerlink" title="3. 删除现有分区（如果需要）"></a><strong>3. 删除现有分区（如果需要）</strong></h4><p>如果磁盘上已有分区，可以输入 <code>d</code> 并选择要删除的分区，重复此操作直到所有旧分区删除完毕。</p>
<h4 id="4-创建新分区"><a href="#4-创建新分区" class="headerlink" title="4. 创建新分区"></a><strong>4. 创建新分区</strong></h4><p>按照 UEFI 或 BIOS 模式进行分区：</p>
<h5 id="UEFI-模式（推荐）"><a href="#UEFI-模式（推荐）" class="headerlink" title="UEFI 模式（推荐）"></a><strong>UEFI 模式（推荐）</strong></h5><ol>
<li><p>创建 </p>
<p>EFI 分区</p>
<p>（512MB，类型 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EFI System</span><br></pre></td></tr></table></figure>

<p>）：</p>
<ul>
<li>输入 <code>n</code>（新建分区）</li>
<li>选择 <code>1</code></li>
<li><code>First sector</code>：默认回车</li>
<li><code>Last sector</code>：输入 <code>+512M</code></li>
<li>输入 <code>t</code>（修改类型），然后输入 <code>1</code>（EFI System）</li>
</ul>
</li>
<li><p>创建 </p>
<p>Swap 分区</p>
<p>（可选，4GB+）：</p>
<ul>
<li>输入 <code>n</code>，选择 <code>2</code></li>
<li><code>First sector</code>：默认回车</li>
<li><code>Last sector</code>：输入 <code>+4G</code>（根据需要调整）</li>
<li>输入 <code>t</code>，选择 <code>2</code>，然后输入 <code>19</code>（Linux swap）</li>
</ul>
</li>
<li><p>创建 </p>
<p>根分区（剩余空间）</p>
<p>：</p>
<ul>
<li>输入 <code>n</code>，选择 <code>3</code></li>
<li><code>First sector</code>：默认回车</li>
<li><code>Last sector</code>：默认回车（使用剩余空间）</li>
</ul>
</li>
</ol>
<h5 id="Legacy-BIOS-模式"><a href="#Legacy-BIOS-模式" class="headerlink" title="Legacy BIOS 模式"></a><strong>Legacy BIOS 模式</strong></h5><ol>
<li><p>创建 </p>
<p>主分区（整个磁盘）</p>
<p>：</p>
<ul>
<li>输入 <code>n</code>，选择 <code>1</code></li>
<li><code>First sector</code>：默认回车</li>
<li><code>Last sector</code>：默认回车（使用整个磁盘）</li>
</ul>
</li>
<li><p>创建 </p>
<p>Swap 分区（可选，4GB+）</p>
<p>：</p>
<ul>
<li>输入 <code>n</code>，选择 <code>2</code></li>
<li><code>First sector</code>：默认回车</li>
<li><code>Last sector</code>：输入 <code>+4G</code></li>
<li>输入 <code>t</code>，选择 <code>2</code>，然后输入 <code>82</code>（Linux swap）</li>
</ul>
</li>
</ol>
<h4 id="5-写入分区表并退出"><a href="#5-写入分区表并退出" class="headerlink" title="5. 写入分区表并退出"></a><strong>5. 写入分区表并退出</strong></h4><p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CopyEdit</span><br><span class="line">w</span><br></pre></td></tr></table></figure>

<p>这样磁盘分区就完成了！</p>
<hr>
<h3 id="方法-2：使用-cfdisk（简单易用）"><a href="#方法-2：使用-cfdisk（简单易用）" class="headerlink" title="方法 2：使用 cfdisk（简单易用）"></a><strong>方法 2：使用 <code>cfdisk</code>（简单易用）</strong></h3><p>如果你更喜欢图形界面：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cfdisk /dev/sda</span><br></pre></td></tr></table></figure>

<ol>
<li><p>选择 </p>
<p>分区表类型</p>
<p>：</p>
<ul>
<li><strong>UEFI 模式</strong> 选择 <code>gpt</code></li>
<li><strong>BIOS 模式</strong> 选择 <code>dos</code></li>
</ul>
</li>
<li><p>选择 <code>New</code> 创建分区，按照上面的 UEFI 或 BIOS 分区方案进行操作。</p>
</li>
<li><p>选择 <code>Write</code> 并确认写入分区表。</p>
</li>
<li><p>选择 <code>Quit</code> 退出。</p>
</li>
</ol>
<hr>
<h3 id="格式化分区"><a href="#格式化分区" class="headerlink" title="格式化分区"></a><strong>格式化分区</strong></h3><p>分区完成后，需要格式化：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkfs.fat -F32 /dev/sda1      # EFI 分区（UEFI 模式）</span><br><span class="line">mkfs.ext4 /dev/sda2          # 根分区</span><br><span class="line">mkswap /dev/sda3             # Swap 分区</span><br><span class="line">swapon /dev/sda3             # 启用 Swap</span><br></pre></td></tr></table></figure>

<p>如果是 BIOS 模式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkfs.ext4 /dev/sda1</span><br><span class="line">mkswap /dev/sda2</span><br><span class="line">swapon /dev/sda2</span><br></pre></td></tr></table></figure>

<h3 id="分区方案示例"><a href="#分区方案示例" class="headerlink" title="分区方案示例"></a>分区方案示例</h3><table>
<thead>
<tr>
<th align="center">已安装系统上的挂载点</th>
<th align="center">分区</th>
<th align="center"><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/GUID_Partition_Table#Partition_type_GUIDs">分区类型</a></th>
<th align="center">建议大小</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>/boot</code>1</td>
<td align="center"><code>/dev/*efi_system_partition*</code></td>
<td align="center"><a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/EFI_system_partition">EFI system partition</a></td>
<td align="center">1 GiB。</td>
</tr>
<tr>
<td align="center"><code>[SWAP]</code></td>
<td align="center"><code>/dev/*swap_partition*</code></td>
<td align="center">Linux <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Swap">swap</a> (交换空间)</td>
<td align="center">至少 4GiB</td>
</tr>
<tr>
<td align="center"><code>/</code></td>
<td align="center"><code>/dev/*root_partition*</code></td>
<td align="center">Linux x86-64 根目录 (&#x2F;)</td>
<td align="center">设备剩余空间，至少23-32GiB</td>
</tr>
</tbody></table>
<h2 id="1-7-格式化分区"><a href="#1-7-格式化分区" class="headerlink" title="1.7 格式化分区"></a>1.7 格式化分区</h2><h3 id="为什么要格式化分区？"><a href="#为什么要格式化分区？" class="headerlink" title="为什么要格式化分区？"></a><strong>为什么要格式化分区？</strong></h3><ol>
<li><strong>创建文件系统</strong>：分区本身只是划分磁盘的区域，而格式化会在分区上创建具体的文件系统，使操作系统能存储和管理文件。</li>
<li><strong>确保数据结构一致</strong>：不同的操作系统和用途需要不同的文件系统，比如 Linux 用 <code>ext4</code>，UEFI 需要 <code>FAT32</code>。</li>
<li><strong>清除已有数据</strong>：格式化会清空原有数据，防止磁盘上的旧数据影响新系统。</li>
</ol>
<hr>
<h3 id="各个命令的解释"><a href="#各个命令的解释" class="headerlink" title="各个命令的解释"></a><strong>各个命令的解释</strong></h3><p>在 Arch Linux 安装过程中，我们会用到以下格式化命令：</p>
<h4 id="1-格式化-EFI-分区（仅适用于-UEFI-模式）"><a href="#1-格式化-EFI-分区（仅适用于-UEFI-模式）" class="headerlink" title="1. 格式化 EFI 分区（仅适用于 UEFI 模式）"></a><strong>1. 格式化 EFI 分区（仅适用于 UEFI 模式）</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs.fat -F32 /dev/sda1</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>mkfs.fat</code>：创建 FAT 文件系统。</li>
<li><code>-F32</code>：指定使用 <strong>FAT32</strong> 格式，这是 UEFI 规范要求的格式。</li>
<li><code>/dev/sda1</code>：要格式化的分区（UEFI 下 <code>/dev/sda1</code> 通常是 EFI 分区）。</li>
</ul>
<p><strong>为什么要用 FAT32？</strong><br>UEFI 固件只能识别 <strong>FAT 文件系统</strong>，因此 EFI 分区必须使用 FAT32，否则引导失败。</p>
<hr>
<h4 id="2-格式化-Linux-根分区"><a href="#2-格式化-Linux-根分区" class="headerlink" title="2. 格式化 Linux 根分区"></a><strong>2. 格式化 Linux 根分区</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs.ext4 /dev/sda2</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>mkfs.ext4</code>：创建 <strong>ext4</strong> 文件系统（Linux 常用的文件系统）。</li>
<li><code>/dev/sda2</code>：要格式化的分区（这里假设 <code>/dev/sda2</code> 是根分区）。</li>
</ul>
<p><strong>为什么要用 ext4？</strong></p>
<ul>
<li><code>ext4</code> 是 Linux 默认的文件系统，稳定可靠，支持大文件和日志功能。</li>
<li>你也可以选择 <code>btrfs</code>、<code>xfs</code> 或 <code>f2fs</code>，但 <code>ext4</code> 兼容性最好。</li>
</ul>
<hr>
<h4 id="3-格式化并启用-Swap-分区"><a href="#3-格式化并启用-Swap-分区" class="headerlink" title="3. 格式化并启用 Swap 分区"></a><strong>3. 格式化并启用 Swap 分区</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkswap /dev/sda3</span><br><span class="line">swapon /dev/sda3</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>mkswap /dev/sda3</code>：将 <code>/dev/sda3</code> 分区格式化为 Swap 分区（交换空间）。</li>
<li><code>swapon /dev/sda3</code>：启用 Swap 分区，使其生效。</li>
</ul>
<p><strong>为什么需要 Swap？</strong><br>Swap 主要用于：</p>
<ul>
<li><strong>内存不足时使用</strong>（比如你的物理内存 4GB，但程序需要 6GB，系统会用 Swap 临时存储数据）。</li>
<li><strong>休眠（hibernate）支持</strong>（如果你的 Swap 够大，Linux 可以将内存数据写入 Swap 并休眠）。</li>
<li><strong>防止 OOM（Out of Memory）</strong>（Swap 让系统在内存不足时还能继续运行，而不是直接崩溃）。</li>
</ul>
<p><strong>Swap 该分多大？</strong></p>
<ul>
<li><strong>无特殊需求</strong>：分配和物理内存一样大（4GB 内存 → 4GB Swap）。</li>
<li><strong>想用休眠（Hibernate）</strong>：Swap 至少等于 <strong>物理内存大小</strong>。</li>
<li><strong>服务器或高内存机器</strong>：可以少分甚至不分 Swap。</li>
</ul>
<h2 id="1-8-挂载分区"><a href="#1-8-挂载分区" class="headerlink" title="1.8 挂载分区"></a>1.8 挂载分区</h2><h3 id="挂载-UEFI-分区方案"><a href="#挂载-UEFI-分区方案" class="headerlink" title="挂载 UEFI 分区方案"></a><strong>挂载 UEFI 分区方案</strong></h3><p>假设你的分区结构如下：</p>
<ul>
<li><code>/dev/sda1</code> → <strong>EFI 分区</strong>（FAT32，512MB）</li>
<li><code>/dev/sda2</code> → <strong>根分区</strong>（ext4）</li>
<li><code>/dev/sda3</code> → <strong>Swap 分区</strong>（可选）</li>
</ul>
<h4 id="1-挂载根分区（-）"><a href="#1-挂载根分区（-）" class="headerlink" title="1. 挂载根分区（/）"></a><strong>1. 挂载根分区（<code>/</code>）</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/sda2 /mnt</span><br></pre></td></tr></table></figure>

<ul>
<li>这会把 <code>/dev/sda2</code>（根分区）挂载到 <code>/mnt</code>，后续的 Arch Linux 安装都将在 <code>/mnt</code> 目录下进行。</li>
</ul>
<h4 id="2-创建-boot-efi-目录并挂载-EFI-分区"><a href="#2-创建-boot-efi-目录并挂载-EFI-分区" class="headerlink" title="2. 创建 /boot/efi 目录并挂载 EFI 分区"></a><strong>2. 创建 <code>/boot/efi</code> 目录并挂载 EFI 分区</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /mnt/boot/efi</span><br><span class="line">mount /dev/sda1 /mnt/boot/efi</span><br></pre></td></tr></table></figure>

<ul>
<li><code>mkdir -p /mnt/boot/efi</code>：创建 EFI 挂载点。</li>
<li><code>mount /dev/sda1 /mnt/boot/efi</code>：挂载 EFI 分区到 <code>/mnt/boot/efi</code>，使系统能正确安装引导程序（如 <code>systemd-boot</code> 或 <code>grub</code>）。</li>
</ul>
<h4 id="3-启用-Swap-分区（如果有）"><a href="#3-启用-Swap-分区（如果有）" class="headerlink" title="3. 启用 Swap 分区（如果有）"></a><strong>3. 启用 Swap 分区（如果有）</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swapon /dev/sda3</span><br></pre></td></tr></table></figure>

<ul>
<li>这会让 Swap 分区生效，提高内存不足时的稳定性。</li>
</ul>
<hr>
<h3 id="检查挂载情况"><a href="#检查挂载情况" class="headerlink" title="检查挂载情况"></a><strong>检查挂载情况</strong></h3><p>可以用以下命令确认分区是否正确挂载：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsblk</span><br></pre></td></tr></table></figure>

<p>你应该能看到类似的输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda      8:0    0    20G  0 disk  </span><br><span class="line">├─sda1   8:1    0   512M  0 part /mnt/boot/efi</span><br><span class="line">├─sda2   8:2    0    19G  0 part /mnt</span><br><span class="line">└─sda3   8:3    0     1G  0 part [SWAP]</span><br></pre></td></tr></table></figure>

<p>这样，你的 UEFI 分区方案就正确挂载完成了！</p>
<h1 id="2-开始安装系统"><a href="#2-开始安装系统" class="headerlink" title="2. 开始安装系统"></a>2. 开始安装系统</h1><h2 id="2-1-选择镜像站"><a href="#2-1-选择镜像站" class="headerlink" title="2.1 选择镜像站"></a>2.1 选择镜像站</h2><p>系统的文件 <code>/etc/pacman.d/mirrorlist</code> 中定义了软件包会从哪个<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E9%95%9C%E5%83%8F">镜像</a>站下载。在 LiveCD 启动的系统上，且在连接到互联网后，<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Reflector">reflector</a> 会通过选择 20 个最新同步的 HTTPS 镜像站并按下载速率对其进行排序来更新镜像列表（<strong>由于只考虑最新的 20 个镜像站，其结果常不佳</strong>）。</p>
<p>在列表中，越靠前的镜像站在下载软件包时，就会有越高的优先级。<strong>请您检查 <code>/etc/pacman.d/mirrorlist</code> 文件</strong>，看看列出的镜像站的顺序是否合适。如果不合适，可以手动<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E7%BC%96%E8%BE%91">编辑</a>文件，将离您所处地理位置最近的镜像移到文件的头部，同时也应该考虑一些其他的评判标准。</p>
<p>如果 <code>/etc/pacman.d/mirrorlist</code> 文件中没有合适的镜像站，可以手动从 <a target="_blank" rel="noopener" href="https://archlinux.org/mirrorlist/">archlinux 官方网站的镜像站列表</a>下载一份。这需要您所在的网络能够正常访问 archlinux 官方网站。例如，使用 <a target="_blank" rel="noopener" href="https://man.archlinux.org/man/curl.1">curl(1)</a> 下载位于中国大陆的 HTTPS 镜像站：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># curl -L &#x27;https://archlinux.org/mirrorlist/?country=CN&amp;protocol=https&#x27; -o /etc/pacman.d/mirrorlist</span><br></pre></td></tr></table></figure>

<p>或者，也可以通过安装 <a target="_blank" rel="noopener" href="https://archlinux.org/packages/?name=pacman-mirrorlist">pacman-mirrorlist</a>包 来获取按国家分列的原始镜像列表。这么做的缺点是，pacman 仍然会使用当前配置中的镜像站来下载软件包数据库和 <a target="_blank" rel="noopener" href="https://archlinux.org/packages/?name=pacman-mirrorlist">pacman-mirrorlist</a>包，这可能会很慢。在挑选了能用的镜像之后，可以执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># pacman -Sy pacman-mirrorlist</span><br></pre></td></tr></table></figure>

<p>再将 <code>/etc/pacman.d/mirrorlist.pacnew</code> 复制到 <code>/etc/pacman.d/mirrorlist</code> 并进行编辑。</p>
<p>或者，如果您记得想要使用的镜像站的 URL，那么可以手动编辑 <code>/etc/pacman.d/mirrorlist</code> 文件并手动输入 URL。</p>
<p>这个文件接下来还会被 <em>pacstrap</em> 拷贝到新系统里，所以请您确保设置正确。</p>
<h2 id="2-2-更新密钥环"><a href="#2-2-更新密钥环" class="headerlink" title="2.2 更新密钥环"></a>2.2 更新密钥环</h2><p>过时的Live 系统内置密钥环会导致在 <em>pacstrap</em> 的时候无法正常安装软件包（提示为文件签名损坏）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># pacman -Syu archlinux-keyring</span><br></pre></td></tr></table></figure>

<p>使用上面的命令更新当前 Live 系统的密钥环，也可以防止因为意外导致开发者私钥被盗用造成的安全问题。</p>
<p>如果您在 Live 系统里启用了<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Arch_Linux_%E4%B8%AD%E6%96%87%E7%A4%BE%E5%8C%BA%E4%BB%93%E5%BA%93">中文社区仓库</a>或其他<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E9%9D%9E%E5%AE%98%E6%96%B9%E7%94%A8%E6%88%B7%E4%BB%93%E5%BA%93">非官方用户仓库</a>，也不要忘了一同更新其密钥环。</p>
<p>参见 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Pacman/%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AD%BE%E5%90%8D">pacman&#x2F;软件包签名</a>。</p>
<h2 id="2-3-安装必需的软件包"><a href="#2-3-安装必需的软件包" class="headerlink" title="2.3 安装必需的软件包"></a>2.3 安装必需的软件包</h2><p>使用 <a target="_blank" rel="noopener" href="https://man.archlinux.org/man/pacstrap.8">pacstrap(8)</a> 脚本，安装 <a target="_blank" rel="noopener" href="https://archlinux.org/packages/?name=base">base</a>包 软件包和 Linux <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E5%86%85%E6%A0%B8">内核</a>以及常规硬件的固件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># pacstrap -K /mnt base linux linux-firmware</span><br></pre></td></tr></table></figure>

<p>这时候可以同时额外安装计算机的 CPU 微码包。如果计算机是 Intel 的 CPU ，使用 <a target="_blank" rel="noopener" href="https://archlinux.org/packages/?name=intel-ucode">intel-ucode</a>包，AMD CPU 则使用 <a target="_blank" rel="noopener" href="https://archlinux.org/packages/?name=amd-ucode">amd-ucode</a>包。也可以暂时都不安装，等到进入系统后再安装。</p>
<p><a target="_blank" rel="noopener" href="https://archlinux.org/packages/?name=base">base</a>包 软件包并没有包含 Live 环境中的全部程序。因此要获得一个功能齐全的基本系统，可能需要安装更多软件包。要安装其他软件包或软件包组（比如 <a target="_blank" rel="noopener" href="https://archlinux.org/groups/x86_64/base-devel/">base-devel</a>包组），请将它们的名字追加到下面的 <em>pacstrap</em> 命令后（以空格分隔），或者也可以在 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97#Chroot">Chroot 进入新系统</a>后使用 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Pacman">pacman</a> 手动<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E5%AE%89%E8%A3%85">安装</a>。特别要考虑安装：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Pacman/%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AD%BE%E5%90%8D">GPG 密钥环</a>（如 <a target="_blank" rel="noopener" href="https://github.com/archlinuxcn/repo/tree/master/archlinuxcn/archlinuxcn-keyring">archlinuxcn-keyring</a>CNRepo，若启用了某些<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E9%9D%9E%E5%AE%98%E6%96%B9%E7%94%A8%E6%88%B7%E4%BB%93%E5%BA%93">非官方用户仓库</a>。）</li>
<li><a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%88%97%E8%A1%A8/%E6%96%87%E6%A1%A3#%E6%8E%A7%E5%88%B6%E5%8F%B0">控制台文本编辑器</a>（如 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Nano">nano</a>、<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Vim">vim</a> 和 <a target="_blank" rel="noopener" href="https://archlinux.org/packages/?name=emacs">emacs</a>包）以便从控制台<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E7%BC%96%E8%BE%91">编辑</a>配置文件（如<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E7%82%B9%E6%96%87%E4%BB%B6">点文件</a>）。</li>
<li>访问和管理 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/RAID#%E5%AE%89%E8%A3%85">RAID</a> 或 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/LVM#%E5%87%86%E5%A4%87">LVM</a> 分区的工具。</li>
<li><a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE">联网</a>所需要的程序（例如<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE#%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%99%A8">网络管理器或 DHCP 客户端</a>，Wi-Fi <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE#%E8%AE%A4%E8%AF%81">认证软件</a>和移动宽带连接所需的 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wzh/index.php?title=ModemManager&action=edit&redlink=1">ModemManager</a>，以及部分 USB 无线网卡需要的 <a target="_blank" rel="noopener" href="https://archlinux.org/packages/?name=usb_modeswitch">usb_modeswitch</a>包）。</li>
<li><a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">文件系统的用户工具</a>（比如 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/XFS">XFS</a> 和 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Btrfs">Btrfs</a> 文件系统对应的管理工具），可用于创建和管理<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">文件系统</a>以及 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Fsck">fsck</a>。</li>
<li>CPU <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E5%BE%AE%E7%A0%81">微码</a>更新 —— <a target="_blank" rel="noopener" href="https://archlinux.org/packages/?name=amd-ucode">amd-ucode</a>包 或 <a target="_blank" rel="noopener" href="https://archlinux.org/packages/?name=intel-ucode">intel-ucode</a>包 —— 用于硬件错误和安全修复。</li>
<li>未包含在 <a target="_blank" rel="noopener" href="https://archlinux.org/packages/?name=linux-firmware">linux-firmware</a>包 中的额外必需固件（如用于<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/ALSA#%E5%9B%BA%E4%BB%B6">内建音频</a>的 <a target="_blank" rel="noopener" href="https://archlinux.org/packages/?name=sof-firmware">sof-firmware</a>包、用于 Marvell 无线的 <a target="_blank" rel="noopener" href="https://archlinux.org/packages/?name=linux-firmware-marvell">linux-firmware-marvell</a>包 以及<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E5%8D%9A%E9%80%9A%E6%97%A0%E7%BA%BF%E7%BD%91%E5%8D%A1">博通无线网卡</a>的固件包)。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://geo.mirror.pkgbuild.com/iso/latest/arch/pkglist.x86_64.txt">文件 pkglist.x86_64.txt</a> 中包含 Live 系统安装的软件包列表。</p>
<h1 id="3-配置系统"><a href="#3-配置系统" class="headerlink" title="3. 配置系统"></a>3. 配置系统</h1><h2 id="3-1-生成-fstab-文件"><a href="#3-1-生成-fstab-文件" class="headerlink" title="3.1 生成 fstab 文件"></a>3.1 生成 fstab 文件</h2><p>通过以下命令生成 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Fstab">fstab</a> 文件 (用 <code>-U</code> 或 <code>-L</code> 选项设置 UUID 或卷标)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># genfstab -U /mnt &gt; /mnt/etc/fstab</span><br></pre></td></tr></table></figure>

<p><strong>强烈建议</strong>在执行完以上命令后，检查一下生成的 <code>/mnt/etc/fstab</code> 文件是否正确。如果有问题，最好在现在手动修改。对于熟练者，可以自行编辑 <code>/mnt/etc/fstab</code> 文件。</p>
<p>可以手动修改 <code>/mnt/etc/fstab</code> 添加挂载选项（参见 <a target="_blank" rel="noopener" href="https://man.archlinux.org/man/mount.8#FILESYSTEM-INDEPENDENT_MOUNT_OPTIONS">mount(8) § FILESYSTEM-INDEPENDENT_MOUNT_OPTIONS</a> 和 <a target="_blank" rel="noopener" href="https://man.archlinux.org/man/ext4.5#MOUNT_OPTIONS">ext4(5) § MOUNT_OPTIONS</a>）。例如，给<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98">固态硬盘</a>的 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Ext4">ext4</a> 文件系统添加 <code>discard</code> 选项以启用 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/TRIM">TRIM</a>。</p>
<h2 id="3-2-chroot-到新安装的系统"><a href="#3-2-chroot-到新安装的系统" class="headerlink" title="3.2 chroot 到新安装的系统"></a>3.2 chroot 到新安装的系统</h2><p>通过以下命令 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Change_root">chroot</a> 到新安装的系统：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># arch-chroot /mnt</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong>此处使用的是<code>arch-chroot</code>而不是直接使用<code>chroot</code>，注意不要输错了。</p>
<h2 id="3-3-设置时区"><a href="#3-3-设置时区" class="headerlink" title="3.3 设置时区"></a>3.3 设置时区</h2><p>通过以下命令设置<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4#%E6%97%B6%E5%8C%BA">时区</a>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ln -sf /usr/share/zoneinfo/Region（地区名）/City（城市名） /etc/localtime</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong>例如，在中国大陆需要将时区设置为北京时间，那么请运行 <code># ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</code>。时区名称是上海而非北京，是因为上海是该时区内人口最多的城市（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Time_in_China#IANA_time_zone_database">参考来源</a>）。</p>
<p>然后运行 <a target="_blank" rel="noopener" href="https://man.archlinux.org/man/hwclock.8">hwclock(8)</a> 以生成 <code>/etc/adjtime</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># hwclock --systohc</span><br></pre></td></tr></table></figure>

<p>这个命令假定已设置硬件时间为 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/UTC">UTC 时间</a>。详细信息请查看<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4#%E6%97%B6%E9%97%B4%E6%A0%87%E5%87%86">系统时间#时间标准</a>。</p>
<p>为了防止时钟漂移并确保时间准确，请使用 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E6%97%B6%E9%97%B4%E5%8D%8F%E8%AE%AE">NTP</a>（网络时间协议，Network Time Protocol）客户端（例如 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Systemd-timesyncd">systemd-timesyncd</a>）设置<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4#%E6%97%B6%E9%92%9F%E5%90%8C%E6%AD%A5">时间同步</a>。</p>
<h2 id="3-4-区域和本地化设置"><a href="#3-4-区域和本地化设置" class="headerlink" title="3.4 区域和本地化设置"></a>3.4 区域和本地化设置</h2><p>程序和库如果需要本地化文本，都依赖<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Locale">区域设置</a>，后者明确规定了地域、货币、时区日期的格式、字符排列方式和其他本地化标准。</p>
<p>需要设置这两个文件：<code>locale.gen</code> 与 <code>locale.conf</code>。</p>
<p><a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E7%BC%96%E8%BE%91">编辑</a> <code>/etc/locale.gen</code>，然后取消掉 <code>en_US.UTF-8 UTF-8</code> 和其他需要的 UTF-8 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Locale">区域设置</a>前的注释（**#**）。</p>
<p>接着执行 <code>locale-gen</code> 以生成 locale 信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># locale-gen</span><br></pre></td></tr></table></figure>

<p>然后创建 <a target="_blank" rel="noopener" href="https://man.archlinux.org/man/locale.conf.5">locale.conf(5)</a> 文件，并<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Locale#%E7%B3%BB%E7%BB%9F%E5%8C%BA%E5%9F%9F%E8%AE%BE%E7%BD%AE">编辑设定 LANG 变量</a>，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc/locale.conf</span><br><span class="line">LANG=en_US.UTF-8</span><br></pre></td></tr></table></figure>

<p>另外对于中文用户：</p>
<p><strong>提示：</strong></p>
<ul>
<li>用户可以设置自己的 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Locale">locale</a>，详情请参阅 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Locale#%E5%9C%A8%E7%94%A8%E6%88%B7%E4%BC%9A%E8%AF%9D%E4%B8%AD%E8%A6%86%E7%9B%96%E7%B3%BB%E7%BB%9F%E5%8C%BA%E5%9F%9F%E8%AE%BE%E7%BD%AE">在用户会话中覆盖系统区域设置</a> 或 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Locale#%E8%AE%BE%E7%BD%AE%E5%BD%93%E5%89%8D%E5%8C%BA%E5%9F%9F">设置当前区域</a>；</li>
<li>将系统 locale 设置为<code>en_US.UTF-8</code>，系统的日志就会用英文显示，这样更容易判断和处理问题；<ul>
<li>也可以设置为 <code>en_GB.UTF-8</code> ［英语（英国）］或 <code>en_SG.UTF-8</code> ［英语（新加坡）］，附带以下特点：<ul>
<li>进入桌面环境后以 24 小时制显示时间；</li>
<li><a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/LibreOffice">LibreOffice</a> 等办公软件的纸张尺寸会默认为 <code>A4</code> 而非 <code>Letter(US)</code>；</li>
<li>可尽量避免不必要且可能造成处理麻烦的英制单位。</li>
</ul>
</li>
<li>设置的 LANG 变量需与 locale 设置一致，否则会出现以下错误：</li>
</ul>
</li>
</ul>
<p><strong>警告：</strong>并不推荐在此设置任何中文 locale，这可能会导致 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Getty">tty</a> 上中文显示为方块（因为 TTY 下没有 CJK 字体）。如果您不经常使用 tty ，或是稍后需要安装<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E6%A1%8C%E9%9D%A2%E7%8E%AF%E5%A2%83">桌面环境</a>，则在不使用 tty 后可以设置为中文的 locale 。为了使 TTY 显示中文，也可以使用打了补丁的<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E5%86%85%E6%A0%B8">内核</a>，如 <a target="_blank" rel="noopener" href="https://github.com/archlinuxcn/repo/tree/master/archlinuxcn/linux-lily">linux-lily</a>CNRepo。</p>
<p>如果需要修改<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97#%E6%8E%A7%E5%88%B6%E5%8F%B0%E9%94%AE%E7%9B%98%E5%B8%83%E5%B1%80%E5%92%8C%E5%AD%97%E4%BD%93">#控制台键盘布局和字体</a>，可编辑 <a target="_blank" rel="noopener" href="https://man.archlinux.org/man/vconsole.conf.5">vconsole.conf(5)</a> 使其长期生效，以德语键盘（qwertz）为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc/vconsole.conf</span><br><span class="line">KEYMAP=de-latin1</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>如果键盘为标准美式键盘（中国最常见的键盘布局），请勿照抄如上设置。</p>
<h2 id="3-5-网络配置"><a href="#3-5-网络配置" class="headerlink" title="3.5 网络配置"></a>3.5 网络配置</h2><p><a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E5%88%9B%E5%BB%BA">创建</a> <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE#%E8%AE%BE%E7%BD%AE%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%8D">hostname</a> 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc/hostname</span><br><span class="line">主机名</span><br></pre></td></tr></table></figure>

<p>请接着完成新安装的环境的<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE">网络配置</a>，配置过程中可能需要安装合适的<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE#%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86">网络管理</a>软件。</p>
<p><strong>警告：</strong>请按上述网络配置指引正确配置好网络后再重新启动，否则系统重新启动后可能无法连接网络（不过可以用 LiveCD 重新进入 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Chroot#%E4%BD%BF%E7%94%A8_arch-chroot">arch-chroot</a> 进行配置）。例如在虚拟机软件 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/VirtualBox">VirtualBox</a> <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/VirtualBox/%E5%9C%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E5%AE%89%E8%A3%85_Arch_Linux">安装</a>并使用桥接模式时就需要配置 DHCP 。</p>
<h2 id="3-6-关于-initramfs"><a href="#3-6-关于-initramfs" class="headerlink" title="3.6 关于 initramfs"></a>3.6 关于 initramfs</h2><p>通常不需要自己创建新的 <em>initramfs</em>，因为在执行 <em>pacstrap</em> 时已经安装 <a target="_blank" rel="noopener" href="https://archlinux.org/packages/?name=linux">linux</a>包，这时已经运行过 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Mkinitcpio">mkinitcpio</a> 了。</p>
<p>如果是 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wzh/index.php?title=%E5%9C%A8_LVM_%E4%B8%8A%E5%AE%89%E8%A3%85_Arch_Linux&action=edit&redlink=1">LVM</a>、<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Dm-crypt">系统加密</a>或 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/RAID#%E9%85%8D%E7%BD%AE_mkinitcpio">RAID</a> 等分区配置，请修改 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Mkinitcpio">mkinitcpio.conf</a> 并用以下命令重新创建一个 Initramfs：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># mkinitcpio -P</span><br></pre></td></tr></table></figure>

<h2 id="3-7-设置-root-密码"><a href="#3-7-设置-root-密码" class="headerlink" title="3.7 设置 root 密码"></a>3.7 设置 root 密码</h2><p>使用以下命令设置 root <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E7%94%A8%E6%88%B7%E5%92%8C%E7%94%A8%E6%88%B7%E7%BB%84#%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E5%AD%98%E5%82%A8">密码</a>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># passwd</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong>建议为 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Root">root</a> 用户选择一个<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E5%AE%89%E5%85%A8#%E9%80%89%E6%8B%A9%E5%AE%89%E5%85%A8%E7%9A%84%E5%AF%86%E7%A0%81">强密码</a>并<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E5%AE%89%E5%85%A8#%E7%BB%B4%E6%8A%A4%E5%AF%86%E7%A0%81%E5%AE%89%E5%85%A8">保护其安全</a>。</p>
<h2 id="3-8-安装引导程序"><a href="#3-8-安装引导程序" class="headerlink" title="3.8 安装引导程序"></a>3.8 安装引导程序</h2><p>需要安装 Linux 引导加载程序，才能在安装后启动系统，可以使用的的引导程序已在<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E5%BC%95%E5%AF%BC%E5%8A%A0%E8%BD%BD%E7%A8%8B%E5%BA%8F">引导加载程序</a>中列出，请选择一个安装并配置它，<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/GRUB">GRUB</a> 是一个比较常见且通用的选择。</p>
<p><strong>警告：</strong>这是安装的最后一步也是关键的一步，请点击上述链接并按指引正确安装好引导加载程序后再重新启动。否则计算机重新启动后将无法正常进入 Arch Linux 系统。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-01-11T07:49:15.000Z" title="2025/1/11 15:49:15">2025-01-11</time>发表</span><span class="level-item"><time dateTime="2025-01-12T09:40:08.865Z" title="2025/1/12 17:40:08">2025-01-12</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/OS/">OS</a></span><span class="level-item">6 分钟读完 (大约854个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/01/11/Write%20your%20own%20Operating%20System/Operating-System-pt-2/">Operating System pt.2</a></p><div class="content"><h2 id="Install-Your-OS-in-a-Virtual-Machine"><a href="#Install-Your-OS-in-a-Virtual-Machine" class="headerlink" title="Install Your OS in a Virtual Machine"></a>Install Your OS in a Virtual Machine</h2><h3 id="1-修改Makefile制作iso文件"><a href="#1-修改Makefile制作iso文件" class="headerlink" title="1. 修改Makefile制作iso文件"></a>1. 修改Makefile制作iso文件</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">mykernel.iso: mykernel.bin</span></span><br><span class="line">	mkdir iso</span><br><span class="line">	mkdir iso/boot</span><br><span class="line">	mkdir iso/boot/grub</span><br><span class="line">	cp <span class="variable">$&lt;</span> iso/boot</span><br><span class="line">	echo &#x27;set timeout=0&#x27; &gt;&gt; iso/boot/grub/grub.cfg</span><br><span class="line">	echo &#x27;set default=0&#x27; &gt;&gt; iso/boot/grub/grub.cfg</span><br><span class="line">	echo &#x27;&#x27; &gt;&gt; iso/boot/grub/grub.cfg</span><br><span class="line">	echo &#x27;menuentry <span class="string">&quot;My Operating System&quot;</span>&#123;&#x27; &gt;&gt; iso/boot/grub/grub.cfg</span><br><span class="line">	echo &#x27;	multiboot /boot/mykernel.bin&#x27; &gt;&gt; iso/boot/grub/grub.cfg</span><br><span class="line">	echo &#x27;	boot&#x27; &gt;&gt; iso/boot/grub/grub.cfg</span><br><span class="line">	echo &#x27;&#125;&#x27; &gt;&gt; iso/boot/grub/grub.cfg</span><br><span class="line">	grub-mkrescue --output=<span class="variable">$@</span> iso</span><br><span class="line">	rm -rf iso</span><br></pre></td></tr></table></figure>

<p>这段Makefile用于生成一个名为<code>mykernel.iso</code>的可启动ISO镜像文件。它依赖于一个名为<code>mykernel.bin</code>的二进制文件，该文件通常是一个操作系统内核或引导程序。以下是逐行解释：</p>
<ol>
<li><strong><code>mykernel.iso: mykernel.bin</code></strong>:<ul>
<li>这行定义了目标文件<code>mykernel.iso</code>和它的依赖文件<code>mykernel.bin</code>。当<code>mykernel.bin</code>发生变化时，<code>mykernel.iso</code>将会被重新生成。</li>
</ul>
</li>
<li><strong><code>mkdir iso</code></strong>:<ul>
<li>创建一个名为<code>iso</code>的目录，用于临时存放构建ISO文件所需的文件。</li>
</ul>
</li>
<li><strong><code>mkdir iso/boot</code></strong>:<ul>
<li>在<code>iso</code>目录下创建一个<code>boot</code>子目录，用于存放引导相关的文件。</li>
</ul>
</li>
<li><strong><code>mkdir iso/boot/grub</code></strong>:<ul>
<li>在<code>iso/boot</code>目录下创建一个<code>grub</code>子目录，用于存放GRUB引导加载器的配置文件。</li>
</ul>
</li>
<li><strong><code>cp $&lt; iso/boot</code></strong>:<ul>
<li>将依赖文件<code>mykernel.bin</code>复制到<code>iso/boot</code>目录中。<code>$&lt;</code>是Makefile中的自动变量，表示第一个依赖文件（即<code>mykernel.bin</code>）。</li>
</ul>
</li>
<li><strong><code>echo &#39;set timeout=0&#39; &gt;&gt; iso/boot/grub/grub.cfg</code></strong>:<ul>
<li>向<code>iso/boot/grub/grub.cfg</code>文件中追加一行，设置GRUB菜单的超时时间为0秒，即不显示菜单直接启动。</li>
</ul>
</li>
<li><strong><code>echo &#39;set default=0&#39; &gt;&gt; iso/boot/grub/grub.cfg</code></strong>:<ul>
<li>向<code>grub.cfg</code>文件中追加一行，设置默认启动项为第一个菜单项。</li>
</ul>
</li>
<li><strong><code>echo &#39;&#39; &gt;&gt; iso/boot/grub/grub.cfg</code></strong>:<ul>
<li>向<code>grub.cfg</code>文件中追加一个空行。</li>
</ul>
</li>
<li><strong><code>echo &#39;menuentry &quot;My Operating System&quot;&#123;&#39; &gt;&gt; iso/boot/grub/grub.cfg</code></strong>:<ul>
<li>向<code>grub.cfg</code>文件中追加一行，定义一个名为”My Operating System”的菜单项。</li>
</ul>
</li>
<li><strong><code>echo &#39; multiboot /boot/mykernel.bin&#39; &gt;&gt; iso/boot/grub/grub.cfg</code></strong>:<ul>
<li>向<code>grub.cfg</code>文件中追加一行，指定使用<code>multiboot</code>命令加载<code>/boot/mykernel.bin</code>文件。</li>
</ul>
</li>
<li><strong><code>echo &#39; boot&#39; &gt;&gt; iso/boot/grub/grub.cfg</code></strong>:<ul>
<li>向<code>grub.cfg</code>文件中追加一行，执行<code>boot</code>命令以启动加载的内核。</li>
</ul>
</li>
<li><strong><code>echo &#39;&#125;&#39; &gt;&gt; iso/boot/grub/grub.cfg</code></strong>:<ul>
<li>向<code>grub.cfg</code>文件中追加一行，结束菜单项的定义。</li>
</ul>
</li>
<li><strong><code>grub-mkrescue --output=$@ iso</code></strong>:<ul>
<li>使用<code>grub-mkrescue</code>命令将<code>iso</code>目录中的内容打包成一个可启动的ISO镜像文件。<code>$@</code>是Makefile中的自动变量，表示目标文件（即<code>mykernel.iso</code>）。</li>
</ul>
</li>
<li><strong><code>rm -rf iso</code></strong>:<ul>
<li>删除临时创建的<code>iso</code>目录及其内容，以清理构建过程中生成的临时文件。</li>
</ul>
</li>
</ol>
<p>这段Makefile的作用是将<code>mykernel.bin</code>文件打包成一个可启动的ISO镜像文件<code>mykernel.iso</code>。它使用GRUB作为引导加载器，并配置GRUB直接启动<code>mykernel.bin</code>。构建完成后，临时目录<code>iso</code>会被删除</p>
<h3 id="2-定义types-h"><a href="#2-定义types-h" class="headerlink" title="2. 定义types.h"></a>2. 定义types.h</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __TYPES_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TYPES_H__</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">char</span> <span class="type">int8_t</span>;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="type">uint8_t</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">short</span> <span class="type">int16_t</span>;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">uint16_t</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">int</span> <span class="type">int32_t</span>;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">uint32_t</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> <span class="type">int64_t</span>;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> <span class="type">uint64_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="3-修改kernel-cpp"><a href="#3-修改kernel-cpp" class="headerlink" title="3. 修改kernel.cpp"></a>3. 修改kernel.cpp</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printf</span><span class="params">(<span class="type">char</span>* str)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint16_t</span>* VideoMemory = (<span class="type">uint16_t</span>*) <span class="number">0xB8000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; str[i] != <span class="string">&#x27;\0&#x27;</span>; ++i) &#123;</span><br><span class="line">        VideoMemory[i] = (VideoMemory[i] &amp; <span class="number">0xFF00</span>) | str[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*constructor)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> constructor start_ctors;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> constructor end_ctors;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">void</span> <span class="title">callConstructors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(constructor* i = &amp;start_ctors; i != &amp;end_ctors; i++) &#123;</span><br><span class="line">        (*i)();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">void</span> <span class="title">kernelMain</span><span class="params">(<span class="type">void</span>* multiboot_structure, <span class="type">uint32_t</span> magicnumber)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Memory-Segments-Global-Descriptor-Table"><a href="#Memory-Segments-Global-Descriptor-Table" class="headerlink" title="Memory Segments, Global Descriptor Table"></a>Memory Segments, Global Descriptor Table</h2></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-01-10T10:30:00.000Z" title="2025/1/10 18:30:00">2025-01-10</time>发表</span><span class="level-item"><time dateTime="2025-01-10T10:23:46.205Z" title="2025/1/10 18:23:46">2025-01-10</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/OS/">OS</a></span><span class="level-item">34 分钟读完 (大约5082个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/01/10/Write%20your%20own%20Operating%20System/Operating-System-pt-1/">Operating System pt.01</a></p><div class="content"><h2 id="Write-your-Own-Operating-System-in-1-hour"><a href="#Write-your-Own-Operating-System-in-1-hour" class="headerlink" title="Write your Own Operating System in 1 hour"></a>Write your Own Operating System in 1 hour</h2><h3 id="1-准备四个文件"><a href="#1-准备四个文件" class="headerlink" title="1. 准备四个文件"></a>1. 准备四个文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kernel.cpp</span><br><span class="line">linker.ld</span><br><span class="line">loader.s</span><br><span class="line">Makefile</span><br></pre></td></tr></table></figure>

<h3 id="2-编写Makefile"><a href="#2-编写Makefile" class="headerlink" title="2. 编写Makefile"></a>2. 编写Makefile</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">GPPPARAMS = -m32</span><br><span class="line">ASPARAMS = --32</span><br><span class="line">LDPARAMS = -melf_i386</span><br><span class="line">objects = loader.o kernel.o</span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.cpp</span></span><br><span class="line">	g++ <span class="variable">$(GPPPARAMS)</span> -o <span class="variable">$@</span> -c <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.s</span></span><br><span class="line">	as <span class="variable">$(ASPARAMS)</span> -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="section">mykernel.bin: linker.ld <span class="variable">$(objects)</span></span></span><br><span class="line">	ld <span class="variable">$(LDPARAMS)</span> -T <span class="variable">$&lt;</span> -o <span class="variable">$@</span> <span class="variable">$(objects)</span></span><br><span class="line"></span><br><span class="line"><span class="section">install: mykernel.bin</span></span><br><span class="line">	sudo cp <span class="variable">$&lt;</span> /boot/mykernel.bin</span><br></pre></td></tr></table></figure>

<p>这段Makefile用于编译和链接一个简单的内核项目。它定义了如何从C++源文件、汇编源文件生成目标文件，并将这些目标文件链接成一个内核二进制文件。最后，它还定义了一个<code>install</code>目标，用于将生成的内核二进制文件复制到系统的<code>/boot</code>目录下。</p>
<h4 id="1-变量定义"><a href="#1-变量定义" class="headerlink" title="1. 变量定义"></a><strong>1. 变量定义</strong></h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GPPPARAMS = -m32</span><br><span class="line">ASPARAMS = --32</span><br><span class="line">LDPARAMS = -melf_i386</span><br><span class="line">objects = loader.o kernel.o</span><br></pre></td></tr></table></figure>

<ul>
<li><code>GPPPARAMS = -m32</code>: 定义了一个变量<code>GPPPARAMS</code>，用于指定<code>g++</code>编译器的参数。<code>-m32</code>表示生成32位的代码。</li>
<li><code>ASPARAMS = --32</code>: 定义了一个变量<code>ASPARAMS</code>，用于指定<code>as</code>汇编器的参数。<code>--32</code>表示生成32位的汇编代码。</li>
<li><code>LDPARAMS = -melf_i386</code>: 定义了一个变量<code>LDPARAMS</code>，用于指定<code>ld</code>链接器的参数。<code>-melf_i386</code>表示生成32位的ELF格式的可执行文件。</li>
<li><code>objects = loader.o kernel.o</code>: 定义了一个变量<code>objects</code>，包含了需要链接的目标文件列表。</li>
</ul>
<h4 id="2-编译C-源文件"><a href="#2-编译C-源文件" class="headerlink" title="2.编译C++源文件"></a><strong>2.编译C++源文件</strong></h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">%.o: %.cpp</span></span><br><span class="line">    g++ <span class="variable">$(GPPPARAMS)</span> -o <span class="variable">$@</span> -c <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>%.o: %.cpp</code>: 这是一个模式规则，表示如何从<code>.cpp</code>文件生成对应的<code>.o</code>目标文件。</li>
<li><code>g++ $(GPPPARAMS) -o $@ -c $&lt;</code>: 使用<code>g++</code>编译器编译<code>.cpp</code>文件。<code>$(GPPPARAMS)</code>展开为<code>-m32</code>，<code>-o $@</code>指定输出文件名为目标文件（即<code>.o</code>文件），<code>-c</code>表示只编译不链接，<code>$&lt;</code>表示第一个依赖文件（即<code>.cpp</code>文件）。</li>
</ul>
<h4 id="3-编译汇编源文件"><a href="#3-编译汇编源文件" class="headerlink" title="3.编译汇编源文件"></a><strong>3.编译汇编源文件</strong></h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">%.o: %.s</span></span><br><span class="line">    as <span class="variable">$(ASPARAMS)</span> -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>%.o: %.s</code>: 这是一个模式规则，表示如何从<code>.s</code>汇编文件生成对应的<code>.o</code>目标文件。</li>
<li><code>as $(ASPARAMS) -o $@ $&lt;</code>: 使用<code>as</code>汇编器编译<code>.s</code>文件。<code>$(ASPARAMS)</code>展开为<code>--32</code>，<code>-o $@</code>指定输出文件名为目标文件（即<code>.o</code>文件），<code>$&lt;</code>表示第一个依赖文件（即<code>.s</code>文件）。</li>
</ul>
<h4 id="4-链接目标文件生成内核二进制文件"><a href="#4-链接目标文件生成内核二进制文件" class="headerlink" title="4.链接目标文件生成内核二进制文件"></a><strong>4.链接目标文件生成内核二进制文件</strong></h4>   <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">mykernel.bin: linker.ld <span class="variable">$(objects)</span></span></span><br><span class="line">    ld <span class="variable">$(LDPARAMS)</span> -T <span class="variable">$&lt;</span> -o <span class="variable">$@</span> <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>mykernel.bin: linker.ld $(objects)</code>: 定义了一个目标<code>mykernel.bin</code>，它依赖于<code>linker.ld</code>链接脚本和<code>$(objects)</code>中的目标文件。</li>
<li><code>ld $(LDPARAMS) -T $&lt; -o $@ $(objects)</code>: 使用<code>ld</code>链接器将目标文件链接成<code>mykernel.bin</code>。<code>$(LDPARAMS)</code>展开为<code>-melf_i386</code>，<code>-T $&lt;</code>指定链接脚本为<code>linker.ld</code>，<code>-o $@</code>指定输出文件名为<code>mykernel.bin</code>，<code>$(objects)</code>是要链接的目标文件列表。</li>
</ul>
<ol start="2">
<li><p><strong>安装内核二进制文件</strong>:</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">install: mykernel.bin</span></span><br><span class="line">    sudo cp <span class="variable">$&lt;</span> /boot/mykernel.bin</span><br></pre></td></tr></table></figure>

<ul>
<li><code>install: mykernel.bin</code>: 定义了一个目标<code>install</code>，它依赖于<code>mykernel.bin</code>。</li>
<li><code>sudo cp $&lt; /boot/mykernel.bin</code>: 使用<code>sudo</code>权限将<code>mykernel.bin</code>复制到<code>/boot</code>目录下。<code>$&lt;</code>表示第一个依赖文件（即<code>mykernel.bin</code>）。</li>
</ul>
</li>
</ol>
<h3 id="3-kernel-cpp"><a href="#3-kernel-cpp" class="headerlink" title="3.kernel.cpp"></a>3.kernel.cpp</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">kernelMain</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于缺少printf函数的定义导致编译失败</p>
<h3 id="4-loader-s"><a href="#4-loader-s" class="headerlink" title="4.loader.s"></a>4.loader.s</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">.set MAGIC, 0x1badb002</span><br><span class="line">.set FLAGS, (1&lt;&lt;0 | 1&lt;&lt;1)</span><br><span class="line">.set CHECKSUM, -(MAGIC + FLAGS)</span><br><span class="line"></span><br><span class="line">.section .multiboot</span><br><span class="line">    .long MAGIC</span><br><span class="line">    .long FLAGS</span><br><span class="line">    .long CHECKSUM</span><br><span class="line"></span><br><span class="line">.section .text</span><br><span class="line">.extern kernelMain</span><br><span class="line">.global loader</span><br><span class="line"></span><br><span class="line">loader:</span><br><span class="line">    mov $kernel_stack, %esp</span><br><span class="line">    push %eax</span><br><span class="line">    push %ebx</span><br><span class="line">    call kernelMain</span><br><span class="line"></span><br><span class="line">_stop:</span><br><span class="line">    cli</span><br><span class="line">    hlt</span><br><span class="line">    jmp _stop</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.section .bss</span><br><span class="line">.space 2*1024*1024;     # 2MB</span><br><span class="line">kernel_stack:</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这段程序是一个简单的操作系统引导程序，使用了Multiboot标准来确保与兼容Multiboot的引导加载程序（如GRUB）兼容。以下是对这段程序的详细解释：</p>
<h4 id="1-定义常量"><a href="#1-定义常量" class="headerlink" title="1. 定义常量"></a>1. 定义常量</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.set MAGIC, 0x1badb002</span><br><span class="line">.set FLAGS, (1&lt;&lt;0 | 1&lt;&lt;1)</span><br><span class="line">.set CHECKSUM, -(MAGIC + FLAGS)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>MAGIC</code>：这是一个魔数，值为 <code>0x1badb002</code>，用于标识这是一个Multiboot兼容的内核。引导加载程序会检查这个值来确定内核是否遵循Multiboot标准。</li>
<li><code>FLAGS</code>：这是一个标志位，用于指定内核需要的特性。<code>1&lt;&lt;0</code> 表示要求引导加载程序在加载内核时提供内存布局信息，<code>1&lt;&lt;1</code> 表示要求提供引导设备信息。</li>
<li><code>CHECKSUM</code>：这是一个校验和，用于验证Multiboot头的完整性。它的值是 <code>-(MAGIC + FLAGS)</code>，确保 <code>MAGIC + FLAGS + CHECKSUM</code> 的结果为0。</li>
</ul>
<h4 id="2-Multiboot头"><a href="#2-Multiboot头" class="headerlink" title="2. Multiboot头"></a>2. Multiboot头</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.section .multiboot</span><br><span class="line">    .long MAGIC</span><br><span class="line">    .long FLAGS</span><br><span class="line">    .long CHECKSUM</span><br></pre></td></tr></table></figure>

<ul>
<li><code>.section .multiboot</code>：定义了一个名为 <code>.multiboot</code> 的节，用于存放Multiboot头。</li>
<li><code>.long MAGIC</code>、<code>.long FLAGS</code>、<code>.long CHECKSUM</code>：分别将 <code>MAGIC</code>、<code>FLAGS</code> 和 <code>CHECKSUM</code> 的值写入Multiboot头。引导加载程序会读取这些值来验证内核的兼容性。</li>
</ul>
<h4 id="3-代码段"><a href="#3-代码段" class="headerlink" title="3. 代码段"></a>3. 代码段</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.section .text</span><br><span class="line">.extern kernelMain</span><br><span class="line">.global loader</span><br><span class="line"></span><br><span class="line">loader:</span><br><span class="line">    mov $kernel_stack, %esp</span><br><span class="line">    push %eax</span><br><span class="line">    push %ebx</span><br><span class="line">    call kernelMain</span><br><span class="line"></span><br><span class="line">_stop:</span><br><span class="line">    cli</span><br><span class="line">    hlt</span><br><span class="line">    jmp _stop</span><br></pre></td></tr></table></figure>

<ul>
<li><code>.section .text</code>：定义了一个名为 <code>.text</code> 的节，用于存放代码。</li>
<li><code>.extern kernelMain</code>：声明 <code>kernelMain</code> 是一个外部函数，通常这是操作系统内核的主函数。</li>
<li><code>.global loader</code>：声明 <code>loader</code> 是一个全局符号，表示操作系统的入口点。</li>
<li><code>loader:</code>：这是操作系统的入口点。引导加载程序在加载内核后会跳转到这个标签处执行。<ul>
<li><code>mov $kernel_stack, %esp</code>：将栈指针 <code>esp</code> 设置为 <code>kernel_stack</code> 的地址，初始化栈。</li>
<li><code>push %eax</code> 和 <code>push %ebx</code>：将寄存器 <code>eax</code> 和 <code>ebx</code> 的值压入栈中。根据Multiboot标准，<code>eax</code> 包含魔数 <code>0x2BADB002</code>，<code>ebx</code> 包含Multiboot信息结构的地址。</li>
<li><code>call kernelMain</code>：调用 <code>kernelMain</code> 函数，进入操作系统内核的主逻辑。</li>
</ul>
</li>
<li><code>_stop:</code>：这是一个无限循环，用于在 <code>kernelMain</code> 返回后停止CPU的执行。<ul>
<li><code>cli</code>：禁用中断。</li>
<li><code>hlt</code>：使CPU进入休眠状态。</li>
<li><code>jmp _stop</code>：跳转到 <code>_stop</code> 标签，形成一个无限循环。</li>
</ul>
</li>
</ul>
<h4 id="4-未初始化数据段"><a href="#4-未初始化数据段" class="headerlink" title="4. 未初始化数据段"></a>4. 未初始化数据段</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.section .bss</span><br><span class="line">.space 2*1024*1024;     # 2MB</span><br><span class="line">kernel_stack:</span><br></pre></td></tr></table></figure>

<ul>
<li><code>.section .bss</code>：定义了一个名为 <code>.bss</code> 的节，用于存放未初始化的数据。</li>
<li><code>.space 2*1024*1024</code>：在 <code>.bss</code> 节中分配了2MB的空间，用于内核栈。</li>
<li><code>kernel_stack:</code>：这是内核栈的起始地址，<code>loader</code> 标签处的代码将栈指针 <code>esp</code> 设置为这个地址。</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这段程序是一个简单的操作系统引导程序，它遵循Multiboot标准，确保与兼容Multiboot的引导加载程序（如GRUB）兼容。程序的主要功能是初始化栈，保存引导加载程序传递的参数，并跳转到操作系统内核的主函数 <code>kernelMain</code>。如果 <code>kernelMain</code> 返回，程序将进入一个无限循环，停止CPU的执行。</p>
<h3 id="5-编写自己的printf函数"><a href="#5-编写自己的printf函数" class="headerlink" title="5. 编写自己的printf函数"></a>5. 编写自己的printf函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printf</span><span class="params">(<span class="type">char</span>* str)</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>* VideoMemory = (<span class="type">unsigned</span> <span class="type">short</span>*) <span class="number">0xB8000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; str[i] != <span class="string">&#x27;\0&#x27;</span>; ++i) &#123;</span><br><span class="line">        VideoMemory[i] = (VideoMemory[i] &amp; <span class="number">0xFF00</span>) | str[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码实现了一个简单的 <code>printf</code> 函数，用于在文本模式下将字符串输出到屏幕。它直接操作显存，将字符写入显存地址 <code>0xB8000</code>，这是x86架构中文本模式下的显存起始地址。以下是对代码的详细解释：</p>
<hr>
<h4 id="1-函数定义"><a href="#1-函数定义" class="headerlink" title="1. 函数定义"></a>1. 函数定义</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printf</span><span class="params">(<span class="type">char</span>* str)</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<ul>
<li>这是一个名为 <code>printf</code> 的函数，接受一个 <code>char*</code> 类型的参数 <code>str</code>，表示要输出的字符串。</li>
</ul>
<hr>
<h4 id="2-显存地址"><a href="#2-显存地址" class="headerlink" title="2. 显存地址"></a>2. 显存地址</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">short</span>* VideoMemory = (<span class="type">unsigned</span> <span class="type">short</span>*) <span class="number">0xB8000</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>0xB8000</code> 是x86架构中文本模式下的显存起始地址。在文本模式下，屏幕上的每个字符由两个字节表示：<ul>
<li><strong>低字节</strong>：字符的ASCII码。</li>
<li><strong>高字节</strong>：字符的属性（如颜色、背景等）。</li>
</ul>
</li>
<li><code>VideoMemory</code> 是一个指向 <code>unsigned short</code> 类型的指针，每个 <code>unsigned short</code>（16位）对应屏幕上的一个字符。</li>
<li>将 <code>0xB8000</code> 强制转换为 <code>unsigned short*</code> 类型，表示从该地址开始，每两个字节对应屏幕上的一个字符。</li>
</ul>
<hr>
<h4 id="3-循环输出字符"><a href="#3-循环输出字符" class="headerlink" title="3. 循环输出字符"></a>3. 循环输出字符</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; str[i] != <span class="string">&#x27;\0&#x27;</span>; ++i) &#123;</span><br><span class="line">    VideoMemory[i] = (VideoMemory[i] &amp; <span class="number">0xFF00</span>) | str[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这是一个 <code>for</code> 循环，用于遍历字符串 <code>str</code> 中的每个字符，直到遇到字符串结束符 <code>\0</code>。</li>
<li>对于每个字符 <code>str[i]</code>：<ul>
<li><code>VideoMemory[i] &amp; 0xFF00</code>：保留当前显存位置的高字节（属性部分），清除低字节（字符部分）。</li>
<li><code>| str[i]</code>：将字符 <code>str[i]</code> 的ASCII码写入低字节。</li>
<li>最终结果是将字符 <code>str[i]</code> 写入显存，同时保留原有的属性（如颜色）。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-显存写入的细节"><a href="#4-显存写入的细节" class="headerlink" title="4. 显存写入的细节"></a>4. 显存写入的细节</h4><ul>
<li>在文本模式下，显存的每个字符由两个字节组成：<ul>
<li><strong>低字节</strong>：字符的ASCII码。</li>
<li><strong>高字节</strong>：字符的属性（如前景色、背景色等）。</li>
</ul>
</li>
<li>例如，如果 <code>VideoMemory[i]</code> 的当前值是 <code>0x0720</code>：<ul>
<li><code>0x07</code> 是属性（灰色前景，黑色背景）。</li>
<li><code>0x20</code> 是字符（空格）。</li>
</ul>
</li>
<li>如果 <code>str[i]</code> 是字符 <code>A</code>（ASCII码为 <code>0x41</code>），则：<ul>
<li><code>VideoMemory[i] = (0x0720 &amp; 0xFF00) | 0x41</code> 的结果是 <code>0x0741</code>。</li>
<li>屏幕上的对应位置会显示字符 <code>A</code>，颜色为灰色前景，黑色背景。</li>
</ul>
</li>
</ul>
<h3 id="6-linker-ld"><a href="#6-linker-ld" class="headerlink" title="6.linker.ld"></a>6.linker.ld</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(loader)</span><br><span class="line">OUTPUT_FORMAT(elf32-i386)</span><br><span class="line">OUTPUT_ARCH(i386:i386)</span><br><span class="line"></span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">    . = 0x0100000;</span><br><span class="line"></span><br><span class="line">    .text :</span><br><span class="line">    &#123;</span><br><span class="line">        *(.mutiboot)</span><br><span class="line">        *(.text*)</span><br><span class="line">        *(.rodata)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .data :</span><br><span class="line">    &#123;</span><br><span class="line">        start_ctors = .;</span><br><span class="line">        KEEP(*( .init_array ));</span><br><span class="line">        KEEP(*(SORT_BY_INIT_PRIORITY( .init_array*)));</span><br><span class="line">        end_ctors = .;</span><br><span class="line"></span><br><span class="line">        *(.data)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .bss :</span><br><span class="line">    &#123;</span><br><span class="line">        *(.bss)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /DISCARD/ : </span><br><span class="line">    &#123;</span><br><span class="line">        *(.fini_array*)</span><br><span class="line">        *(.comment)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个链接器脚本（Linker Script），用于定义操作系统内核的内存布局和段（Section）的组织方式。它指定了内核的入口点、输出格式、架构以及各个段（如 <code>.text</code>、<code>.data</code>、<code>.bss</code> 等）的加载地址和顺序。以下是对脚本的详细解释：</p>
<hr>
<h4 id="1-入口点和输出格式"><a href="#1-入口点和输出格式" class="headerlink" title="1. 入口点和输出格式"></a>1. 入口点和输出格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(loader)</span><br><span class="line">OUTPUT_FORMAT(elf32-i386)</span><br><span class="line">OUTPUT_ARCH(i386:i386)</span><br></pre></td></tr></table></figure>

<ul>
<li>**ENTRY(loader)**：指定程序的入口点为 <code>loader</code> 符号。这是操作系统内核的启动代码，通常是引导加载程序（如 GRUB）跳转到的第一个函数。</li>
<li>**OUTPUT_FORMAT(elf32-i386)**：指定输出文件的格式为 32 位 ELF 格式，适用于 x86 架构。</li>
<li>**OUTPUT_ARCH(i386:i386 )**：指定输出文件的架构为 32 位 x86（i386）。</li>
</ul>
<hr>
<h4 id="2-内存布局"><a href="#2-内存布局" class="headerlink" title="2. 内存布局"></a>2. 内存布局</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">    . = 0x0100000;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>SECTIONS</strong>：定义内存布局的起始。</li>
<li><strong>. &#x3D; 0x0100000</strong>：设置当前地址为 <code>0x0100000</code>（1 MB）。这是内核加载的起始地址，通常用于操作系统内核的加载地址。</li>
</ul>
<hr>
<h4 id="3-text-段"><a href="#3-text-段" class="headerlink" title="3. .text 段"></a>3. <code>.text</code> 段</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.text :</span><br><span class="line">&#123;</span><br><span class="line">    *(.mutiboot)</span><br><span class="line">    *(.text*)</span><br><span class="line">    *(.rodata)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>.text</strong>：定义代码段（<code>.text</code>），包含可执行代码和只读数据。<ul>
<li>***(.mutiboot)**：包含所有输入文件中的 <code>.multiboot</code> 段（Multiboot 头）。</li>
<li>***(.text*)**：包含所有输入文件中的代码段（<code>.text</code> 及其变体）。</li>
<li>***(.rodata)**：包含所有输入文件中的只读数据段（<code>.rodata</code>）。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-data-段"><a href="#4-data-段" class="headerlink" title="4. .data 段"></a>4. <code>.data</code> 段</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.data :</span><br><span class="line">&#123;</span><br><span class="line">    start_ctors = .;</span><br><span class="line">    KEEP(*( .init_array ));</span><br><span class="line">    KEEP(*(SORT_BY_INIT_PRIORITY( .init_array*)));</span><br><span class="line">    end_ctors = .;</span><br><span class="line"></span><br><span class="line">    *(.data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>.data</strong>：定义数据段（<code>.data</code>），包含已初始化的全局变量和静态变量。<ul>
<li>**start_ctors &#x3D; .;**：定义一个符号 <code>start_ctors</code>，表示构造函数（全局对象的构造函数）的起始地址。</li>
<li>**KEEP(*( .init_array ))**：保留所有输入文件中的 <code>.init_array</code> 段，用于存放全局对象的构造函数指针。</li>
<li>**KEEP(*(SORT_BY_INIT_PRIORITY( .init_array* )))**：保留所有输入文件中的 <code>.init_array*</code> 段，并按初始化优先级排序。</li>
<li>**end_ctors &#x3D; .;**：定义一个符号 <code>end_ctors</code>，表示构造函数的结束地址。</li>
<li>***(.data)**：包含所有输入文件中的数据段（<code>.data</code>）。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="5-bss-段"><a href="#5-bss-段" class="headerlink" title="5. .bss 段"></a>5. <code>.bss</code> 段</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.bss :</span><br><span class="line">&#123;</span><br><span class="line">    *(.bss)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>.bss</strong>：定义未初始化数据段（<code>.bss</code>），包含未初始化的全局变量和静态变量。<ul>
<li>***(.bss)**：包含所有输入文件中的 <code>.bss</code> 段。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="6-丢弃的段"><a href="#6-丢弃的段" class="headerlink" title="6. 丢弃的段"></a>6. 丢弃的段</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/DISCARD/ : </span><br><span class="line">&#123;</span><br><span class="line">    *(.fini_array*)</span><br><span class="line">    *(.comment)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>**&#x2F;DISCARD&#x2F;**：定义需要丢弃的段。<ul>
<li>***(.fini_array*)**：丢弃所有输入文件中的 <code>.fini_array*</code> 段（析构函数表）。</li>
<li>***(.comment)**：丢弃所有输入文件中的 <code>.comment</code> 段（注释信息）。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h4><p>这个链接器脚本的主要功能是：</p>
<ol>
<li>定义内核的入口点为 <code>loader</code>。</li>
<li>指定输出文件为 32 位 ELF 格式，适用于 x86 架构。</li>
<li>设置内核的加载地址为 <code>0x0100000</code>（1 MB）。</li>
<li>组织代码段（<code>.text</code>）、数据段（<code>.data</code>）和未初始化数据段（<code>.bss</code>）的内存布局。</li>
<li>保留构造函数表（<code>.init_array</code>），丢弃析构函数表（<code>.fini_array</code>）和注释信息（<code>.comment</code>）。</li>
</ol>
<hr>
<h4 id="8-关键点"><a href="#8-关键点" class="headerlink" title="8. 关键点"></a>8. 关键点</h4><ul>
<li><strong>Multiboot 头</strong>：<code>.multiboot</code> 段必须位于内核的最开始，以便引导加载程序（如 GRUB）能够正确识别内核。</li>
<li><strong>构造函数和析构函数</strong>：<code>.init_array</code> 和 <code>.fini_array</code> 用于全局对象的构造和析构。操作系统内核通常不需要析构函数，因此丢弃 <code>.fini_array</code>。</li>
<li><strong>内存布局</strong>：内核的加载地址和段的组织方式对操作系统的正常运行至关重要。</li>
</ul>
<hr>
<h4 id="9-示例内核的加载过程"><a href="#9-示例内核的加载过程" class="headerlink" title="9. 示例内核的加载过程"></a>9. 示例内核的加载过程</h4><ol>
<li>引导加载程序（如 GRUB）将内核加载到 <code>0x0100000</code> 地址。</li>
<li>跳转到 <code>loader</code> 入口点，开始执行内核代码。</li>
<li>内核的代码段、数据段和未初始化数据段按照链接器脚本的定义进行布局。</li>
<li>全局对象的构造函数在启动时被调用（通过 <code>.init_array</code>）。</li>
</ol>
<hr>
<p>通过这个链接器脚本，操作系统内核可以正确地加载到内存中，并按照预期的布局运行。</p>
<h3 id="7-kernelMain函数修改"><a href="#7-kernelMain函数修改" class="headerlink" title="7.kernelMain函数修改"></a>7.kernelMain函数修改</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">void</span> <span class="title">kernelMain</span><span class="params">(<span class="type">void</span>* multiboot_structure, <span class="type">unsigned</span> <span class="type">int</span> magicnumber)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>extern &quot;C&quot;</code> 是 C++ 中的一个关键字，用于指定函数使用 C 语言的链接规则（linkage）。它的主要作用是防止 C++ 编译器对函数名进行名称修饰（name mangling），从而确保函数名在编译后的目标文件中保持原样，以便与 C 代码或其他外部代码正确链接。</p>
<hr>
<h4 id="1-C-的名称修饰（Name-Mangling）"><a href="#1-C-的名称修饰（Name-Mangling）" class="headerlink" title="1. C++ 的名称修饰（Name Mangling）"></a>1. C++ 的名称修饰（Name Mangling）</h4><p>在 C++ 中，函数名在编译时会被编译器修饰（mangled），以支持函数重载和其他 C++ 特性。例如，一个函数 <code>void foo(int)</code> 可能会被修饰为 <code>_Z3fooi</code>。这种修饰后的名称包含了函数的参数类型和返回类型信息。</p>
<p>然而，C 语言没有名称修饰的概念。C 编译器会直接使用函数名作为符号名。因此，如果 C++ 代码需要与 C 代码或其他外部代码（如汇编代码或操作系统引导加载程序）交互，就需要使用 <code>extern &quot;C&quot;</code> 来禁用名称修饰。</p>
<hr>
<h4 id="2-extern-C-的作用"><a href="#2-extern-C-的作用" class="headerlink" title="2. extern &quot;C&quot; 的作用"></a>2. <code>extern &quot;C&quot;</code> 的作用</h4><p><code>extern &quot;C&quot;</code> 的作用是告诉 C++ 编译器：</p>
<ul>
<li>按照 C 语言的规则处理函数的链接。</li>
<li>不进行名称修饰，直接使用函数名作为符号名。</li>
</ul>
<h3 id="8-修改grub-cfg"><a href="#8-修改grub-cfg" class="headerlink" title="8. 修改grub.cfg"></a>8. 修改grub.cfg</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">### BEGIN MYKERNEL ###</span><br><span class="line">menuentry &#x27;My Operating System&#x27;&#123;</span><br><span class="line">        mutiboot /boot/mykernel.bin</span><br><span class="line">        boot</span><br><span class="line">&#125;</span><br><span class="line">### END MYKERNEL ###</span><br></pre></td></tr></table></figure>

<p>这段代码是一个 <strong>GRUB 引导加载程序的配置文件片段</strong>，用于定义一个名为 “My Operating System” 的菜单项，并指定如何加载和启动你的操作系统内核（<code>mykernel.bin</code>）。以下是对这段配置的详细解释：</p>
<hr>
<h4 id="1-配置文件的作用"><a href="#1-配置文件的作用" class="headerlink" title="1. 配置文件的作用"></a>1. 配置文件的作用</h4><p>GRUB（Grand Unified Bootloader）是一个常用的引导加载程序，用于加载操作系统内核。GRUB 的配置文件（通常是 <code>/boot/grub/grub.cfg</code> 或 <code>/boot/grub2/grub.cfg</code>）定义了启动菜单和启动选项。</p>
<p>这段代码是 GRUB 配置文件的一部分，用于添加一个自定义的启动项，加载你的操作系统内核。</p>
<hr>
<h4 id="2-配置内容解析"><a href="#2-配置内容解析" class="headerlink" title="2. 配置内容解析"></a>2. 配置内容解析</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">### BEGIN MYKERNEL ###</span><br><span class="line">menuentry &#x27;My Operating System&#x27;&#123;</span><br><span class="line">        multiboot /boot/mykernel.bin</span><br><span class="line">        boot</span><br><span class="line">&#125;</span><br><span class="line">### END MYKERNEL ###</span><br></pre></td></tr></table></figure>

<p>(1) <code>### BEGIN MYKERNEL ###</code> 和 <code>### END MYKERNEL ###</code></p>
<ul>
<li>这是注释，用于标记配置文件的开始和结束。GRUB 会忽略这些注释。</li>
<li>它们的作用是帮助开发者识别和区分不同的配置块。</li>
</ul>
<p>(2) <code>menuentry &#39;My Operating System&#39; &#123; ... &#125;</code></p>
<ul>
<li><code>menuentry</code> 是 GRUB 配置中的一个关键字，用于定义一个启动菜单项。</li>
<li><code>&#39;My Operating System&#39;</code> 是菜单项的名称，显示在 GRUB 启动菜单中。</li>
<li><code>&#123; ... &#125;</code> 中是菜单项的具体配置。</li>
</ul>
<p>(3) <code>multiboot /boot/mykernel.bin</code></p>
<ul>
<li><code>multiboot</code> 是 GRUB 的一个命令，用于加载符合 <strong>Multiboot 规范</strong> 的内核文件。</li>
<li><code>/boot/mykernel.bin</code> 是你的操作系统内核文件的路径。GRUB 会从文件系统中加载这个文件。<ul>
<li><code>/boot/</code> 是内核文件通常存放的目录。</li>
<li><code>mykernel.bin</code> 是你的内核文件名。</li>
</ul>
</li>
</ul>
<p>(4) <code>boot</code></p>
<ul>
<li><code>boot</code> 是 GRUB 的一个命令，用于启动已加载的内核。</li>
<li>执行 <code>boot</code> 后，GRUB 会将控制权交给内核，开始操作系统的启动过程。</li>
</ul>
<h3 id="9-Addendum"><a href="#9-Addendum" class="headerlink" title="9.Addendum"></a>9.Addendum</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*constructor)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> constructor start_ctors;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> constructor end_ctors;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">void</span> <span class="title">callConstructors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(constructor* i = &amp;start_ctors; i != &amp;end_ctors; i++) &#123;</span><br><span class="line">        (*i)();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.section .text</span><br><span class="line">.extern kernelMain</span><br><span class="line">.extern callConstructors</span><br><span class="line">.global loader</span><br><span class="line"></span><br><span class="line">loader:</span><br><span class="line">    mov $kernel_stack, %esp</span><br><span class="line"></span><br><span class="line">    call callConstructors</span><br><span class="line"></span><br><span class="line">    push %eax</span><br><span class="line">    push %ebx</span><br><span class="line">    call kernelMain</span><br></pre></td></tr></table></figure>

<p>这段代码是操作系统内核启动代码的一部分，主要用于调用全局对象的构造函数（constructors），然后跳转到内核的主函数 <code>kernelMain</code>。以下是对代码的详细解释：</p>
<hr>
<h4 id="1-构造函数指针类型"><a href="#1-构造函数指针类型" class="headerlink" title="1. 构造函数指针类型"></a>1. 构造函数指针类型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*constructor)</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>定义了一个函数指针类型 <code>constructor</code>，指向一个没有参数和返回值的函数。</li>
<li>这种类型的函数通常用于全局对象的构造函数。</li>
</ul>
<hr>
<h4 id="2-外部符号声明"><a href="#2-外部符号声明" class="headerlink" title="2. 外部符号声明"></a>2. 外部符号声明</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> constructor start_ctors;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> constructor end_ctors;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>start_ctors</code> 和 <code>end_ctors</code> 是两个外部符号，分别表示构造函数表的起始和结束地址。</li>
<li>这些符号通常在链接器脚本中定义，用于标记全局构造函数表的范围。</li>
<li><code>extern &quot;C&quot;</code> 用于禁用 C++ 的名称修饰（name mangling），确保符号名在链接时保持一致。</li>
</ul>
<hr>
<h4 id="3-调用构造函数"><a href="#3-调用构造函数" class="headerlink" title="3. 调用构造函数"></a>3. 调用构造函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">void</span> <span class="title">callConstructors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(constructor* i = &amp;start_ctors; i != &amp;end_ctors; i++) &#123;</span><br><span class="line">        (*i)();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>callConstructors</code> 是一个函数，用于遍历构造函数表并调用每个构造函数。</li>
<li><code>start_ctors</code> 和 <code>end_ctors</code> 分别指向构造函数表的起始和结束地址。</li>
<li>通过 <code>for</code> 循环遍历构造函数表，依次调用每个构造函数。</li>
</ul>
<hr>
<h4 id="4-汇编代码"><a href="#4-汇编代码" class="headerlink" title="4. 汇编代码"></a>4. 汇编代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.section .text</span><br><span class="line">.extern kernelMain</span><br><span class="line">.extern callConstructors</span><br><span class="line">.global loader</span><br><span class="line"></span><br><span class="line">loader:</span><br><span class="line">    mov $kernel_stack, %esp</span><br><span class="line"></span><br><span class="line">    call callConstructors</span><br><span class="line"></span><br><span class="line">    push %eax</span><br><span class="line">    push %ebx</span><br><span class="line">    call kernelMain</span><br></pre></td></tr></table></figure>

<p>(1) <code>.section .text</code></p>
<ul>
<li>定义代码段（<code>.text</code>），用于存放可执行代码。</li>
</ul>
<p>(2) <code>.extern kernelMain</code> 和 <code>.extern callConstructors</code></p>
<ul>
<li>声明 <code>kernelMain</code> 和 <code>callConstructors</code> 是外部符号，分别表示内核的主函数和构造函数调用函数。</li>
</ul>
<p>(3) <code>.global loader</code></p>
<ul>
<li>声明 <code>loader</code> 是一个全局符号，表示操作系统的入口点。</li>
</ul>
<p>(4) <code>loader:</code></p>
<ul>
<li>这是操作系统的入口点，引导加载程序（如 GRUB）会跳转到这个标签处执行。</li>
</ul>
<p>(5) <code>mov $kernel_stack, %esp</code></p>
<ul>
<li>将栈指针 <code>esp</code> 设置为 <code>kernel_stack</code> 的地址，初始化栈。</li>
<li><code>kernel_stack</code> 是一个符号，通常在链接器脚本中定义，表示内核栈的起始地址。</li>
</ul>
<p>(6) <code>call callConstructors</code></p>
<ul>
<li>调用 <code>callConstructors</code> 函数，遍历并调用所有全局对象的构造函数。</li>
</ul>
<p> (7) <code>push %eax</code> 和 <code>push %ebx</code></p>
<ul>
<li>将寄存器 <code>eax</code> 和 <code>ebx</code> 的值压入栈中。</li>
<li>根据 Multiboot 规范，<code>eax</code> 包含魔数 <code>0x2BADB002</code>，<code>ebx</code> 包含 Multiboot 信息结构的地址。</li>
</ul>
<p>(8) <code>call kernelMain</code></p>
<ul>
<li>调用 <code>kernelMain</code> 函数，进入操作系统内核的主逻辑。</li>
</ul>
<hr>
<h4 id="5-链接器脚本中的构造函数表"><a href="#5-链接器脚本中的构造函数表" class="headerlink" title="5. 链接器脚本中的构造函数表"></a>5. 链接器脚本中的构造函数表</h4><p>在链接器脚本中，通常会定义 <code>start_ctors</code> 和 <code>end_ctors</code> 符号，用于标记构造函数表的范围。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">    . = 0x0100000;</span><br><span class="line"></span><br><span class="line">    .text :</span><br><span class="line">    &#123;</span><br><span class="line">        *(.multiboot)</span><br><span class="line">        *(.text*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .data :</span><br><span class="line">    &#123;</span><br><span class="line">        start_ctors = .;</span><br><span class="line">        KEEP(*(.init_array));</span><br><span class="line">        KEEP(*(SORT_BY_INIT_PRIORITY(.init_array.*)));</span><br><span class="line">        end_ctors = .;</span><br><span class="line"></span><br><span class="line">        *(.data)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .bss :</span><br><span class="line">    &#123;</span><br><span class="line">        *(.bss)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>start_ctors</code> 和 <code>end_ctors</code> 分别指向 <code>.init_array</code> 段的起始和结束地址。</li>
<li><code>.init_array</code> 段存放全局对象的构造函数指针。</li>
</ul>
<hr>
<h4 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h4><p>这段代码的主要功能是：</p>
<ol>
<li>定义构造函数指针类型 <code>constructor</code>。</li>
<li>声明外部符号 <code>start_ctors</code> 和 <code>end_ctors</code>，表示构造函数表的范围。</li>
<li>实现 <code>callConstructors</code> 函数，遍历并调用所有全局对象的构造函数。</li>
<li>在汇编代码中，初始化栈，调用构造函数，然后跳转到内核的主函数 <code>kernelMain</code>。</li>
</ol>
<p>通过这种方式，操作系统内核可以在启动时正确初始化全局对象，然后进入主逻辑。</p>
</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.jpg" alt="Rossignol"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Rossignol</p><p class="is-size-6 is-block">NaN</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Mars</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives/"><p class="title">24</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories/"><p class="title">15</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags/"><p class="title">16</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/0xRossignol" target="_blank" rel="me noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/0xRossignol"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Golang/"><span class="level-start"><span class="level-item">Golang</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/Golang/basics/"><span class="level-start"><span class="level-item">basics</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/Java/basics/"><span class="level-start"><span class="level-item">basics</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/Java/basics/Thinking-in-Java/"><span class="level-start"><span class="level-item">Thinking in Java</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/Linux/Arch-Linux/"><span class="level-start"><span class="level-item">Arch Linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/OS/"><span class="level-start"><span class="level-item">OS</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Software-Construction/"><span class="level-start"><span class="level-item">Software Construction</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul><li><a class="level is-mobile" href="/categories/Software-Construction/MIT6-031/"><span class="level-start"><span class="level-item">MIT6.031</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/TypeScript/"><span class="level-start"><span class="level-item">TypeScript</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/test/"><span class="level-start"><span class="level-item">test</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/toy-projects/"><span class="level-start"><span class="level-item">toy projects</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%85%AB%E8%82%A1/"><span class="level-start"><span class="level-item">八股</span></span><span class="level-end"><span class="level-item tag">4</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%85%AB%E8%82%A1/JavaSE/"><span class="level-start"><span class="level-item">JavaSE</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-04-06T14:45:19.961Z">2025-04-06</time></p><p class="title"><a href="/2025/04/06/%E5%85%AB%E8%82%A1/Java/IO/IO%20%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-04-06T14:45:19.961Z">2025-04-06</time></p><p class="title"><a href="/2025/04/06/%E5%85%AB%E8%82%A1/Java/IO/IO%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-04-06T14:45:19.961Z">2025-04-06</time></p><p class="title"><a href="/2025/04/06/%E5%85%AB%E8%82%A1/Java/IO/NIO%20%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-04-06T14:45:06.006Z">2025-04-06</time></p><p class="title"><a href="/2025/04/06/%E5%85%AB%E8%82%A1/Java/IO/IO%20%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-04-06T13:55:29.000Z">2025-04-06</time></p><p class="title"><a href="/2025/04/06/%E5%85%AB%E8%82%A1/Java/Java%E5%9F%BA%E7%A1%80/JavaSE%20pt.3/">JavaSE pt.3</a></p><p class="categories"><a href="/categories/%E5%85%AB%E8%82%A1/">八股</a> / <a href="/categories/%E5%85%AB%E8%82%A1/JavaSE/">JavaSE</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2025/04/"><span class="level-start"><span class="level-item">四月 2025</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/03/"><span class="level-start"><span class="level-item">三月 2025</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/02/"><span class="level-start"><span class="level-item">二月 2025</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/01/"><span class="level-start"><span class="level-item">一月 2025</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/12/"><span class="level-start"><span class="level-item">十二月 2024</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Arch-Linux/"><span class="tag">Arch Linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/English/"><span class="tag">English</span><span class="tag">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Golang/"><span class="tag">Golang</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OS/"><span class="tag">OS</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Software-Construction/"><span class="tag">Software Construction</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TypeScript/"><span class="tag">TypeScript</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/git/"><span class="tag">git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/python/"><span class="tag">python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/test/"><span class="tag">test</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/toy-projects/"><span class="tag">toy projects</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%B8%AD%E6%96%87/"><span class="tag">中文</span><span class="tag">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%85%AB%E8%82%A1/"><span class="tag">八股</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B1%87%E7%BC%96/"><span class="tag">汇编</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BF%BB%E8%AF%91/"><span class="tag">翻译</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="MyBlog" height="28"></a><p class="is-size-7"><span>&copy; 2025 Rossignol</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>