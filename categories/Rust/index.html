<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>分类: Rust - MyBlog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="MyBlog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="MyBlog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="MyBlog"><meta property="og:url" content="http://example.com/"><meta property="og:site_name" content="MyBlog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:author" content="Rossignol"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"MyBlog","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"Rossignol"},"publisher":{"@type":"Organization","name":"MyBlog","logo":{"@type":"ImageObject","url":"http://example.com/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="MyBlog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/0xRossignol"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories/">分类</a></li><li class="is-active"><a href="#" aria-current="page">Rust</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-06-08T14:20:26.000Z" title="2025/6/8 22:20:26">2025-06-08</time>发表</span><span class="level-item"><time dateTime="2025-06-08T14:31:45.553Z" title="2025/6/8 22:31:45">2025-06-08</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Rust/">Rust</a><span> / </span><a class="link-muted" href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></span><span class="level-item">2 分钟读完 (大约267个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/06/08/Rust/The%20Rust%20Programming%20Language/14.5%20Cargo%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%89%A9%E5%B1%95%E5%91%BD%E4%BB%A4/">14.5 Cargo 自定义扩展命令</a></p><div class="content"><h2 id="Cargo-自定义扩展命令"><a href="#Cargo-自定义扩展命令" class="headerlink" title="Cargo 自定义扩展命令"></a>Cargo 自定义扩展命令</h2><p>Cargo 的设计使得开发者可以通过新的子命令来对 Cargo 进行扩展，而无需修改其本身。如果 <code>$PATH</code> 中有类似 <code>cargo-something</code> 的二进制文件，就可以通过 <code>cargo something</code> 来像 Cargo 子命令一样运行它。像这样的自定义命令也可以运行 <code>cargo --list</code> 来展示出来。能够通过 <code>cargo install</code> 向 Cargo 安装扩展并可以如内建 Cargo 工具那样运行它们是 Cargo 设计上的一个非常方便的优点！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过 Cargo 和 <a target="_blank" rel="noopener" href="https://crates.io/">crates.io</a> 来分享代码是使得 Rust 生态环境可以用于许多不同的任务的重要组成部分。Rust 的标准库是小而稳定的，不过 crate 易于分享和使用，并采用一个不同于语言自身的时间线来提供改进。不要犹豫在 <a target="_blank" rel="noopener" href="https://crates.io/">crates.io</a> 上共享对你有用的代码，因为它很有可能对别人也很有用！</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-06-08T14:10:26.000Z" title="2025/6/8 22:10:26">2025-06-08</time>发表</span><span class="level-item"><time dateTime="2025-06-08T14:31:39.722Z" title="2025/6/8 22:31:39">2025-06-08</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Rust/">Rust</a><span> / </span><a class="link-muted" href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></span><span class="level-item">3 分钟读完 (大约449个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/06/08/Rust/The%20Rust%20Programming%20Language/14.4%20%E4%BD%BF%E7%94%A8%20cargo%20install%20%E5%AE%89%E8%A3%85%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6/">14.4 使用 cargo install 安装二进制文件</a></p><div class="content"><h2 id="使用-cargo-install-安装二进制文件"><a href="#使用-cargo-install-安装二进制文件" class="headerlink" title="使用 cargo install 安装二进制文件"></a>使用 <code>cargo install</code> 安装二进制文件</h2><p><code>cargo install</code> 命令用于在本地安装和使用二进制 crate。它并不打算替换系统中的包；它意在作为一个方便 Rust 开发者们安装其他人已经在 <a target="_blank" rel="noopener" href="https://crates.io/">crates.io</a> 上共享的工具的手段。只有拥有二进制目标文件的包能够被安装。<strong>二进制目标</strong> 文件是在 crate 有 <em>src&#x2F;main.rs</em> 或者其他指定为二进制文件时所创建的可执行程序，这不同于自身不能执行但适合包含在其他程序中的库目标文件。通常 crate 的 <em>README</em> 文件中有该 crate 是库、二进制目标还是两者兼有的信息。</p>
<p>所有来自 <code>cargo install</code> 的二进制文件都安装到 Rust 安装根目录的 <em>bin</em> 文件夹中。如果你是使用 <em>rustup.rs</em> 来安装 Rust 且没有自定义任何配置，这个目录将是 <em>$HOME&#x2F;.cargo&#x2F;bin</em>。确保将这个目录添加到 <code>$PATH</code> 环境变量中就能够运行通过 <code>cargo install</code> 安装的程序了。</p>
<p>例如，第十二章提到的叫做 <code>ripgrep</code> 的用于搜索文件的 <code>grep</code> 的 Rust 实现。为了安装 <code>ripgrep</code> 运行如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo install ripgrep</span></span><br><span class="line">    Updating crates.io index</span><br><span class="line">  Downloaded ripgrep v14.1.1</span><br><span class="line">  Downloaded 1 crate (213.6 KB) in 0.40s</span><br><span class="line">  Installing ripgrep v14.1.1</span><br><span class="line">--snip--</span><br><span class="line">   Compiling grep v0.3.2</span><br><span class="line">    Finished `release` profile [optimized + debuginfo] target(s) in 6.73s</span><br><span class="line">  Installing ~/.cargo/bin/rg</span><br><span class="line">   Installed package `ripgrep v14.1.1` (executable `rg`)</span><br></pre></td></tr></table></figure>

<p>倒数第二行输出展示了安装的二进制文件的位置和名称，在这里 <code>ripgrep</code> 被命名为 <code>rg</code>。只要你像上面提到的那样将安装目录加入 <code>$PATH</code>，就可以运行 <code>rg --help</code> 并开始使用一个更快更 Rust 的工具来搜索文件了！</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-06-08T14:00:26.000Z" title="2025/6/8 22:00:26">2025-06-08</time>发表</span><span class="level-item"><time dateTime="2025-06-08T14:31:33.863Z" title="2025/6/8 22:31:33">2025-06-08</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Rust/">Rust</a><span> / </span><a class="link-muted" href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></span><span class="level-item">17 分钟读完 (大约2591个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/06/08/Rust/The%20Rust%20Programming%20Language/14.3%20Cargo%20%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4/">14.3 Cargo 工作空间</a></p><div class="content"><h2 id="Cargo-工作空间"><a href="#Cargo-工作空间" class="headerlink" title="Cargo 工作空间"></a>Cargo 工作空间</h2><p>第十二章中，我们构建一个包含二进制 crate 和库 crate 的包。你可能会发现，随着项目开发的深入，库 crate 持续增大，而你希望将其进一步拆分成多个库 crate。Cargo 提供了一个叫<strong>工作空间</strong>（<em>workspaces</em>）的功能，它可以帮助我们管理多个相关的协同开发的包。</p>
<h3 id="创建工作空间"><a href="#创建工作空间" class="headerlink" title="创建工作空间"></a>创建工作空间</h3><p><strong>工作空间</strong>是一系列共享同样的 <em>Cargo.lock</em> 和输出目录的包。让我们使用工作空间创建一个项目 —— 这里采用常见的代码以便可以关注工作空间的结构。有多种组织工作空间的方式，所以我们只展示一个常用方法。我们的工作空间有一个二进制项目和两个库。二进制项目会提供主要功能，并会依赖另两个库。一个库会提供 <code>add_one</code> 方法而第二个会提供 <code>add_two</code> 方法。这三个 crate 将会是相同工作空间的一部分。让我们以新建工作空间目录开始：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> add</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> add</span></span><br></pre></td></tr></table></figure>

<p>接着在 <em>add</em> 目录中，创建 <em>Cargo.toml</em> 文件，用于配置整个整个工作空间。它不会包含 <code>[package]</code> 部分。相反，它以 <code>[workspace]</code> 部分作为开始，允许我们向工作区添加成员。我们还通过将 <code>resolver</code> 设置为 <code>&quot;3&quot;</code>，在工作区中使用 Cargo 最新且最强大的解析算法。</p>
<p>接着在 <em>add</em> 目录中，创建 <em>Cargo.toml</em> 文件，用于配置整个整个工作空间。它不会包含 <code>[package]</code> 部分。相反，它以 <code>[workspace]</code> 部分作为开始，允许我们向工作区添加成员。我们还通过将 <code>resolver</code> 设置为 <code>&quot;3&quot;</code>，在工作区中使用 Cargo 最新且最强大的解析算法。</p>
<p>文件名：Cargo.toml</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[workspace]</span></span><br><span class="line"><span class="attr">resolver</span> = <span class="string">&quot;3&quot;</span></span><br></pre></td></tr></table></figure>

<p>接下来，在 <em>add</em> 目录运行 <code>cargo new</code> 新建 <code>adder</code> 二进制 crate：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo new adder</span></span><br><span class="line">    Creating binary (application) `adder` package</span><br><span class="line">      Adding `adder` as member of workspace at `file:///projects/add`</span><br></pre></td></tr></table></figure>

<p>在工作空间中运行 <code>cargo new</code> 也会自动将新建包加入到工作空间 <code>Cargo.toml</code> 的 <code>[workspace]</code> 定义的 <code>members</code> 键中，像这样：</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[workspace]</span></span><br><span class="line"><span class="attr">resolver</span> = <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">members</span> = [<span class="string">&quot;adder&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>到此为止，可以运行 <code>cargo build</code> 来构建工作空间。<em>add</em> 目录中的文件应该看起来像这样：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── Cargo.lock</span><br><span class="line">├── Cargo.toml</span><br><span class="line">├── adder</span><br><span class="line">│   ├── Cargo.toml</span><br><span class="line">│   └── src</span><br><span class="line">│       └── main.rs</span><br><span class="line">└── target</span><br></pre></td></tr></table></figure>

<p>工作空间在顶级目录只有一个 <em>target</em> 目录，用于存放编译生成的产物；<code>adder</code> 包并没有自己的 <em>target</em> 目录。即使进入 <em>adder</em> 目录运行 <code>cargo build</code>，构建结果也位于 <em>add&#x2F;target</em> 而不是 <em>add&#x2F;adder&#x2F;target</em>。工作空间中的 crate 之间相互依赖。如果每个 crate 有其自己的 <em>target</em> 目录，为了在自己的 <em>target</em> 目录中生成构建结果，工作空间中的每一个 crate 都不得不相互重新编译其他 crate。通过共享一个 <em>target</em> 目录，工作空间可以避免其他 crate 重复构建。</p>
<h3 id="在工作空间中创建第二个包"><a href="#在工作空间中创建第二个包" class="headerlink" title="在工作空间中创建第二个包"></a>在工作空间中创建第二个包</h3><p>接下来，让我们在工作空间中创建另一个成员包，并将其命名为 <code>add_one</code>。生成一个名为 <code>add_one</code> 的库 crate：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo new add_one --lib</span></span><br><span class="line">    Creating library `add_one` package</span><br><span class="line">      Adding `add_one` as member of workspace at `file:///projects/add`</span><br></pre></td></tr></table></figure>

<p>现在顶层的 <em>Cargo.toml</em> 的 <code>members</code> 列表将会包含 add_one* 路径：</p>
<p>文件名：Cargo.toml</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[workspace]</span></span><br><span class="line"><span class="attr">resolver</span> = <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">members</span> = [<span class="string">&quot;adder&quot;</span>, <span class="string">&quot;add_one&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>现在 <em>add</em> 目录应该有如下目录和文件：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">├── Cargo.lock</span><br><span class="line">├── Cargo.toml</span><br><span class="line">├── add_one</span><br><span class="line">│   ├── Cargo.toml</span><br><span class="line">│   └── src</span><br><span class="line">│       └── lib.rs</span><br><span class="line">├── adder</span><br><span class="line">│   ├── Cargo.toml</span><br><span class="line">│   └── src</span><br><span class="line">│       └── main.rs</span><br><span class="line">└── target</span><br></pre></td></tr></table></figure>

<p>在 <em>add_one&#x2F;src&#x2F;lib.rs</em> 文件中，增加一个 <code>add_one</code> 函数：</p>
<p>文件名：add_one&#x2F;src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_one</span>(x: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    x + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们有了二进制 <code>adder</code> 包依赖库 crate <code>add_one</code> 包。首先需要在 <em>adder&#x2F;Cargo.toml</em> 文件中增加 <code>add_one</code> 作为路径依赖：</p>
<p>文件名：adder&#x2F;Cargo.toml</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">add_one</span> = &#123; path = <span class="string">&quot;../add_one&quot;</span> &#125;</span><br></pre></td></tr></table></figure>

<p>cargo 并不假定工作空间中的 Crates 会相互依赖，所以需要显式表明工作空间中 crate 的依赖关系。</p>
<p>接下来，在 <code>adder</code> crate 中使用（ <code>add_one</code> crate 中的）函数 <code>add_one</code>。打开 <em>adder&#x2F;src&#x2F;main.rs</em> 在顶部增加一行 <code>use</code> 将新 <code>add_one</code> 库 crate 引入作用域。接着修改 <code>main</code> 函数来调用 <code>add_one</code> 函数，如示例 14-7 所示。</p>
<p>文件名：adder&#x2F;src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num</span> = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world! &#123;num&#125; plus one is &#123;&#125;!&quot;</span>, add_one::<span class="title function_ invoke__">add_one</span>(num));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 14-7：在 <code>adder</code> crate 中使用 <code>add_one</code> 库 crate</p>
<p>在顶层 <em>add</em> 目录中运行 <code>cargo build</code> 来构建工作空间！</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo build</span></span><br><span class="line">   Compiling add_one v0.1.0 (file:///projects/add/add_one)</span><br><span class="line">   Compiling adder v0.1.0 (file:///projects/add/adder)</span><br><span class="line">    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.22s</span><br></pre></td></tr></table></figure>

<p>为了在顶层 <em>add</em> 目录运行二进制 crate，可以通过 <code>-p</code> 参数和包名称来运行 <code>cargo run</code> 指定工作空间中我们希望使用的包：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run -p adder</span></span><br><span class="line">    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.00s</span><br><span class="line">     Running `target/debug/adder`</span><br><span class="line">Hello, world! 10 plus one is 11!</span><br></pre></td></tr></table></figure>

<p>这会运行 <em>adder&#x2F;src&#x2F;main.rs</em> 中的代码，其依赖 <code>add_one</code> crate</p>
<h4 id="在工作空间中依赖外部包"><a href="#在工作空间中依赖外部包" class="headerlink" title="在工作空间中依赖外部包"></a>在工作空间中依赖外部包</h4><p>还需注意的是工作空间只在根目录有一个 <em>Cargo.lock</em>，而不是在每一个 crate 目录都有 <em>Cargo.lock</em>。这确保了所有的 crate 都使用完全相同版本的依赖。如果在 <em>Cargo.toml</em> 和 <em>add_one&#x2F;Cargo.toml</em> 中都增加 <code>rand</code> crate，则 Cargo 会将其都解析为同一版本并记录到唯一的 <em>Cargo.lock</em> 中。使得工作空间中的所有 crate 都使用相同的依赖意味着其中的 crate 都是相互兼容的。让我们在 <em>add_one&#x2F;Cargo.toml</em> 中的 <code>[dependencies]</code> 部分增加 <code>rand</code> crate 以便能够在 <code>add_one</code> crate 中使用 <code>rand</code> crate：</p>
<p>文件名：add_one&#x2F;Cargo.toml</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">rand</span> = <span class="string">&quot;0.8.5&quot;</span></span><br></pre></td></tr></table></figure>

<p>现在就可以在 <em>add_one&#x2F;src&#x2F;lib.rs</em> 中增加 <code>use rand;</code> 了，接着在 <em>add</em> 目录运行 <code>cargo build</code> 构建整个工作空间就会引入并编译 <code>rand</code> crate。我们会收到一个警告，因为我们并没有引用已导入作用域的 <code>rand</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo build</span></span><br><span class="line">    Updating crates.io index</span><br><span class="line">  Downloaded rand v0.8.5</span><br><span class="line">   --snip--</span><br><span class="line">   Compiling rand v0.8.5</span><br><span class="line">   Compiling add_one v0.1.0 (file:///projects/add/add_one)</span><br><span class="line">warning: unused import: `rand`</span><br><span class="line"><span class="meta prompt_"> --&gt; </span><span class="language-bash">add_one/src/lib.rs:1:5</span></span><br><span class="line">  |</span><br><span class="line">1 | use rand;</span><br><span class="line">  |     ^^^^</span><br><span class="line">  |</span><br><span class="line">  = note: `#[warn(unused_imports)]` on by default</span><br><span class="line"></span><br><span class="line">warning: `add_one` (lib) generated 1 warning (run `cargo fix --lib -p add_one` to apply 1 suggestion)</span><br><span class="line">   Compiling adder v0.1.0 (file:///projects/add/adder)</span><br><span class="line">    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.95s</span><br></pre></td></tr></table></figure>

<p>现在顶级的 <em>Cargo.lock</em> 包含了 <code>add_one</code> 的 <code>rand</code> 依赖的信息。然而，即使 <code>rand</code> 被用于工作空间的某处，也不能在其他 crate 中使用它，除非也在它们的 <em>Cargo.toml</em> 中加入 <code>rand</code>。例如，如果在顶级的 <code>adder</code> crate 的 <em>adder&#x2F;src&#x2F;main.rs</em> 中增加 <code>use rand;</code>，会得到一个错误：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo build</span></span><br><span class="line">  --snip--</span><br><span class="line">   Compiling adder v0.1.0 (file:///projects/add/adder)</span><br><span class="line">error[E0432]: unresolved import `rand`</span><br><span class="line"><span class="meta prompt_"> --&gt; </span><span class="language-bash">adder/src/main.rs:2:5</span></span><br><span class="line">  |</span><br><span class="line">2 | use rand;</span><br><span class="line">  |     ^^^^ no external crate `rand`</span><br></pre></td></tr></table></figure>

<p>为了修复这个错误，修改顶级 <code>adder</code> crate 的 <em>Cargo.toml</em> 来表明 <code>rand</code> 也是这个 crate 的依赖。构建 <code>adder</code> crate 会将 <code>rand</code> 加入到 <em>Cargo.lock</em> 中 <code>adder</code> 的依赖列表中，但是这并不会下载 <code>rand</code> 的额外拷贝。Cargo 确保了工作空间中任何使用 <code>rand</code> 的 crate 都采用相同的版本，这节省了空间并确保了工作空间中的 crate 将是相互兼容的。</p>
<p>如果工作空间中的 crate 指定了不兼容的同一依赖的不同版本，Cargo 会解析它们，但仍会尽量减少解析的版本数量。</p>
<h4 id="为工作空间增加测试"><a href="#为工作空间增加测试" class="headerlink" title="为工作空间增加测试"></a>为工作空间增加测试</h4><p>作为另一个改进，让我们为 <code>add_one</code> crate 中的 <code>add_one::add_one</code> 函数增加一个测试：</p>
<p>文件名：add_one&#x2F;src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_one</span>(x: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    x + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">it_works</span>() &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">3</span>, <span class="title function_ invoke__">add_one</span>(<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在顶级 <em>add</em> 目录运行 <code>cargo test</code>。在像这样的工作空间结构中运行 <code>cargo test</code> 会运行工作空间中所有 crate 的测试。：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo <span class="built_in">test</span></span></span><br><span class="line">   Compiling add_one v0.1.0 (file:///projects/add/add_one)</span><br><span class="line">   Compiling adder v0.1.0 (file:///projects/add/adder)</span><br><span class="line">    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.20s</span><br><span class="line">     Running unittests src/lib.rs (target/debug/deps/add_one-93c49ee75dc46543)</span><br><span class="line"></span><br><span class="line">running 1 test</span><br><span class="line">test tests::it_works ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br><span class="line"></span><br><span class="line">     Running unittests src/main.rs (target/debug/deps/adder-3a47283c568d2b6a)</span><br><span class="line"></span><br><span class="line">running 0 tests</span><br><span class="line"></span><br><span class="line">test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br><span class="line"></span><br><span class="line">   Doc-tests add_one</span><br><span class="line"></span><br><span class="line">running 0 tests</span><br><span class="line"></span><br><span class="line">test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br></pre></td></tr></table></figure>

<p>输出的第一部分显示 <code>add_one</code> crate 的 <code>it_works</code> 测试通过了。下一个部分显示 <code>adder</code> crate 中找到了零个测试，最后一部分显示 <code>add_one</code> crate 中有零个文档测试。</p>
<p>也可以选择运行工作空间中特定 crate 的测试，通过在根目录使用 <code>-p</code> 参数并指定希望测试的 crate 名称：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo <span class="built_in">test</span> -p add_one</span></span><br><span class="line">    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.00s</span><br><span class="line">     Running unittests src/lib.rs (target/debug/deps/add_one-93c49ee75dc46543)</span><br><span class="line"></span><br><span class="line">running 1 test</span><br><span class="line">test tests::it_works ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br><span class="line"></span><br><span class="line">   Doc-tests add_one</span><br><span class="line"></span><br><span class="line">running 0 tests</span><br><span class="line"></span><br><span class="line">test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br></pre></td></tr></table></figure>

<p>输出显示了 <code>cargo test</code> 只运行了 <code>add_one</code> crate 的测试而没有运行 <code>adder</code> crate 的测试。</p>
<p>如果你选择向 <a target="_blank" rel="noopener" href="https://crates.io/">crates.io</a> 发布工作空间中的 crate，每一个工作空间中的 crate 需要单独发布。就像 <code>cargo test</code> 一样，可以通过 <code>-p</code> 参数并指定期望发布的 crate 名来发布工作空间中的某个特定的 crate。</p>
<p>现在尝试以类似 <code>add_one</code> crate 的方式向工作空间增加 <code>add_two</code> crate 来作为更多的练习！</p>
<p>随着项目增长，考虑使用工作空间：每一个更小的组件比一大块代码要容易理解。如果它们经常需要同时被修改的话，将 crate 保持在工作空间中更易于协调 crate 的改变。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-06-08T13:50:26.000Z" title="2025/6/8 21:50:26">2025-06-08</time>发表</span><span class="level-item"><time dateTime="2025-06-08T14:31:27.902Z" title="2025/6/8 22:31:27">2025-06-08</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Rust/">Rust</a><span> / </span><a class="link-muted" href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></span><span class="level-item">31 分钟读完 (大约4578个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/06/08/Rust/The%20Rust%20Programming%20Language/14.2%20%E5%B0%86%20crate%20%E5%8F%91%E5%B8%83%E5%88%B0%20Crates.io/">14.2 将 crate 发布到 Crates.io</a></p><div class="content"><h2 id="将-crate-发布到-Crates-io"><a href="#将-crate-发布到-Crates-io" class="headerlink" title="将 crate 发布到 Crates.io"></a>将 crate 发布到 Crates.io</h2><p>我们曾经在项目中使用 <a target="_blank" rel="noopener" href="https://crates.io/">crates.io</a> 上的包作为依赖，不过你也可以通过发布自己的包来向他人分享代码。<a target="_blank" rel="noopener" href="https://crates.io/">crates.io</a> 上的 crate 注册表会分发你包的源代码，因此它主要托管开源代码。</p>
<p>Rust 和 Cargo 有一些帮助他人更方便地找到和使用你发布的包的功能。我们将介绍一些这样的功能，接着讲到如何发布一个包。</p>
<h3 id="编写有用的文档注释"><a href="#编写有用的文档注释" class="headerlink" title="编写有用的文档注释"></a>编写有用的文档注释</h3><p>准确的包文档有助于其他用户理解如何以及何时使用它们，所以花一些时间编写文档是值得的。第三章中我们讨论了如何使用双斜杠 <code>//</code> 注释 Rust 代码。Rust 也有特定的用于文档的注释类型，通常被称为<strong>文档注释</strong>（<em>documentation comments</em>），它们会生成 HTML 文档。这些 HTML 展示公有 API 文档注释的内容，它们意在让对库感兴趣的程序员理解如何<strong>使用</strong>这个 crate，而不是它是如何被<strong>实现</strong>的。</p>
<p>文档注释使用三斜杠 <code>///</code> 而不是双斜杠以支持 Markdown 注解来格式化文本。文档注释就位于需要文档的项的之前。示例 14-1 展示了一个 <code>my_crate</code> crate 中 <code>add_one</code> 函数的文档注释。</p>
<p>文件名：src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Adds one to the number given.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// # Examples</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// ```</span></span><br><span class="line"><span class="comment">/// let arg = 5;</span></span><br><span class="line"><span class="comment">/// let answer = my_crate::add_one(arg);</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// assert_eq!(6, answer);</span></span><br><span class="line"><span class="comment">/// ```</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_one</span>(x: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    x + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 14-1：一个函数的文档注释</p>
<p>这里，我们提供了一个 <code>add_one</code> 函数工作的描述，接着开始了一个标题为 <code>Examples</code> 的部分，和展示如何使用 <code>add_one</code> 函数的代码。可以运行 <code>cargo doc</code> 来生成这个文档注释的 HTML 文档。这个命令运行由 Rust 分发的工具 <code>rustdoc</code> 并将生成的 HTML 文档放入 <em>target&#x2F;doc</em> 目录。</p>
<p>为了方便起见，运行 <code>cargo doc --open</code> 会构建当前 crate 文档（同时还有所有 crate 依赖的文档）的 HTML 并在浏览器中打开。导航到 <code>add_one</code> 函数将会发现文档注释的文本是如何渲染的，如图 14-1 所示：</p>
<p><img src="/./assert/14/trpl14-01.png" alt="trpl14-01"></p>
<h4 id="常用（文档注释）部分"><a href="#常用（文档注释）部分" class="headerlink" title="常用（文档注释）部分"></a>常用（文档注释）部分</h4><p>示例 14-1 中使用了 <code># Examples</code> Markdown 标题在 HTML 中创建了一个以 “Examples” 为标题的部分。其他一些 crate 作者经常在文档注释中使用的部分有：</p>
<ul>
<li><strong>Panics</strong>：这个函数可能会 <code>panic!</code> 的场景。并不希望程序崩溃的函数调用者应该确保他们不会在这些情况下调用此函数。</li>
<li><strong>Errors</strong>：如果这个函数返回 <code>Result</code>，此部分描述可能会出现何种错误以及什么情况会造成这些错误，这有助于调用者编写代码来采用不同的方式处理不同的错误。</li>
<li><strong>Safety</strong>：如果这个函数使用 <code>unsafe</code> 代码（这会在第二十章讨论），这一部分应该会涉及到期望函数调用者支持的确保 <code>unsafe</code> 块中代码正常工作的不变条件（invariants）。</li>
</ul>
<p>大部分文档注释不需要所有这些部分，不过这是一个提醒你检查调用你代码的用户有兴趣了解的内容的列表。</p>
<h4 id="文档注释作为测试"><a href="#文档注释作为测试" class="headerlink" title="文档注释作为测试"></a>文档注释作为测试</h4><p>在文档注释中增加示例代码块是一个清楚的表明如何使用库的方法，这么做还有一个额外的好处：<code>cargo test</code> 也会像测试那样运行文档中的示例代码！没有什么比有例子的文档更好的了，但最糟糕的莫过于写完文档后改动了代码，而导致例子不能正常工作。尝试 <code>cargo test</code> 运行像示例 14-1 中 <code>add_one</code> 函数的文档；应该在测试结果中看到像这样的部分：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   Doc-tests my_crate</span><br><span class="line"></span><br><span class="line">running 1 test</span><br><span class="line">test src/lib.rs - add_one (line 5) ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.27s</span><br></pre></td></tr></table></figure>

<p>现在尝试改变函数或例子来使例子中的 <code>assert_eq!</code> 产生 panic。再次运行 <code>cargo test</code>，你将会看到文档测试捕获到了例子与代码不再同步！</p>
<h4 id="注释包含项的结构"><a href="#注释包含项的结构" class="headerlink" title="注释包含项的结构"></a>注释包含项的结构</h4><p>文档注释风格 <code>//!</code> 为包含注释的项，而不是位于注释之后的项增加文档。这通常用于 crate 根文件（通常是 <em>src&#x2F;lib.rs</em>）或模块的根文件为 crate 或模块整体提供文档。</p>
<p>作为一个例子，为了增加描述包含 <code>add_one</code> 函数的 <code>my_crate</code> crate 目的的文档，可以在 <em>src&#x2F;lib.rs</em> 开头增加以 <code>//!</code> 开头的注释，如示例 14-2 所示：</p>
<p>文件名：src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! # My Crate</span></span><br><span class="line"><span class="comment">//!</span></span><br><span class="line"><span class="comment">//! `my_crate` is a collection of utilities to make performing certain</span></span><br><span class="line"><span class="comment">//! calculations more convenient.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// Adds one to the number given.</span></span><br><span class="line"><span class="comment">// --snip--</span></span><br></pre></td></tr></table></figure>

<p>示例 14-2：<code>my_crate</code> crate 整体的文档</p>
<p>注意 <code>//!</code> 的最后一行之后没有任何代码。因为它们以 <code>//!</code> 开头而不是 <code>///</code>，这是属于包含此注释的项而不是注释之后项的文档。在这个情况下是 <em>src&#x2F;lib.rs</em> 文件，也就是 crate 根文件。这些注释描述了整个 crate。</p>
<p>如果运行 <code>cargo doc --open</code>，将会发现这些注释显示在 <code>my_crate</code> 文档的首页，位于 crate 中公有项列表之上，如图 14-2 所示：</p>
<p><img src="/./assert/14/trpl14-02.png" alt="trpl14-02"></p>
<p>图 14-2：包含 <code>my_crate</code> 整体描述的注释所渲染的文档</p>
<p>位于项之中的文档注释对于描述 crate 和模块特别有用。使用它们描述其容器整体的目的来帮助 crate 用户理解你的代码组织。</p>
<h3 id="使用-pub-use-导出便捷的公有-API"><a href="#使用-pub-use-导出便捷的公有-API" class="headerlink" title="使用 pub use 导出便捷的公有 API"></a>使用 <code>pub use</code> 导出便捷的公有 API</h3><p>公有 API 的结构是你发布 crate 时主要需要考虑的。crate 用户没有你那么熟悉其结构，并且如果模块层级过大他们可能会难以找到所需的部分。</p>
<p>第七章介绍了如何使用 <code>pub</code> 关键字将项变为公有，和如何使用 <code>use</code> 关键字将项引入作用域。然而你开发时候使用的文件架构可能并不方便用户使用。你的结构可能是一个包含多个层级的分层结构，不过这对于用户来说并不方便。这是因为想要使用被定义在很深层级中的类型的人可能很难发现这些类型的存在。他们也可能会厌烦要使用 <code>use my_crate::some_module::another_module::UsefulType;</code> 而不是 <code>use my_crate::UsefulType;</code> 来使用类型。</p>
<p>好消息是，即使文件结构对于用户来说<strong>不是</strong>很方便，你也无需重新安排内部组织：你可以选择使用 <code>pub use</code> 重导出（re-export）项来使公有结构不同于私有结构。重导出获取位于一个位置的公有项并将其公开到另一个位置，好像它就定义在这个新位置一样。</p>
<p>例如，假设我们创建了一个描述艺术概念的库 <code>art</code>。这个库中包含了一个有两个枚举 <code>PrimaryColor</code> 和 <code>SecondaryColor</code> 的模块 <code>kinds</code>，以及一个包含函数 <code>mix</code> 的模块 <code>utils</code>，如示例 14-3 所示：</p>
<p>文件名：src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! # Art</span></span><br><span class="line"><span class="comment">//!</span></span><br><span class="line"><span class="comment">//! A library for modeling artistic concepts.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> kinds &#123;</span><br><span class="line">    <span class="comment">/// The primary colors according to the RYB color model.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">PrimaryColor</span> &#123;</span><br><span class="line">        Red,</span><br><span class="line">        Yellow,</span><br><span class="line">        Blue,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// The secondary colors according to the RYB color model.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">SecondaryColor</span> &#123;</span><br><span class="line">        Orange,</span><br><span class="line">        Green,</span><br><span class="line">        Purple,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> utils &#123;</span><br><span class="line">    <span class="keyword">use</span> crate::kinds::*;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Combines two primary colors in equal amounts to create</span></span><br><span class="line">    <span class="comment">/// a secondary color.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">mix</span>(c1: PrimaryColor, c2: PrimaryColor) <span class="punctuation">-&gt;</span> SecondaryColor &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 14-3：一个库 <code>art</code> 其组织包含 <code>kinds</code> 和 <code>utils</code> 模块</p>
<p><code>cargo doc</code> 所生成的 crate 文档首页如图 14-3 所示：</p>
<p><img src="/./assert/14/trpl14-03.png" alt="trpl14-03"></p>
<p>图 14-3：包含 <code>kinds</code> 和 <code>utils</code> 模块的库 <code>art</code> 的文档首页</p>
<p>注意 <code>PrimaryColor</code> 和 <code>SecondaryColor</code> 类型、以及 <code>mix</code> 函数都没有在首页中列出。我们必须点击 <code>kinds</code> 或 <code>utils</code> 才能看到它们。</p>
<p>另一个依赖这个库的 crate 需要 <code>use</code> 语句来导入 <code>art</code> 中的项，这包含指定其当前定义的模块结构。示例 14-4 展示了一个使用 <code>art</code> crate 中 <code>PrimaryColor</code> 和 <code>mix</code> 项的 crate 的例子：</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> art::kinds::PrimaryColor;</span><br><span class="line"><span class="keyword">use</span> art::utils::mix;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">red</span> = PrimaryColor::Red;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">yellow</span> = PrimaryColor::Yellow;</span><br><span class="line">    <span class="title function_ invoke__">mix</span>(red, yellow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 14-4：一个通过导出内部结构使用 <code>art</code> crate 中项的 crate</p>
<p>示例 14-4 中使用 <code>art</code> crate 代码的作者不得不搞清楚 <code>PrimaryColor</code> 位于 <code>kinds</code> 模块而 <code>mix</code> 位于 <code>utils</code> 模块。<code>art</code> crate 的模块结构相比使用它的开发者来说对编写它的开发者更有意义。其内部结构并没有对尝试理解如何使用 <code>art</code> crate 的人提供任何有价值的信息，相反因为不得不搞清楚所需的内容在何处和必须在 <code>use</code> 语句中指定模块名称而显得混乱。</p>
<p>为了从公有 API 中去掉 crate 的内部组织，我们可以采用示例 14-3 中的 <code>art</code> crate 并增加 <code>pub use</code> 语句来重导出项到顶层结构，如示例 14-5 所示：</p>
<p>文件名：src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! # Art</span></span><br><span class="line"><span class="comment">//!</span></span><br><span class="line"><span class="comment">//! A library for modeling artistic concepts.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> self::kinds::PrimaryColor;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> self::kinds::SecondaryColor;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> self::utils::mix;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> kinds &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> utils &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 14-5：增加 <code>pub use</code> 语句重导出项</p>
<p>现在此 crate 由 <code>cargo doc</code> 生成的 API 文档会在首页列出重导出的项以及其链接（re-exports），如图 14-4 所示，这使得 <code>PrimaryColor</code> 和 <code>SecondaryColor</code> 类型和 <code>mix</code> 函数更易于查找。</p>
<p><img src="/./assert/14/trpl14-04.png" alt="trpl14-04"></p>
<p>图 14-10：<code>art</code> 文档的首页，这里列出了重导出的项</p>
<p><code>art</code> crate 的用户仍然可以看到并使用示例 14-3 中的内部结构，如示例 14-4 所示，或者可以使用示例 14-5 中更为方便的结构，如示例 14-6 所示：</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> art::PrimaryColor;</span><br><span class="line"><span class="keyword">use</span> art::mix;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 14-6：一个使用 <code>art</code> crate 中重导出项的程序</p>
<p>对于有很多嵌套模块的情况，使用 <code>pub use</code> 将类型重导出到顶级结构对于使用 crate 的人来说将会是大为不同的体验。<code>pub use</code> 的另一个常见用法是重导出当前 crate 的依赖的定义使其 crate 定义变成你 crate 公有 API 的一部分。</p>
<p>创建一个有用的公有 API 结构更像是一门艺术而非科学，你可以反复检视它们来找出最适合用户的 API。<code>pub use</code> 提供了解耦组织 crate 内部结构和与终端用户体现的灵活性。观察一些你所安装的 crate 的代码来看看其内部结构是否不同于公有 API。</p>
<h3 id="创建-Crates-io-账号"><a href="#创建-Crates-io-账号" class="headerlink" title="创建 Crates.io 账号"></a>创建 Crates.io 账号</h3><p>在你可以发布任何 crate 之前，需要在 <a target="_blank" rel="noopener" href="https://crates.io/">crates.io</a> 上注册账号并获取一个 API token。为此，访问位于 <a target="_blank" rel="noopener" href="https://crates.io/">crates.io</a> 的首页并使用 GitHub 账号登录。（目前 GitHub 账号是必须的，不过将来该网站可能会支持其他创建账号的方法）一旦登录之后，查看位于 <a target="_blank" rel="noopener" href="https://crates.io/me/">https://crates.io/me/</a> 的账户设置页面并获取 API token。然后运行 <code>cargo login</code> 命令，并在提示时粘贴该 token，操作如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo login</span></span><br><span class="line">abcdefghijklmnopqrstuvwxyz012345</span><br></pre></td></tr></table></figure>

<p>这个命令会通知 Cargo 你的 API token 并将其储存在本地的 <em>~&#x2F;.cargo&#x2F;credentials</em> 文件中。注意这个 token 是一个<strong>秘密</strong>（<strong>secret</strong>）且不应该与其他人共享。如果因为任何原因与他人共享了这个信息，应该立即到 <a target="_blank" rel="noopener" href="https://crates.io/">crates.io</a> 撤销并重新生成一个 token。</p>
<h3 id="向新-crate-添加元数据"><a href="#向新-crate-添加元数据" class="headerlink" title="向新 crate 添加元数据"></a>向新 crate 添加元数据</h3><p>比如说你已经有一个希望发布的 crate。在发布之前，你需要在 crate 的 <em>Cargo.toml</em> 文件的 <code>[package]</code> 部分增加一些本 crate 的元数据（metadata）。</p>
<p>首先 crate 需要一个唯一的名称。虽然在本地开发 crate 时，可以使用任何你喜欢的名称。不过 <a target="_blank" rel="noopener" href="https://crates.io/">crates.io</a> 上的 crate 名称遵守先到先得的分配原则。一旦某个 crate 名称被使用，其他人就不能再发布这个名称的 crate 了。请搜索你希望使用的名称来找出它是否已被使用。如果没有，修改 <em>Cargo.toml</em> 中 <code>[package]</code> 里的<code>name</code> 字段为你希望用于发布的名称，像这样：</p>
<p>文件名：Cargo.toml</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;guessing_game&quot;</span></span><br></pre></td></tr></table></figure>

<p>即使你选择了一个唯一的名称，如果此时尝试运行 <code>cargo publish</code> 发布该 crate 的话，会得到一个警告接着是一个错误：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo publish</span></span><br><span class="line">    Updating crates.io index</span><br><span class="line">warning: manifest has no description, license, license-file, documentation, homepage or repository.</span><br><span class="line">See https://doc.rust-lang.org/cargo/reference/manifest.html#package-metadata for more info.</span><br><span class="line">--snip--</span><br><span class="line">error: failed to publish to registry at https://crates.io</span><br><span class="line"></span><br><span class="line">Caused by:</span><br><span class="line">  the remote server responded with an error (status 400 Bad Request): missing or empty metadata fields: description, license. Please see https://doc.rust-lang.org/cargo/reference/manifest.html for more information on configuring these fields</span><br></pre></td></tr></table></figure>

<p>这个错误是因为我们缺少一些关键信息：关于该 crate 用途的描述和用户可能在何种条款下使用该 crate 的 license。在 <em>Cargo.toml</em> 中添加通常是一两句话的描述，因为它将在搜索结果中和你的 crate 一起显示。对于 <code>license</code> 字段，你需要一个 <strong>license 标识符值</strong>（<em>license identifier value</em>）。<a target="_blank" rel="noopener" href="http://spdx.org/licenses/">Linux 基金会的 Software Package Data Exchange (SPDX)</a> 列出了可以使用的标识符。例如，为了指定 crate 使用 MIT License，增加 <code>MIT</code> 标识符：</p>
<p>文件名：Cargo.toml</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;guessing_game&quot;</span></span><br><span class="line"><span class="attr">license</span> = <span class="string">&quot;MIT&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果你希望使用不存在于 SPDX 的 license，则需要将 license 文本放入一个文件，将该文件包含进项目中，接着使用 <code>license-file</code> 来指定文件名而不是使用 <code>license</code> 字段。</p>
<p>关于项目所适用的 license 指导超出了本书的范畴。很多 Rust 社区成员选择与 Rust 自身相同的 license，这是一个双许可的 <code>MIT OR Apache-2.0</code>。这个实践展示了也可以通过 <code>OR</code> 分隔为项目指定多个 license 标识符。</p>
<p>那么，有了唯一的名称、版本号、由 <code>cargo new</code> 新建项目时增加的作者信息、描述和所选择的 license，已经准备好发布的项目的 <em>Cargo.toml</em> 文件可能看起来像这样：</p>
<p>文件名：Cargo.toml</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;guessing_game&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2024&quot;</span></span><br><span class="line"><span class="attr">description</span> = <span class="string">&quot;A fun game where you guess what number the computer has chosen.&quot;</span></span><br><span class="line"><span class="attr">license</span> = <span class="string">&quot;MIT OR Apache-2.0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="http://doc.rust-lang.org/cargo/">Cargo 的文档</a> 描述了其他可以指定的元数据，它们可以帮助你的 crate 更容易被发现和使用！</p>
<h3 id="发布到-Crates-io"><a href="#发布到-Crates-io" class="headerlink" title="发布到 Crates.io"></a>发布到 Crates.io</h3><p>现在我们创建了一个账号，保存了 API token，为 crate 选择了一个名字，并指定了所需的元数据，你已经准备好发布了！发布 crate 会上传特定版本的 crate 到 <a target="_blank" rel="noopener" href="https://crates.io/">crates.io</a> 以供他人使用。</p>
<p>发布 crate 时请多加小心，因为发布是<strong>永久性的</strong>（<em>permanent</em>）。对应版本不可能被覆盖，其代码也不可能被删除。<a target="_blank" rel="noopener" href="https://crates.io/">crates.io</a> 的一个主要目标是作为一个存储代码的永久文档服务器，这样所有依赖 <a target="_blank" rel="noopener" href="https://crates.io/">crates.io</a> 中的 crate 的项目都能一直正常工作。而允许删除版本没办法达成这个目标。然而，可以被发布的版本号却没有限制。</p>
<p>再次运行 <code>cargo publish</code> 命令。这次它应该会成功：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo publish</span></span><br><span class="line">    Updating crates.io index</span><br><span class="line">   Packaging guessing_game v0.1.0 (file:///projects/guessing_game)</span><br><span class="line">   Verifying guessing_game v0.1.0 (file:///projects/guessing_game)</span><br><span class="line">   Compiling guessing_game v0.1.0</span><br><span class="line">(file:///projects/guessing_game/target/package/guessing_game-0.1.0)</span><br><span class="line">    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.19s</span><br><span class="line">   Uploading guessing_game v0.1.0 (file:///projects/guessing_game)</span><br></pre></td></tr></table></figure>

<p>恭喜！你现在向 Rust 社区分享了代码，而且任何人都可以轻松的将你的 crate 加入他们项目的依赖。</p>
<h3 id="发布现有-crate-的新版本"><a href="#发布现有-crate-的新版本" class="headerlink" title="发布现有 crate 的新版本"></a>发布现有 crate 的新版本</h3><p>当你修改了 crate 并准备好发布新版本时，改变 <em>Cargo.toml</em> 中 <code>version</code> 所指定的值。请使用<a target="_blank" rel="noopener" href="http://semver.org/">语义化版本规则</a>来根据修改的类型决定下一个版本号。接着运行 <code>cargo publish</code> 来上传新版本。</p>
<h3 id="使用-cargo-yank-从-Crates-io-撤回版本"><a href="#使用-cargo-yank-从-Crates-io-撤回版本" class="headerlink" title="使用 cargo yank 从 Crates.io 撤回版本"></a>使用 <code>cargo yank</code> 从 Crates.io 撤回版本</h3><p>虽然你不能删除 crate 的历史版本，但是可以阻止任何将来的项目将它们加入到依赖中。这在某个版本因为这样或那样的原因被破坏的情况很有用。对于这种情况，Cargo 支持<strong>撤回</strong>（<em>yanking</em>）某个版本。</p>
<p><strong>撤回</strong>某个版本会阻止新项目依赖此版本，不过所有现存此依赖的项目仍然能够下载和依赖这个版本。从本质上说，撤回意味着所有带有 <em>Cargo.lock</em> 的项目的依赖不会被破坏，同时任何新生成的 <em>Cargo.lock</em> 将不能使用被撤回的版本。</p>
<p>为了撤回一个版本的 crate，在之前发布 crate 的目录运行 <code>cargo yank</code> 并指定希望撤回的版本。例如，如果我们发布了一个名为 <code>guessing_game</code> 的 crate 的 1.0.1 版本并希望撤回它，在 <code>guessing_game</code> 项目目录运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo yank --vers 1.0.1</span></span><br><span class="line">    Updating crates.io index</span><br><span class="line">        Yank guessing_game@1.0.1</span><br></pre></td></tr></table></figure>

<p>也可以撤销撤回操作，并允许项目可以再次开始依赖某个版本，通过在命令上增加 <code>--undo</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo yank --vers 1.0.1 --undo</span></span><br><span class="line">    Updating crates.io index</span><br><span class="line">      Unyank guessing_game@1.0.1</span><br></pre></td></tr></table></figure>

<p>撤回<strong>并没有</strong>删除任何代码。举例来说，撤回功能并不能删除不小心上传的秘密信息。如果出现了这种情况，请立即重新设置这些秘密信息。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-06-08T13:30:26.000Z" title="2025/6/8 21:30:26">2025-06-08</time>发表</span><span class="level-item"><time dateTime="2025-06-08T14:31:21.778Z" title="2025/6/8 22:31:21">2025-06-08</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Rust/">Rust</a><span> / </span><a class="link-muted" href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></span><span class="level-item">5 分钟读完 (大约707个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/06/08/Rust/The%20Rust%20Programming%20Language/14.1%20%E9%87%87%E7%94%A8%E5%8F%91%E5%B8%83%E9%85%8D%E7%BD%AE%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9E%84%E5%BB%BA/">14.1 采用发布配置自定义构建</a></p><div class="content"><h2 id="采用发布配置自定义构建"><a href="#采用发布配置自定义构建" class="headerlink" title="采用发布配置自定义构建"></a>采用发布配置自定义构建</h2><p>在 Rust 中<strong>发布配置</strong>（<em>release profiles</em>）文件是预定义和可定制的，它们包含不同的配置，允许程序员更灵活地控制代码编译的多种选项。每一个配置都相互独立。</p>
<p>Cargo 有两个主要的配置：运行 <code>cargo build</code> 时采用的 <code>dev</code> 配置和运行 <code>cargo build --release</code> 的 <code>release</code> 配置。<code>dev</code> 配置为开发定义了良好的默认配置，<code>release</code> 配置则为发布构建定义了良好的默认配置。</p>
<p>这些配置名称可能很眼熟，因为它们出现在构建的输出中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo build</span></span><br><span class="line">    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.00s</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo build --release</span></span><br><span class="line">    Finished `release` profile [optimized] target(s) in 0.32s</span><br></pre></td></tr></table></figure>

<p>构建输出中的 <code>dev</code> 和 <code>release</code> 表明编译器在使用不同的配置。</p>
<p>当项目的 <em>Cargo.toml</em> 文件中没有显式增加任何 <code>[profile.*]</code> 部分的时候，Cargo 会对每一个配置都采用默认设置。通过增加任何希望定制的配置对应的 <code>[profile.*]</code> 部分，我们可以选择覆盖任意默认设置的子集。例如，如下是 <code>dev</code> 和 <code>release</code> 配置的 <code>opt-level</code> 设置的默认值：</p>
<p>文件名：Cargo.toml</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[profile.dev]</span></span><br><span class="line"><span class="attr">opt-level</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="section">[profile.release]</span></span><br><span class="line"><span class="attr">opt-level</span> = <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><code>opt-level</code> 设置控制 Rust 会对代码进行何种程度的优化。这个配置的值从 0 到 3。越高的优化级别需要更多的时间编译，所以如果你在进行开发并经常编译，可能会希望在牺牲一些代码性能的情况下减少优化以便编译得快一些。因此 <code>dev</code> 的 <code>opt-level</code> 默认为 <code>0</code>。当你准备发布时，花费更多时间在编译上则更好。只需要在发布模式编译一次，而编译出来的程序则会运行很多次，所以发布模式用更长的编译时间换取运行更快的代码。这正是为什么 <code>release</code> 配置的 <code>opt-level</code> 默认为 <code>3</code>。</p>
<p>我们可以选择通过在 <em>Cargo.toml</em> 增加不同的值来覆盖任何默认设置。比如，如果我们想要在开发配置中使用级别 1 的优化，则可以在 <em>Cargo.toml</em> 中增加这两行：</p>
<p>文件名：Cargo.toml</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[profile.dev]</span></span><br><span class="line"><span class="attr">opt-level</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>这会覆盖默认的设置 <code>0</code>。现在运行 <code>cargo build</code> 时，Cargo 将会使用 <code>dev</code> 的默认配置加上定制的 <code>opt-level</code>。因为 <code>opt-level</code> 设置为 <code>1</code>，Cargo 会比默认进行更多的优化，但是没有发布构建那么多。</p>
<p>对于每个配置的设置和其默认值的完整列表，请参阅<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/cargo/reference/profiles.html">Cargo 的文档</a>。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-06-06T12:30:26.000Z" title="2025/6/6 20:30:26">2025-06-06</time>发表</span><span class="level-item"><time dateTime="2025-06-08T14:31:14.915Z" title="2025/6/8 22:31:14">2025-06-08</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Rust/">Rust</a><span> / </span><a class="link-muted" href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></span><span class="level-item">9 分钟读完 (大约1289个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/06/06/Rust/The%20Rust%20Programming%20Language/13.4%20%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94%EF%BC%9A%E5%BE%AA%E7%8E%AF%20VS%20%E8%BF%AD%E4%BB%A3%E5%99%A8/">13.4 性能对比：循环 VS 迭代器</a></p><div class="content"><h2 id="性能对比：循环-VS-迭代器"><a href="#性能对比：循环-VS-迭代器" class="headerlink" title="性能对比：循环 VS 迭代器"></a>性能对比：循环 VS 迭代器</h2><p>为了决定是否使用循环或迭代器，你需要了解哪个实现更快：使用显式 <code>for</code> 循环的 <code>search</code> 函数版本，还是使用迭代器的版本。</p>
<p>我们进行了一个基准测试，将阿瑟·柯南·道尔的《福尔摩斯探案集》全文加载到一个 <code>String</code> 中，并在内容中查找单词 <em>the</em>。以下是使用 <code>for</code> 循环版本和使用迭代器版本的 <code>search</code> 函数的基准测试结果：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test bench_search_for  ... bench:  19,620,300 ns/iter (+/- 915,700)</span><br><span class="line">test bench_search_iter ... bench:  19,234,900 ns/iter (+/- 657,200)</span><br></pre></td></tr></table></figure>

<p>两种实现具有相似的性能表现！这里我们不会解释性能测试的代码，我们的目的并不是为了证明它们是完全等同的，而是得出一个怎样比较这两种实现方式性能的基本思路。</p>
<p>对于一个更全面的性能测试，你应该使用不同大小的文本作为 <code>contents</code>，不同的单词以及长度各异的单词作为 <code>query</code>，以及各种其他变化进行检查。关键在于：迭代器，作为一个高级的抽象，被编译成了与手写的底层代码大体一致性能的代码。迭代器是 Rust 的<strong>零成本抽象</strong>（<em>zero-cost abstractions</em>）之一，它意味着抽象并不会引入额外的运行时开销，它与本贾尼·斯特劳斯特卢普（C++ 的设计和实现者）在《Foundations of C++》（2012）中所定义的<strong>零开销</strong>（<em>zero-overhead</em>）如出一辙：</p>
<blockquote>
<p>In general, C++ implementations obey the zero-overhead principle: What you don’t use, you don’t pay for. And further: What you do use, you couldn’t hand code any better.</p>
<p>总的来说，C++ 的实现遵循了零开销原则：不使用的功能无需为其付出代价；而已经使用的功能，也不可能通过手写代码做得更好。</p>
</blockquote>
<p>作为另一个例子，以下代码取自一个音频解码器。解码算法使用线性预测数学运算（linear prediction mathematical operation）来根据之前样本的线性函数预测将来的值。这些代码使用迭代器链对作用域中的三个变量进行某种数学计算：一个叫 <code>buffer</code> 的数据 slice、一个有 12 个元素的数组 <code>coefficients</code>、和一个代表位数据位移量的 <code>qlp_shift</code>。我们在这个例子中声明了这些变量，但没有为它们赋值；虽然这些代码在其上下文之外没有太多意义，不过仍是一个简明的现实例子，来展示 Rust 如何将高级概念转换为底层代码。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">buffer</span>: &amp;<span class="keyword">mut</span> [<span class="type">i32</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">coefficients</span>: [<span class="type">i64</span>; <span class="number">12</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">qlp_shift</span>: <span class="type">i16</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">12</span>..buffer.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">prediction</span> = coefficients.<span class="title function_ invoke__">iter</span>()</span><br><span class="line">                                 .<span class="title function_ invoke__">zip</span>(&amp;buffer[i - <span class="number">12</span>..i])</span><br><span class="line">                                 .<span class="title function_ invoke__">map</span>(|(&amp;c, &amp;s)| c * s <span class="keyword">as</span> <span class="type">i64</span>)</span><br><span class="line">                                 .sum::&lt;<span class="type">i64</span>&gt;() &gt;&gt; qlp_shift;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">delta</span> = buffer[i];</span><br><span class="line">    buffer[i] = prediction <span class="keyword">as</span> <span class="type">i32</span> + delta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了计算 <code>prediction</code> 的值，这段代码遍历了 <code>coefficients</code> 中的 12 个值，使用 <code>zip</code> 方法将系数与 <code>buffer</code> 的前 12 个值组合在一起。接着将每一对值相乘，再将所有结果相加，然后将总和右移 <code>qlp_shift</code> 位。</p>
<p>像音频解码器这样的程序通常最看重计算的性能。这里，我们创建了一个迭代器，使用了两个适配器，接着消费了其值。那么这段 Rust 代码将会被编译为什么样的汇编代码呢？好吧，在编写本书的这个时候，它被编译成与手写的相同的汇编代码。遍历 <code>coefficients</code> 的值完全用不到循环：Rust 知道这里会迭代 12 次，所以它“展开”（unroll）了循环。展开是一种将循环迭代转换为重复代码，并移除循环控制代码开销的代码优化技术。</p>
<p>所有的系数（coefficients）都被储存在了寄存器中，这意味着访问它们非常快。这里也没有运行时数组访问边界检查。所有这些 Rust 能够提供的优化使得结果代码极为高效。现在你知道了这些，请放心大胆的使用迭代器和闭包吧！它们使得代码看起来更高级，但并不为此引入运行时性能损失。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>闭包和迭代器是 Rust 受函数式编程语言观念所启发的特性。它们对 Rust 以高性能来明确的表达高级概念的能力有很大贡献。闭包和迭代器的实现达到了不影响运行时性能的程度。这正是 Rust 致力于提供零成本抽象的目标的一部分。</p>
<p>现在我们改进了 I&#x2F;O 项目的（代码）表现力，那么让我们来看看 <code>cargo</code> 的更多功能，这些功能将帮助我们将项目分享给全世界。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-06-06T10:30:26.000Z" title="2025/6/6 18:30:26">2025-06-06</time>发表</span><span class="level-item"><time dateTime="2025-06-08T14:31:02.200Z" title="2025/6/8 22:31:02">2025-06-08</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Rust/">Rust</a><span> / </span><a class="link-muted" href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></span><span class="level-item">18 分钟读完 (大约2706个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/06/06/Rust/The%20Rust%20Programming%20Language/13.2%20%E4%BD%BF%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%84%E7%90%86%E5%85%83%E7%B4%A0%E5%BA%8F%E5%88%97/">13.2 使用迭代器处理元素序列</a></p><div class="content"><h2 id="使用迭代器处理元素序列"><a href="#使用迭代器处理元素序列" class="headerlink" title="使用迭代器处理元素序列"></a>使用迭代器处理元素序列</h2><p>迭代器模式允许你依次对一个序列中的项执行某些操作。<strong>迭代器</strong>（<em>iterator</em>）负责遍历序列中的每一项并确定序列何时结束的逻辑。使用迭代器时，你无需自己重新实现这些逻辑。</p>
<p>在 Rust 中，迭代器是<strong>惰性的</strong>（<em>lazy</em>），这意味着在调用消费迭代器的方法之前不会执行任何操作。例如，示例 13-10 中的代码通过调用定义于 <code>Vec&lt;T&gt;</code> 上的 <code>iter</code> 方法在一个 vector <code>v1</code> 上创建了一个迭代器。这段代码本身并没有执行任何有用的操作。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">v1_iter</span> = v1.<span class="title function_ invoke__">iter</span>();</span><br></pre></td></tr></table></figure>

<p>示例 13-10：创建一个迭代器</p>
<p>迭代器被储存在 <code>v1_iter</code> 变量中。一旦创建迭代器之后，可以选择用多种方式利用它。在第三章的示例 3-5 中，我们使用 <code>for</code> 循环来遍历一个数组并在每一个项上执行了一些代码。在底层它隐式地创建并接着消费了一个迭代器，不过直到现在我们都一笔带过了它具体是如何工作的。</p>
<p>示例 13-11 中的例子将迭代器的创建和 <code>for</code> 循环中的使用分开。当 <code>for</code> 循环使用 <code>v1_iter</code> 中的迭代器时，迭代器中的每一个元素都会用于循环的一次迭代，并打印出每个值。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">v1_iter</span> = v1.<span class="title function_ invoke__">iter</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="variable">val</span> <span class="keyword">in</span> v1_iter &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Got: &#123;val&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 13-11：在一个 <code>for</code> 循环中使用迭代器</p>
<p>在标准库中没有提供迭代器的语言中，我们可能会使用一个从 0 开始索引的变量，使用这个变量索引 vector 中的值，并循环增加其值直到达到 vector 中的元素总量，以实现相同的功能。</p>
<p>迭代器为我们处理了所有这些逻辑，这减少了重复代码并消除了潜在的混乱。另外，迭代器的实现方式提供了对多种不同的序列使用相同逻辑的灵活性，而不仅仅是像 vector 这样可索引的数据结构。让我们看看迭代器是如何做到这些的。</p>
<h3 id="Iterator-trait-和-next-方法"><a href="#Iterator-trait-和-next-方法" class="headerlink" title="Iterator trait 和 next 方法"></a><code>Iterator</code> trait 和 <code>next</code> 方法</h3><p>迭代器都实现了名为 <code>Iterator</code> 的定义于标准库的 trait。这个 trait 的定义看起来像这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略了方法的默认实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里有一个我们还未讲到的新语法：<code>type Item</code> 和 <code>Self::Item</code>，它们定义了 trait 的<strong>关联类型</strong>（<em>associated type</em>）。第二十章会深入讲解关联类型，不过现在只需知道这段代码表明实现 <code>Iterator</code> trait 要求同时定义一个 <code>Item</code> 类型，这个 <code>Item</code> 类型被用作 <code>next</code> 方法的返回值类型。换句话说，<code>Item</code> 类型将是迭代器返回元素的类型。</p>
<p><code>Iterator</code> trait 仅要求实现者定义一个方法：<code>next</code> 方法，该方法每次返回迭代器中的一个项，封装在 <code>Some</code> 中，并且当迭代完成时，返回 <code>None</code>。</p>
<p>可以直接调用迭代器的 <code>next</code> 方法；示例 13-12 展示了对由 vector 创建的迭代器重复调用 <code>next</code> 方法时返回的值。</p>
<p>文件名：src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">iterator_demonstration</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v1_iter</span> = v1.<span class="title function_ invoke__">iter</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(v1_iter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v1_iter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="number">2</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v1_iter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="number">3</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v1_iter.<span class="title function_ invoke__">next</span>(), <span class="literal">None</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 13-12：在迭代器上（直接）调用 <code>next</code> 方法</p>
<p>注意我们需要将 <code>v1_iter</code> 声明为可变的：在迭代器上调用 <code>next</code> 方法会改变迭代器内部的状态，该状态用于跟踪迭代器在序列中的位置。换句话说，代码<strong>消费</strong>（consume）了，或者说用尽了迭代器。每一次 <code>next</code> 调用都会从迭代器中消费一个项。使用 <code>for</code> 循环时无需使 <code>v1_iter</code> 可变因为 <code>for</code> 循环会获取 <code>v1_iter</code> 的所有权并在后台使 <code>v1_iter</code> 可变。</p>
<p>还需要注意的是，从 <code>next</code> 调用中获取的值是对 vector 中值的不可变引用。<code>iter</code> 方法生成一个不可变引用的迭代器。如果我们需要一个获取 <code>v1</code> 所有权并返回拥有所有权的迭代器，则可以调用 <code>into_iter</code> 而不是 <code>iter</code>。类似地，如果我们希望迭代可变引用，可以调用 <code>iter_mut</code> 而不是 <code>iter</code>。</p>
<h3 id="消费迭代器的方法"><a href="#消费迭代器的方法" class="headerlink" title="消费迭代器的方法"></a>消费迭代器的方法</h3><p><code>Iterator</code> trait 有一系列不同的由标准库提供默认实现的方法；你可以在 <code>Iterator</code> trait 的标准库 API 文档中找到所有这些方法。一些方法在其定义中调用了 <code>next</code> 方法，这也就是为什么在实现 <code>Iterator</code> trait 时要求实现 <code>next</code> 方法的原因。</p>
<p>这些调用 <code>next</code> 方法的方法被称为<strong>消费适配器</strong>（<em>consuming adaptors</em>），因为调用它们会消耗迭代器。一个消费适配器的例子是 <code>sum</code> 方法，这个方法获取迭代器的所有权并反复调用 <code>next</code> 来遍历迭代器，从而消费迭代器。在遍历过程中，它将每个项累加到一个运行时总和中，并在迭代完成时返回这个总和。示例 13-13 有一个展示 <code>sum</code> 方法使用的测试：</p>
<p>文件名：src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">iterator_sum</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1_iter</span> = v1.<span class="title function_ invoke__">iter</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">total</span>: <span class="type">i32</span> = v1_iter.<span class="title function_ invoke__">sum</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(total, <span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 13-13：调用 <code>sum</code> 方法获取迭代器所有项的总和</p>
<p>调用 <code>sum</code> 之后不再允许使用 <code>v1_iter</code> 因为调用 <code>sum</code> 时它会获取迭代器的所有权。</p>
<h3 id="产生其他迭代器的方法"><a href="#产生其他迭代器的方法" class="headerlink" title="产生其他迭代器的方法"></a>产生其他迭代器的方法</h3><p><code>Iterator</code> trait 中定义了另一类方法，被称为<strong>迭代器适配器</strong>（<em>iterator adaptors</em>），它们不会消耗当前的迭代器，而是通过改变原始迭代器的某些方面来生成不同的迭代器。</p>
<p>示例 13-14 展示了一个调用迭代器适配器方法 <code>map</code> 的例子，该方法使用一个闭包对每个元素进行操作。<code>map</code> 方法返回一个新的迭代器，该迭代器生成经过修改的元素。这里的闭包创建了一个新的迭代器，其中 vector 中的每个元素都被加 1。</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v1</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">v1.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">map</span>(|x| x + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>示例 13-14：调用迭代器适配器 <code>map</code> 来创建一个新迭代器</p>
<p>不过这些代码会产生一个警告：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">   Compiling iterators v0.1.0 (file:///projects/iterators)</span><br><span class="line">warning: unused `Map` that must be used</span><br><span class="line"><span class="meta prompt_"> --&gt; </span><span class="language-bash">src/main.rs:4:5</span></span><br><span class="line">  |</span><br><span class="line">4 |     v1.iter().map(|x| x + 1);</span><br><span class="line">  |     ^^^^^^^^^^^^^^^^^^^^^^^^</span><br><span class="line">  |</span><br><span class="line">  = note: iterators are lazy and do nothing unless consumed</span><br><span class="line">  = note: `#[warn(unused_must_use)]` on by default</span><br><span class="line">help: use `let _ = ...` to ignore the resulting value</span><br><span class="line">  |</span><br><span class="line">4 |     let _ = v1.iter().map(|x| x + 1);</span><br><span class="line">  |     +++++++</span><br><span class="line"></span><br><span class="line">warning: `iterators` (bin &quot;iterators&quot;) generated 1 warning</span><br><span class="line">    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.47s</span><br><span class="line">     Running `target/debug/iterators`</span><br></pre></td></tr></table></figure>

<p>示例 13-14 中的代码实际上并没有做任何事；所指定的闭包从未被调用过。警告提醒了我们原因所在：迭代器适配器是惰性的，因此我们需要在此处消费迭代器。</p>
<p>为了修复这个警告并消费迭代器，我们将使用第十二章示例 12-1 结合 <code>env::args</code> 使用的 <code>collect</code> 方法。这个方法消费迭代器并将结果收集到一个集合数据类型中。</p>
<p>在示例 13-15 中，我们将遍历由 <code>map</code> 调用生成的迭代器结果收集到一个 vector 中。这个 vector 将包含原始 vector 中每个元素加 1 的结果。</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v1</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">v2</span>: <span class="type">Vec</span>&lt;_&gt; = v1.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">map</span>(|x| x + <span class="number">1</span>).<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(v2, <span class="built_in">vec!</span>[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br></pre></td></tr></table></figure>

<p>示例 13-15：调用 <code>map</code> 方法创建一个新迭代器，接着调用 <code>collect</code> 方法消费新迭代器并创建一个 vector</p>
<p>由于 <code>map</code> 接受一个闭包，因此我们可以指定希望在每个元素上执行的任何操作。这是一个很好的例子，展示了如何通过闭包来自定义某些行为，同时复用 <code>Iterator</code> trait 提供的迭代行为。</p>
<p>可以链式调用多个迭代器适配器来以一种可读的方式进行复杂的操作。不过因为所有的迭代器都是惰性的，你必须调用一个消费适配器方法，才能从这些迭代器适配器的调用中获取结果。</p>
<h3 id="使用捕获其环境的闭包"><a href="#使用捕获其环境的闭包" class="headerlink" title="使用捕获其环境的闭包"></a>使用捕获其环境的闭包</h3><p>很多迭代器适配器接受闭包作为参数，而我们通常会指定捕获其环境的闭包作为迭代器适配器的参数。</p>
<p>作为一个例子，我们使用 <code>filter</code> 方法来获取一个闭包。该闭包从迭代器中获取一项并返回一个 <code>bool</code>。如果闭包返回 <code>true</code>，其值将会包含在 <code>filter</code> 提供的新迭代器中。如果闭包返回 <code>false</code>，其值不会被包含。</p>
<p>示例 13-16 中使用 <code>filter</code> 和一个捕获环境中变量 <code>shoe_size</code> 的闭包来遍历一个 <code>Shoe</code> 结构体集合。它只会返回指定鞋码的鞋子。</p>
<p>文件名：src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(PartialEq, Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Shoe</span> &#123;</span><br><span class="line">    size: <span class="type">u32</span>,</span><br><span class="line">    style: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">shoes_in_size</span>(shoes: <span class="type">Vec</span>&lt;Shoe&gt;, shoe_size: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;Shoe&gt; &#123;</span><br><span class="line">    shoes.<span class="title function_ invoke__">into_iter</span>().<span class="title function_ invoke__">filter</span>(|s| s.size == shoe_size).<span class="title function_ invoke__">collect</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">filters_by_size</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">shoes</span> = <span class="built_in">vec!</span>[</span><br><span class="line">            Shoe &#123;</span><br><span class="line">                size: <span class="number">10</span>,</span><br><span class="line">                style: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;sneaker&quot;</span>),</span><br><span class="line">            &#125;,</span><br><span class="line">            Shoe &#123;</span><br><span class="line">                size: <span class="number">13</span>,</span><br><span class="line">                style: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;sandal&quot;</span>),</span><br><span class="line">            &#125;,</span><br><span class="line">            Shoe &#123;</span><br><span class="line">                size: <span class="number">10</span>,</span><br><span class="line">                style: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;boot&quot;</span>),</span><br><span class="line">            &#125;,</span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">in_my_size</span> = <span class="title function_ invoke__">shoes_in_size</span>(shoes, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert_eq!</span>(</span><br><span class="line">            in_my_size,</span><br><span class="line">            <span class="built_in">vec!</span>[</span><br><span class="line">                Shoe &#123;</span><br><span class="line">                    size: <span class="number">10</span>,</span><br><span class="line">                    style: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;sneaker&quot;</span>)</span><br><span class="line">                &#125;,</span><br><span class="line">                Shoe &#123;</span><br><span class="line">                    size: <span class="number">10</span>,</span><br><span class="line">                    style: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;boot&quot;</span>)</span><br><span class="line">                &#125;,</span><br><span class="line">            ]</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 13-16：使用 <code>filter</code> 方法和一个捕获 <code>shoe_size</code> 的闭包</p>
<p><code>shoes_in_size</code> 函数获取一个鞋子 vector 的所有权和一个鞋码作为参数。它返回一个只包含指定鞋码的鞋子的 vector。</p>
<p><code>shoes_in_size</code> 函数体中调用了 <code>into_iter</code> 来创建一个获取 vector 所有权的迭代器。接着调用 <code>filter</code> 将这个迭代器适配成一个只含有那些闭包返回 <code>true</code> 的元素的新迭代器。</p>
<p>闭包从环境中捕获了 <code>shoe_size</code> 变量并使用其值与每一只鞋的大小作比较，只保留指定鞋码的鞋子。最终，调用 <code>collect</code> 将迭代器适配器返回的值收集进一个 vector 并返回。</p>
<p>这个测试展示当调用 <code>shoes_in_size</code> 时，返回的只会是与我们指定的鞋码相同的鞋子。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-06-06T10:30:26.000Z" title="2025/6/6 18:30:26">2025-06-06</time>发表</span><span class="level-item"><time dateTime="2025-06-08T14:31:08.625Z" title="2025/6/8 22:31:08">2025-06-08</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Rust/">Rust</a><span> / </span><a class="link-muted" href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></span><span class="level-item">13 分钟读完 (大约1977个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/06/06/Rust/The%20Rust%20Programming%20Language/13.3%20%E6%94%B9%E8%BF%9B%20IO%20%E9%A1%B9%E7%9B%AE/">13.3 改进 IO 项目</a></p><div class="content"><h2 id="改进-I-O-项目"><a href="#改进-I-O-项目" class="headerlink" title="改进 I&#x2F;O 项目"></a>改进 I&#x2F;O 项目</h2><p>掌握了这些关于迭代器的新知识后，我们可以使用迭代器来改进第十二章中 I&#x2F;O 项目的实现来使得代码更简洁明了。接下来，让我们看看迭代器如何改进 <code>Config::build</code> 函数和 <code>search</code> 函数的实现。</p>
<h3 id="使用迭代器消除-clone"><a href="#使用迭代器消除-clone" class="headerlink" title="使用迭代器消除 clone"></a>使用迭代器消除 <code>clone</code></h3><p>在示例 12-6 中，我们增加了一些代码获取一个 <code>String</code> 类型的 slice 并创建一个 <code>Config</code> 结构体的实例，它们索引 slice 中的值并克隆这些值以便 <code>Config</code> 结构体可以拥有这些值。在示例 13-17 中重现了第十二章结尾示例 12-23 中 <code>Config::build</code> 函数的实现：</p>
<p>文件名：src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">build</span>(args: &amp;[<span class="type">String</span>]) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Config, &amp;<span class="string">&#x27;static str&gt; &#123;</span></span><br><span class="line"><span class="string">        if args.len() &lt; 3 &#123;</span></span><br><span class="line"><span class="string">            return Err(&quot;not enough arguments&quot;);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        let query = args[1].clone();</span></span><br><span class="line"><span class="string">        let file_path = args[2].clone();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        let ignore_case = env::var(&quot;IGNORE_CASE&quot;).is_ok();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Ok(Config &#123;</span></span><br><span class="line"><span class="string">            query,</span></span><br><span class="line"><span class="string">            file_path,</span></span><br><span class="line"><span class="string">            ignore_case,</span></span><br><span class="line"><span class="string">        &#125;)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>示例 13-17：重现示例 12-23 的 <code>Config::build</code> 函数</p>
<p>当时我们说过不必担心低效的 <code>clone</code> 调用，因为我们以后会将其移除。好吧，就是现在！</p>
<p>起初这里需要 <code>clone</code> 的原因是参数 <code>args</code> 中有一个 <code>String</code> 元素的 slice，而 <code>build</code> 函数并不拥有 <code>args</code>。为了能够返回 <code>Config</code> 实例的所有权，我们不得不克隆 <code>Config</code> 中字段 <code>query</code> 和 <code>file_path</code> 的值，这样 <code>Config</code> 实例就能拥有这些值。</p>
<p>在学习了迭代器之后，我们可以将 <code>build</code> 函数改为获取一个有所有权的迭代器作为参数，而不是借用 slice。我们将使用迭代器功能代替之前检查 slice 长度和索引特定位置的代码。这样可以更清晰地表达 <code>Config::build</code> 函数的操作，因为迭代器会负责访问这些值。</p>
<p>一旦 <code>Config::build</code> 获取了迭代器的所有权并不再使用借用的索引操作，就可以将迭代器中的 <code>String</code> 值移动到 <code>Config</code> 中，而不是调用 <code>clone</code> 分配新的空间。</p>
<h4 id="直接使用返回的迭代器"><a href="#直接使用返回的迭代器" class="headerlink" title="直接使用返回的迭代器"></a>直接使用返回的迭代器</h4><p>打开 I&#x2F;O 项目的 <em>src&#x2F;main.rs</em> 文件，它看起来应该像这样：</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span> = Config::<span class="title function_ invoke__">build</span>(&amp;args).<span class="title function_ invoke__">unwrap_or_else</span>(|err| &#123;</span><br><span class="line">        <span class="built_in">eprintln!</span>(<span class="string">&quot;Problem parsing arguments: &#123;err&#125;&quot;</span>);</span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先我们修改第十二章结尾示例 12-24 中的 <code>main</code> 函数的开头为示例 13-18 中的代码。在更新 <code>Config::build</code> 之前这些代码还不能编译：</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span> = Config::<span class="title function_ invoke__">build</span>(env::<span class="title function_ invoke__">args</span>()).<span class="title function_ invoke__">unwrap_or_else</span>(|err| &#123;</span><br><span class="line">        <span class="built_in">eprintln!</span>(<span class="string">&quot;Problem parsing arguments: &#123;err&#125;&quot;</span>);</span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 13-18：将 <code>env::args</code> 的返回值传递给 <code>Config::build</code></p>
<p><code>env::args</code> 函数返回一个迭代器！不同于将迭代器的值收集到一个 vector 中接着传递一个 slice 给 <code>Config::build</code>，现在我们直接将 <code>env::args</code> 返回的迭代器的所有权传递给 <code>Config::build</code>。</p>
<p>接下来需要更新 <code>Config::build</code> 的定义。在 I&#x2F;O 项目的 <em>src&#x2F;lib.rs</em> 中，将 <code>Config::build</code> 的签名改为如示例 13-19 所示。这仍然不能编译因为我们还需更新函数体。</p>
<p>文件名：src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">build</span>(</span><br><span class="line">        <span class="keyword">mut</span> args: <span class="keyword">impl</span> <span class="title class_">Iterator</span>&lt;Item = <span class="type">String</span>&gt;,</span><br><span class="line">    ) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Config, &amp;<span class="string">&#x27;static str&gt; &#123;</span></span><br><span class="line"><span class="string">        // --snip--</span></span><br></pre></td></tr></table></figure>

<p>示例 13-19：以迭代器作为参数更新 <code>Config::build</code> 的签名</p>
<p><code>env::args</code> 函数的标准库文档显示，它返回的迭代器的类型为 <code>std::env::Args</code>，并且这个类型实现了 <code>Iterator</code> trait 并返回 <code>String</code> 值。</p>
<p>我们已经更新了 <code>Config::build</code> 函数的签名，因此参数 <code>args</code> 有一个带有 trait bound <code>impl Iterator&lt;Item = String&gt;</code> 的泛型类型，而不是 <code>&amp;[String]</code>。这里用到了第十章[“trait 作为参数”](.&#x2F;10.2 Trait：定义共同行为)部分讨论过的 <code>impl Trait</code> 语法，这意味着 <code>args</code> 可以是任何实现了 <code>Iterator</code> trait 并返回 <code>String</code> 项（item）的类型。</p>
<p>由于我们获取了 <code>args</code> 的所有权，并且将通过迭代来修改 <code>args</code>，因此我们可以在 <code>args</code> 参数的声明中添加 <code>mut</code> 关键字，使其可变。</p>
<h4 id="使用-Iterator-trait-方法代替索引"><a href="#使用-Iterator-trait-方法代替索引" class="headerlink" title="使用 Iterator trait 方法代替索引"></a>使用 <code>Iterator</code> trait 方法代替索引</h4><p>接下来，我们将修改 <code>Config::build</code> 的函数体。因为 <code>args</code> 实现了 <code>Iterator</code> trait，因此我们知道可以对其调用 <code>next</code> 方法！示例 13-20 更新了示例 12-23 中的代码，以使用 <code>next</code> 方法：</p>
<p>文件名：src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">build</span>(</span><br><span class="line">        <span class="keyword">mut</span> args: <span class="keyword">impl</span> <span class="title class_">Iterator</span>&lt;Item = <span class="type">String</span>&gt;,</span><br><span class="line">    ) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Config, &amp;<span class="string">&#x27;static str&gt; &#123;</span></span><br><span class="line"><span class="string">        args.next();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        let query = match args.next() &#123;</span></span><br><span class="line"><span class="string">            Some(arg) =&gt; arg,</span></span><br><span class="line"><span class="string">            None =&gt; return Err(&quot;Didn&#x27;</span>t get a query string<span class="string">&quot;),</span></span><br><span class="line"><span class="string">        &#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        let file_path = match args.next() &#123;</span></span><br><span class="line"><span class="string">            Some(arg) =&gt; arg,</span></span><br><span class="line"><span class="string">            None =&gt; return Err(&quot;</span>Didn<span class="string">&#x27;t get a file path&quot;),</span></span><br><span class="line"><span class="string">        &#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        let ignore_case = env::var(&quot;IGNORE_CASE&quot;).is_ok();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Ok(Config &#123;</span></span><br><span class="line"><span class="string">            query,</span></span><br><span class="line"><span class="string">            file_path,</span></span><br><span class="line"><span class="string">            ignore_case,</span></span><br><span class="line"><span class="string">        &#125;)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>示例 13-20：修改 <code>Config::build</code> 的函数体来使用迭代器方法</p>
<p>请记住 <code>env::args</code> 返回值的第一个值是程序的名称。我们希望忽略它并获取下一个值，所以首先调用 <code>next</code> 且不对其返回值做任何操作。然后，我们再次调用 <code>next</code> 来获取要放入 <code>Config</code> 结构体的 <code>query</code> 字段的值。如果 <code>next</code> 返回 <code>Some</code>，使用 <code>match</code> 来提取其值。如果它返回 <code>None</code>，则意味着没有提供足够的参数并通过 <code>Err</code> 值提早返回。我们对 <code>file_path</code> 的值也进行同样的操作。</p>
<h3 id="使用迭代器适配器让代码更清晰"><a href="#使用迭代器适配器让代码更清晰" class="headerlink" title="使用迭代器适配器让代码更清晰"></a>使用迭代器适配器让代码更清晰</h3><p>I&#x2F;O 项目中其他可以利用迭代器的地方是 <code>search</code> 函数，示例 13-21 中重现了第十二章结尾示例 12-19 中此函数的定义：</p>
<p>文件名：src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">search</span>&lt;<span class="string">&#x27;a&gt;(query: &amp;str, contents: &amp;&#x27;</span>a <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="string">&#x27;a str&gt; &#123;</span></span><br><span class="line"><span class="string">    let mut results = Vec::new();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    for line in contents.lines() &#123;</span></span><br><span class="line"><span class="string">        if line.contains(query) &#123;</span></span><br><span class="line"><span class="string">            results.push(line);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    results</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>示例 13-21：示例 12-19 中 <code>search</code> 函数的定义</p>
<p>可以通过使用迭代器适配器方法来编写更简明的代码。这样做还可以避免使用一个可变的中间 <code>results</code> vector。函数式编程风格倾向于最小化可变状态的数量来使代码更清晰。去除可变状态可能会使未来的并行搜索优化变得更容易，因为我们不必管理对 <code>results</code> vector 的并发访问。示例 13-22 展示了这一变化：</p>
<p>文件名：src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">search</span>&lt;<span class="string">&#x27;a&gt;(query: &amp;str, contents: &amp;&#x27;</span>a <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="string">&#x27;a str&gt; &#123;</span></span><br><span class="line"><span class="string">    contents</span></span><br><span class="line"><span class="string">        .lines()</span></span><br><span class="line"><span class="string">        .filter(|line| line.contains(query))</span></span><br><span class="line"><span class="string">        .collect()</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>示例 13-22：在 <code>search</code> 函数实现中使用迭代器适配器</p>
<p>回忆一下，<code>search</code> 函数的目的是返回所有 <code>contents</code> 中包含 <code>query</code> 的行。类似于示例 13-16 中的 <code>filter</code> 例子，这段代码使用 <code>filter</code> 适配器来保留 <code>line.contains(query)</code> 返回 <code>true</code> 的行。接着使用 <code>collect</code> 将匹配行收集到另一个 vector 中。这样就容易多了！尝试对 <code>search_case_insensitive</code> 函数做出同样的使用迭代器方法的修改吧。s</p>
<h3 id="选择循环或迭代器"><a href="#选择循环或迭代器" class="headerlink" title="选择循环或迭代器"></a>选择循环或迭代器</h3><p>接下来的逻辑问题就是在代码中应该选择哪种风格，以及原因：是使用示例 13-21 中的原始实现还是使用示例 13-22 中使用迭代器的版本？大部分 Rust 程序员倾向于使用迭代器风格。开始这有点难以掌握，不过一旦你对不同迭代器的工作方式有了感觉之后，迭代器反而更容易理解。相比摆弄不同的循环并创建新 vector，（迭代器）代码则更关注循环的高层次目的。这抽象掉那些老生常谈的代码，这样就更容易看清代码所特有的概念，比如迭代器中每个元素必须满足的过滤条件。</p>
<p>不过这两种实现真的完全等价吗？直觉上的假设是更底层的循环会更快一些。让我们聊聊性能吧。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-06-06T10:10:26.000Z" title="2025/6/6 18:10:26">2025-06-06</time>发表</span><span class="level-item"><time dateTime="2025-06-08T14:30:51.936Z" title="2025/6/8 22:30:51">2025-06-08</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Rust/">Rust</a><span> / </span><a class="link-muted" href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></span><span class="level-item">36 分钟读完 (大约5421个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/06/06/Rust/The%20Rust%20Programming%20Language/13.1%20%E9%97%AD%E5%8C%85%EF%BC%9A%E5%8F%AF%E4%BB%A5%E6%8D%95%E8%8E%B7%E7%8E%AF%E5%A2%83%E7%9A%84%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/">13.1 闭包：可以捕获环境的匿名函数</a></p><div class="content"><p>Rust 的 <strong>闭包</strong>（<em>closures</em>）是可以保存在变量中或作为参数传递给其他函数的匿名函数。你可以在一个地方创建闭包，然后在不同的上下文中执行闭包运算。不同于函数，闭包允许捕获其被定义时所在作用域中的值。我们将展示这些闭包特性如何支持代码复用和行为定制。</p>
<h3 id="使用闭包捕获环境"><a href="#使用闭包捕获环境" class="headerlink" title="使用闭包捕获环境"></a>使用闭包捕获环境</h3><p>我们首先了解如何通过闭包捕获定义它的环境中的值以便之后使用。考虑如下场景：我们的 T 恤公司偶尔会向邮件列表中的某位成员赠送一件限量版的独家 T 恤作为促销。邮件列表中的成员可以选择将他们的喜爱的颜色添加到个人信息中。如果被选中的成员设置了喜爱的颜色，他们将获得那个颜色的 T 恤。如果他没有设置喜爱的颜色，他们会获赠公司当前库存最多的颜色的款式。</p>
<p>有很多种方式来实现这一点。例如，使用有 <code>Red</code> 和 <code>Blue</code> 两个变体的 <code>ShirtColor</code> 枚举（出于简单考虑限定为两种颜色）。我们使用 <code>Inventory</code> 结构体来代表公司的库存，它有一个类型为 <code>Vec&lt;ShirtColor&gt;</code> 的 <code>shirts</code> 字段表示库存中的衬衫的颜色。<code>Inventory</code> 上定义的 <code>giveaway</code> 方法获取免费衬衫得主所喜爱的颜色（如有），并返回其获得的衬衫的颜色。初始代码如示例 13-1 所示：</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug, PartialEq, Copy, Clone)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">ShirtColor</span> &#123;</span><br><span class="line">    Red,</span><br><span class="line">    Blue,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Inventory</span> &#123;</span><br><span class="line">    shirts: <span class="type">Vec</span>&lt;ShirtColor&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Inventory</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">giveaway</span>(&amp;<span class="keyword">self</span>, user_preference: <span class="type">Option</span>&lt;ShirtColor&gt;) <span class="punctuation">-&gt;</span> ShirtColor &#123;</span><br><span class="line">        user_preference.<span class="title function_ invoke__">unwrap_or_else</span>(|| <span class="keyword">self</span>.<span class="title function_ invoke__">most_stocked</span>())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">most_stocked</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> ShirtColor &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num_red</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num_blue</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> <span class="variable">color</span> <span class="keyword">in</span> &amp;<span class="keyword">self</span>.shirts &#123;</span><br><span class="line">            <span class="keyword">match</span> color &#123;</span><br><span class="line">                ShirtColor::Red =&gt; num_red += <span class="number">1</span>,</span><br><span class="line">                ShirtColor::Blue =&gt; num_blue += <span class="number">1</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> num_red &gt; num_blue &#123;</span><br><span class="line">            ShirtColor::Red</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ShirtColor::Blue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">store</span> = Inventory &#123;</span><br><span class="line">        shirts: <span class="built_in">vec!</span>[ShirtColor::Blue, ShirtColor::Red, ShirtColor::Blue],</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user_pref1</span> = <span class="title function_ invoke__">Some</span>(ShirtColor::Red);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">giveaway1</span> = store.<span class="title function_ invoke__">giveaway</span>(user_pref1);</span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;The user with preference &#123;:?&#125; gets &#123;:?&#125;&quot;</span>,</span><br><span class="line">        user_pref1, giveaway1</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user_pref2</span> = <span class="literal">None</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">giveaway2</span> = store.<span class="title function_ invoke__">giveaway</span>(user_pref2);</span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;The user with preference &#123;:?&#125; gets &#123;:?&#125;&quot;</span>,</span><br><span class="line">        user_pref2, giveaway2</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 13-1：衬衫公司赠送场景</p>
<p><code>main</code> 函数中定义的 <code>store</code> 还剩下两件蓝衬衫和一件红衬衫，可以在限量版促销活动中赠送。我们通过调用 <code>giveaway</code> 方法，为一个期望红衬衫的用户和一个没有特定偏好的用户进行赠送。</p>
<p>再次强调，这段代码有多种实现方式。这里为了专注于闭包，我们继续使用已经学习过的概念，除了 <code>giveaway</code> 方法体中使用了闭包。在 <code>giveaway</code> 方法中，我们将用户偏好作为 <code>Option&lt;ShirtColor&gt;</code> 类型的参数获取，并在 <code>user_preference</code> 上调用 <code>unwrap_or_else</code> 方法。<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or_else"><code>Option</code> 上的 <code>unwrap_or_else</code> 方法</a>由标准库定义。它接受一个无参闭包作为参数，该闭包返回一个 <code>T</code> 类型的值（与 <code>Option&lt;T&gt;</code> 的 <code>Some</code> 变体中存储的值类型相同，这里是 <code>ShirtColor</code>）。如果 <code>Option&lt;T&gt;</code> 是 <code>Some</code> 变体，则 <code>unwrap_or_else</code> 返回 <code>Some</code> 中的值。如果 <code>Option&lt;T&gt;</code> 是 <code>None</code> 变体，则 <code>unwrap_or_else</code> 调用闭包并返回闭包的返回值。</p>
<p>我们将闭包表达式 <code>|| self.most_stocked()</code> 作为 <code>unwrap_or_else</code> 的参数。这是一个本身不获取参数的闭包（如果闭包有参数，它们会出现在两道竖杠之间）。闭包体调用了 <code>self.most_stocked()</code>。我们在这里定义了闭包，而 <code>unwrap_or_else</code> 的实现会在之后需要其结果的时候执行闭包。</p>
<p>运行代码会打印出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">   Compiling shirt-company v0.1.0 (file:///projects/shirt-company)</span><br><span class="line">    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.27s</span><br><span class="line">     Running `target/debug/shirt-company`</span><br><span class="line">The user with preference Some(Red) gets Red</span><br><span class="line">The user with preference None gets Blue</span><br></pre></td></tr></table></figure>

<p>这里有一个有趣的地方是，我们传递了一个闭包，该闭包会在当前的 <code>Inventory</code> 实例上调用 <code>self.most_stocked()</code> 方法。标准库不需要了解我们定义的 <code>Inventory</code> 或 <code>ShirtColor</code> 类型，也不需要了解我们在这个场景中要使用的逻辑。闭包捕获了对 <code>self</code>（即 <code>Inventory</code> 实例）的不可变引用，并将其与我们指定的代码一起传递给 <code>unwrap_or_else</code> 方法。相比之下，函数无法以这种方式捕获其环境。</p>
<h3 id="闭包类型推断和注解"><a href="#闭包类型推断和注解" class="headerlink" title="闭包类型推断和注解"></a>闭包类型推断和注解</h3><p>函数与闭包还有更多区别。闭包通常不要求像 <code>fn</code> 函数那样对参数和返回值进行类型注解。函数需要类型注解是因为这些类型是暴露给用户的显式接口的一部分。严格定义这些接口对于确保所有人对函数使用和返回值的类型达成一致理解非常重要。与此相比，闭包并不用于这样暴露在外的接口：它们储存在变量中并被使用，不用命名它们或暴露给库的用户调用。</p>
<p>闭包通常较短，并且只与特定的上下文相关，而不是适用于任意情境。在这些有限的上下文中，编译器可以推断参数和返回值的类型，类似于它推断大多数变量类型的方式（尽管在某些罕见的情况下，编译器也需要闭包的类型注解）。</p>
<p>类似于变量，如果我们希望增加代码的明确性和清晰度，可以添加类型注解，但代价是会使代码变得比严格必要的更冗长。为示例 13-1 中定义的闭包标注类型看起来如示例 13-2 中的定义一样。这个例子中，我们定义了一个闭包并将它保存在变量中，而不是像示例 13-1 那样在传参的地方定义它。</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">expensive_closure</span> = |num: <span class="type">u32</span>| <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;calculating slowly...&quot;</span>);</span><br><span class="line">    thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">2</span>));</span><br><span class="line">    num</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>示例 13-2：为闭包的参数和返回值增加可选的类型注解</p>
<p>有了类型注解，闭包的语法看起来就更像函数的语法了。如下是一个对其参数加一的函数的定义与拥有相同行为闭包语法的纵向对比。这里增加了一些空格来对齐相应部分。这展示了除了使用管道符（|，pipes）以及一些可选语法外，闭包语法与函数语法有多么地相似：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span>  <span class="title function_">add_one_v1</span>   (x: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123; x + <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">add_one_v2</span> = |x: <span class="type">u32</span>| <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123; x + <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">add_one_v3</span> = |x|             &#123; x + <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">add_one_v4</span> = |x|               x + <span class="number">1</span>  ;</span><br></pre></td></tr></table></figure>

<p>第一行展示了一个函数定义，第二行展示了一个完整标注的闭包定义。第三行闭包定义中省略了类型注解，而第四行去掉了可选的大括号，因为闭包体只有一个表达式，所以大括号是可选的。这些都是有效的闭包定义，并在调用时产生相同的行为。调用闭包是 <code>add_one_v3</code> 和 <code>add_one_v4</code> 能够编译的必要条件，因为类型将从其用法中推断出来。这类似于 <code>let v = Vec::new();</code>，Rust 需要类型注解或是某种类型的值被插入到 <code>Vec</code> 中，才能推断其类型。</p>
<p>对于闭包定义，编译器会为每个参数和返回值推断出一个具体类型。例如，示例 13-3 展示了一个简短的闭包定义，该闭包仅仅返回作为参数接收到的值。除了作为示例用途外，这个闭包并不是很实用。注意这个定义没有增加任何类型注解。因为没有类型注解，我们可以使用任意类型来调用这个闭包，我们在这里第一次调用时使用了 <code>String</code> 类型。但是如果我们接着尝试使用整数来调用 <code>example_closure</code>，就会得到一个错误。</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">example_closure</span> = |x| x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">example_closure</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line"><span class="keyword">let</span> <span class="variable">n</span> = <span class="title function_ invoke__">example_closure</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>示例 13-3：尝试调用一个被推断为两个不同类型的闭包</p>
<p>编译器给出如下错误：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">   Compiling closure-example v0.1.0 (file:///projects/closure-example)</span><br><span class="line">error[E0308]: mismatched types</span><br><span class="line"><span class="meta prompt_"> --&gt; </span><span class="language-bash">src/main.rs:5:29</span></span><br><span class="line">  |</span><br><span class="line">5 |     let n = example_closure(5);</span><br><span class="line">  |             --------------- ^- help: try using a conversion method: `.to_string()`</span><br><span class="line">  |             |               |</span><br><span class="line">  |             |               expected `String`, found integer</span><br><span class="line">  |             arguments to this function are incorrect</span><br><span class="line">  |</span><br><span class="line">note: expected because the closure was earlier called with an argument of type `String`</span><br><span class="line"><span class="meta prompt_"> --&gt; </span><span class="language-bash">src/main.rs:4:29</span></span><br><span class="line">  |</span><br><span class="line">4 |     let s = example_closure(String::from(&quot;hello&quot;));</span><br><span class="line">  |             --------------- ^^^^^^^^^^^^^^^^^^^^^ expected because this argument is of type `String`</span><br><span class="line">  |             |</span><br><span class="line">  |             in this closure call</span><br><span class="line">note: closure parameter defined here</span><br><span class="line"><span class="meta prompt_"> --&gt; </span><span class="language-bash">src/main.rs:2:28</span></span><br><span class="line">  |</span><br><span class="line">2 |     let example_closure = |x| x;</span><br><span class="line">  |                            ^</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0308`.</span><br><span class="line">error: could not compile `closure-example` (bin &quot;closure-example&quot;) due to 1 previous error</span><br></pre></td></tr></table></figure>

<p>第一次使用 <code>String</code> 值调用 <code>example_closure</code> 时，编译器推断出 <code>x</code> 的类型以及闭包的返回类型为 <code>String</code>。接着这些类型被锁定进闭包 <code>example_closure</code> 中，如果尝试对同一闭包使用不同类型则就会得到类型错误。</p>
<h3 id="捕获引用或移动所有权"><a href="#捕获引用或移动所有权" class="headerlink" title="捕获引用或移动所有权"></a>捕获引用或移动所有权</h3><p>闭包可以通过三种方式捕获其环境中的值，它们直接对应到函数获取参数的三种方式：不可变借用、可变借用和获取所有权。闭包将根据函数体中对捕获值的操作来决定使用哪种方式。</p>
<p>在示例 13-4 中定义了一个捕获名为 <code>list</code> 的 vector 的不可变引用的闭包，因为只需不可变引用就能打印其值：</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">list</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Before defining closure: &#123;list:?&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">only_borrows</span> = || <span class="built_in">println!</span>(<span class="string">&quot;From closure: &#123;list:?&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Before calling closure: &#123;list:?&#125;&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">only_borrows</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;After calling closure: &#123;list:?&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 13-4：定义并调用一个捕获不可变引用的闭包</p>
<p>这个示例也展示了变量可以绑定一个闭包定义，并且我们可以像使用函数名一样，使用变量名和括号来调用该闭包。</p>
<p>因为同时可以有多个 <code>list</code> 的不可变引用，所以在闭包定义之前，闭包定义之后调用之前，闭包调用之后代码仍然可以访问 <code>list</code>。该代码可以编译、运行并输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">   Compiling closure-example v0.1.0 (file:///projects/closure-example)</span><br><span class="line">    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s</span><br><span class="line">     Running `target/debug/closure-example`</span><br><span class="line">Before defining closure: [1, 2, 3]</span><br><span class="line">Before calling closure: [1, 2, 3]</span><br><span class="line">From closure: [1, 2, 3]</span><br><span class="line">After calling closure: [1, 2, 3]</span><br></pre></td></tr></table></figure>

<p>接下来在示例 13-5 中，我们修改闭包体让它向 <code>list</code> vector 增加一个元素。闭包现在捕获一个可变引用：</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">list</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Before defining closure: &#123;list:?&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">borrows_mutably</span> = || list.<span class="title function_ invoke__">push</span>(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">borrows_mutably</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;After calling closure: &#123;list:?&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 13-5：定义并调用一个捕获可变引用的闭包</p>
<p>代码可以编译、运行并打印：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">   Compiling closure-example v0.1.0 (file:///projects/closure-example)</span><br><span class="line">    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s</span><br><span class="line">     Running `target/debug/closure-example`</span><br><span class="line">Before defining closure: [1, 2, 3]</span><br><span class="line">After calling closure: [1, 2, 3, 7]</span><br></pre></td></tr></table></figure>

<p>注意在 <code>borrows_mutably</code> 闭包的定义和调用之间不再有 <code>println!</code>，这是因为当 <code>borrows_mutably</code> 被定义时，它捕获了对 <code>list</code> 的可变引用。闭包在被调用后就不再被使用，这时可变借用结束。因为当可变借用存在时不允许有其它的借用，所以在闭包定义和调用之间不能有不可变引用来进行打印。可以尝试在这里添加 <code>println!</code> 看看你会得到什么报错信息！</p>
<p>即使闭包体不严格需要所有权，如果希望强制闭包获取它在环境中所使用的值的所有权，可以在参数列表前使用 <code>move</code> 关键字。</p>
<p>当将闭包传递到一个新的线程时，这个技巧特别有用，因为它将数据的所有权移动到新线程中。我们将在第十六章讨论并发时详细讨论线程以及为什么你可能需要使用它们。不过现在，我们先简要探索一下如何使用需要 <code>move</code> 关键字的闭包来生成一个新线程。示例 13-6 展示了如何修改示例 13-4，以便在一个新线程中而不是在主线程中打印 vector：</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">list</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Before defining closure: &#123;list:?&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || <span class="built_in">println!</span>(<span class="string">&quot;From thread: &#123;list:?&#125;&quot;</span>))</span><br><span class="line">        .<span class="title function_ invoke__">join</span>()</span><br><span class="line">        .<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 13-6：使用 <code>move</code> 来强制闭包为线程获取 <code>list</code> 的所有权</p>
<p>我们生成了一个新的线程，并给这个线程传递一个闭包作为参数来运行，闭包体打印出列表。在示例 13-4 中，闭包仅通过不可变引用捕获了 <code>list</code>，因为这是打印列表所需的最小访问权限。这个例子中，尽管闭包体依然只需要不可变引用，我们还是在闭包定义前写上 <code>move</code> 关键字，以确保 <code>list</code> 被移动到闭包中。新线程可能在主线程剩余部分执行完前执行完，也可能在主线程执行完之后执行完。如果主线程维护了 <code>list</code> 的所有权但却在新线程之前结束并且丢弃了 <code>list</code>，则在线程中的不可变引用将失效。因此，编译器要求 <code>list</code> 被移动到在新线程中运行的闭包中，这样引用就是有效的。试着移除 <code>move</code> 关键字，或者在闭包定义后在主线程中使用 <code>list</code>，看看你会得到什么编译器报错！</p>
<h3 id="将捕获的值移出闭包和-Fn-trait"><a href="#将捕获的值移出闭包和-Fn-trait" class="headerlink" title="将捕获的值移出闭包和 Fn trait"></a>将捕获的值移出闭包和 <code>Fn</code> trait</h3><p>一旦闭包捕获了定义它的环境中的某个值的引用或所有权（也就影响了什么会被移<strong>进</strong>闭包，如有），闭包体中的代码则决定了在稍后执行闭包时，这些引用或值将如何处理（也就影响了什么会被移<strong>出</strong>闭包，如有）。闭包体可以执行以下任一操作：将一个捕获的值移出闭包，修改捕获的值，既不移动也不修改值，或者一开始就不从环境中捕获任何值。</p>
<p>闭包捕获和处理环境中的值的方式会影响闭包实现哪些 trait，而 trait 是函数和结构体指定它们可以使用哪些类型闭包的方式。根据闭包体如何处理这些值，闭包会自动、渐进地实现一个、两个或全部三个 <code>Fn</code> trait。</p>
<ol>
<li><code>FnOnce</code> 适用于只能被调用一次的闭包。所有闭包至少都实现了这个 trait，因为所有闭包都能被调用。一个会将捕获的值从闭包体中移出的闭包只会实现 <code>FnOnce</code> trait，而不会实现其他 <code>Fn</code> 相关的 trait，因为它只能被调用一次。</li>
<li><code>FnMut</code> 适用于不会将捕获的值移出闭包体，但可能会修改捕获值的闭包。这类闭包可以被调用多次。</li>
<li><code>Fn</code> 适用于既不将捕获的值移出闭包体，也不修改捕获值的闭包，同时也包括不从环境中捕获任何值的闭包。这类闭包可以被多次调用而不会改变其环境，这在会多次并发调用闭包的场景中十分重要。</li>
</ol>
<p>让我们来看示例 13-1 中使用的在 <code>Option&lt;T&gt;</code> 上的 <code>unwrap_or_else</code> 方法的定义：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="type">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">unwrap_or_else</span>&lt;F&gt;(<span class="keyword">self</span>, f: F) <span class="punctuation">-&gt;</span> T</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        F: <span class="title function_ invoke__">FnOnce</span>() <span class="punctuation">-&gt;</span> T</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(x) =&gt; x,</span><br><span class="line">            <span class="literal">None</span> =&gt; <span class="title function_ invoke__">f</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回忆一下，<code>T</code> 是表示 <code>Option</code> 中 <code>Some</code> 变体中的值的类型的泛型。类型 <code>T</code> 也是 <code>unwrap_or_else</code> 函数的返回值类型：举例来说，在 <code>Option&lt;String&gt;</code> 上调用 <code>unwrap_or_else</code> 会得到一个 <code>String</code>。</p>
<p>接着注意到 <code>unwrap_or_else</code> 函数有额外的泛型参数 <code>F</code>。<code>F</code> 是参数 <code>f</code> 的类型，<code>f</code> 是调用 <code>unwrap_or_else</code> 时提供的闭包。</p>
<p>泛型 <code>F</code> 的 trait bound 是 <code>FnOnce() -&gt; T</code>，这意味着 <code>F</code> 必须能够被调用一次，没有参数并返回一个 <code>T</code>。在 trait bound 中使用 <code>FnOnce</code> 表示 <code>unwrap_or_else</code> 最多只会调用 <code>f</code> 一次。在 <code>unwrap_or_else</code> 的函数体中可以看到，如果 <code>Option</code> 是 <code>Some</code>，<code>f</code> 不会被调用。如果 <code>Option</code> 是 <code>None</code>，<code>f</code> 将会被调用一次。由于所有的闭包都实现了 <code>FnOnce</code>，<code>unwrap_or_else</code> 接受所有三种类型的闭包，灵活性达到极致。</p>
<blockquote>
<p>注意：如果我们要做的事情不需要从环境中捕获值，则可以在需要某种实现了 <code>Fn</code> trait 的东西时使用函数而不是闭包。举个例子，可以在 <code>Option&lt;Vec&lt;T&gt;&gt;</code> 的值上调用 <code>unwrap_or_else(Vec::new)</code>，以便在值为 <code>None</code> 时获取一个新的空的 vector。编译器会自动为函数定义实现适用的 <code>Fn</code> trait。</p>
</blockquote>
<p>现在让我们来看定义在 slice 上的标准库方法 <code>sort_by_key</code>，看看它与 <code>unwrap_or_else</code> 的区别，以及为什么 <code>sort_by_key</code> 使用 <code>FnMut</code> 而不是 <code>FnOnce</code> 作为 trait bound。这个闭包以一个 slice 中当前被考虑的元素的引用作为参数，并返回一个可以排序的 <code>K</code> 类型的值。当你想按照 slice 中每个元素的某个属性进行排序时，这个函数非常有用。在示例 13-7 中，我们有一个 <code>Rectangle</code> 实例的列表，并使用 <code>sort_by_key</code> 按 <code>Rectangle</code> 的 <code>width</code> 属性对它们从低到高排序：</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">list</span> = [</span><br><span class="line">        Rectangle &#123; width: <span class="number">10</span>, height: <span class="number">1</span> &#125;,</span><br><span class="line">        Rectangle &#123; width: <span class="number">3</span>, height: <span class="number">5</span> &#125;,</span><br><span class="line">        Rectangle &#123; width: <span class="number">7</span>, height: <span class="number">12</span> &#125;,</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    list.<span class="title function_ invoke__">sort_by_key</span>(|r| r.width);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;list:#?&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 13-7：使用 <code>sort_by_key</code> 对长方形按宽度排序</p>
<p>代码输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">   Compiling rectangles v0.1.0 (file:///projects/rectangles)</span><br><span class="line">    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.41s</span><br><span class="line">     Running `target/debug/rectangles`</span><br><span class="line">[</span><br><span class="line">    Rectangle &#123;</span><br><span class="line">        width: 3,</span><br><span class="line">        height: 5,</span><br><span class="line">    &#125;,</span><br><span class="line">    Rectangle &#123;</span><br><span class="line">        width: 7,</span><br><span class="line">        height: 12,</span><br><span class="line">    &#125;,</span><br><span class="line">    Rectangle &#123;</span><br><span class="line">        width: 10,</span><br><span class="line">        height: 1,</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><code>sort_by_key</code> 被定义为接收一个 <code>FnMut</code> 闭包的原因是它会多次调用这个闭包：对 slice 中的每个元素调用一次。闭包 <code>|r| r.width</code> 不捕获、修改或将任何东西移出它的环境，所以它满足 trait bound 的要求。</p>
<p>相比之下，示例 13-8 展示了一个只实现了 <code>FnOnce</code> trait 的闭包的例子，因为它从环境中移出了一个值。编译器不允许我们在 <code>sort_by_key</code> 中使用这个闭包：</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">list</span> = [</span><br><span class="line">        Rectangle &#123; width: <span class="number">10</span>, height: <span class="number">1</span> &#125;,</span><br><span class="line">        Rectangle &#123; width: <span class="number">3</span>, height: <span class="number">5</span> &#125;,</span><br><span class="line">        Rectangle &#123; width: <span class="number">7</span>, height: <span class="number">12</span> &#125;,</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">sort_operations</span> = <span class="built_in">vec!</span>[];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">value</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;closure called&quot;</span>);</span><br><span class="line"></span><br><span class="line">    list.<span class="title function_ invoke__">sort_by_key</span>(|r| &#123;</span><br><span class="line">        sort_operations.<span class="title function_ invoke__">push</span>(value);</span><br><span class="line">        r.width</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;list:#?&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 13-8：尝试在 <code>sort_by_key</code> 上使用一个 <code>FnOnce</code> 闭包</p>
<p>这是一个刻意构造的、复杂且无效的方式，试图统计在对 <code>list</code> 进行排序时 <code>sort_by_key</code> 调用闭包的次数。该代码试图通过将闭包环境中的 <code>value</code>（一个 <code>String</code>）插入 <code>sort_operations</code> vector 来实现计数。闭包捕获了 <code>value</code>，然后通过将 <code>value</code> 的所有权转移给 <code>sort_operations</code> vector 的方式将其移出闭包。这个闭包只能被调用一次；尝试第二次调用它将无法工作，因为这时 <code>value</code> 已经不在闭包的环境中，无法被再次插入 <code>sort_operations</code> 中！因而，这个闭包只实现了 <code>FnOnce</code>。当我们尝试编译此代码时，会出现错误提示：<code>value</code> 不能从闭包中移出，因为闭包必须实现 <code>FnMut</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">   Compiling rectangles v0.1.0 (file:///projects/rectangles)</span><br><span class="line">error[E0507]: cannot move out of `value`, a captured variable in an `FnMut` closure</span><br><span class="line"><span class="meta prompt_">  --&gt; </span><span class="language-bash">src/main.rs:18:30</span></span><br><span class="line">   |</span><br><span class="line">15 |     let value = String::from(&quot;closure called&quot;);</span><br><span class="line">   |         ----- captured outer variable</span><br><span class="line">16 |</span><br><span class="line">17 |     list.sort_by_key(|r| &#123;</span><br><span class="line">   |                      --- captured by this `FnMut` closure</span><br><span class="line">18 |         sort_operations.push(value);</span><br><span class="line">   |                              ^^^^^ move occurs because `value` has type `String`, which does not implement the `Copy` trait</span><br><span class="line">   |</span><br><span class="line">help: consider cloning the value if the performance cost is acceptable</span><br><span class="line">   |</span><br><span class="line">18 |         sort_operations.push(value.clone());</span><br><span class="line">   |                                   ++++++++</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0507`.</span><br><span class="line">error: could not compile `rectangles` (bin &quot;rectangles&quot;) due to 1 previous error</span><br></pre></td></tr></table></figure>

<p>报错指向了闭包体中将 <code>value</code> 移出环境的那一行。要修复此问题，我们需要修改闭包体，使其不会将值移出环境。在环境中维护一个计数器，并在闭包体中递增其值，是计算闭包被调用次数的一个更直观的方法。示例 13-9 中的闭包可以在 <code>sort_by_key</code> 中使用，因为它只捕获了 <code>num_sort_operations</code> 计数器的可变引用，因此可以被多次调用：</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">list</span> = [</span><br><span class="line">        Rectangle &#123; width: <span class="number">10</span>, height: <span class="number">1</span> &#125;,</span><br><span class="line">        Rectangle &#123; width: <span class="number">3</span>, height: <span class="number">5</span> &#125;,</span><br><span class="line">        Rectangle &#123; width: <span class="number">7</span>, height: <span class="number">12</span> &#125;,</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num_sort_operations</span> = <span class="number">0</span>;</span><br><span class="line">    list.<span class="title function_ invoke__">sort_by_key</span>(|r| &#123;</span><br><span class="line">        num_sort_operations += <span class="number">1</span>;</span><br><span class="line">        r.width</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;list:#?&#125;, sorted in &#123;num_sort_operations&#125; operations&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 13-9：允许在 <code>sort_by_key</code> 上使用一个 <code>FnMut</code> 闭包</p>
<p>当定义或使用涉及闭包的函数或类型时，<code>Fn</code> trait 十分重要。在下个小节中，我们将讨论迭代器。许多迭代器方法都接收闭包参数，因此在继续前，请记住这些闭包的细节！s</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-06-01T12:50:26.000Z" title="2025/6/1 20:50:26">2025-06-01</time>发表</span><span class="level-item"><time dateTime="2025-06-01T12:58:47.877Z" title="2025/6/1 20:58:47">2025-06-01</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Rust/">Rust</a><span> / </span><a class="link-muted" href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></span><span class="level-item">8 分钟读完 (大约1161个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/06/01/Rust/The%20Rust%20Programming%20Language/12.6%20%E5%B0%86%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E8%BE%93%E5%87%BA%E5%88%B0%E6%A0%87%E5%87%86%E9%94%99%E8%AF%AF%E8%80%8C%E4%B8%8D%E6%98%AF%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA/">12.6 将错误信息输出到标准错误而不是标准输出</a></p><div class="content"><h2 id="将错误信息输出到标准错误而不是标准输出"><a href="#将错误信息输出到标准错误而不是标准输出" class="headerlink" title="将错误信息输出到标准错误而不是标准输出"></a>将错误信息输出到标准错误而不是标准输出</h2><p>目前为止，我们将所有的输出都通过 <code>println!</code> 写到了终端。大部分终端都提供了两种输出：<strong>标准输出</strong>（<em>standard output</em>，<code>stdout</code>）对应一般信息，<strong>标准错误</strong>（<em>standard error</em>，<code>stderr</code>）则用于错误信息。这种区别允许用户选择将程序正常输出定向到一个文件中并仍将错误信息打印到屏幕上。</p>
<p>但是 <code>println!</code> 宏只能够打印到标准输出，所以我们必须使用其他方法来打印到标准错误。</p>
<h3 id="检查错误写入何处"><a href="#检查错误写入何处" class="headerlink" title="检查错误写入何处"></a>检查错误写入何处</h3><p>首先，让我们观察一下目前 <code>minigrep</code> 打印的所有内容是如何被写入标准输出的，包括那些应该被写入标准错误的错误信息。可以通过将标准输出流重定向到一个文件同时有意产生一个错误来做到这一点。我们没有重定向标准错误流，所以任何发送到标准错误的内容将会继续显示在屏幕上。</p>
<p>命令行程序被期望将错误信息发送到标准错误流，这样即便选择将标准输出流重定向到文件中时仍然能看到错误信息。目前我们的程序并不符合期望；相反我们将看到它将错误信息输出保存到了文件中！</p>
<p>我们通过 <code>&gt;</code> 和文件路径 <em>output.txt</em> 来运行程序，我们期望重定向标准输出流到该文件中。在这里，我们没有传递任何参数，所以会产生一个错误：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run &gt; output.txt</span></span><br></pre></td></tr></table></figure>

<p><code>&gt;</code> 语法告诉 shell 将标准输出的内容写入到 <em>output.txt</em> 文件中而不是屏幕上。我们并没有看到期望的错误信息打印到屏幕上，所以这意味着它一定被写入了文件中。如下是 <em>output.txt</em> 所包含的：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Problem parsing arguments: not enough arguments</span><br></pre></td></tr></table></figure>

<p>是的，错误信息被打印到了标准输出中。像这样的错误信息被打印到标准错误中将会有用得多，这将使得只有成功运行所产生的输出才会写入文件。我们接下来就修改。</p>
<h3 id="将错误打印到标准错误"><a href="#将错误打印到标准错误" class="headerlink" title="将错误打印到标准错误"></a>将错误打印到标准错误</h3><p>让我们如示例 12-24 所示的代码改变错误信息是如何被打印的。得益于本章早些时候的重构，所有打印错误信息的代码都位于 <code>main</code> 一个函数中。标准库提供了 <code>eprintln!</code> 宏来打印到标准错误流，所以将两个调用 <code>println!</code> 打印错误信息的位置替换为 <code>eprintln!</code>：</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span> = Config::<span class="title function_ invoke__">build</span>(&amp;args).<span class="title function_ invoke__">unwrap_or_else</span>(|err| &#123;</span><br><span class="line">        <span class="built_in">eprintln!</span>(<span class="string">&quot;Problem parsing arguments: &#123;err&#125;&quot;</span>);</span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = minigrep::<span class="title function_ invoke__">run</span>(config) &#123;</span><br><span class="line">        <span class="built_in">eprintln!</span>(<span class="string">&quot;Application error: &#123;e&#125;&quot;</span>);</span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 12-24：使用 <code>eprintln!</code> 将错误信息写入标准错误而不是标准输出</p>
<p>现在我们再次尝试用同样的方式运行程序，不使用任何参数并通过 <code>&gt;</code> 重定向标准输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run &gt; output.txt</span></span><br><span class="line">Problem parsing arguments: not enough arguments</span><br></pre></td></tr></table></figure>

<p>现在我们看到了屏幕上的错误信息，同时 <em>output.txt</em> 里什么也没有，这正是命令行程序所期望的行为。</p>
<p>如果使用不会造成错误的参数再次运行程序，不过仍然将标准输出重定向到一个文件，像这样：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run -- to poem.txt &gt; output.txt</span></span><br></pre></td></tr></table></figure>

<p>我们并不会在终端看到任何输出，同时 <code>output.txt</code> 将会包含其结果：</p>
<p>文件名：output.txt</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Are you nobody, too?</span><br><span class="line">How dreary to be somebody!</span><br></pre></td></tr></table></figure>

<p>这一部分展示了现在我们适当地使用了成功时产生的标准输出和错误时产生的标准错误。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这一章中，我们回顾了目前为止的一些主要章节并涉及了如何在 Rust 环境中进行常规的 I&#x2F;O 操作。通过使用命令行参数、文件、环境变量和打印错误的 <code>eprintln!</code> 宏，现在你已经准备好编写命令行程序了。通过结合前几章的知识，你的代码将会是组织良好的，并能有效的将数据存储到合适的数据结构中、更好的处理错误，并且还是经过良好测试的。</p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/categories/Rust/page/0/">上一页</a></div><div class="pagination-next"><a href="/categories/Rust/page/2/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/categories/Rust/">1</a></li><li><a class="pagination-link" href="/categories/Rust/page/2/">2</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/categories/Rust/page/5/">5</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.jpg" alt="Rossignol"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Rossignol</p><p class="is-size-6 is-block">NaN</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Mars</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives/"><p class="title">82</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories/"><p class="title">15</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags/"><p class="title">13</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/0xRossignol" target="_blank" rel="me noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/0xRossignol"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Golang/"><span class="level-start"><span class="level-item">Golang</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/Golang/basics/"><span class="level-start"><span class="level-item">basics</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/Java/basics/"><span class="level-start"><span class="level-item">basics</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/Java/basics/Thinking-in-Java/"><span class="level-start"><span class="level-item">Thinking in Java</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/Linux/Arch-Linux/"><span class="level-start"><span class="level-item">Arch Linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/OS/"><span class="level-start"><span class="level-item">OS</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Rust/"><span class="level-start"><span class="level-item">Rust</span></span><span class="level-end"><span class="level-item tag">48</span></span></a><ul><li><a class="level is-mobile" href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">Rust程序设计语言</span></span><span class="level-end"><span class="level-item tag">48</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/test/"><span class="level-start"><span class="level-item">test</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/toy-projects/"><span class="level-start"><span class="level-item">toy projects</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%85%AB%E8%82%A1/"><span class="level-start"><span class="level-item">八股</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%85%AB%E8%82%A1/JavaSE/"><span class="level-start"><span class="level-item">JavaSE</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%85%AB%E8%82%A1/Java%E9%9B%86%E5%90%88/"><span class="level-start"><span class="level-item">Java集合</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-06-08T14:20:26.000Z">2025-06-08</time></p><p class="title"><a href="/2025/06/08/Rust/The%20Rust%20Programming%20Language/14.5%20Cargo%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%89%A9%E5%B1%95%E5%91%BD%E4%BB%A4/">14.5 Cargo 自定义扩展命令</a></p><p class="categories"><a href="/categories/Rust/">Rust</a> / <a href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-06-08T14:10:26.000Z">2025-06-08</time></p><p class="title"><a href="/2025/06/08/Rust/The%20Rust%20Programming%20Language/14.4%20%E4%BD%BF%E7%94%A8%20cargo%20install%20%E5%AE%89%E8%A3%85%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6/">14.4 使用 cargo install 安装二进制文件</a></p><p class="categories"><a href="/categories/Rust/">Rust</a> / <a href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-06-08T14:00:26.000Z">2025-06-08</time></p><p class="title"><a href="/2025/06/08/Rust/The%20Rust%20Programming%20Language/14.3%20Cargo%20%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4/">14.3 Cargo 工作空间</a></p><p class="categories"><a href="/categories/Rust/">Rust</a> / <a href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-06-08T13:50:26.000Z">2025-06-08</time></p><p class="title"><a href="/2025/06/08/Rust/The%20Rust%20Programming%20Language/14.2%20%E5%B0%86%20crate%20%E5%8F%91%E5%B8%83%E5%88%B0%20Crates.io/">14.2 将 crate 发布到 Crates.io</a></p><p class="categories"><a href="/categories/Rust/">Rust</a> / <a href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-06-08T13:30:26.000Z">2025-06-08</time></p><p class="title"><a href="/2025/06/08/Rust/The%20Rust%20Programming%20Language/14.1%20%E9%87%87%E7%94%A8%E5%8F%91%E5%B8%83%E9%85%8D%E7%BD%AE%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9E%84%E5%BB%BA/">14.1 采用发布配置自定义构建</a></p><p class="categories"><a href="/categories/Rust/">Rust</a> / <a href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2025/06/"><span class="level-start"><span class="level-item">六月 2025</span></span><span class="level-end"><span class="level-item tag">15</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/05/"><span class="level-start"><span class="level-item">五月 2025</span></span><span class="level-end"><span class="level-item tag">47</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/04/"><span class="level-start"><span class="level-item">四月 2025</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/03/"><span class="level-start"><span class="level-item">三月 2025</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/02/"><span class="level-start"><span class="level-item">二月 2025</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/12/"><span class="level-start"><span class="level-item">十二月 2024</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Arch-Linux/"><span class="tag">Arch Linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/English/"><span class="tag">English</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Golang/"><span class="tag">Golang</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OS/"><span class="tag">OS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Rust/"><span class="tag">Rust</span><span class="tag">48</span></a></div><div class="control"><a class="tags has-addons" href="/tags/git/"><span class="tag">git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/python/"><span class="tag">python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/test/"><span class="tag">test</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/toy-projects/"><span class="tag">toy projects</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%B8%AD%E6%96%87/"><span class="tag">中文</span><span class="tag">59</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%85%AB%E8%82%A1/"><span class="tag">八股</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BF%BB%E8%AF%91/"><span class="tag">翻译</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="MyBlog" height="28"></a><p class="is-size-7"><span>&copy; 2025 Rossignol</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>