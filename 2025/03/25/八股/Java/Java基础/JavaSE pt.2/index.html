<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>JavaSE pt.2 - MyBlog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="MyBlog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="MyBlog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="1. 面向对象基础1.1 面向对象和面向过程的区别？面向过程（ Procedural-Oriented Programming , POP ） 和面向对象 （ Object-Oriented Programming , OOP ） 是两种常见的编程范式，两者的区别主要是解决问题的不同：  面向过程 ： 将解决问题的过程拆成一个一个函数，通过函数的执行解决问题。 面向对象 ： 先抽象出对象，然后用对"><meta property="og:type" content="blog"><meta property="og:title" content="JavaSE pt.2"><meta property="og:url" content="http://example.com/2025/03/25/%E5%85%AB%E8%82%A1/Java/Java%E5%9F%BA%E7%A1%80/JavaSE%20pt.2/"><meta property="og:site_name" content="MyBlog"><meta property="og:description" content="1. 面向对象基础1.1 面向对象和面向过程的区别？面向过程（ Procedural-Oriented Programming , POP ） 和面向对象 （ Object-Oriented Programming , OOP ） 是两种常见的编程范式，两者的区别主要是解决问题的不同：  面向过程 ： 将解决问题的过程拆成一个一个函数，通过函数的执行解决问题。 面向对象 ： 先抽象出对象，然后用对"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/2025/03/25/%E5%85%AB%E8%82%A1/Java/Java%E5%9F%BA%E7%A1%80/JavaSE%20pt.2/asserts/JavaSE%20pt%202/001.png"><meta property="og:image" content="http://example.com/2025/03/25/%E5%85%AB%E8%82%A1/Java/Java%E5%9F%BA%E7%A1%80/JavaSE%20pt.2/asserts/JavaSE%20pt%202/002.png"><meta property="og:image" content="http://example.com/2025/03/25/%E5%85%AB%E8%82%A1/Java/Java%E5%9F%BA%E7%A1%80/JavaSE%20pt.2/asserts/JavaSE%20pt%202/003.png"><meta property="og:image" content="http://example.com/2025/03/25/%E5%85%AB%E8%82%A1/Java/Java%E5%9F%BA%E7%A1%80/JavaSE%20pt.2/asserts/JavaSE%20pt%202/004.png"><meta property="og:image" content="http://example.com/2025/03/25/%E5%85%AB%E8%82%A1/Java/Java%E5%9F%BA%E7%A1%80/JavaSE%20pt.2/asserts/JavaSE%20pt%202/005.png"><meta property="article:published_time" content="2025-03-25T13:00:29.000Z"><meta property="article:modified_time" content="2025-04-06T14:51:14.670Z"><meta property="article:author" content="Rossignol"><meta property="article:tag" content="Java"><meta property="article:tag" content="中文"><meta property="article:tag" content="八股"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/2025/03/25/%E5%85%AB%E8%82%A1/Java/Java%E5%9F%BA%E7%A1%80/JavaSE%20pt.2/asserts/JavaSE%20pt%202/001.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2025/03/25/%E5%85%AB%E8%82%A1/Java/Java%E5%9F%BA%E7%A1%80/JavaSE%20pt.2/"},"headline":"JavaSE pt.2","image":["http://example.com/2025/03/25/%E5%85%AB%E8%82%A1/Java/Java%E5%9F%BA%E7%A1%80/JavaSE%20pt.2/asserts/JavaSE%20pt%202/001.png","http://example.com/2025/03/25/%E5%85%AB%E8%82%A1/Java/Java%E5%9F%BA%E7%A1%80/JavaSE%20pt.2/asserts/JavaSE%20pt%202/002.png","http://example.com/2025/03/25/%E5%85%AB%E8%82%A1/Java/Java%E5%9F%BA%E7%A1%80/JavaSE%20pt.2/asserts/JavaSE%20pt%202/003.png","http://example.com/2025/03/25/%E5%85%AB%E8%82%A1/Java/Java%E5%9F%BA%E7%A1%80/JavaSE%20pt.2/asserts/JavaSE%20pt%202/004.png","http://example.com/2025/03/25/%E5%85%AB%E8%82%A1/Java/Java%E5%9F%BA%E7%A1%80/JavaSE%20pt.2/asserts/JavaSE%20pt%202/005.png"],"datePublished":"2025-03-25T13:00:29.000Z","dateModified":"2025-04-06T14:51:14.670Z","author":{"@type":"Person","name":"Rossignol"},"publisher":{"@type":"Organization","name":"MyBlog","logo":{"@type":"ImageObject","url":"http://example.com/img/logo.svg"}},"description":"1. 面向对象基础1.1 面向对象和面向过程的区别？面向过程（ Procedural-Oriented Programming , POP ） 和面向对象 （ Object-Oriented Programming , OOP ） 是两种常见的编程范式，两者的区别主要是解决问题的不同：  面向过程 ： 将解决问题的过程拆成一个一个函数，通过函数的执行解决问题。 面向对象 ： 先抽象出对象，然后用对"}</script><link rel="canonical" href="http://example.com/2025/03/25/%E5%85%AB%E8%82%A1/Java/Java%E5%9F%BA%E7%A1%80/JavaSE%20pt.2/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="MyBlog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/0xRossignol"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-03-25T13:00:29.000Z" title="2025/3/25 21:00:29">2025-03-25</time>发表</span><span class="level-item"><time dateTime="2025-04-06T14:51:14.670Z" title="2025/4/6 22:51:14">2025-04-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%85%AB%E8%82%A1/">八股</a><span> / </span><a class="link-muted" href="/categories/%E5%85%AB%E8%82%A1/JavaSE/">JavaSE</a></span><span class="level-item">1 小时读完 (大约7678个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">JavaSE pt.2</h1><div class="content"><h2 id="1-面向对象基础"><a href="#1-面向对象基础" class="headerlink" title="1. 面向对象基础"></a>1. 面向对象基础</h2><h3 id="1-1-面向对象和面向过程的区别？"><a href="#1-1-面向对象和面向过程的区别？" class="headerlink" title="1.1 面向对象和面向过程的区别？"></a>1.1 面向对象和面向过程的区别？</h3><p>面向过程（ Procedural-Oriented Programming , POP ） 和面向对象 （ Object-Oriented Programming , OOP ） 是两种常见的编程范式，两者的区别主要是解决问题的不同：</p>
<ul>
<li><strong>面向过程</strong> ： 将解决问题的过程拆成一个一个函数，通过函数的执行解决问题。</li>
<li><strong>面向对象</strong> ： 先抽象出对象，然后用对象执行方法的方式解决问题。</li>
</ul>
<p>相较于 POP ， OOP 程序一般具有以下优点：</p>
<ul>
<li><strong>易维护</strong> ： 由于良好的结构和封装性， OOP 程序通常更容易维护。</li>
<li><strong>易复用</strong> ： 通过继承和多态， OOP 设计使得代码更具复用性，方便扩展功能。</li>
<li><strong>易扩展</strong> ： 模块化设计使系统扩展变的更加容易和灵活。</li>
</ul>
<p>POP 的编程方式通常更为简单和直接，适合处理一些较简单的任务。</p>
<p>POP 和 OOP 的性能差异主要取决于它们的运行机制，而不仅仅是编程范式本身。因此，简单比较两者性能是一个常见误区。（ <a target="_blank" rel="noopener" href="https://github.com/Snailclimb/JavaGuide/issues/431">相关 issue</a> ）</p>
<h3 id="1-2-创建一个对象用什么运算符？对象实体与对象引用有何不同？"><a href="#1-2-创建一个对象用什么运算符？对象实体与对象引用有何不同？" class="headerlink" title="1.2 创建一个对象用什么运算符？对象实体与对象引用有何不同？"></a>1.2 创建一个对象用什么运算符？对象实体与对象引用有何不同？</h3><p><code>new</code> 运算符， <code>new</code> 对象创建对象实例（对象实例在堆内存中）， 对象引用指向对象实例（对象引用存放在栈内存中）。</p>
<ul>
<li>1 个对象引用可以指向 0 个或 1 个对象</li>
<li>一个对象可以有 n 个引用指向它</li>
</ul>
<h3 id="1-3-对象相等和引用相等的区别？"><a href="#1-3-对象相等和引用相等的区别？" class="headerlink" title="1.3 对象相等和引用相等的区别？"></a>1.3 对象相等和引用相等的区别？</h3><ul>
<li>对象的相等一般比较的是内存中查询放的内容是否相等。</li>
<li>引用相等一般比较的是它们指向的内存地址是否相等。</li>
</ul>
<h3 id="1-4-如果一个类没有声明构造方法，该程序能正确执行吗？"><a href="#1-4-如果一个类没有声明构造方法，该程序能正确执行吗？" class="headerlink" title="1.4 如果一个类没有声明构造方法，该程序能正确执行吗？"></a>1.4 如果一个类没有声明构造方法，该程序能正确执行吗？</h3><p>如果一个对象没有声明构造方法，也可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果自己添加了构造方法， Java 就不会添加默认的构造方法了。</p>
<p>如果重载了有参的构造方法，<strong>记得都要把无参的构造方法也写出来</strong>（无论是否用到），因为这可以帮助我们在创建对象的时候少踩坑。</p>
<h3 id="1-5-构造方法有哪些特点？是否可以被-override-？"><a href="#1-5-构造方法有哪些特点？是否可以被-override-？" class="headerlink" title="1.5 构造方法有哪些特点？是否可以被 override ？"></a>1.5 构造方法有哪些特点？是否可以被 <code>override</code> ？</h3><p>特点：</p>
<ul>
<li><strong>名称与类名相同</strong> ： 构造方法的名称必须与类名完全一致</li>
<li><strong>没有返回值</strong> ： 构造方法没有返回类型且不能用 <code>void</code> 声明</li>
<li><strong>自动执行</strong> ： 在生成类的对象时，构造方法会自动执行，无需显式调用</li>
</ul>
<p>构造方法 <strong>不能被重写 （ override ）</strong> ， 但 <strong>可以被重载 （ overload ）</strong> 。</p>
<h3 id="1-6-面向对象三大特征？"><a href="#1-6-面向对象三大特征？" class="headerlink" title="1.6 面向对象三大特征？"></a>1.6 面向对象三大特征？</h3><h4 id="1-6-1-封装"><a href="#1-6-1-封装" class="headerlink" title="1.6.1 封装"></a>1.6.1 封装</h4><p>封装是指将对象的状态信息 （属性） 隐藏在对象内部， 不允许外部对象直接访问。都是可以提供一些可被外界访问的方法来操作属性。</p>
<h4 id="1-6-2-继承"><a href="#1-6-2-继承" class="headerlink" title="1.6.2 继承"></a>1.6.2 继承</h4><p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p>
<p>注意：</p>
<ol>
<li>子类拥有父类对象的所有属性和方法（包括私有属性和方法），但是父类的私有属性和方法子类无法访问， <strong>只是拥有</strong> 。</li>
<li>子类可以拥有自己的属性和方法。</li>
<li>子类可以用自己的方式实现父类的方法。</li>
</ol>
<h4 id="1-6-3-多态"><a href="#1-6-3-多态" class="headerlink" title="1.6.3 多态"></a>1.6.3 多态</h4><p>多态表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</p>
<p>特点：</p>
<ul>
<li>对象类型和引用类型之间具有继承（类） &#x2F; 实现（接口） 关系</li>
<li>引用类型变量发出的方法调用的到底时哪个类中的方法，必须在程序运行期间才能确定</li>
<li>多态不能调用 “只在子类存在但父类不存在的方法”</li>
<li>如果子类重写了父类的方法，真正执行的是子类重写的方法，如果没有，执行的是父类的方法。</li>
</ul>
<h3 id="1-7-接口和抽象类的共同点和区别？"><a href="#1-7-接口和抽象类的共同点和区别？" class="headerlink" title="1.7 接口和抽象类的共同点和区别？"></a>1.7 接口和抽象类的共同点和区别？</h3><p>共同点：</p>
<ul>
<li><strong>实例化</strong> ： 接口和抽象类都不能直接实例化，只能被实现 （接口） 或继承 （抽象类） 后才能创建具体的对象。</li>
<li><strong>抽象方法</strong> ： 接口和抽象类都可以包含抽象方法，抽象方法没有方法体，必须在子类或实现类中实现。</li>
</ul>
<p>区别：</p>
<ul>
<li><strong>设计目的</strong> ：<br>接口主要用于对类的行为进行约束，实现接口就具有对应的行为。<br>抽象类主要用于代码复用，强调的是所属关系。</li>
<li><strong>继承和实现</strong> ：<br>一个类只能继承一个类 （包括抽象类）<br>一个类可以实现多个接口，一个接口也可以继承多个其他接口。</li>
<li><strong>成员变量</strong> ：<br>接口中的成员变量只能是 <code>public static final</code> 类型的，不能被修改且必须有初始值。<br>抽象类的成员变量可以有任何修饰符 （ <code>private</code> , <code>protected</code> , <code>public</code> ） 可以在子类中被重新定义或赋值。</li>
<li><strong>方法</strong> ：<ul>
<li>Java 8 之前，接口中的方法默认为 <code>public abstract</code> ， 也就是只能由方法声明。 自 Java 8 起，可以在接口中定义 <code>default</code> 方法和 <code>static</code> 方法，自 Java 9 起，接口可以包含 <code>private</code> 方法。</li>
<li>抽象类可以包含抽象方法和非抽象方法。抽象方法没有方法体，必须在子类中实现。非抽象方法有具体实现，可以直接在抽象类中使用或在子类中重写。</li>
</ul>
</li>
</ul>
<p>在 Java 8 及以上版本中，接口引入了新的方法类型： <code>default</code> 方法、 <code>static</code> 方法和 <code>private</code> 方法。这些方法让接口的使用更加灵活。</p>
<p>Java 8 引入的 <code>default</code> 方法用于提供接口方法的默认实现，可以在实现类中被覆盖。这样就可以在不修改实现类的情况下向现有接口添加新功能，从而增强接口的扩展性和向后兼容性。</p>
<p>Java 8 引入的 <code>static</code> 方法无法在实现类中被覆盖，只能通过接口名直接调用，类似于类中的静态方法。static 方法通常用于定义一些通用的、与接口相关的工具方法，一般很少用。</p>
<p>Java 9 允许在接口中使用 <code>private</code> 方法。 <code>private</code> 方法可以用于在接口内部共享代码，不对外暴露。</p>
<h3 id="1-8-深拷贝和浅拷贝的区别？什么是引用拷贝？"><a href="#1-8-深拷贝和浅拷贝的区别？什么是引用拷贝？" class="headerlink" title="1.8 深拷贝和浅拷贝的区别？什么是引用拷贝？"></a>1.8 深拷贝和浅拷贝的区别？什么是引用拷贝？</h3><p>深拷贝与浅拷贝的区别：</p>
<ul>
<li><strong>浅拷贝</strong> ： 浅拷贝会在堆上创建一个新的对象（区别与深拷贝的一点），不过，如果元对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，即拷贝对象和原对象共用同一个内部对象。</li>
<li><strong>深拷贝</strong> ： 深拷贝会完全复制整个对象，包括对象所包含的内部对象。</li>
</ul>
<p>实例：</p>
<h4 id="1-8-1-浅拷贝"><a href="#1-8-1-浅拷贝" class="headerlink" title="1.8.1 浅拷贝"></a>1.8.1 浅拷贝</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 省略构造函数、Getter&amp;Setter方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Address <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Address) <span class="built_in">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">    <span class="comment">// 省略构造函数、Getter&amp;Setter方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) <span class="built_in">super</span>.clone();</span><br><span class="line">            <span class="keyword">return</span> person;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;武汉&quot;</span>));</span><br><span class="line"><span class="type">Person</span> <span class="variable">person1Copy</span> <span class="operator">=</span> person1.clone();</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">System.out.println(person1.getAddress() == person1Copy.getAddress());</span><br></pre></td></tr></table></figure>

<p>从输出结构就可以看出， <code>person1</code> 的克隆对象和 <code>person1</code> 使用的仍然是同一个 <code>Address</code> 对象。</p>
<h4 id="1-8-2-深拷贝"><a href="#1-8-2-深拷贝" class="headerlink" title="1.8.2 深拷贝"></a>1.8.2 深拷贝</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Person <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) <span class="built_in">super</span>.clone();</span><br><span class="line">        person.setAddress(person.getAddress().clone());</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;武汉&quot;</span>));</span><br><span class="line"><span class="type">Person</span> <span class="variable">person1Copy</span> <span class="operator">=</span> person1.clone();</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line">System.out.println(person1.getAddress() == person1Copy.getAddress());</span><br></pre></td></tr></table></figure>

<p>从输出结构可以看出，显然 <code>person1</code> 的克隆对象和 <code>person1</code> 包含的 <code>Address</code> 对象已经是不同的了。</p>
<h4 id="1-8-3-引用拷贝"><a href="#1-8-3-引用拷贝" class="headerlink" title="1.8.3 引用拷贝"></a>1.8.3 引用拷贝</h4><p>引用拷贝就是两个不同的引用指向同一个对象。</p>
<img src="./asserts/JavaSE pt 2/001.png">

<h2 id="2-Object"><a href="#2-Object" class="headerlink" title="2. Object"></a>2. Object</h2><h3 id="2-1-Object-类的常见方法有哪些？"><a href="#2-1-Object-类的常见方法有哪些？" class="headerlink" title="2.1 Object 类的常见方法有哪些？"></a>2.1 Object 类的常见方法有哪些？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于创建并返回当前对象的一份拷贝。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实例被垃圾回收器回收的时候触发的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-和-equals-的区别？"><a href="#2-2-和-equals-的区别？" class="headerlink" title="2.2 == 和 equals() 的区别？"></a>2.2 <code>==</code> 和 <code>equals()</code> 的区别？</h3><p><code>==</code> 对基本类型和引用类型的作用是不同的：</p>
<ul>
<li>对基本数据类型， <code>==</code> 比较的是值</li>
<li>对引用数据类型， <code>==</code> 比较的是对象的内存地址</li>
</ul>
<blockquote>
<p>Java 只有值传递，所以对 <code>==</code> 来说，不管是基本数据类型还是引用数据类型，其本质都是比较值。</p>
</blockquote>
<p><code>equals()</code> 不能用于基本数据类型的判断。 <code>equals()</code> 存在于 <code>Object</code> 类中， 因此所有的类都有 <code>equals()</code> 方法。</p>
<p><code>equals()</code> 方法存在两种使用情况：</p>
<ul>
<li>类没有重写： 等价于通过 <code>==</code> 比较对象。</li>
<li>类重写了： 一般都重写 <code>equals()</code> 方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 <code>true</code> (即认为这两个对象相等)。</li>
</ul>
<p><code>String</code> 中的 <code>equals</code> 方法是被重写过的，因为 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址，而 <code>String</code> 的 <code>equals</code> 方法比较的是对象的值。</p>
<p>当创建 <code>String</code> 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 <code>String</code> 对象。</p>
<p><code>String</code> 类 <code>equals()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object anObject)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">anotherString</span> <span class="operator">=</span> (String)anObject;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="type">char</span> v1[] = value;</span><br><span class="line">            <span class="type">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-hashcode-有什么用？"><a href="#2-3-hashcode-有什么用？" class="headerlink" title="2.3 hashcode() 有什么用？"></a>2.3 <code>hashcode()</code> 有什么用？</h3><p><code>hashcode()</code> 的作用是获取哈希值（ <code>int</code> 整形 ）， 也称为散列码，用于确定该对象在哈希表中的索引位置。</p>
<p><code>hashCode()</code> 定义在 JDK 的 <code>Object</code> 类中，这就意味着 <code>Java</code> 中的任何类都包含有 <code>hashCode()</code> 函数。另外需要注意的是： <code>Object</code> 的 <code>hashCode()</code> 方法是本地方法，也就是用 <code>C</code> 语言或 <code>C++</code> 实现的。</p>
<p>散列表存储的是键值对( key-value )，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p>
<h3 id="2-4-为什么要有-hashcode-？"><a href="#2-4-为什么要有-hashcode-？" class="headerlink" title="2.4 为什么要有 hashcode() ？"></a>2.4 为什么要有 <code>hashcode()</code> ？</h3><blockquote>
<p>当把对象加入 <code>HashSet</code> 时， <code>HashSet</code> 会先计算对象的 <code>hashCode</code> 值来判断对象加入的位置，同时也会与其他已经加入的对象的 <code>hashCode</code> 值作比较，如果没有相符的 <code>hashCode</code> ， <code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashCode</code> 值的对象，这时会调用 <code>equals()</code> 方法来检查 <code>hashCode</code> 相等的对象是否真的相同。如果两者相同， <code>HashSet</code> 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 <code>equals</code> 的次数，相应就大大提高了执行速度。<br>—— Head First Java</p>
</blockquote>
<p><code>hashCode()</code> 和 <code>equals()</code> 都是用于比较两个对象是否相等。</p>
<h4 id="2-4-1-为什么-JDK-还要同时提供这两个方法呢？"><a href="#2-4-1-为什么-JDK-还要同时提供这两个方法呢？" class="headerlink" title="2.4.1 为什么 JDK 还要同时提供这两个方法呢？"></a>2.4.1 为什么 JDK 还要同时提供这两个方法呢？</h4><p>在一些容器（比如 <code>HashMap</code> 、 <code>HashSet</code> ）中，有了 <code>hashCode()</code> 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进 <code>HashSet</code> 的过程）</p>
<p>在前面也提到了添加元素进 <code>HashSet</code> 的过程，如果 <code>HashSet</code> 在对比的时候，同样的 <code>hashCode</code> 有多个对象，它会继续使用 <code>equals()</code> 来判断是否真的相同。也就是说 <code>hashCode</code> 帮助我们大大缩小了查找成本。</p>
<h4 id="2-4-2-为什么不只提供-hashCode-方法呢？"><a href="#2-4-2-为什么不只提供-hashCode-方法呢？" class="headerlink" title="2.4.2 为什么不只提供 hashCode() 方法呢？"></a>2.4.2 为什么不只提供 <code>hashCode()</code> 方法呢？</h4><p>因为两个对象的 hashCode 值相等并不代表两个对象就相等。</p>
<p><code>hashCode()</code> 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（ 所谓哈希碰撞也就是指的是不同的对象得到相同的 <code>hashCode</code> )。</p>
<p>总结：</p>
<ul>
<li>两个对象的 <code>hashcode</code> 值相等， 两个对象不一定相等。</li>
<li>两个对象的 <code>hashcode</code> 值相等且 <code>equals()</code> 方法返回 <code>true</code> ，才认为两个对象相等。</li>
<li>两个对象的 <code>hashcode</code> 不相等， 可以直接认为两个对象不相等。</li>
</ul>
<h3 id="2-5-为什么重写-equals-方法时必须重写-hashcode-方法？"><a href="#2-5-为什么重写-equals-方法时必须重写-hashcode-方法？" class="headerlink" title="2.5 为什么重写 equals() 方法时必须重写 hashcode() 方法？"></a>2.5 为什么重写 <code>equals()</code> 方法时必须重写 <code>hashcode()</code> 方法？</h3><p>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p>
<p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象， <code>hashCode</code> 值却不相等。</p>
<p><strong>思考</strong> ： 重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话，使用 <code>HashMap</code> 可能会出现什么问题。</p>
<p>答案：</p>
<p>基础：</p>
<p>会出现 <code>equals</code> 判断相同的对象由于 <code>hashcode</code> 不同导致 <code>hashmap</code> 中存在多个相同的对象。</p>
<p>Deepseek 优化：</p>
<p>当重写 <code>equals()</code> 而未重写 <code>hashCode()</code> 时，使用 <code>HashMap</code> 可能引发以下问题：</p>
<ul>
<li><p>哈希冲突误判： <code>HashMap</code> 通过 <code>hashCode()</code> 确定键值对的存储桶位置。若两个逻辑相等的对象（ <code>equals()</code> 为 <code>true</code> ）产生不同哈希值，它们会被错误分配到不同存储桶，导致 <code>HashMap</code> 无法识别其等价性。</p>
</li>
<li><p>数据重复存储：本应覆盖的键值对会作为不同键被重复存储，例如 <code>map.put(a,1)</code> 和 <code>map.put(b,1)</code> 会形成两个独立条目（ 尽管 <code>a.equals(b) == true</code> ）。</p>
</li>
<li><p>检索数据失败：通过等价对象查询时（ 如 <code>map.get(b)</code> 查询已存入的 <code>a</code> ），由于哈希定位到错误存储桶，可能返回 <code>null</code> 而非预期值。</p>
</li>
<li><p>破坏契约原则：违反 Java 对象契约（ <code>equal</code> 对象必须有相同 <code>hashCode</code> ），导致所有依赖哈希机制的集合类（ <code>HashSet</code> 、 <code>HashTable</code> 等）行为异常。</p>
</li>
</ul>
<p><strong>总结</strong> ：</p>
<ul>
<li><p><code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p>
</li>
<li><p>两个对象有相同的 <code>hashCode</code> 值，他们也不一定是相等的（哈希碰撞）。</p>
</li>
</ul>
<h2 id="3-String"><a href="#3-String" class="headerlink" title="3. String"></a>3. String</h2><h3 id="3-1-String-StringBuffer-StringBuilder-的区别？"><a href="#3-1-String-StringBuffer-StringBuilder-的区别？" class="headerlink" title="3.1 String , StringBuffer , StringBuilder 的区别？"></a>3.1 String , StringBuffer , StringBuilder 的区别？</h3><p><strong>可变性</strong>：</p>
<p><code>String</code> 是不可变的。</p>
<p><code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，最关键的是 <code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法，比如 <code>append</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, CharSequence &#123;</span><br><span class="line">    <span class="type">char</span>[] value;</span><br><span class="line">    <span class="keyword">public</span> AbstractStringBuilder <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> appendNull();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">        ensureCapacityInternal(count + len);</span><br><span class="line">        str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">        count += len;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>线程安全性</strong> ：</p>
<p><code>String</code> 中的对象是不可变的，也就可以理解为常量，<strong>线程安全</strong>。 <code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code> 、 <code>append</code> 、 <code>insert</code> 、 <code>indexOf</code> 等公共方法。 <code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是<strong>线程安全</strong>的。 <code>StringBuilder</code> 并没有对方法进行加同步锁，所以是<strong>非线程安全</strong>的。</p>
<p><strong>性能</strong> ：</p>
<p>每次对 <code>String</code> 类型进行改变时都会生成一个新的 <code>String</code> 对象，然后将指针指向新的对象。 <code>StringBuffer</code> 每次都会对对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10% ~ 15% 的性能提升，但却要冒多线程不安全的风险。</p>
<p>总结：</p>
<ul>
<li>操作少量数据： 用 <code>String</code></li>
<li>单线程操作字符串缓冲区下操作大量数据： <code>StringBuilder</code></li>
<li>多线程操作字符串缓冲区下操作大量数据： <code>StringBuffer</code></li>
</ul>
<h3 id="3-2-String-为什么不可变？"><a href="#3-2-String-为什么不可变？" class="headerlink" title="3.2 String 为什么不可变？"></a>3.2 String 为什么不可变？</h3><p><code>String</code> 类中使用 <code>fianl</code> 关键字修饰字符数组来保存字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：<strong>被 <code>fianl</code> 修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象</strong>。<br>因此， <code>fianl</code> 修饰的数组保存字符串<strong>并不是 <code>String</code> 不可变的根本原因</strong>， 因为这个数组保存的字符串是可变的（ <code>final</code> 修饰引用类型变量的情况）。</p>
</blockquote>
<p><code>String</code> 真正不可变的原因：</p>
<ol>
<li>保存字符串的数组被 <code>final</code> 修饰且为私有的，并且 <code>String</code> 类没有提供&#x2F;暴露修改这个字符串的方法。</li>
<li><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</li>
</ol>
<blockquote>
<p>补充：<br>在 Java 9 之后， <code>String</code> <code>StringBuilder</code> 与 <code>StringBuffer</code> 的实现被改用 <code>byte</code> 数组存储字符串。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable,Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">// @Stable 注解表示变量最多被修改一次，称为“稳定的”。</span></span><br><span class="line">    <span class="meta">@Stable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, CharSequence &#123;</span><br><span class="line">    <span class="type">byte</span>[] value;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Java-9-为何要将-String-的底层实现由-char-改成了-byte"><a href="#Java-9-为何要将-String-的底层实现由-char-改成了-byte" class="headerlink" title="Java 9 为何要将 String 的底层实现由 char[] 改成了 byte[] ?"></a>Java 9 为何要将 <code>String</code> 的底层实现由 <code>char[]</code> 改成了 <code>byte[]</code> ?</h4><p>新版的 <code>String</code> 支持两个编码方案： <code>Latin-1</code> 和 <code>UTF-16</code> 。如果字符串中包含的汉字没有超过 <code>Latin-1</code> 可表示范围内的字符，那就会使用 <code>Latin-1</code> 。 <code>Latin-1</code> 编码方案下， <code>byte</code> 占一个字节（ 8 位 ）， <code>char</code> 占用 2 个字节（ 16 ）， <code>byte</code> 相较 <code>char</code> 节省一半的内存空间。</p>
<img src="./asserts/JavaSE pt 2/002.png">

<p>如果字符串中包含的汉字超过 Latin-1 可表示范围内的字符，byte 和 char 所占用的空间是一样的。</p>
<p><a target="_blank" rel="noopener" href="https://openjdk.org/jeps/254">官方介绍</a></p>
<h3 id="3-3-字符串拼接用-还是-StringBuilder-？"><a href="#3-3-字符串拼接用-还是-StringBuilder-？" class="headerlink" title="3.3 字符串拼接用 + 还是 StringBuilder ？"></a>3.3 字符串拼接用 <code>+</code> 还是 <code>StringBuilder</code> ？</h3><p>Java 语言本身不支持运算符重载， <strong>“+”和“+&#x3D;”是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的运算符</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;he&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;llo&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> str1 + str2 + str3;</span><br></pre></td></tr></table></figure>

<p>对应字节码：</p>
<img src="./asserts/JavaSE pt 2/003.png">

<p>可以看出，字符串对象通过“+”的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</p>
<p>不过，在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：<strong>编译器不会创建单个 <code>StringBuilder</code> 以复用，会导致创建过多的 <code>StringBuilder</code> 对象</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">&quot;he&quot;</span>, <span class="string">&quot;llo&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    s += arr[i];</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure>

<p><code>StringBuilder</code> 对象是在循环内部被创建的，这意味着每循环一次就会创建一个 <code>StringBuilder</code> 对象。</p>
<img src="./asserts/JavaSE pt 2/004.png">

<p>如果直接使用 <code>StringBuilder</code> 对象进行字符串拼接的话，就不会存在这个问题了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">&quot;he&quot;</span>, <span class="string">&quot;llo&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="keyword">for</span> (String value : arr) &#123;</span><br><span class="line">    s.append(value);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure>

<img src="./asserts/JavaSE pt 2/005.png">

<p>在 JDK 9 中，字符串相加“+”改为用动态方法 <code>makeConcatWithConstants()</code> 来实现，通过提前分配空间从而减少了部分临时对象的创建。然而这种优化主要针对简单的字符串拼接，如： <code>a+b+c</code> 。对于循环中的大量拼接操作，仍然会逐个动态分配内存（类似于两个两个 <code>append</code> 的概念），并不如手动使用 <code>StringBuilder</code> 来进行拼接效率高。</p>
<h3 id="3-4-String-equals-和-Object-equals-有什么区别？"><a href="#3-4-String-equals-和-Object-equals-有什么区别？" class="headerlink" title="3.4 String equals() 和 Object equals() 有什么区别？"></a>3.4 String equals() 和 Object equals() 有什么区别？</h3><p>String 中的 equals 方法是被重写过的，比较的是 String 字符串的值是否相等。 Object 的 equals 方法是比较的对象的内存地址。</p>
<h3 id="3-5-字符串常量池的作用？"><a href="#3-5-字符串常量池的作用？" class="headerlink" title="3.5 字符串常量池的作用？"></a>3.5 字符串常量池的作用？</h3><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（ <code>String</code> 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在字符串常量池中创建字符串对象 ”ab“</span></span><br><span class="line"><span class="comment">// 将字符串对象 ”ab“ 的引用赋值给 aa</span></span><br><span class="line"><span class="type">String</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象 ”ab“，赋值给引用 bb</span></span><br><span class="line"><span class="type">String</span> <span class="variable">bb</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">System.out.println(aa==bb); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="3-6-String-s1-new-String-“abc”-这句话创建了几个字符串对象？"><a href="#3-6-String-s1-new-String-“abc”-这句话创建了几个字符串对象？" class="headerlink" title="3.6 String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象？"></a>3.6 String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象？</h3><p>答案：<strong>会创建 1 或 2 个字符串对象</strong>。</p>
<ol>
<li>字符串常量池中不存在 “abc”：会创建 2 个 字符串对象。一个在字符串常量池中，由 ldc 指令触发创建。一个在堆中，由 new String() 创建，并使用常量池中的 “abc” 进行初始化。</li>
<li>字符串常量池中已存在 “abc”：会创建 1 个 字符串对象。该对象在堆中，由 new String() 创建，并使用常量池中的 “abc” 进行初始化。</li>
</ol>
<p>分析：</p>
<ol>
<li>如果字符串常量池中不存在字符串对象 “abc”，那么它首先会在字符串常量池中创建字符串对象 “abc”，然后在堆内存中再创建其中一个字符串对象 “abc”。</li>
</ol>
<p>字节码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在堆内存中分配一个尚未初始化的 String 对象。</span></span><br><span class="line"><span class="comment">// #2 是常量池中的一个符号引用，指向 java/lang/String 类。</span></span><br><span class="line"><span class="comment">// 在类加载的解析阶段，这个符号引用会被解析成直接引用，即指向实际的 java/lang/String 类。</span></span><br><span class="line"><span class="number">0</span> <span class="keyword">new</span> #<span class="number">2</span> &lt;java/lang/String&gt;</span><br><span class="line"><span class="comment">// 复制栈顶的 String 对象引用，为后续的构造函数调用做准备。</span></span><br><span class="line"><span class="comment">// 此时操作数栈中有两个相同的对象引用：一个用于传递给构造函数，另一个用于保持对新对象的引用，后续将其存储到局部变量表。</span></span><br><span class="line"><span class="number">3</span> dup</span><br><span class="line"><span class="comment">// JVM 先检查字符串常量池中是否存在 &quot;abc&quot;。</span></span><br><span class="line"><span class="comment">// 如果常量池中已存在 &quot;abc&quot;，则直接返回该字符串的引用；</span></span><br><span class="line"><span class="comment">// 如果常量池中不存在 &quot;abc&quot;，则 JVM 会在常量池中创建该字符串字面量并返回它的引用。</span></span><br><span class="line"><span class="comment">// 这个引用被压入操作数栈，用作构造函数的参数。</span></span><br><span class="line"><span class="number">4</span> ldc #<span class="number">3</span> &lt;abc&gt;</span><br><span class="line"><span class="comment">// 调用构造方法，使用从常量池中加载的 &quot;abc&quot; 初始化堆中的 String 对象</span></span><br><span class="line"><span class="comment">// 新的 String 对象将包含与常量池中的 &quot;abc&quot; 相同的内容，但它是一个独立的对象，存储于堆中。</span></span><br><span class="line"><span class="number">6</span> invokespecial #<span class="number">4</span> &lt;java/lang/String.&lt;init&gt; : (Ljava/lang/String;)V&gt;</span><br><span class="line"><span class="comment">// 将堆中的 String 对象引用存储到局部变量表</span></span><br><span class="line"><span class="number">9</span> astore_1</span><br><span class="line"><span class="comment">// 返回，结束方法</span></span><br><span class="line"><span class="number">10</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<h3 id="3-7-String-intern-方法有什么用？"><a href="#3-7-String-intern-方法有什么用？" class="headerlink" title="3.7 String intern 方法有什么用？"></a>3.7 String intern 方法有什么用？</h3><p><code>String.intern()</code> 是一个 <code>native</code> 方法，用于处理字符串常量池中的对象引用。工作流程：</p>
<ol>
<li><strong>常量池中已有相同内容的字符串对象</strong> ： 如果字符串常量池中已经有一个与调用 <code>intern()</code> 方法的字符串内容相同的对象， <code>intern()</code> 返回常量池中该对象的引用。</li>
<li><strong>常量池中没有相同内容的字符串对象</strong> ： <code>intern()</code> 方法会将当前字符串对象的引用添加到字符串常量池中，并返回该引用。</li>
</ol>
<p>总结：</p>
<ul>
<li><code>intern()</code> 方法的主要作用是确保字符串引用在常量池中的唯一性。</li>
<li>当调用 <code>intern()</code> 时，如果常量池中已经存在相同内容的字符串，则返回常量池中已有对象的引用；否则，将该字符串添加到常量池并返回其引用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s1 指向字符串常量池中的 &quot;Java&quot; 对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Java&quot;</span>;</span><br><span class="line"><span class="comment">// s2 也指向字符串常量池中的 &quot;Java&quot; 对象，和 s1 是同一个对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.intern();</span><br><span class="line"><span class="comment">// 在堆中创建一个新的 &quot;Java&quot; 对象，s3 指向它</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line"><span class="comment">// s4 指向字符串常量池中的 &quot;Java&quot; 对象，和 s1 是同一个对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s3.intern();</span><br><span class="line"><span class="comment">// s1 和 s2 指向的是同一个常量池中的对象</span></span><br><span class="line">System.out.println(s1 == s2); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// s3 指向堆中的对象，s4 指向常量池中的对象，所以不同</span></span><br><span class="line">System.out.println(s3 == s4); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// s1 和 s4 都指向常量池中的同一个对象</span></span><br><span class="line">System.out.println(s1 == s4); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="3-8-String-类型的变量和常量做-“-”-运算时发生了什么？"><a href="#3-8-String-类型的变量和常量做-“-”-运算时发生了什么？" class="headerlink" title="3.8 String 类型的变量和常量做 “+” 运算时发生了什么？"></a>3.8 String 类型的变量和常量做 “+” 运算时发生了什么？</h3><p><strong>不加 <code>final</code> 关键词</strong> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> str1 + str2;</span><br><span class="line"><span class="type">String</span> <span class="variable">str5</span> <span class="operator">=</span> <span class="string">&quot;string&quot;</span>;</span><br><span class="line">System.out.println(str3 == str4);<span class="comment">//false</span></span><br><span class="line">System.out.println(str3 == str5);<span class="comment">//true</span></span><br><span class="line">System.out.println(str4 == str5);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong> ：比较 String 字符串的值是否相等，可以使用 <code>equals()</code> 方法。 String 中的 <code>equals</code> 方法是被重写过的。 Object 的 equals 方法是比较的对象的<strong>内存地址</strong>，而 String 的 equals 方法比较的是<strong>字符串的值是否相等</strong>。如果你使用 &#x3D;&#x3D; 比较两个字符串是否相等的话，IDEA 还是提示你使用 equals() 方法替换。</p>
</blockquote>
<p><strong>对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。</strong></p>
<p>在编译过程中，Javac 编译器（下文中统称为编译器）会进行一个叫做 常量折叠(Constant Folding) 的代码优化。</p>
<p>常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。</p>
<p>对于 <code>String str3 = &quot;str&quot; + &quot;ing&quot;;</code> 编译器会优化成 <code>String str3 = &quot;string&quot;;</code> 。</p>
<p>并不是所有的常量都会进行折叠，只有编译器在程序编译期就可以确定值的常量才可以：</p>
<ul>
<li>基本数据类型( byte、boolean、short、char、int、float、long、double)以及字符串常量。</li>
<li>final 修饰的基本数据类型和字符串变量</li>
<li>字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（&lt;&lt;、&gt;&gt;、&gt;&gt;&gt; ）</li>
</ul>
<p><strong>引用的值在程序编译期是无法确定的，编译器无法对其进行优化。</strong></p>
<p>对象引用和“+”的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>().append(str1).append(str2).toString();</span><br></pre></td></tr></table></figure>

<p>在平时写代码的时候，尽量避免多个字符串对象拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 <code>StringBuilder</code> 或者 <code>StringBuffer</code> 。</p>
<p>不过，<strong>字符串使用 final 关键字声明之后</strong>，可以让编译器当做常量来处理 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"><span class="comment">// 下面两个表达式其实是等价的</span></span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;<span class="comment">// 常量池中的对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> str1 + str2; <span class="comment">// 常量池中的对象</span></span><br><span class="line">System.out.println(c == d);<span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>被 <code>final</code> 关键字修饰之后的 <code>String</code> 会被编译器当做常量来处理，编译器在程序编译期就可以确定它的值，其效果就相当于访问常量。</p>
<h2 id="NEXT"><a href="#NEXT" class="headerlink" title="NEXT"></a>NEXT</h2><p><a href="JavaSE%20pt.3.md">JavaSE pt.3</a></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>JavaSE pt.2</p><p><a href="http://example.com/2025/03/25/八股/Java/Java基础/JavaSE pt.2/">http://example.com/2025/03/25/八股/Java/Java基础/JavaSE pt.2/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Rossignol</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2025-03-25</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2025-04-06</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Java/">Java</a><a class="link-muted mr-2" rel="tag" href="/tags/%E4%B8%AD%E6%96%87/">中文</a><a class="link-muted mr-2" rel="tag" href="/tags/%E5%85%AB%E8%82%A1/">八股</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2025/04/06/%E5%85%AB%E8%82%A1/Java/Java%E5%9F%BA%E7%A1%80/JavaSE%20pt.3/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">JavaSE pt.3</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2025/03/10/%E5%85%AB%E8%82%A1/Java/Java%E5%9F%BA%E7%A1%80/JavaSE%20pt.1/"><span class="level-item">JavaSE pt.1</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.jpg" alt="Rossignol"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Rossignol</p><p class="is-size-6 is-block">NaN</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Mars</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives/"><p class="title">50</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories/"><p class="title">15</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags/"><p class="title">13</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/0xRossignol" target="_blank" rel="me noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/0xRossignol"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Golang/"><span class="level-start"><span class="level-item">Golang</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/Golang/basics/"><span class="level-start"><span class="level-item">basics</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/Java/basics/"><span class="level-start"><span class="level-item">basics</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/Java/basics/Thinking-in-Java/"><span class="level-start"><span class="level-item">Thinking in Java</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/Linux/Arch-Linux/"><span class="level-start"><span class="level-item">Arch Linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/OS/"><span class="level-start"><span class="level-item">OS</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Rust/"><span class="level-start"><span class="level-item">Rust</span></span><span class="level-end"><span class="level-item tag">11</span></span></a><ul><li><a class="level is-mobile" href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">Rust程序设计语言</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/test/"><span class="level-start"><span class="level-item">test</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/toy-projects/"><span class="level-start"><span class="level-item">toy projects</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%85%AB%E8%82%A1/"><span class="level-start"><span class="level-item">八股</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%85%AB%E8%82%A1/JavaSE/"><span class="level-start"><span class="level-item">JavaSE</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%85%AB%E8%82%A1/Java%E9%9B%86%E5%90%88/"><span class="level-start"><span class="level-item">Java集合</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-05-21T09:55:26.000Z">2025-05-21</time></p><p class="title"><a href="/2025/05/21/Rust/The%20Rust%20Programming%20Language/05.1%20%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%8C%96/">5.1 结构体的定义和实例化</a></p><p class="categories"><a href="/categories/Rust/">Rust</a> / <a href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-05-21T09:20:35.952Z">2025-05-21</time></p><p class="title"><a href="/2025/05/21/Rust/The%20Rust%20Programming%20Language/15.2%20%E9%80%9A%E8%BF%87%20Deref%20trait%20%E5%B0%86%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%BD%93%E4%BD%9C%E5%B8%B8%E8%A7%84%E5%BC%95%E7%94%A8%E5%A4%84%E7%90%86/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-05-21T09:14:12.218Z">2025-05-21</time></p><p class="title"><a href="/2025/05/21/Rust/The%20Rust%20Programming%20Language/13.2%20%E4%BD%BF%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%84%E7%90%86%E5%85%83%E7%B4%A0%E5%BA%8F%E5%88%97/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-05-21T08:55:26.000Z">2025-05-21</time></p><p class="title"><a href="/2025/05/21/Rust/The%20Rust%20Programming%20Language/04.3%20Slice%20%E7%B1%BB%E5%9E%8B/">4.3 Slice 类型</a></p><p class="categories"><a href="/categories/Rust/">Rust</a> / <a href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-05-20T08:55:26.000Z">2025-05-20</time></p><p class="title"><a href="/2025/05/20/Rust/The%20Rust%20Programming%20Language/04.2%20%E5%BC%95%E7%94%A8%E4%B8%8E%E5%80%9F%E7%94%A8/">4.2 引用与借用</a></p><p class="categories"><a href="/categories/Rust/">Rust</a> / <a href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2025/05/"><span class="level-start"><span class="level-item">五月 2025</span></span><span class="level-end"><span class="level-item tag">30</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/04/"><span class="level-start"><span class="level-item">四月 2025</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/03/"><span class="level-start"><span class="level-item">三月 2025</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/02/"><span class="level-start"><span class="level-item">二月 2025</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/12/"><span class="level-start"><span class="level-item">十二月 2024</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Arch-Linux/"><span class="tag">Arch Linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/English/"><span class="tag">English</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Golang/"><span class="tag">Golang</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OS/"><span class="tag">OS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Rust/"><span class="tag">Rust</span><span class="tag">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/git/"><span class="tag">git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/python/"><span class="tag">python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/test/"><span class="tag">test</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/toy-projects/"><span class="tag">toy projects</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%B8%AD%E6%96%87/"><span class="tag">中文</span><span class="tag">22</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%85%AB%E8%82%A1/"><span class="tag">八股</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BF%BB%E8%AF%91/"><span class="tag">翻译</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="MyBlog" height="28"></a><p class="is-size-7"><span>&copy; 2025 Rossignol</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>