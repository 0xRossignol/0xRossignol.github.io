<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>JavaSE pt.1 - MyBlog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="MyBlog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="MyBlog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="First tip：根据 JavaGuide 和 Deepseek 内容整理 1. 基础概念与常识1.1 Java 语言有哪些特点？ 简单易学（语法简单，容易上手） 面向对象（封装、继承、多态） 平台无关（Java 虚拟机） 支持多线程 可靠性（异常处理、GC） 安全性（访问权限修饰符、限制程序直接访问系统资源） 高效性（通过 JIT[^JIT] 编译器等技术优化） 支持网络编程 编译与解释并存"><meta property="og:type" content="blog"><meta property="og:title" content="JavaSE pt.1"><meta property="og:url" content="http://example.com/2025/03/10/%E5%85%AB%E8%82%A1/Java/Java%E5%9F%BA%E7%A1%80/JavaSE%20pt.1/"><meta property="og:site_name" content="MyBlog"><meta property="og:description" content="First tip：根据 JavaGuide 和 Deepseek 内容整理 1. 基础概念与常识1.1 Java 语言有哪些特点？ 简单易学（语法简单，容易上手） 面向对象（封装、继承、多态） 平台无关（Java 虚拟机） 支持多线程 可靠性（异常处理、GC） 安全性（访问权限修饰符、限制程序直接访问系统资源） 高效性（通过 JIT[^JIT] 编译器等技术优化） 支持网络编程 编译与解释并存"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/2025/03/10/%E5%85%AB%E8%82%A1/Java/Java%E5%9F%BA%E7%A1%80/JavaSE%20pt.1/asserts/JavaSE%20pt%201/001.png"><meta property="og:image" content="http://example.com/2025/03/10/%E5%85%AB%E8%82%A1/Java/Java%E5%9F%BA%E7%A1%80/JavaSE%20pt.1/asserts/JavaSE%20pt%201/002.png"><meta property="og:image" content="http://example.com/2025/03/10/%E5%85%AB%E8%82%A1/Java/Java%E5%9F%BA%E7%A1%80/JavaSE%20pt.1/asserts/JavaSE%20pt%201/003.png"><meta property="og:image" content="http://example.com/2025/03/10/%E5%85%AB%E8%82%A1/Java/Java%E5%9F%BA%E7%A1%80/JavaSE%20pt.1/asserts/JavaSE%20pt%201/004.png"><meta property="og:image" content="http://example.com/2025/03/10/%E5%85%AB%E8%82%A1/Java/Java%E5%9F%BA%E7%A1%80/JavaSE%20pt.1/asserts/JavaSE%20pt%201/005.png"><meta property="article:published_time" content="2025-03-10T14:42:26.000Z"><meta property="article:modified_time" content="2025-04-06T14:51:24.561Z"><meta property="article:author" content="Rossignol"><meta property="article:tag" content="Java"><meta property="article:tag" content="中文"><meta property="article:tag" content="八股"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/2025/03/10/%E5%85%AB%E8%82%A1/Java/Java%E5%9F%BA%E7%A1%80/JavaSE%20pt.1/asserts/JavaSE%20pt%201/001.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2025/03/10/%E5%85%AB%E8%82%A1/Java/Java%E5%9F%BA%E7%A1%80/JavaSE%20pt.1/"},"headline":"JavaSE pt.1","image":["http://example.com/2025/03/10/%E5%85%AB%E8%82%A1/Java/Java%E5%9F%BA%E7%A1%80/JavaSE%20pt.1/asserts/JavaSE%20pt%201/001.png","http://example.com/2025/03/10/%E5%85%AB%E8%82%A1/Java/Java%E5%9F%BA%E7%A1%80/JavaSE%20pt.1/asserts/JavaSE%20pt%201/002.png","http://example.com/2025/03/10/%E5%85%AB%E8%82%A1/Java/Java%E5%9F%BA%E7%A1%80/JavaSE%20pt.1/asserts/JavaSE%20pt%201/003.png","http://example.com/2025/03/10/%E5%85%AB%E8%82%A1/Java/Java%E5%9F%BA%E7%A1%80/JavaSE%20pt.1/asserts/JavaSE%20pt%201/004.png","http://example.com/2025/03/10/%E5%85%AB%E8%82%A1/Java/Java%E5%9F%BA%E7%A1%80/JavaSE%20pt.1/asserts/JavaSE%20pt%201/005.png"],"datePublished":"2025-03-10T14:42:26.000Z","dateModified":"2025-04-06T14:51:24.561Z","author":{"@type":"Person","name":"Rossignol"},"publisher":{"@type":"Organization","name":"MyBlog","logo":{"@type":"ImageObject","url":"http://example.com/img/logo.svg"}},"description":"First tip：根据 JavaGuide 和 Deepseek 内容整理 1. 基础概念与常识1.1 Java 语言有哪些特点？ 简单易学（语法简单，容易上手） 面向对象（封装、继承、多态） 平台无关（Java 虚拟机） 支持多线程 可靠性（异常处理、GC） 安全性（访问权限修饰符、限制程序直接访问系统资源） 高效性（通过 JIT[^JIT] 编译器等技术优化） 支持网络编程 编译与解释并存"}</script><link rel="canonical" href="http://example.com/2025/03/10/%E5%85%AB%E8%82%A1/Java/Java%E5%9F%BA%E7%A1%80/JavaSE%20pt.1/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="MyBlog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/0xRossignol"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-03-10T14:42:26.000Z" title="2025/3/10 22:42:26">2025-03-10</time>发表</span><span class="level-item"><time dateTime="2025-04-06T14:51:24.561Z" title="2025/4/6 22:51:24">2025-04-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%85%AB%E8%82%A1/">八股</a><span> / </span><a class="link-muted" href="/categories/%E5%85%AB%E8%82%A1/JavaSE/">JavaSE</a></span><span class="level-item">1 小时读完 (大约9587个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">JavaSE pt.1</h1><div class="content"><p>First tip：<br>根据 <strong>JavaGuide</strong> 和 <strong>Deepseek</strong> 内容整理</p>
<h2 id="1-基础概念与常识"><a href="#1-基础概念与常识" class="headerlink" title="1. 基础概念与常识"></a>1. 基础概念与常识</h2><h3 id="1-1-Java-语言有哪些特点？"><a href="#1-1-Java-语言有哪些特点？" class="headerlink" title="1.1 Java 语言有哪些特点？"></a>1.1 Java 语言有哪些特点？</h3><ol>
<li>简单易学（语法简单，容易上手）</li>
<li>面向对象（封装、继承、多态）</li>
<li>平台无关（Java 虚拟机）</li>
<li>支持多线程</li>
<li>可靠性（异常处理、GC）</li>
<li>安全性（访问权限修饰符、限制程序直接访问系统资源）</li>
<li>高效性（通过 <strong>JIT</strong>[^JIT] 编译器等技术优化）</li>
<li>支持网络编程</li>
<li>编译与解释并存</li>
</ol>
<p>[^JIT]: <strong>JIT</strong> 即 “Just in Time”</p>
<blockquote>
<p>拓展：<br>“Write once, Run everywhere” ，即跨平台这一特点已经不再是 Java 的主要特点了（ <strong>Docker</strong> 等技术的出现使跨平台相当轻松）。Java 的优势转变为了其强大的生态。</p>
</blockquote>
<h3 id="1-2-JavaSE-和-JavaEE"><a href="#1-2-JavaSE-和-JavaEE" class="headerlink" title="1.2 JavaSE 和 JavaEE"></a>1.2 JavaSE 和 JavaEE</h3><ul>
<li><p>JavaSE ( <em>Java Platform, Standard Edition</em> )： Java 编程语言的基础，包含了支持 Java 程序开发和运行的核心类库以及 JVM 等核心组件。可以用于构建桌面应用程序或简单的服务器应用程序。</p>
</li>
<li><p>JavaEE ( <em>Java Platform, Enterprise Edition</em> )：建立在 JavaSE 的基础上，包含了支持企业级应用开发和部署的标准与规范（ Servlet、 JSP、 EJB、 JDBC、 JPA、 JTA 等）。可以用于构建分布式、可移植、健壮、可伸缩和安全的服务端 Java 应用程序。</p>
</li>
</ul>
<p>简单来说，Java SE 是 Java 的基础版本，Java EE 是 Java 的高级版本。Java SE 更适合开发桌面应用程序或简单的服务器应用程序，Java EE 更适合开发复杂的企业级应用程序或 Web 应用程序。</p>
<h3 id="1-3-JVM、JDK、JRE"><a href="#1-3-JVM、JDK、JRE" class="headerlink" title="1.3 JVM、JDK、JRE"></a>1.3 JVM、JDK、JRE</h3><h4 id="1-3-1-JVM"><a href="#1-3-1-JVM" class="headerlink" title="1.3.1 JVM"></a>1.3.1 JVM</h4><p>JVM ( <em>Java Virtual Machine</em> ) 是运行 <strong>Java 字节码</strong> 的虚拟机。JVM 有针对不同系统的实现，目的是使用相同的字节码得到相同的结果。字节码和 JVM 是实现 Java 语言 “Write once, Run everywhere” 的关键。</p>
<p><strong>JVM 不止一种，只要满足 JVM 规范，每个公司、组织或者个人都可以开发自己的专属 JVM。</strong> 我们平时接触到的 <em>HotSpotVM</em> 只是 JVM 规范的一种实现。</p>
<p>除了 HotSpotVM 外，还有 <em>J9 VM, Zing VM, JRockit VM</em> 等实现。</p>
<h4 id="1-3-2-JDK-和-JRE"><a href="#1-3-2-JDK-和-JRE" class="headerlink" title="1.3.2 JDK 和 JRE"></a>1.3.2 JDK 和 JRE</h4><p>JDK( <em>Java Development Kit</em> )是 Java 开发工具包，用于创建和编译 Java 程序。它包含了 JRE ( <em>Java Runtime Environment</em> ) 以及编译器 Javac 和其他工具 ( <em>javadoc, jdb（调试器）, jconsole（监控工具）, javap(反编译工具)</em> )。</p>
<p>JRE 是运行已编译的 Java 程序所需的环境，包括：</p>
<ul>
<li>JVM</li>
<li>Java 基础类库 ( <em>Class Library</em> )：一组标准类库，提供常用的功能和 API（如 <em>I&#x2F;O 操作、 网络通信、 数据结构</em> 等）</li>
</ul>
<p>简单来说，JRE 只包含运行 Java 程序所需的环境和类库，而 JDK 不仅包含 JRE ，还包括用于开发和调试的工具。</p>
<p>不过，从 JDK 9 开始，就不需要区分 JDK 和 JRE 的关系了，取而代之的是模块系统（ JDK 被重新组织成 94 个模块）+ <a target="_blank" rel="noopener" href="https://openjdk.org/jeps/282">jlink</a> 工具 (随 Java 9 一起发布的新命令行工具，用于生成自定义 Java 运行时映像，该映像仅包含给定应用程序所需的模块) 。并且，从 JDK 11 开始，Oracle 不再提供单独的 JRE 下载。</p>
<p>可以用 jlink 根据自己的需求，创建一个更小的 runtime ，而不是都使用同样的 JRE 。</p>
<p>定制的、模块化的 Java 运行时映像有助于简化 Java 应用的部署和节省内存、增强安全性和可维护性。</p>
<h3 id="1-4-什么是字节码？采用字节码的好处是什么？"><a href="#1-4-什么是字节码？采用字节码的好处是什么？" class="headerlink" title="1.4 什么是字节码？采用字节码的好处是什么？"></a>1.4 什么是字节码？采用字节码的好处是什么？</h3><p>在 Java 中，能被 JVM 理解的代码（即扩展名为 <code>.class</code> 的文件）就是字节码，它不面向任何特定的处理器，只面向虚拟机。字节码在一定程度上解决了传统解释型语言执行效率低的问题，保留了解释型语言可移植的特点。因此 Java 程序无需重新编译便可在多种不同操作系统上运行。</p>
<img src="./asserts/JavaSE pt 1/001.png">

<p><code>.class -&gt; 机器码</code> 这一步 JVM 类加载器 首先加载字节码文件，然后通过解释器逐行解释执行，这种方式执行速度相对较慢。而且，有些方法和代码块经常需要被调用（即热点代码），所以后来引进了 <strong>JIT</strong> ( <em>Just In Time Compilation</em> )编译器， 而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。这也解释了为什么经常说 <strong>Java 是编译与解释共存的语言</strong>。</p>
<img src="./asserts/JavaSE pt 1/002.png">

<blockquote>
<p>HotSpot 采用了<strong>惰性评估 ( Lazy Evaluation )</strong> 的做法，根据二八定律，消耗大部分系统资源的只有一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。</p>
</blockquote>
<img src="./asserts/JavaSE pt 1/003.png">

<img src="./asserts/JavaSE pt 1/004.png">

<h3 id="1-5-为什么说-Java-语言-“编译与解释并存”-？"><a href="#1-5-为什么说-Java-语言-“编译与解释并存”-？" class="headerlink" title="1.5 为什么说 Java 语言 “编译与解释并存” ？"></a>1.5 为什么说 Java 语言 “编译与解释并存” ？</h3><p>该问题在 <a href="#14-%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E8%8A%82%E7%A0%81%E9%87%87%E7%94%A8%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88">上一问</a> 已经提到过。</p>
<h4 id="1-5-1-分类"><a href="#1-5-1-分类" class="headerlink" title="1.5.1 分类"></a>1.5.1 分类</h4><p>我们可以将高级语言按照程序的执行方式分为两类：</p>
<ul>
<li><p><strong>编译型</strong>： <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%B7%A8%E8%AD%AF%E8%AA%9E%E8%A8%80">编译型语言</a> 会通过 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%B7%A8%E8%AD%AF%E5%99%A8">编译器</a> 将源代码一次性翻译成机器码。一般编译型语言执行速度较快，开发效率较低。</p>
</li>
<li><p><strong>解释型</strong>： <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%9B%B4%E8%AD%AF%E8%AA%9E%E8%A8%80">解释型语言</a> 会通过 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%9B%B4%E8%AD%AF%E5%99%A8">解释器</a> 一句一句的将代码解释（interpret）为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。</p>
</li>
</ul>
<blockquote>
<p>为了改善解释语言的效率而发展出的即时编译技术，已经缩小了这两种语言间的差距。这种技术混合了编译语言与解释型语言的优点，它像编译语言一样，先把程序源代码编译成字节码。到执行期时，再将字节码直译，之后执行。Java 与 LLVM 是这种技术的代表产物。</p>
</blockquote>
<h4 id="1-5-2-为什么说-Java-语言-“编译与解释并存”-？"><a href="#1-5-2-为什么说-Java-语言-“编译与解释并存”-？" class="headerlink" title="1.5.2 为什么说 Java 语言 “编译与解释并存” ？"></a>1.5.2 为什么说 Java 语言 “编译与解释并存” ？</h4><p>这是因为 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（.class 文件），这种字节码必须由 Java 解释器来解释执行。</p>
<h3 id="1-6-AOT-有什么优点？为什么不全部使用-AOT-？"><a href="#1-6-AOT-有什么优点？为什么不全部使用-AOT-？" class="headerlink" title="1.6 AOT 有什么优点？为什么不全部使用 AOT ？"></a>1.6 AOT 有什么优点？为什么不全部使用 AOT ？</h3><p>JDK9 引入了新的编译模式 <strong>AOT</strong> ( <em>Ahead Of Time Compilation</em> ) 。 和 JIT 不同的是，这种编译模式会在程序被执行前就将其编译成机器码，属于静态编译（ C、C++、Rust、Go 等语言就是静态编译）。AOT 避免了 JIT 预热等各方面的开销，可以提高 Java 程序的启动速度，避免预热时间过长。并且， AOT 还能减少内存占用和增强 Java 程序的安全性 （ AOT 编译后的代码不容易被反编译和修改）， 特别适合云原生场景。</p>
<img src="./asserts/JavaSE pt 1/005.png">

<p>可以看出， AOT 的主要优势在于启动时间、内存占用和打包体积。 JIT 的主要优势在于具备更高的极限处理能力，可以降低请求的最大延迟。</p>
<h4 id="1-6-1-既然-AOT-有那么多优点，为什么不全部使用-AOT-？"><a href="#1-6-1-既然-AOT-有那么多优点，为什么不全部使用-AOT-？" class="headerlink" title="1.6.1 既然 AOT 有那么多优点，为什么不全部使用 AOT ？"></a>1.6.1 既然 AOT 有那么多优点，为什么不全部使用 AOT ？</h4><p>JIT 和 AOT 各有优点， AOT 更适合云原生场景，对微服务架构的支持也比较友好。除此之外， AOT 编译无法支持 Java 的一些动态特性，如反射、动态代理、动态加载、 JNI ( <em>Java Native Interface</em> ) 等。然而，很多框架和库（如 <em>Spring</em> 、 <em>CGLIB</em> ）都用到了这些特性。如果只使用 AOT 编译，那就无法使用这些库和框架了，或者说需要针对性地去做适配和优化。</p>
<h3 id="1-7-Oracle-JDK-和-OpenJDK"><a href="#1-7-Oracle-JDK-和-OpenJDK" class="headerlink" title="1.7 Oracle JDK 和 OpenJDK"></a>1.7 Oracle JDK 和 OpenJDK</h3><p>Oracle 官方在 2012 年的博客：</p>
<blockquote>
<p>问：OpenJDK 存储库中的源代码与用于构建 Oracle JDK 的代码之间有什么区别？<br>答：非常接近 - 我们的 Oracle JDK 版本构建过程基于 OpenJDK 7 构建，只添加了几个部分，例如部署代码，其中包括 Oracle 的 Java 插件和 Java WebStart 的实现，以及一些闭源的第三方组件，如图形光栅化器，一些开源的第三方组件，如 Rhino，以及一些零碎的东西，如附加文档或第三方字体。展望未来，我们的目的是开源 Oracle JDK 的所有部分，除了我们考虑商业功能的部分。</p>
</blockquote>
<p>OracleJDK 和 OpenJDK 的区别：</p>
<ol>
<li><p>是否开源： OpenJDK 是一个完全开源的参考模型，而 Oracle JDK 是基于 OpenJDK 实现的，并非完全开源。OpenJDK 开源项目：<a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk">Github</a> 。</p>
</li>
<li><p>是否免费： OracleJDK 提供免费版本，但一般有时间限制。 JDK17 之后的版本可以免费分发和商用，但仅有 3 年时间， 3 年后无法免费商用。不过，JDK8u221 之前只要不升级可以无限期免费。 OpenJDK 是完全免费的。</p>
</li>
<li><p>功能性： OracleJDK 在 OpenJDK 的基础上添加了一些特有的功能和工具，比如 <em>Java Flight Recorder ( JFR ， 一种监控工具 )</em> 、 <em>Java Mission Control ( JMC ，一种监控工具 )</em> 等工具。不过，在 Java 11 之后， OracleJDK 和 OpenJDK 的功能基本一致，之前 OracleJDK 中的私有组件大部分也已经被捐赠给开源组织。</p>
</li>
<li><p>稳定性： OpenJDK 不提供 LTS 服务， 而 OracleJDK 大概每三年都会推出一个 LTS 版本进行长期支持。不过，很多公司都基于 OpenJDK 提供了对应的和 OracleJDK 周期相同的 LTS 版本。因此，两者的稳定性其实差不多。</p>
</li>
<li><p>协议： OracleJDK 使用 BCL&#x2F;OTN 协议， 而 OpenJDK 根据 GPLv2 许可获得许可。</p>
</li>
</ol>
<blockquote>
<p>既然 Oracle JDK 这么好，那为什么还要有 OpenJDK？</p>
<ol>
<li>OpenJDK 是开源的，开源意味着你可以对它根据你自己的需要进行修改、优化，比如 Alibaba 基于 OpenJDK 开发了 <a target="_blank" rel="noopener" href="https://github.com/alibaba/dragonwell8">Dragonwell8</a>。</li>
<li>OpenJDK 是商业免费的（这也是为什么通过 yum 包管理器上默认安装的 JDK 是 OpenJDK 而不是 Oracle JDK）。虽然 Oracle JDK 也是商业免费（比如 JDK 8），但并不是所有版本都是免费的。</li>
<li>OpenJDK 更新频率更快。Oracle JDK 一般是每 6 个月发布一个新版本，而 OpenJDK 一般是每 3 个月发布一个新版本。（现在你知道为啥 Oracle JDK 更稳定了吧，先在 OpenJDK 试试水，把大部分问题都解决掉了才在 Oracle JDK 上发布）</li>
</ol>
</blockquote>
<h4 id="1-7-1-Oracle-JDK-和-OpenJDK-如何选择？"><a href="#1-7-1-Oracle-JDK-和-OpenJDK-如何选择？" class="headerlink" title="1.7.1 Oracle JDK 和 OpenJDK 如何选择？"></a>1.7.1 Oracle JDK 和 OpenJDK 如何选择？</h4><p>建议选择 OpenJDK 或者基于 OpenJDK 的发行版，比如 AWS 的 Amazon Corretto，阿里巴巴的 Alibaba Dragonwell。</p>
<h3 id="1-8-C-和-Java-的区别？"><a href="#1-8-C-和-Java-的区别？" class="headerlink" title="1.8 C++ 和 Java 的区别？"></a>1.8 C++ 和 Java 的区别？</h3><p>虽然 Java 和 C++ 都是面向对象的语言，但是它们有挺多不同的地方：</p>
<ul>
<li>Java 不提供指针直接访问内存，程序内存更安全。</li>
<li>Java 是单继承的， C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以。</li>
<li>Java 有自动内存管理垃圾回收机制（GC），不需要程序员手动释放无用内存。</li>
<li>C++ 同时支持方法重载和操作符重载， Java 只支持方法重载（操作符重载增加了复杂性）。</li>
</ul>
<h2 id="2-基本语法"><a href="#2-基本语法" class="headerlink" title="2. 基本语法"></a>2. 基本语法</h2><h3 id="2-1-注释有哪几种形式？"><a href="#2-1-注释有哪几种形式？" class="headerlink" title="2.1 注释有哪几种形式？"></a>2.1 注释有哪几种形式？</h3><ol>
<li>单行注释</li>
<li>多行注释</li>
<li>文档注释</li>
</ol>
<p>用得较多的是<strong>单行注释和文档注释</strong>，多行注释在开发中使用的相对较少。</p>
<blockquote>
<p><strong>代码的注释不是越详细越好。实际上好的代码本身就是注释，我们要尽量规范和美化自己的代码来减少不必要的注释。</strong><br><strong>若编程语言足够有表达力，就不需要注释，尽量通过代码来阐述。</strong><br>例子：<br>去掉下面复杂的注释，只需要创建一个与注释所言同一事物的函数即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// check to see if the employee is eligible for full benefits</span></span><br><span class="line"><span class="keyword">if</span> ((employee.flags &amp; HOURLY_FLAG) &amp;&amp; (employee.age &gt; <span class="number">65</span>))</span><br></pre></td></tr></table></figure>

<p>应替换为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (employee.isEligibleForFullBenefits())</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="2-2-标识符和关键字的区别是什么？"><a href="#2-2-标识符和关键字的区别是什么？" class="headerlink" title="2.2 标识符和关键字的区别是什么？"></a>2.2 标识符和关键字的区别是什么？</h3><p>简单来说，<strong>标识符就是一个名字</strong>。</p>
<p>有一些标识符， Java 语言已经赋予其特殊的含义，只能在特定的地方使用，这些标识符就是 <strong>关键字</strong> 。 简单来说， <strong>关键字就是被赋予特殊含义的标识符</strong>。</p>
<h4 id="2-2-1-Java-语言的关键字有哪些？"><a href="#2-2-1-Java-语言的关键字有哪些？" class="headerlink" title="2.2.1 Java 语言的关键字有哪些？"></a>2.2.1 Java 语言的关键字有哪些？</h4><table>
<thead>
<tr>
<th>分类</th>
<th>关键 字</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>访问控制</td>
<td>private</td>
<td>protected</td>
<td>public</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>类、方法和变量修饰符</td>
<td>abstract</td>
<td>class</td>
<td>extends</td>
<td>final</td>
<td>implements</td>
<td>interface</td>
<td>native</td>
</tr>
<tr>
<td></td>
<td>new</td>
<td>static</td>
<td>strictfp</td>
<td>synchronized</td>
<td>transient</td>
<td>volatile</td>
<td>enum</td>
</tr>
<tr>
<td>程序控制</td>
<td>break</td>
<td>continue</td>
<td>return</td>
<td>do</td>
<td>while</td>
<td>if</td>
<td>else</td>
</tr>
<tr>
<td></td>
<td>for</td>
<td>instanceof</td>
<td>switch</td>
<td>case</td>
<td>default</td>
<td>assert</td>
<td></td>
</tr>
<tr>
<td>错误处理</td>
<td>try</td>
<td>catch</td>
<td>throw</td>
<td>throws</td>
<td>finally</td>
<td></td>
<td></td>
</tr>
<tr>
<td>包相关</td>
<td>import</td>
<td>package</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>基本类型</td>
<td>boolean</td>
<td>byte</td>
<td>char</td>
<td>double</td>
<td>float</td>
<td>int</td>
<td>long</td>
</tr>
<tr>
<td></td>
<td>short</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>变量引用</td>
<td>super</td>
<td>this</td>
<td>void</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>保留字</td>
<td>goto</td>
<td>const</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>Tips: 所有的关键字都是小写的，在 IDE 中以特殊颜色显示<br><code>default</code> 这个关键字既属于程序控制，也属于类、方法和变量修饰符。</p>
<ul>
<li>在程序控制中，当在 <code>switch</code> 中匹配不到任何情况时，可以使用 <code>default</code> 编写默认匹配的情况。</li>
<li>在类、方法和变量修饰符中，从 JDK8 开始引入了默认方法，可以使用 <code>default</code> 关键字来定义一个方法的默认实现。</li>
<li>在访问控制中，如果一个方法前没有任何修饰符，则默认会有一个修饰符 <code>default</code> ，但是这个修饰符加上就会报错。</li>
</ul>
</blockquote>
<p><strong>注意</strong>： 虽然 <code>true</code> , <code>false</code> 和 <code>null</code> 看起来像关键字但实际上它们只是字面量，不可以作为标识符使用。</p>
<p>官方文档：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html">https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html</a></p>
<h3 id="2-3-自增自减运算符"><a href="#2-3-自增自减运算符" class="headerlink" title="2.3 自增自减运算符"></a>2.3 自增自减运算符</h3><p>Java 提供了自增 ( <code>++</code> ) 和自减 ( <code>--</code> ) 运算符来简化操作。</p>
<p><code>++</code> 和 <code>--</code> 运算符可以放在变量前后：</p>
<ul>
<li><strong>前缀</strong>： 先自增（减）变量的值，然后再使用该变量。</li>
<li><strong>后缀</strong>： 先使用该变量，再自增（减）。</li>
</ul>
<p>笔试题：</p>
<p>运行该代码后 <code>a</code> , <code>b</code> , <code>c</code> , <code>d</code> 和 <code>e</code> 分别为？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line"><span class="comment">// 1 --&gt; a = 9</span></span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a++;</span><br><span class="line"><span class="comment">// 2 --&gt; a = 10 , b = 9</span></span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ++a;</span><br><span class="line"><span class="comment">// 3 --&gt; a = 11 , b = 9 , c = 11</span></span><br><span class="line"><span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> c--;</span><br><span class="line"><span class="comment">// 4 --&gt; a = 11 , b = 9 , c = 10 , d = 11</span></span><br><span class="line"><span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> --d;</span><br><span class="line"><span class="comment">// 5 --&gt; a = 11 , b = 9 , c = 10 , d = 10 , e = 10</span></span><br></pre></td></tr></table></figure>

<p>答案： <code>a = 11</code> 、<code>b = 9</code> 、 <code>c = 10</code> 、 <code>d = 10</code> 、 <code>e = 10</code> 。具体过程看注释。</p>
<h3 id="2-3-移位运算符"><a href="#2-3-移位运算符" class="headerlink" title="2.3 移位运算符"></a>2.3 移位运算符</h3><p>移位运算符是最基本的运算符之一，几乎每种编程语言都包含这一运算符。移位操作中，被操作的数据被视为二进制数，移位就是将其向左或向右移动若干位的运算。</p>
<p>移位运算符在各种框架以及 JDK 自身的源码中使用还是挺广泛的，HashMap（JDK1.8） 中的 hash 方法的源码就用到了移位运算符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class="line">    <span class="comment">// ^：按位异或</span></span><br><span class="line">    <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用移位运算符的主要原因：</strong></p>
<ol>
<li><strong>高效</strong> ： 移位运算符直接对应处理器的移位指令，这些指令通常在一个时钟周期内完成。</li>
<li><strong>节省内存</strong> ： 通过移位操作可以使一个整数存储多个布尔值或标志位。</li>
</ol>
<p>移位运算符最常用于快速乘以或除以 2 的幂次方。除此之外，它还在以下方面发挥着重要作用：</p>
<ul>
<li><strong>位字段管理</strong> ： 存储和操作多个布尔值。</li>
<li><strong>哈希算法和加密算法</strong> ： 通过移位和与、或等操作来混淆数据。</li>
<li><strong>数据压缩</strong> ： 如霍夫曼编码通过移位运算符可以快速处理和操作二进制数据，已生成紧凑的压缩格式。</li>
<li><strong>数据校验</strong> ： 如 CRC （循环冗余校验）通过移位和多项式除法生成和校验数据完整性。</li>
<li><strong>内存对齐</strong> ： 通过移位操作可以计算和调整数据的对齐地址。</li>
</ul>
<p>Java 中有三种移位运算符：</p>
<ul>
<li><code>&lt;&lt;</code> ： 左移运算符，向左移若干位，高位丢弃，低位补零，相当于乘 2^n（不溢出的情况下）。</li>
<li><code>&gt;&gt;</code> ： 带符号右移，高位补符号位，低位丢弃。相当于除 2^n 。</li>
<li><code>&gt;&gt;&gt;</code> ： 无符号右移，忽略符号位，空位补零。</li>
</ul>
<p>由于 <code>double</code> ， <code>float</code> 在二进制中的表现比较特殊，因此<strong>不能来进行移位操作</strong>。</p>
<p>移位操作符实际上支持的类型只有 <code>int</code> 和 <code>long</code> ，编译器在对 <code>short</code> 、 <code>byte</code> 、 <code>char</code> 类型进行移位前，都会<strong>将其转换为 <code>int</code> 类型再操作</strong>。</p>
<h4 id="2-3-1-如果移位的位数超过数值所占的位数会怎么样？"><a href="#2-3-1-如果移位的位数超过数值所占的位数会怎么样？" class="headerlink" title="2.3.1 如果移位的位数超过数值所占的位数会怎么样？"></a>2.3.1 如果移位的位数超过数值所占的位数会怎么样？</h4><p>当 int 类型左移&#x2F;右移位数大于等于 32 位操作时，会<strong>先求余（%）后再进行左移&#x2F;右移操作</strong>。也就是说<strong>左移&#x2F;右移 32 位相当于不进行移位操作（32%32&#x3D;0）</strong>，左移&#x2F;右移 42 位相当于左移&#x2F;右移 10 位（42%32&#x3D;10）。当 long 类型进行左移&#x2F;右移操作时，由于 long 对应的二进制是 64 位，因此求余操作的基数也变成了 64。</p>
<p>也就是说： <code>x&lt;&lt;42</code> 等同于 <code>x&lt;&lt;10</code> ， <code>x&gt;&gt;42</code> 等同于 <code>x&gt;&gt;10</code> ， <code>x &gt;&gt;&gt;42</code> 等同于 <code>x &gt;&gt;&gt; 10</code> 。</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;初始数据：&quot;</span> + i);</span><br><span class="line">System.out.println(<span class="string">&quot;初始数据对应的二进制字符串：&quot;</span> + Integer.toBinaryString(i));</span><br><span class="line">i &lt;&lt;= <span class="number">10</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;左移 10 位后的数据 &quot;</span> + i);</span><br><span class="line">System.out.println(<span class="string">&quot;左移 10 位后的数据对应的二进制字符 &quot;</span> + Integer.toBinaryString(i));</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">初始数据：-1</span><br><span class="line">初始数据对应的二进制字符串：11111111111111111111111111111111</span><br><span class="line">左移 10 位后的数据 -1024</span><br><span class="line">左移 10 位后的数据对应的二进制字符 11111111111111111111110000000000</span><br></pre></td></tr></table></figure>

<p>由于左移位数大于等于 32 位操作时，会先求余（%）后再进行左移操作，所以下面的代码左移 42 位相当于左移 10 位（42%32&#x3D;10），输出结果和前面的代码一样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;初始数据：&quot;</span> + i);</span><br><span class="line">System.out.println(<span class="string">&quot;初始数据对应的二进制字符串：&quot;</span> + Integer.toBinaryString(i));</span><br><span class="line">i &lt;&lt;= <span class="number">42</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;左移 10 位后的数据 &quot;</span> + i);</span><br><span class="line">System.out.println(<span class="string">&quot;左移 10 位后的数据对应的二进制字符 &quot;</span> + Integer.toBinaryString(i));</span><br></pre></td></tr></table></figure>

<p>右移运算符使用类似。</p>
<h3 id="2-4-continue-、-break-和-return-的区别是什么？"><a href="#2-4-continue-、-break-和-return-的区别是什么？" class="headerlink" title="2.4 continue 、 break 和 return 的区别是什么？"></a>2.4 continue 、 break 和 return 的区别是什么？</h3><ol>
<li><code>continue</code> ：跳出当前一次的循环，继续下一次循环。</li>
<li><code>break</code> ： 跳出整个循环体。</li>
</ol>
<p><code>return</code> 用于跳出当前方法。一般用于：</p>
<ol>
<li><code>return</code> ： 直接结束方法执行，没有返回值。</li>
<li><code>return value</code> ： 返回一个特定值。</li>
</ol>
<p>思考：</p>
<p>下列语句的结果是什么？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 1 --&gt; i = 0 , f = f , sout 0</span></span><br><span class="line">            System.out.println(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            <span class="comment">// i++ sout xixi</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 2 --&gt; i = 1 , f = f , sout 1</span></span><br><span class="line">            System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            <span class="comment">// i++</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// 3 --&gt; i = 2 , f = f , sout 2</span></span><br><span class="line">            System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// i++ f = t sout xixi</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="comment">// 4 --&gt; i = 3 , f = t , sout 3</span></span><br><span class="line">            System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">            <span class="comment">//break</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">4</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;xixi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        <span class="comment">// 5 --&gt; sout haha</span></span><br><span class="line">        System.out.println(<span class="string">&quot;haha&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;heihei&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">xixi</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">xixi</span><br><span class="line">3</span><br><span class="line">haha</span><br></pre></td></tr></table></figure>

<h2 id="3-基本数据类型"><a href="#3-基本数据类型" class="headerlink" title="3. 基本数据类型"></a>3. 基本数据类型</h2><h3 id="3-1-Java-中的几种基本数据类型？"><a href="#3-1-Java-中的几种基本数据类型？" class="headerlink" title="3.1 Java 中的几种基本数据类型？"></a>3.1 Java 中的几种基本数据类型？</h3><ul>
<li>6 种数字类型<ul>
<li>4 种整数型： <code>byte</code> , <code>short</code> , <code>int</code> , <code>long</code></li>
<li>2 种浮点型： <code>float</code> , <code>double</code></li>
</ul>
</li>
<li>1 种字符型： <code>char</code></li>
<li>1 种布尔型： <code>boolean</code></li>
</ul>
<p>基本数据类型的默认值和所占空间：</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>位数</th>
<th>字节</th>
<th>默认值</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td><code>byte</code></td>
<td>8</td>
<td>1</td>
<td>0</td>
<td>-128 ~ 127</td>
</tr>
<tr>
<td><code>short</code></td>
<td>16</td>
<td>2</td>
<td>0</td>
<td>-2 ^ 15 ~ 2 ^ 15 - 1</td>
</tr>
<tr>
<td><code>int</code></td>
<td>32</td>
<td>4</td>
<td>0</td>
<td>-2 ^ 31 ~ 2 ^ 31 - 1</td>
</tr>
<tr>
<td><code>long</code></td>
<td>64</td>
<td>8</td>
<td>0L</td>
<td>-2 ^ 63 ~ 2 ^ 63 - 1</td>
</tr>
<tr>
<td><code>char</code></td>
<td>16</td>
<td>2</td>
<td>‘u0000’</td>
<td>0 ~ 2 ^ 16 - 1</td>
</tr>
<tr>
<td><code>float</code></td>
<td>32</td>
<td>4</td>
<td>0f</td>
<td>1.4 E -45 ~ 3.4028235 E 38</td>
</tr>
<tr>
<td><code>double</code></td>
<td>64</td>
<td>8</td>
<td>0d</td>
<td>4.9 E -324 ~ 1.7976931348623157 E 308</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td>1</td>
<td></td>
<td>false</td>
<td>true , false</td>
</tr>
</tbody></table>
<p>对于 <code>boolean</code> ，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。逻辑上理解是占用 1 位，但是实际中会考虑计算机高效存储因素。</p>
<p>Java 的每种基本类型所占存储空间的大小<strong>不会像其他大多数语言那样随机器硬件架构的变化而变化</strong>。这种所占存储空间大小的不变性是 Java 程序比用其他大多数语言编写的程序更具可移植性的原因之一。</p>
<p>注意：</p>
<ol>
<li>Java 里使用 <code>long</code> 类型的数据一定要加上 <strong>L</strong> ， 否则将作为整形解析。</li>
<li>Java 里使用 <code>float</code> 类型一定要加上 <strong>f 或 F</strong> ， 否则无法通过编译。</li>
<li><code>char = h</code> char 单引号 <code>String a = &quot;hello&quot;</code> String 双引号。</li>
</ol>
<p>这八种基本类型都有对应的包装类分别为： <code>Byte</code> 、 <code>Short</code> 、 <code>Integer</code> 、 <code>Long</code> 、 <code>Float</code> 、 <code>Double</code> 、 <code>Character</code> 、 <code>Boolean</code> 。</p>
<h3 id="3-2-基本类型和包装类型的区别？"><a href="#3-2-基本类型和包装类型的区别？" class="headerlink" title="3.2 基本类型和包装类型的区别？"></a>3.2 基本类型和包装类型的区别？</h3><ul>
<li><strong>用途</strong> ： 除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。并且，<strong>包装类型可用于泛型，而基本类型不可以</strong>。</li>
<li><strong>存储方式</strong> ： 基本数据类型的局部变量存放在 <strong>Java 虚拟机栈中的局部变量表</strong>中，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 <strong>Java 虚拟机的堆</strong>中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于<strong>堆</strong>中。</li>
<li><strong>占用空间</strong> ： 相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。</li>
<li><strong>默认值</strong> ： 成员变量包装类型不赋值就是 null ，而基本类型有默认值且不是 null。</li>
<li><strong>比较方式</strong> ： 对于基本数据类型来说，<code>==</code> 比较的是值。对于包装数据类型来说，<code>==</code> 比较的是<strong>对象的内存地址</strong>。所有整型包装类对象之间值的比较，<strong>全部使用 <code>equals()</code> 方法</strong>。</li>
</ul>
<p><strong>为什么说是几乎所有对象实例都存在于堆中呢？</strong></p>
<p>这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存</p>
<p><strong>注意：</strong></p>
<p>基本数据类型存放在栈中是一个常见的误区！ 基本数据类型的存储位置取决于它们的<strong>作用和声明方式</strong>。如果它们是<strong>局部变量</strong>，那么它们会存放在<strong>栈</strong>中；如果它们是<strong>成员变量</strong>，那么们会存放在<strong>堆&#x2F;方法区&#x2F;元空间</strong>中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="comment">// 成员变量，存放在堆中</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 被 static 修饰的成员变量，JDK 1.7 及之前位于方法区，1.8 后存放于元空间，均不存放于堆中。</span></span><br><span class="line">    <span class="comment">// 变量属于类，不属于对象。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 局部变量，存放在栈中</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">40</span>; <span class="comment">// 编译错误，不能在方法中使用 static 修饰局部变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-包装类型的缓存机制"><a href="#3-3-包装类型的缓存机制" class="headerlink" title="3.3 包装类型的缓存机制"></a>3.3 包装类型的缓存机制</h3><p><code>Byte</code> , <code>Short</code> , <code>Integer</code> , <code>Long</code> 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据， <code>Character</code> 创建了数值在 [0,127] 范围的缓存数据， <code>Boolean</code> 直接返回 <code>True</code> or <code>False</code> 。</p>
<p>Integer 缓存源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntegerCache</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Character 缓存源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Character <span class="title function_">valueOf</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c &lt;= <span class="number">127</span>) &#123; <span class="comment">// must cache</span></span><br><span class="line">      <span class="keyword">return</span> CharacterCache.cache[(<span class="type">int</span>)c];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Character</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CharacterCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">CharacterCache</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Character cache[] = <span class="keyword">new</span> <span class="title class_">Character</span>[<span class="number">127</span> + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cache.length; i++)</span><br><span class="line">            cache[i] = <span class="keyword">new</span> <span class="title class_">Character</span>((<span class="type">char</span>)i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Boolean 缓存源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title function_">valueOf</span><span class="params">(<span class="type">boolean</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (b ? TRUE : FALSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是<strong>在性能和资源之间的权衡</strong>。</p>
<p>两种浮点数类型的包装类<strong>没有实现缓存机制</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">33</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">33</span>;</span><br><span class="line">System.out.println(i1 == i2);<span class="comment">// 输出 true</span></span><br><span class="line"></span><br><span class="line"><span class="type">Float</span> <span class="variable">i11</span> <span class="operator">=</span> <span class="number">333f</span>;</span><br><span class="line"><span class="type">Float</span> <span class="variable">i22</span> <span class="operator">=</span> <span class="number">333f</span>;</span><br><span class="line">System.out.println(i11 == i22);<span class="comment">// 输出 false</span></span><br><span class="line"></span><br><span class="line"><span class="type">Double</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">1.2</span>;</span><br><span class="line"><span class="type">Double</span> <span class="variable">i4</span> <span class="operator">=</span> <span class="number">1.2</span>;</span><br><span class="line">System.out.println(i3 == i4);<span class="comment">// 输出 false</span></span><br></pre></td></tr></table></figure>

<p>问题：下面的代码的输出结果是 true 还是 false ？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">40</span>);</span><br><span class="line">System.out.println(i1==i2);</span><br></pre></td></tr></table></figure>

<p><code>Integer i1=40</code> 这一行代码会发生装箱，也就是说这行代码等价于 <code>Integer i1=Integer.valueOf(40)</code> 。因此， <code>i1</code> 直接使用的是缓存中的对象。而 <code>Integer i2 = new Integer(40)</code> 会直接创建新的对象。</p>
<p>因此，答案是 <code>false</code> 。</p>
<p><strong>所有整型包装类对象之间值的比较，全部使用 equals 方法比较。</strong></p>
<h3 id="3-4-自动装箱与自动拆箱？原理？"><a href="#3-4-自动装箱与自动拆箱？原理？" class="headerlink" title="3.4 自动装箱与自动拆箱？原理？"></a>3.4 自动装箱与自动拆箱？原理？</h3><p>自动拆装箱？</p>
<ul>
<li><strong>装箱</strong> ： 将基本类型用对应的引用类型包装起来。</li>
<li><strong>拆箱</strong> ： 将包装类型转换为基本数据类型。</li>
</ul>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;  <span class="comment">//装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i;   <span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure>

<p>字节码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">L1</span><br><span class="line"></span><br><span class="line"> LINENUMBER 8 L1</span><br><span class="line"></span><br><span class="line"> ALOAD 0</span><br><span class="line"></span><br><span class="line"> BIPUSH 10</span><br><span class="line"></span><br><span class="line"> INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;</span><br><span class="line"></span><br><span class="line"> PUTFIELD AutoBoxTest.i : Ljava/lang/Integer;</span><br><span class="line"></span><br><span class="line">L2</span><br><span class="line"></span><br><span class="line"> LINENUMBER 9 L2</span><br><span class="line"></span><br><span class="line"> ALOAD 0</span><br><span class="line"></span><br><span class="line"> ALOAD 0</span><br><span class="line"></span><br><span class="line"> GETFIELD AutoBoxTest.i : Ljava/lang/Integer;</span><br><span class="line"></span><br><span class="line"> INVOKEVIRTUAL java/lang/Integer.intValue ()I</span><br><span class="line"></span><br><span class="line"> PUTFIELD AutoBoxTest.n : I</span><br><span class="line"></span><br><span class="line"> RETURN</span><br></pre></td></tr></table></figure>

<p>从字节码中，可以发现装箱其实就是调用了包装类的 <code>valueOf()</code> 方法，拆箱其实就是调用了 <code>xxxValue()</code> 方法。</p>
<p>因此，</p>
<ul>
<li><code>Integer i = 10</code> 等价于 <code>Integer i = Integer.valueOf(10)</code></li>
<li><code>int n = i</code> 等价于 <code>int n = i.intValue()</code></li>
</ul>
<p>注意： <strong>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">sum</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 应该使用 long 而不是 Long</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= Integer.MAX_VALUE; i++)</span><br><span class="line">        sum += i;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-5-为什么浮点数运算会有精度丢失？"><a href="#3-5-为什么浮点数运算会有精度丢失？" class="headerlink" title="3.5 为什么浮点数运算会有精度丢失？"></a>3.5 为什么浮点数运算会有精度丢失？</h3><p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2.0f</span> - <span class="number">1.9f</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1.8f</span> - <span class="number">1.7f</span>;</span><br><span class="line">System.out.printf(<span class="string">&quot;%.9f&quot;</span>,a);<span class="comment">// 0.100000024</span></span><br><span class="line">System.out.println(b);<span class="comment">// 0.099999905</span></span><br><span class="line">System.out.println(a == b);<span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>精度丢失和计算机保存浮点数的机制有很大关系。计算机是二进制的，且计算机在保存一个数字时，宽度是有限的，无限循环的小数存储时只能被截断，所以会出现小数精度丢失的情况。</p>
<p>比如：<br>十进制下的 0.2 就没办法精确转化为二进制小数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0.2 转换为二进制数的过程为，不断乘以 2，直到不存在小数为止，</span></span><br><span class="line"><span class="comment">// 在这个计算过程中，得到的整数部分从上到下排列就是二进制的结果。</span></span><br><span class="line"><span class="number">0.2</span> * <span class="number">2</span> = <span class="number">0.4</span> -&gt; <span class="number">0</span></span><br><span class="line"><span class="number">0.4</span> * <span class="number">2</span> = <span class="number">0.8</span> -&gt; <span class="number">0</span></span><br><span class="line"><span class="number">0.8</span> * <span class="number">2</span> = <span class="number">1.6</span> -&gt; <span class="number">1</span></span><br><span class="line"><span class="number">0.6</span> * <span class="number">2</span> = <span class="number">1.2</span> -&gt; <span class="number">1</span></span><br><span class="line"><span class="number">0.2</span> * <span class="number">2</span> = <span class="number">0.4</span> -&gt; <span class="number">0</span>（发生循环）</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>关于浮点数，具体看 <a target="_blank" rel="noopener" href="http://kaito-kidd.com/2018/08/08/computer-system-float-point/">计算机系统基础</a> 这篇博客。</p>
<h3 id="3-6-如何解决浮点数运算精度丢失？"><a href="#3-6-如何解决浮点数运算精度丢失？" class="headerlink" title="3.6 如何解决浮点数运算精度丢失？"></a>3.6 如何解决浮点数运算精度丢失？</h3><p><code>BigDecimal</code> 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算的场景都是通过 <code>BigDecimal</code> 实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.00&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// BigDecimal 的 subtract 方法用于执行精确的减法运算。</span></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">x</span> <span class="operator">=</span> a.subtract(c);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">y</span> <span class="operator">=</span> b.subtract(c);</span><br><span class="line"></span><br><span class="line">System.out.println(x); <span class="comment">/* 0.2 */</span></span><br><span class="line">System.out.println(y); <span class="comment">/* 0.20 */</span></span><br><span class="line"><span class="comment">// 比较内容，不是比较值</span></span><br><span class="line">System.out.println(Objects.equals(x, y)); <span class="comment">/* false */</span></span><br><span class="line"><span class="comment">// 比较值相等用相等compareTo，相等返回0</span></span><br><span class="line">System.out.println(<span class="number">0</span> == x.compareTo(y)); <span class="comment">/* true */</span></span><br></pre></td></tr></table></figure>

<p><code>BigDecimal</code> 的详细介绍在 <a href="%E5%85%B6%E4%BB%96%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9.md">重要知识点</a> 里。</p>
<h3 id="3-7-超过-long-整型的数据如何表示？"><a href="#3-7-超过-long-整型的数据如何表示？" class="headerlink" title="3.7 超过 long 整型的数据如何表示？"></a>3.7 超过 <code>long</code> 整型的数据如何表示？</h3><p>在 Java 中，64 位 long 整型是最大的整数类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> Long.MAX_VALUE;</span><br><span class="line">System.out.println(l + <span class="number">1</span>); <span class="comment">// -9223372036854775808</span></span><br><span class="line">System.out.println(l + <span class="number">1</span> == Long.MIN_VALUE); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>BigInteger 内部使用 int[] 数组来存储任意大小的整形数据。</p>
<p>注意：</p>
<p>相对于常规整数类型的运算来说，BigInteger 运算的效率会相对较低。</p>
<h2 id="4-变量"><a href="#4-变量" class="headerlink" title="4. 变量"></a>4. 变量</h2><h3 id="4-1-成员变量与局部变量的区别？"><a href="#4-1-成员变量与局部变量的区别？" class="headerlink" title="4.1 成员变量与局部变量的区别？"></a>4.1 成员变量与局部变量的区别？</h3><ul>
<li><p><strong>语法形式</strong> ： 成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或参数；成员变量可以被 <code>public</code> , <code>private</code> , <code>static</code> 等修饰符修饰，而局部变量不能被访问控制修饰符及 <code>static</code> 修饰；但是成员变量和局部变量都能被 <code>final</code> 修饰。</p>
</li>
<li><p><strong>存储方式</strong> ： 如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有，这个成员变量是属于实例的。对象存储在堆内存，局部变量存储在栈内存。</p>
</li>
<li><p><strong>生存时间</strong> ： 成员变量是对象的一部分，随着对象的创建而存在，局部变量随方法的调用而自动生成，随方法的调用结束而消亡。</p>
</li>
<li><p><strong>默认值</strong> ： 成员变量如果没有被赋初值，则会自动以类型的默认值赋值（ 例外：被 <code>fianl</code> 修饰必须显式赋值 ），而局部变量不会自动赋值。</p>
</li>
</ul>
<h4 id="4-1-1-为什么成员变量有默认值？"><a href="#4-1-1-为什么成员变量有默认值？" class="headerlink" title="4.1.1 为什么成员变量有默认值？"></a>4.1.1 为什么成员变量有默认值？</h4><ol>
<li><p>如果没有默认值？ –&gt; 变量存储的是内存地址对应的任意随机值，程序读取该值运行会出现意外。</p>
</li>
<li><p>默认值有两种设置方式：手动和自动，根据第一点，没有手动赋值一定要自动赋值。成员变量在运行时可借助反射等方法手动赋值，而局部变量不行。</p>
</li>
<li><p>对于编译器（ javac ）来说，局部变量没赋值很好判断，可以直接报错。而成员变量可能是运行时赋值，无法判断，误报“没默认值”又会影响用户体验，所以采用自动赋默认值。</p>
</li>
</ol>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VariableExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员变量</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法中的局部变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 栈中分配的局部变量</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello, world!&quot;</span>; <span class="comment">// 栈中分配的局部变量</span></span><br><span class="line">        System.out.println(num1);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带参数的方法中的局部变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(<span class="type">int</span> num2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> num2 + <span class="number">10</span>; <span class="comment">// 栈中分配的局部变量</span></span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法中的局部变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">VariableExample</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name; <span class="comment">// 对成员变量进行赋值</span></span><br><span class="line">        <span class="built_in">this</span>.age = age; <span class="comment">// 对成员变量进行赋值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num3</span> <span class="operator">=</span> <span class="number">20</span>; <span class="comment">// 栈中分配的局部变量</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;Hello, &quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot;!&quot;</span>; <span class="comment">// 栈中分配的局部变量</span></span><br><span class="line">        System.out.println(num3);</span><br><span class="line">        System.out.println(str2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-静态变量有什么用？"><a href="#4-2-静态变量有什么用？" class="headerlink" title="4.2 静态变量有什么用？"></a>4.2 静态变量有什么用？</h3><p>静态变量也就是被 static 关键字修饰的变量。它可以被类的所有实例共享，无论一个类创建了多少个对象，它们都共享同一份静态变量。静态变量只会被分配一次内存，即使创建多个对象，这样可以节省内存。</p>
<p>通常情况下，静态变量会被 <code>final</code> 关键字<strong>修饰成为常量</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConstantVariableExample</span> &#123;</span><br><span class="line">    <span class="comment">// 常量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">constantVar</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-字符型常量和字符串型常量的区别？"><a href="#4-3-字符型常量和字符串型常量的区别？" class="headerlink" title="4.3 字符型常量和字符串型常量的区别？"></a>4.3 字符型常量和字符串型常量的区别？</h3><ul>
<li><p><strong>形式</strong> ： 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符。</p>
</li>
<li><p><strong>含义</strong> ： 字符常量相当于<strong>一个整型值 ( ASCII 值)</strong> ,可以参加表达式运算; 字符串常量代表<strong>一个地址值</strong> ( 该字符串在内存中存放位置 ) 。</p>
</li>
<li><p><strong>占内存大小</strong> ： 字符常量只占 2 个字节; 字符串常量占若干个字节。</p>
</li>
</ul>
<p>注意： <code>char</code> 在 Java 中占<strong>两个字节</strong>。</p>
<h2 id="5-方法"><a href="#5-方法" class="headerlink" title="5. 方法"></a>5. 方法</h2><h3 id="5-1-什么是方法的返回值？-方法有哪几种类型？"><a href="#5-1-什么是方法的返回值？-方法有哪几种类型？" class="headerlink" title="5.1 什么是方法的返回值？ 方法有哪几种类型？"></a>5.1 什么是方法的返回值？ 方法有哪几种类型？</h3><p><strong>方法的返回值</strong> 是指获取到的某个方法体执行后产生的结果。</p>
<p>可以按照方法的返回值和参数类型分类：</p>
<ol>
<li><p>无参数无返回值方法</p>
</li>
<li><p>有参数无返回值的方法</p>
</li>
<li><p>有返回值无参数的方法</p>
</li>
<li><p>有返回值有参数的方法</p>
</li>
</ol>
<h3 id="5-2-静态方法为什么不能调用非静态成员？"><a href="#5-2-静态方法为什么不能调用非静态成员？" class="headerlink" title="5.2 静态方法为什么不能调用非静态成员？"></a>5.2 静态方法为什么不能调用非静态成员？</h3><p>需要结合 JVM 的相关知识，主要原因如下：</p>
<ol>
<li><p>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</p>
</li>
<li><p>在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</p>
</li>
</ol>
<h3 id="5-3-静态方法和实例方法有何不同？"><a href="#5-3-静态方法和实例方法有何不同？" class="headerlink" title="5.3 静态方法和实例方法有何不同？"></a>5.3 静态方法和实例方法有何不同？</h3><ol>
<li><p><strong>调用方式</strong> ：<br>在外部调用静态方法时，可以使用 <code>类名.方法名</code> 的方式，也可以使用 <code>对象.方法名</code> 的方式，而实例方法只有后面这种方式。也就是说，<strong>调用静态方法可以无需创建对象</strong>。<br>不过，需要注意的是一般<strong>不建议使用 <code>对象.方法名</code> 的方式来调用静态方法</strong>。这种方式非常容易造成混淆，静态方法不属于类的某个对象而是属于这个类。<br>因此，一般建议使用 <code>类名.方法名</code> 的方式来调用静态方法。</p>
</li>
<li><p><strong>访问类成员是否存在限制</strong> ：<br>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。</p>
</li>
</ol>
<h3 id="5-4-重载和重写有什么区别？"><a href="#5-4-重载和重写有什么区别？" class="headerlink" title="5.4 重载和重写有什么区别？"></a>5.4 重载和重写有什么区别？</h3><blockquote>
<p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理<br>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，就要覆盖父类方法</p>
</blockquote>
<h4 id="5-4-1-重载"><a href="#5-4-1-重载" class="headerlink" title="5.4.1 重载"></a>5.4.1 重载</h4><p>发生在同一个类中（或者父类和子类之间），方法名<strong>必须相同</strong>，<strong>参数类型不同、个数不同、顺序不同</strong>，方法返回值和访问修饰符<strong>可以不同</strong>。</p>
<p>综上：重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</p>
<h4 id="5-4-2-重写"><a href="#5-4-2-重写" class="headerlink" title="5.4.2 重写"></a>5.4.2 重写</h4><p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p>
<ol>
<li><p><strong>方法名、参数列表必须相同</strong>，子类方法返回值类型应比父类方法返回值类型<strong>更小或相等</strong>，抛出的异常范围<strong>小于等于父类</strong>，访问修饰符范围<strong>大于等于父类</strong>。</p>
</li>
<li><p>如果父类方法访问修饰符为 <code>private</code> &#x2F; <code>final</code> &#x2F; <code>static</code> 则子类就不能重写该方法，但是被 <code>static</code> 修饰的方法能够被再次声明。</p>
</li>
<li><p>构造方法无法被重写</p>
</li>
</ol>
<h4 id="5-4-3-总结"><a href="#5-4-3-总结" class="headerlink" title="5.4.3 总结"></a>5.4.3 总结</h4><p>综上：<strong>重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。</strong></p>
<table>
<thead>
<tr>
<th>区别点</th>
<th>重载</th>
<th>重写</th>
</tr>
</thead>
<tbody><tr>
<td>发生范围</td>
<td>同一个类</td>
<td>子类</td>
</tr>
<tr>
<td>参数列表</td>
<td>必须修改</td>
<td>一定不能改</td>
</tr>
<tr>
<td>返回类型</td>
<td>可修改</td>
<td>比父类方法返回值类型更小或相等</td>
</tr>
<tr>
<td>异常</td>
<td>可修改</td>
<td>比父类方法声明抛出的异常类更小或相等</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>可修改</td>
<td>一定不能做更严格的限制（可以降低限制）</td>
</tr>
<tr>
<td>发生阶段</td>
<td>编译期</td>
<td>运行期</td>
</tr>
</tbody></table>
<p>补充： 如果方法的返回类型是 <strong><code>void</code> 和基本数据类型</strong>，则返回值重写时<strong>不可修改</strong>。但是如果方法的返回值是<strong>引用类型</strong>，重写时是<strong>可以返回该引用类型的子类</strong>的。</p>
<h3 id="5-5-什么是可变长参数？"><a href="#5-5-什么是可变长参数？" class="headerlink" title="5.5 什么是可变长参数？"></a>5.5 什么是可变长参数？</h3><p>从 Java5 开始，Java 支持定义可变长参数，可变长参数就是允许在调用方法时传入不定长度的参数。就比如下面这个方法就可以接受 0 个或者多个参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(String... args)</span> &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>可变参数<strong>只能作为函数的最后一个参数</strong>，但其前面可以有也<strong>可以没有任何其他参数</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(String arg1, String... args)</span> &#123; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-5-1-遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？"><a href="#5-5-1-遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？" class="headerlink" title="5.5.1 遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？"></a>5.5.1 遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？</h4><p>会优先匹配固定参数的方法，因为固定参数的方法匹配度更高。</p>
<p>Java 的可变参数编译后实际会被转换成一个数组，看编译后生成的 class 文件就可以看出来了。</p>
<h2 id="NEXT"><a href="#NEXT" class="headerlink" title="NEXT"></a>NEXT</h2><p><a href="JavaSE%20pt.2.md">JavaSE pt.2</a></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>JavaSE pt.1</p><p><a href="http://example.com/2025/03/10/八股/Java/Java基础/JavaSE pt.1/">http://example.com/2025/03/10/八股/Java/Java基础/JavaSE pt.1/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Rossignol</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2025-03-10</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2025-04-06</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Java/">Java</a><a class="link-muted mr-2" rel="tag" href="/tags/%E4%B8%AD%E6%96%87/">中文</a><a class="link-muted mr-2" rel="tag" href="/tags/%E5%85%AB%E8%82%A1/">八股</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2025/03/25/%E5%85%AB%E8%82%A1/Java/Java%E5%9F%BA%E7%A1%80/JavaSE%20pt.2/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">JavaSE pt.2</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2025/03/10/%E5%85%AB%E8%82%A1/Java/Java%E5%9F%BA%E7%A1%80/%E5%85%B6%E4%BB%96%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/"><span class="level-item">重要知识点</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.jpg" alt="Rossignol"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Rossignol</p><p class="is-size-6 is-block">NaN</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Mars</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives/"><p class="title">50</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories/"><p class="title">15</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags/"><p class="title">13</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/0xRossignol" target="_blank" rel="me noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/0xRossignol"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Golang/"><span class="level-start"><span class="level-item">Golang</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/Golang/basics/"><span class="level-start"><span class="level-item">basics</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/Java/basics/"><span class="level-start"><span class="level-item">basics</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/Java/basics/Thinking-in-Java/"><span class="level-start"><span class="level-item">Thinking in Java</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/Linux/Arch-Linux/"><span class="level-start"><span class="level-item">Arch Linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/OS/"><span class="level-start"><span class="level-item">OS</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Rust/"><span class="level-start"><span class="level-item">Rust</span></span><span class="level-end"><span class="level-item tag">11</span></span></a><ul><li><a class="level is-mobile" href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">Rust程序设计语言</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/test/"><span class="level-start"><span class="level-item">test</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/toy-projects/"><span class="level-start"><span class="level-item">toy projects</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%85%AB%E8%82%A1/"><span class="level-start"><span class="level-item">八股</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%85%AB%E8%82%A1/JavaSE/"><span class="level-start"><span class="level-item">JavaSE</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%85%AB%E8%82%A1/Java%E9%9B%86%E5%90%88/"><span class="level-start"><span class="level-item">Java集合</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-05-21T09:55:26.000Z">2025-05-21</time></p><p class="title"><a href="/2025/05/21/Rust/The%20Rust%20Programming%20Language/05.1%20%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%8C%96/">5.1 结构体的定义和实例化</a></p><p class="categories"><a href="/categories/Rust/">Rust</a> / <a href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-05-21T09:20:35.952Z">2025-05-21</time></p><p class="title"><a href="/2025/05/21/Rust/The%20Rust%20Programming%20Language/15.2%20%E9%80%9A%E8%BF%87%20Deref%20trait%20%E5%B0%86%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%BD%93%E4%BD%9C%E5%B8%B8%E8%A7%84%E5%BC%95%E7%94%A8%E5%A4%84%E7%90%86/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-05-21T09:14:12.218Z">2025-05-21</time></p><p class="title"><a href="/2025/05/21/Rust/The%20Rust%20Programming%20Language/13.2%20%E4%BD%BF%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%84%E7%90%86%E5%85%83%E7%B4%A0%E5%BA%8F%E5%88%97/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-05-21T08:55:26.000Z">2025-05-21</time></p><p class="title"><a href="/2025/05/21/Rust/The%20Rust%20Programming%20Language/04.3%20Slice%20%E7%B1%BB%E5%9E%8B/">4.3 Slice 类型</a></p><p class="categories"><a href="/categories/Rust/">Rust</a> / <a href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-05-20T08:55:26.000Z">2025-05-20</time></p><p class="title"><a href="/2025/05/20/Rust/The%20Rust%20Programming%20Language/04.2%20%E5%BC%95%E7%94%A8%E4%B8%8E%E5%80%9F%E7%94%A8/">4.2 引用与借用</a></p><p class="categories"><a href="/categories/Rust/">Rust</a> / <a href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2025/05/"><span class="level-start"><span class="level-item">五月 2025</span></span><span class="level-end"><span class="level-item tag">30</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/04/"><span class="level-start"><span class="level-item">四月 2025</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/03/"><span class="level-start"><span class="level-item">三月 2025</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/02/"><span class="level-start"><span class="level-item">二月 2025</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/12/"><span class="level-start"><span class="level-item">十二月 2024</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Arch-Linux/"><span class="tag">Arch Linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/English/"><span class="tag">English</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Golang/"><span class="tag">Golang</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OS/"><span class="tag">OS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Rust/"><span class="tag">Rust</span><span class="tag">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/git/"><span class="tag">git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/python/"><span class="tag">python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/test/"><span class="tag">test</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/toy-projects/"><span class="tag">toy projects</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%B8%AD%E6%96%87/"><span class="tag">中文</span><span class="tag">22</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%85%AB%E8%82%A1/"><span class="tag">八股</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BF%BB%E8%AF%91/"><span class="tag">翻译</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="MyBlog" height="28"></a><p class="is-size-7"><span>&copy; 2025 Rossignol</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>