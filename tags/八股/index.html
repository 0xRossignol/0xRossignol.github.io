<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>标签: 八股 - MyBlog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="MyBlog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="MyBlog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="MyBlog"><meta property="og:url" content="http://example.com/"><meta property="og:site_name" content="MyBlog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:author" content="Rossignol"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"MyBlog","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"Rossignol"},"publisher":{"@type":"Organization","name":"MyBlog","logo":{"@type":"ImageObject","url":"http://example.com/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="MyBlog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/0xRossignol"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags/">标签</a></li><li class="is-active"><a href="#" aria-current="page">八股</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-04-06T13:55:29.000Z" title="2025/4/6 21:55:29">2025-04-06</time>发表</span><span class="level-item"><time dateTime="2025-04-06T14:50:55.437Z" title="2025/4/6 22:50:55">2025-04-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%85%AB%E8%82%A1/">八股</a><span> / </span><a class="link-muted" href="/categories/%E5%85%AB%E8%82%A1/JavaSE/">JavaSE</a></span><span class="level-item">34 分钟读完 (大约5092个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/04/06/%E5%85%AB%E8%82%A1/Java/Java%E5%9F%BA%E7%A1%80/JavaSE%20pt.3/">JavaSE pt.3</a></p><div class="content"><h2 id="1-异常"><a href="#1-异常" class="headerlink" title="1. 异常"></a>1. 异常</h2><p><strong>Java 异常类层次结构：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">    Throwable --&gt;Exception;</span><br><span class="line">    Throwable --&gt;Error;</span><br><span class="line"></span><br><span class="line">    Exception --&gt;CheckedException;</span><br><span class="line">    Exception --&gt;UncheckedException;</span><br><span class="line"></span><br><span class="line">    Error --&gt; Errors;</span><br><span class="line"></span><br><span class="line">    subgraph CheckedException [Checked Exceptions]</span><br><span class="line">        direction TB;</span><br><span class="line">        IOException;</span><br><span class="line">        ClassNotFoundException;</span><br><span class="line">        SQLException;</span><br><span class="line">        FileNotFoundException;</span><br><span class="line">        ......;</span><br><span class="line">    end</span><br><span class="line">    CheckedException --&gt; IOException;</span><br><span class="line">    CheckedException --&gt; ClassNotFoundException;</span><br><span class="line">    CheckedException --&gt; SQLException;</span><br><span class="line">    CheckedException --&gt; FileNotFoundException;</span><br><span class="line"></span><br><span class="line">    subgraph UncheckedException [Unchecked Exceptions]</span><br><span class="line">        direction TB;</span><br><span class="line">        ArithmeticException;</span><br><span class="line">        ClassCastException;</span><br><span class="line">        IllegalThreadStateException;</span><br><span class="line">        IndexOutOfBoundsException;</span><br><span class="line">        ......;</span><br><span class="line">    end</span><br><span class="line">    UncheckedException --&gt; ArithmeticException;</span><br><span class="line">    UncheckedException --&gt; ClassCastException;</span><br><span class="line">    UncheckedException --&gt; IllegalThreadStateException;</span><br><span class="line">    UncheckedException --&gt; IndexOutOfBoundsException;</span><br><span class="line"></span><br><span class="line">    subgraph Errors [Errors]</span><br><span class="line">        direction TB;</span><br><span class="line">        OutOfMemoryError;</span><br><span class="line">        VirtualMachineError;</span><br><span class="line">        StackOverflowError;</span><br><span class="line">        AssertionError;</span><br><span class="line">        IOError;</span><br><span class="line">        ......;</span><br><span class="line">    end</span><br><span class="line">    Errors --&gt; OutOfMemoryError;</span><br><span class="line">    Errors --&gt; VirtualMachineError;</span><br><span class="line">    Errors --&gt; StackOverflowError;</span><br><span class="line">    Errors --&gt; AssertionError;</span><br><span class="line">    Errors --&gt; IOError;</span><br></pre></td></tr></table></figure>

<h3 id="1-1-Exception-和-Error-有什么区别？"><a href="#1-1-Exception-和-Error-有什么区别？" class="headerlink" title="1.1 Exception 和 Error 有什么区别？"></a>1.1 Exception 和 Error 有什么区别？</h3><p>在 Java 中， 所有的异常都有一个共同的祖先 ： <code>java.lang</code> 包下的 <code>Throwable</code> 类。 <code>Throwable</code> 类有两个重要的子类:</p>
<ul>
<li><code>Exception</code> ： 程序本身可以处理的异常，通常可以通过 <code>catch</code> 来捕获。 <code>Exception</code> 又可以分为 Checked Exception （ 受检查异常， <strong>必须处理</strong> ） 和 Unchecked Exception （ 不受检查异常， <strong>可以不处理</strong> ）。</li>
<li><code>Error</code> ： <code>Error</code> 属于程序无法处理的错误，不建议通过 <code>catch</code> 捕获。如 Java 虚拟机运行错误 （ <code>Virtural MachineError</code> ） 、 虚拟机内存不够错误 （ <code>OutOfMemoryError</code> ） 、 类定义错误 （ <code>NoClassDefFoundError</code> ） 等。这类异常发生时， JVM 一般会选择线程终止。</li>
</ul>
<h3 id="1-2-Checked-Exception-和-Unchecked-Exception-有什么区别？"><a href="#1-2-Checked-Exception-和-Unchecked-Exception-有什么区别？" class="headerlink" title="1.2 Checked Exception 和 Unchecked Exception 有什么区别？"></a>1.2 Checked Exception 和 Unchecked Exception 有什么区别？</h3><p><strong>Checked Exception</strong> 即 <strong>受检查异常</strong> ，Java 代码在编译过程中，如果受检查异常没有被 <code>catch</code> 或者 <code>throws</code> 关键字处理的话，就<strong>没办法通过编译</strong>。</p>
<p>除了 <code>RuntimeException</code> 及其子类以外，其他的 <code>Exception</code> 类及其子类都属于受检查异常 。常见的受检查异常有：<strong>IO 相关的异常、ClassNotFoundException、SQLException</strong> …。</p>
<p><code>Unchecked Exception</code> 即 <strong>不受检查异常</strong> ，Java 代码在编译过程中 ，我们即使不处理不受检查异常<strong>也可以正常通过编译</strong>。</p>
<p>RuntimeException 及其子类都统称为非受检查异常，常见的有：</p>
<ul>
<li><code>NullPointerException</code>(空指针错误)</li>
<li><code>IllegalArgumentException</code>(参数错误比如方法入参类型错误)</li>
<li><code>NumberFormatException</code>（字符串转换为数字格式错误，<code>IllegalArgumentException</code> 的子类）</li>
<li><code>ArrayIndexOutOfBoundsException</code>（数组越界错误）</li>
<li><code>ClassCastException</code>（类型转换错误）</li>
<li><code>ArithmeticException</code>（算术错误）</li>
<li><code>SecurityException</code> （安全错误比如权限不够）</li>
<li><code>UnsupportedOperationException</code> (不支持的操作错误比如重复创建同一用户)</li>
<li>……</li>
</ul>
<h3 id="1-3-Throwable-类常用方法有哪些？"><a href="#1-3-Throwable-类常用方法有哪些？" class="headerlink" title="1.3 Throwable 类常用方法有哪些？"></a>1.3 Throwable 类常用方法有哪些？</h3><ul>
<li><code>String getMessage()</code> : 返回异常发生时的详细信息</li>
<li><code>String toString()</code> : 返回异常发生时的简要描述</li>
<li><code>String getLocalizedMessage()</code> : 返回异常对象的本地化信息。使用 <code>Throwable</code> 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage()</code> 返回的结果相同</li>
<li><code>void printStackTrace()</code> : 在控制台上打印 <code>Throwable</code> 对象封装的异常信息</li>
</ul>
<h3 id="1-4-try-catch-finally-如何使用？"><a href="#1-4-try-catch-finally-如何使用？" class="headerlink" title="1.4 try-catch-finally 如何使用？"></a>1.4 try-catch-finally 如何使用？</h3><ul>
<li>try 块：用于捕获异常。其后可接零个或多个 catch 块，<strong>如果没有 catch 块，则必须跟一个 finally 块</strong>。</li>
<li>catch 块：用于处理 try 捕获到的异常。</li>
<li>finally 块：<strong>无论是否捕获或处理异常</strong>，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在<strong>方法返回之前被执行</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Try to do something&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;RuntimeException&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Catch Exception -&gt; &quot;</span> + e.getMessage());</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Finally&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Try to do something</span><br><span class="line">Catch Exception -&gt; RuntimeException</span><br><span class="line">Finally</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：**<em>不要在 finally 语句块中使用 return !</em>** 当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。这是因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(f(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value * value;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure>

<h3 id="1-5-finally-中的代码一定会执行吗？"><a href="#1-5-finally-中的代码一定会执行吗？" class="headerlink" title="1.5 finally 中的代码一定会执行吗？"></a>1.5 finally 中的代码一定会执行吗？</h3><p><strong><em>不一定。</em></strong></p>
<p>如： finally 之前虚拟机被终止， finally 中的代码就不会执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Try to do something&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;RuntimeException&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Catch Exception -&gt; &quot;</span> + e.getMessage());</span><br><span class="line">    <span class="comment">// 终止当前正在运行的Java虚拟机</span></span><br><span class="line">    System.exit(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Finally&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Try to do something</span><br><span class="line">Catch Exception -&gt; RuntimeException</span><br></pre></td></tr></table></figure>

<p>另外，在以下 2 种特殊情况下，finally 块的代码也不会被执行：</p>
<ol>
<li>程序所在线程死亡。</li>
<li>关闭 CPU 。</li>
</ol>
<h3 id="1-6-如何使用-try-with-resources-代替-try-catch-finally？"><a href="#1-6-如何使用-try-with-resources-代替-try-catch-finally？" class="headerlink" title="1.6 如何使用 try-with-resources 代替 try-catch-finally？"></a>1.6 如何使用 try-with-resources 代替 try-catch-finally？</h3><ol>
<li><strong>适用范围 （资源定义）</strong> ： 任何实现 <code>java.lang.AutoCloseable</code> 或者 <code>java.io.Closeable</code> 的对象。</li>
<li><strong>关闭资源和 finally 块的执行顺序</strong> ： 在 <code>try-catch-resources</code> 语句中，任何 catch 或 finally 块在声明的资源关闭后运行。</li>
</ol>
<p>Effective Java 中指出；</p>
<blockquote>
<p>面对必须要关闭的资源，我们总是应该优先使用 <code>try-with-resources</code> 而不是<code>try-finally</code> 。随之产生的代码更简短，更清晰，产生的异常对我们也更有用。 <code>try-with-resources</code> 语句让我们更容易编写必须要关闭的资源的代码，若采用 <code>try-finally</code> 则几乎做不到这点。</p>
</blockquote>
<p>Java 中类似于 <code>InputStream</code> 、 <code>OutputStream</code> 、 <code>Scanner</code> 、 <code>PrintWriter</code> 等的资源都需要我们调用 <code>close()</code> 方法来手动关闭，一般情况下我们都是通过 <code>try-catch-finally</code> 语句来实现这个需求，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取文本文件的内容</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    scanner = <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D://read.txt&quot;</span>));</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (scanner != <span class="literal">null</span>) &#123;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 Java 7 之后的 <code>try-with-resources</code> 语句改造上面的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>))) &#123;</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException fnfe) &#123;</span><br><span class="line">    fnfe.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多个资源需要关闭的时候，使用 <code>try-with-resources</code> 实现起来也非常简单，如果还是用 <code>try-catch-finally</code> 可能会带来很多问题。</p>
<p>通过使用分号分隔，可以在 try-with-resources 块中声明多个资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (</span><br><span class="line">    <span class="type">BufferedInputStream</span> <span class="variable">bin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>)));</span><br><span class="line">    <span class="type">BufferedOutputStream</span> <span class="variable">bout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;out.txt&quot;</span>)))</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="keyword">while</span> ((b = bin.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        bout.write(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-7-异常使用有哪些需要注意的地方？"><a href="#1-7-异常使用有哪些需要注意的地方？" class="headerlink" title="1.7 异常使用有哪些需要注意的地方？"></a>1.7 异常使用有哪些需要注意的地方？</h3><ul>
<li><strong>不要把异常定义为静态变量</strong>，因为这样会导致异常栈信息错乱。每次手动抛出异常，我们都需要手动 new 一个异常对象抛出。</li>
<li>抛出的异常信息一定要<strong>有意义</strong>。</li>
<li>建议<strong>抛出更加具体的异常</strong>，比如字符串转换为数字格式错误的时候应该抛出 NumberFormatException 而不是其父类 IllegalArgumentException。</li>
<li><strong>避免重复记录日志</strong>：如果在捕获异常的地方已经记录了足够的信息（包括异常类型、错误信息和堆栈跟踪等），那么在业务代码中再次抛出这个异常时，就不应该再次记录相同的错误信息。重复记录日志会使得日志文件膨胀，并且可能会掩盖问题的实际原因，使得问题更难以追踪和解决。</li>
<li>……</li>
</ul>
<h2 id="2-泛型"><a href="#2-泛型" class="headerlink" title="2. 泛型"></a>2. 泛型</h2><h3 id="2-1-什么是泛型？有什么作用？"><a href="#2-1-什么是泛型？有什么作用？" class="headerlink" title="2.1 什么是泛型？有什么作用？"></a>2.1 什么是泛型？有什么作用？</h3><p><strong>Java 泛型 （ Generics ）</strong> 是 JDK 5 引入的新特性。使用泛型可以增强代码的可读性和稳定性。</p>
<p>编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。比如 <code>ArrayList&lt;Person&gt; persons = new ArrayList&lt;Person&gt;()</code> 这行代码就指明了该 <code>ArrayList</code> 对象只能传入 <code>Person</code> 对象，如果传入其他类型的对象就会报错。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br></pre></td></tr></table></figure>

<p>并且，原生 List 返回类型是 Object ，需要手动转换类型才能使用，使用泛型后编译器自动转换。</p>
<h3 id="2-2-泛型的使用方式有哪几种？"><a href="#2-2-泛型的使用方式有哪几种？" class="headerlink" title="2.2 泛型的使用方式有哪几种？"></a>2.2 泛型的使用方式有哪几种？</h3><p>泛型一般有三种使用方式: <strong>泛型类、泛型接口、泛型方法</strong> 。</p>
<ol>
<li><p><strong>泛型类</strong> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line"><span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Generic</span>&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Generic</span><span class="params">(T key)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getKey</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何实例化泛型类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Generic&lt;Integer&gt; genericInteger = <span class="keyword">new</span> <span class="title class_">Generic</span>&lt;Integer&gt;(<span class="number">123456</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>泛型接口</strong> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Generator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现泛型接口，不指定类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GeneratorImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;T&gt;&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> T <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现泛型接口，指定类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GeneratorImpl</span> <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;String&gt; &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>泛型方法</strong> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt; E &gt; <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">( E[] inputArray )</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">for</span> ( E element : inputArray )&#123;</span><br><span class="line">        System.out.printf( <span class="string">&quot;%s &quot;</span>, element );</span><br><span class="line">     &#125;</span><br><span class="line">     System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建不同类型数组：Integer, Double 和 Character</span></span><br><span class="line">Integer[] intArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">String[] stringArray = &#123; <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span> &#125;;</span><br><span class="line">printArray( intArray  );</span><br><span class="line">printArray( stringArray  );</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>注意: <code>public static &lt; E &gt; void printArray( E[] inputArray )</code> 一般被称为<strong>静态泛型方法</strong>;在 java 中泛型只是一个占位符，必须在传递类型后才能使用。类在实例化时才能真正的传递类型参数，由于静态方法的加载先于类的实例化，也就是说类中的泛型还没有传递真正的类型参数，静态的方法的加载就已经完成了，所以静态泛型方法是没有办法使用类上声明的泛型的。只能使用自己声明的 <code>&lt;E&gt;</code></p>
</blockquote>
<h3 id="2-3-项目中哪里用到了泛型？"><a href="#2-3-项目中哪里用到了泛型？" class="headerlink" title="2.3 项目中哪里用到了泛型？"></a>2.3 项目中哪里用到了泛型？</h3><ul>
<li>自定义接口通用返回结果 <code>CommonResult&lt;T&gt;</code> 通过参数 T 可根据具体的返回类型动态指定结果的数据类型</li>
<li>定义 Excel 处理类 <code>ExcelUtil&lt;T&gt;</code> 用于动态指定 Excel 导出的数据类型</li>
<li>构建集合工具类（参考 Collections 中的 sort, binarySearch 方法）。</li>
<li>……</li>
</ul>
<h2 id="3-反射"><a href="#3-反射" class="headerlink" title="3. 反射"></a>3. 反射</h2><p>详细解读见 <a href="./%E5%85%B6%E4%BB%96%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9.md">其他重要知识点</a></p>
<h3 id="3-1-什么是反射？"><a href="#3-1-什么是反射？" class="headerlink" title="3.1 什么是反射？"></a>3.1 什么是反射？</h3><p>反射之所以被称为框架的灵魂，主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。</p>
<h3 id="3-2-反射的优缺点？"><a href="#3-2-反射的优缺点？" class="headerlink" title="3.2 反射的优缺点？"></a>3.2 反射的优缺点？</h3><p>反射可以让我们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利。</p>
<p>不过，反射让我们在运行时有了分析操作类的能力的同时，也增加了安全问题，比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。</p>
<p>相关阅读：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/1392351/java-reflection-why-is-it-so-slow">Java Reflection: Why is it so slow?</a> 。</p>
<h3 id="3-3-反射的应用场景？"><a href="#3-3-反射的应用场景？" class="headerlink" title="3.3 反射的应用场景？"></a>3.3 反射的应用场景？</h3><p>像 <code>Spring/Spring Boot、MyBatis</code> 等等框架中都大量使用了反射机制。</p>
<p><strong>这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。</strong></p>
<p>比如下面是通过 JDK 实现动态代理的示例代码，其中就使用了反射类 <code>Method</code> 来调用指定的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DebugInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理类中的真实对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DebugInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before method &quot;</span> + method.getName());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;after method &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外， <strong>注解</strong> 的实现也用到了反射。为什么使用 Spring 的时候 ，一个 <code>@Component</code> 注解就声明了一个类为 Spring Bean 呢？为什么通过一个 <code>@Value</code> 注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？这些都是因为你可以基于反射分析类，然后获取到类&#x2F;属性&#x2F;方法&#x2F;方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。</p>
<h2 id="4-注解"><a href="#4-注解" class="headerlink" title="4. 注解"></a>4. 注解</h2><h3 id="4-1-注解是什么？"><a href="#4-1-注解是什么？" class="headerlink" title="4.1 注解是什么？"></a>4.1 注解是什么？</h3><p><code>Annotation</code> 是 Java 5 开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类、方法或变量，提供某些信息供程序在编译或运行时使用。</p>
<p>注解本质时一个继承了 <code>Annotation</code> 的特殊接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Override</span> <span class="keyword">extends</span> <span class="title class_">Annotation</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK 提供了很多内置的注解 （ <code>@Override , @Deprecated</code> ），同时，我们还可以自定义注解。</p>
<h3 id="4-2-注解的解析方式有几种？"><a href="#4-2-注解的解析方式有几种？" class="headerlink" title="4.2 注解的解析方式有几种？"></a>4.2 注解的解析方式有几种？</h3><p>注解只有被解析之后才会生效，常见的解析方法有两种：</p>
<ul>
<li><p><strong>编译期直接扫描</strong> ：　编译器在编译 Java 代码时扫描对应的注解并处理，比如某个方法使用　<code>@Override</code> 注解，编译器在编译时就会检测当前的方法是否重写了父类对应的方法。</p>
</li>
<li><p><strong>运行期通过反射代理</strong> ： 像框架中自带的注解 （如 Spring 框架的 <code>@Value</code>, <code>@Component</code> ）都是通过反射来进行处理的。</p>
</li>
</ul>
<h2 id="5-SPI"><a href="#5-SPI" class="headerlink" title="5. SPI"></a>5. SPI</h2><p>关于 SPI 的详细解读，请看<a href="./%E5%85%B6%E4%BB%96%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9.md">其他重要知识点</a></p>
<h3 id="5-1-什么是-SPI"><a href="#5-1-什么是-SPI" class="headerlink" title="5.1 什么是 SPI"></a>5.1 什么是 SPI</h3><p>SPI 即 Service Provider Interface ， 字面意思就是“ 服务提供者的接口 ”， 可指：专门提供给服务提供者或者扩展框架功能的开发者去使用的一个接口。</p>
<p>SPI 将服务接口和具体的服务实现分离开，将服务调用方和服务实现者解耦，能提升程序的扩展性、可维护性。修改或替换服务并不需要修改调用方。</p>
<p>很多框架都使用了 Java 的 SPI 机制，如 Spring框架、数据库加载驱动、日志接口以及 Dubbo 的扩展实现等等。</p>
<h3 id="5-2-SPI-和-API-的区别？"><a href="#5-2-SPI-和-API-的区别？" class="headerlink" title="5.2 SPI 和 API 的区别？"></a>5.2 SPI 和 API 的区别？</h3><p><img src="/./asserts/JavaSE%20pt%203/01.png" alt="区别"></p>
<p>一般模块之间都是通过接口进行通讯，因此在服务调用方和服务实现方（也称服务提供者）之间引入一个“接口”。</p>
<ul>
<li><p>当<strong>实现方提供了接口和实现</strong>，我们可以通过调用实现方的接口从而拥有实现方给我们提供的能力，这就是 API。这种情况下，接口和实现都是放在实现方的包中。调用方通过接口调用实现方的功能，而不需要关心具体的实现细节。</p>
</li>
<li><p>当<strong>接口存在于调用方这边时</strong>，这就是 SPI 。由接口调用方确定接口规则，然后由不同的厂商根据这个规则对这个接口进行实现，从而提供服务。</p>
</li>
</ul>
<p>例子： 公司 H 是一家科技公司，新设计了一款芯片，然后现在需要量产了，而市面上有好几家芯片制造业公司，这个时候，只要 H 公司指定好了这芯片生产的标准（定义好了接口标准），那么这些合作的芯片公司（服务提供者）就按照标准交付自家特色的芯片（提供不同方案的实现，但是给出来的结果是一样的）。</p>
<h3 id="5-3-SPI-的优缺点"><a href="#5-3-SPI-的优缺点" class="headerlink" title="5.3 SPI 的优缺点"></a>5.3 SPI 的优缺点</h3><p>通过 SPI 机制能够大大地提高接口设计的灵活性，但是 SPI 机制也存在一些缺点，比如：</p>
<ul>
<li><p>需要遍历加载所有的实现类，不能做到按需加载，这样效率相对较低。</p>
</li>
<li><p>当多个 ServiceLoader 同时 load 时，会有并发问题。</p>
</li>
</ul>
<h2 id="6-序列化和反序列化"><a href="#6-序列化和反序列化" class="headerlink" title="6. 序列化和反序列化"></a>6. 序列化和反序列化</h2><p><a href="./%E5%85%B6%E4%BB%96%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9.md">具体介绍</a></p>
<h3 id="6-1-什么是序列化和反序列化？"><a href="#6-1-什么是序列化和反序列化？" class="headerlink" title="6.1 什么是序列化和反序列化？"></a>6.1 什么是序列化和反序列化？</h3><ul>
<li><p><strong>序列化</strong> ： 将数据或对象转换成可以存储或传输的形式 （通常是二进制字节流， 也可以是 JSON 、 XML 等文本格式）</p>
</li>
<li><p><strong>反序列化</strong> ：将序列化过程中生成的数据转换为原始数据结构或对象的过程。</p>
</li>
</ul>
<p>常见应用场景：</p>
<ul>
<li><p>对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；</p>
</li>
<li><p>将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；</p>
</li>
<li><p>将对象存储到数据库（如 Redis）之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；</p>
</li>
<li><p>将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。</p>
</li>
</ul>
<h3 id="6-2-序列化协议对应-TCP-IP-4层模型的哪一层？"><a href="#6-2-序列化协议对应-TCP-IP-4层模型的哪一层？" class="headerlink" title="6.2 序列化协议对应 TCP&#x2F;IP 4层模型的哪一层？"></a>6.2 序列化协议对应 TCP&#x2F;IP 4层模型的哪一层？</h3><p><img src="/./asserts/JavaSE%20pt%203/02.png" alt="OSI 七层协议"></p>
<p>如上图所示，OSI 七层协议模型中，表示层做的事情主要就是对应用层的用户数据进行处理转换为二进制流。反过来的话，就是将二进制流转换成应用层的用户数据。</p>
<p>OSI 七层协议模型中的应用层、表示层和会话层对应的都是 TCP&#x2F;IP 四层模型中的应用层，所以序列化协议属于 TCP&#x2F;IP 协议应用层的一部分。</p>
<h3 id="6-3-如果有些字段不想序列化怎么办？"><a href="#6-3-如果有些字段不想序列化怎么办？" class="headerlink" title="6.3 如果有些字段不想序列化怎么办？"></a>6.3 如果有些字段不想序列化怎么办？</h3><p>对于不想进行序列化的变量，使用 <code>transient</code> 关键字修饰。</p>
<p><code>transient</code> 关键词的作用是： 阻止实例中使用此关键字的变量序列化；当对象被反序列化时，被 <code>transient</code> 修饰的关键字不会被持久化和恢复。</p>
<p>注意：</p>
<ul>
<li><code>transient</code> 只能修饰变量</li>
<li><code>transient</code> 修饰的变量，在反序列化后变量值会被设置成默认值。</li>
<li><code>static</code> 变量因为不属于任何对象，所以无论有没有 <code>transient</code> 修饰都不会被序列化。</li>
</ul>
<h3 id="6-4-常见的序列化协议"><a href="#6-4-常见的序列化协议" class="headerlink" title="6.4 常见的序列化协议"></a>6.4 常见的序列化协议</h3><p>JDK 自带的序列化方法一般不用，因为序列化效率低且存在安全问题。较常用的序列化协议有 Hession , Kryo , Protobuf , protoStuff ， 这些都是基于二进制的序列化协议。</p>
<p>像 JSON 和 XML 这种属于文本类序列化方式。虽然可读性比较好，但是性能较差，一般不会选择。</p>
<h3 id="6-5-为什么不推荐-JDK-自带的序列化？"><a href="#6-5-为什么不推荐-JDK-自带的序列化？" class="headerlink" title="6.5 为什么不推荐 JDK 自带的序列化？"></a>6.5 为什么不推荐 JDK 自带的序列化？</h3><ul>
<li><strong>不支持跨语言调用</strong></li>
<li><strong>性能差</strong> ： 相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。</li>
<li><strong>存在安全问题</strong> ： 序列化和反序列化本身并不存在问题。但当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码。</li>
</ul>
<h2 id="7-I-O"><a href="#7-I-O" class="headerlink" title="7. I&#x2F;O"></a>7. I&#x2F;O</h2><p><a href="../IO/IO%20%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93.md">基础</a><br><a href="../IO/IO%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93.md">设计模式</a><br><a href="../IO/IO%20%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3.md">模型</a></p>
<h2 id="8-语法糖"><a href="#8-语法糖" class="headerlink" title="8. 语法糖"></a>8. 语法糖</h2><h3 id="8-1-什么是语法糖？"><a href="#8-1-什么是语法糖？" class="headerlink" title="8.1 什么是语法糖？"></a>8.1 什么是语法糖？</h3><p>语法糖（Syntactic sugar） 代指的是编程语言为了方便程序员开发程序而设计的一种特殊语法，这种语法对编程语言的功能并没有影响。实现相同的功能，基于语法糖写出来的代码往往更简单简洁且更易阅读。</p>
<p>JVM 其实并不能识别语法糖，Java 语法糖要想被正确执行，需要先通过编译器进行解糖，也就是在程序编译阶段将其转换成 JVM 认识的基本语法。这也侧面说明，Java 中真正支持语法糖的是 Java 编译器而不是 JVM。如果去看 <code>com.sun.tools.javac.main.JavaCompiler</code> 的源码，会发现在 <code>compile()</code> 中有一个步骤就是调用 <code>desugar()</code> ，这个方法就是负责解语法糖的实现的。</p>
<h3 id="8-2-Java-中常见的语法糖"><a href="#8-2-Java-中常见的语法糖" class="headerlink" title="8.2 Java 中常见的语法糖"></a>8.2 Java 中常见的语法糖</h3><p><a href="./%E5%85%B6%E4%BB%96%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9.md">详解</a></p>
<h2 id="NEXT"><a href="#NEXT" class="headerlink" title="NEXT"></a>NEXT</h2><p><a href="./%E5%85%B6%E4%BB%96%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9.md">下一篇</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-03-25T13:00:29.000Z" title="2025/3/25 21:00:29">2025-03-25</time>发表</span><span class="level-item"><time dateTime="2025-04-06T14:51:14.670Z" title="2025/4/6 22:51:14">2025-04-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%85%AB%E8%82%A1/">八股</a><span> / </span><a class="link-muted" href="/categories/%E5%85%AB%E8%82%A1/JavaSE/">JavaSE</a></span><span class="level-item">1 小时读完 (大约7678个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/03/25/%E5%85%AB%E8%82%A1/Java/Java%E5%9F%BA%E7%A1%80/JavaSE%20pt.2/">JavaSE pt.2</a></p><div class="content"><h2 id="1-面向对象基础"><a href="#1-面向对象基础" class="headerlink" title="1. 面向对象基础"></a>1. 面向对象基础</h2><h3 id="1-1-面向对象和面向过程的区别？"><a href="#1-1-面向对象和面向过程的区别？" class="headerlink" title="1.1 面向对象和面向过程的区别？"></a>1.1 面向对象和面向过程的区别？</h3><p>面向过程（ Procedural-Oriented Programming , POP ） 和面向对象 （ Object-Oriented Programming , OOP ） 是两种常见的编程范式，两者的区别主要是解决问题的不同：</p>
<ul>
<li><strong>面向过程</strong> ： 将解决问题的过程拆成一个一个函数，通过函数的执行解决问题。</li>
<li><strong>面向对象</strong> ： 先抽象出对象，然后用对象执行方法的方式解决问题。</li>
</ul>
<p>相较于 POP ， OOP 程序一般具有以下优点：</p>
<ul>
<li><strong>易维护</strong> ： 由于良好的结构和封装性， OOP 程序通常更容易维护。</li>
<li><strong>易复用</strong> ： 通过继承和多态， OOP 设计使得代码更具复用性，方便扩展功能。</li>
<li><strong>易扩展</strong> ： 模块化设计使系统扩展变的更加容易和灵活。</li>
</ul>
<p>POP 的编程方式通常更为简单和直接，适合处理一些较简单的任务。</p>
<p>POP 和 OOP 的性能差异主要取决于它们的运行机制，而不仅仅是编程范式本身。因此，简单比较两者性能是一个常见误区。（ <a target="_blank" rel="noopener" href="https://github.com/Snailclimb/JavaGuide/issues/431">相关 issue</a> ）</p>
<h3 id="1-2-创建一个对象用什么运算符？对象实体与对象引用有何不同？"><a href="#1-2-创建一个对象用什么运算符？对象实体与对象引用有何不同？" class="headerlink" title="1.2 创建一个对象用什么运算符？对象实体与对象引用有何不同？"></a>1.2 创建一个对象用什么运算符？对象实体与对象引用有何不同？</h3><p><code>new</code> 运算符， <code>new</code> 对象创建对象实例（对象实例在堆内存中）， 对象引用指向对象实例（对象引用存放在栈内存中）。</p>
<ul>
<li>1 个对象引用可以指向 0 个或 1 个对象</li>
<li>一个对象可以有 n 个引用指向它</li>
</ul>
<h3 id="1-3-对象相等和引用相等的区别？"><a href="#1-3-对象相等和引用相等的区别？" class="headerlink" title="1.3 对象相等和引用相等的区别？"></a>1.3 对象相等和引用相等的区别？</h3><ul>
<li>对象的相等一般比较的是内存中查询放的内容是否相等。</li>
<li>引用相等一般比较的是它们指向的内存地址是否相等。</li>
</ul>
<h3 id="1-4-如果一个类没有声明构造方法，该程序能正确执行吗？"><a href="#1-4-如果一个类没有声明构造方法，该程序能正确执行吗？" class="headerlink" title="1.4 如果一个类没有声明构造方法，该程序能正确执行吗？"></a>1.4 如果一个类没有声明构造方法，该程序能正确执行吗？</h3><p>如果一个对象没有声明构造方法，也可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果自己添加了构造方法， Java 就不会添加默认的构造方法了。</p>
<p>如果重载了有参的构造方法，<strong>记得都要把无参的构造方法也写出来</strong>（无论是否用到），因为这可以帮助我们在创建对象的时候少踩坑。</p>
<h3 id="1-5-构造方法有哪些特点？是否可以被-override-？"><a href="#1-5-构造方法有哪些特点？是否可以被-override-？" class="headerlink" title="1.5 构造方法有哪些特点？是否可以被 override ？"></a>1.5 构造方法有哪些特点？是否可以被 <code>override</code> ？</h3><p>特点：</p>
<ul>
<li><strong>名称与类名相同</strong> ： 构造方法的名称必须与类名完全一致</li>
<li><strong>没有返回值</strong> ： 构造方法没有返回类型且不能用 <code>void</code> 声明</li>
<li><strong>自动执行</strong> ： 在生成类的对象时，构造方法会自动执行，无需显式调用</li>
</ul>
<p>构造方法 <strong>不能被重写 （ override ）</strong> ， 但 <strong>可以被重载 （ overload ）</strong> 。</p>
<h3 id="1-6-面向对象三大特征？"><a href="#1-6-面向对象三大特征？" class="headerlink" title="1.6 面向对象三大特征？"></a>1.6 面向对象三大特征？</h3><h4 id="1-6-1-封装"><a href="#1-6-1-封装" class="headerlink" title="1.6.1 封装"></a>1.6.1 封装</h4><p>封装是指将对象的状态信息 （属性） 隐藏在对象内部， 不允许外部对象直接访问。都是可以提供一些可被外界访问的方法来操作属性。</p>
<h4 id="1-6-2-继承"><a href="#1-6-2-继承" class="headerlink" title="1.6.2 继承"></a>1.6.2 继承</h4><p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p>
<p>注意：</p>
<ol>
<li>子类拥有父类对象的所有属性和方法（包括私有属性和方法），但是父类的私有属性和方法子类无法访问， <strong>只是拥有</strong> 。</li>
<li>子类可以拥有自己的属性和方法。</li>
<li>子类可以用自己的方式实现父类的方法。</li>
</ol>
<h4 id="1-6-3-多态"><a href="#1-6-3-多态" class="headerlink" title="1.6.3 多态"></a>1.6.3 多态</h4><p>多态表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</p>
<p>特点：</p>
<ul>
<li>对象类型和引用类型之间具有继承（类） &#x2F; 实现（接口） 关系</li>
<li>引用类型变量发出的方法调用的到底时哪个类中的方法，必须在程序运行期间才能确定</li>
<li>多态不能调用 “只在子类存在但父类不存在的方法”</li>
<li>如果子类重写了父类的方法，真正执行的是子类重写的方法，如果没有，执行的是父类的方法。</li>
</ul>
<h3 id="1-7-接口和抽象类的共同点和区别？"><a href="#1-7-接口和抽象类的共同点和区别？" class="headerlink" title="1.7 接口和抽象类的共同点和区别？"></a>1.7 接口和抽象类的共同点和区别？</h3><p>共同点：</p>
<ul>
<li><strong>实例化</strong> ： 接口和抽象类都不能直接实例化，只能被实现 （接口） 或继承 （抽象类） 后才能创建具体的对象。</li>
<li><strong>抽象方法</strong> ： 接口和抽象类都可以包含抽象方法，抽象方法没有方法体，必须在子类或实现类中实现。</li>
</ul>
<p>区别：</p>
<ul>
<li><strong>设计目的</strong> ：<br>接口主要用于对类的行为进行约束，实现接口就具有对应的行为。<br>抽象类主要用于代码复用，强调的是所属关系。</li>
<li><strong>继承和实现</strong> ：<br>一个类只能继承一个类 （包括抽象类）<br>一个类可以实现多个接口，一个接口也可以继承多个其他接口。</li>
<li><strong>成员变量</strong> ：<br>接口中的成员变量只能是 <code>public static final</code> 类型的，不能被修改且必须有初始值。<br>抽象类的成员变量可以有任何修饰符 （ <code>private</code> , <code>protected</code> , <code>public</code> ） 可以在子类中被重新定义或赋值。</li>
<li><strong>方法</strong> ：<ul>
<li>Java 8 之前，接口中的方法默认为 <code>public abstract</code> ， 也就是只能由方法声明。 自 Java 8 起，可以在接口中定义 <code>default</code> 方法和 <code>static</code> 方法，自 Java 9 起，接口可以包含 <code>private</code> 方法。</li>
<li>抽象类可以包含抽象方法和非抽象方法。抽象方法没有方法体，必须在子类中实现。非抽象方法有具体实现，可以直接在抽象类中使用或在子类中重写。</li>
</ul>
</li>
</ul>
<p>在 Java 8 及以上版本中，接口引入了新的方法类型： <code>default</code> 方法、 <code>static</code> 方法和 <code>private</code> 方法。这些方法让接口的使用更加灵活。</p>
<p>Java 8 引入的 <code>default</code> 方法用于提供接口方法的默认实现，可以在实现类中被覆盖。这样就可以在不修改实现类的情况下向现有接口添加新功能，从而增强接口的扩展性和向后兼容性。</p>
<p>Java 8 引入的 <code>static</code> 方法无法在实现类中被覆盖，只能通过接口名直接调用，类似于类中的静态方法。static 方法通常用于定义一些通用的、与接口相关的工具方法，一般很少用。</p>
<p>Java 9 允许在接口中使用 <code>private</code> 方法。 <code>private</code> 方法可以用于在接口内部共享代码，不对外暴露。</p>
<h3 id="1-8-深拷贝和浅拷贝的区别？什么是引用拷贝？"><a href="#1-8-深拷贝和浅拷贝的区别？什么是引用拷贝？" class="headerlink" title="1.8 深拷贝和浅拷贝的区别？什么是引用拷贝？"></a>1.8 深拷贝和浅拷贝的区别？什么是引用拷贝？</h3><p>深拷贝与浅拷贝的区别：</p>
<ul>
<li><strong>浅拷贝</strong> ： 浅拷贝会在堆上创建一个新的对象（区别与深拷贝的一点），不过，如果元对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，即拷贝对象和原对象共用同一个内部对象。</li>
<li><strong>深拷贝</strong> ： 深拷贝会完全复制整个对象，包括对象所包含的内部对象。</li>
</ul>
<p>实例：</p>
<h4 id="1-8-1-浅拷贝"><a href="#1-8-1-浅拷贝" class="headerlink" title="1.8.1 浅拷贝"></a>1.8.1 浅拷贝</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 省略构造函数、Getter&amp;Setter方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Address <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Address) <span class="built_in">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">    <span class="comment">// 省略构造函数、Getter&amp;Setter方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) <span class="built_in">super</span>.clone();</span><br><span class="line">            <span class="keyword">return</span> person;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;武汉&quot;</span>));</span><br><span class="line"><span class="type">Person</span> <span class="variable">person1Copy</span> <span class="operator">=</span> person1.clone();</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">System.out.println(person1.getAddress() == person1Copy.getAddress());</span><br></pre></td></tr></table></figure>

<p>从输出结构就可以看出， <code>person1</code> 的克隆对象和 <code>person1</code> 使用的仍然是同一个 <code>Address</code> 对象。</p>
<h4 id="1-8-2-深拷贝"><a href="#1-8-2-深拷贝" class="headerlink" title="1.8.2 深拷贝"></a>1.8.2 深拷贝</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Person <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) <span class="built_in">super</span>.clone();</span><br><span class="line">        person.setAddress(person.getAddress().clone());</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;武汉&quot;</span>));</span><br><span class="line"><span class="type">Person</span> <span class="variable">person1Copy</span> <span class="operator">=</span> person1.clone();</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line">System.out.println(person1.getAddress() == person1Copy.getAddress());</span><br></pre></td></tr></table></figure>

<p>从输出结构可以看出，显然 <code>person1</code> 的克隆对象和 <code>person1</code> 包含的 <code>Address</code> 对象已经是不同的了。</p>
<h4 id="1-8-3-引用拷贝"><a href="#1-8-3-引用拷贝" class="headerlink" title="1.8.3 引用拷贝"></a>1.8.3 引用拷贝</h4><p>引用拷贝就是两个不同的引用指向同一个对象。</p>
<img src="./asserts/JavaSE pt 2/001.png">

<h2 id="2-Object"><a href="#2-Object" class="headerlink" title="2. Object"></a>2. Object</h2><h3 id="2-1-Object-类的常见方法有哪些？"><a href="#2-1-Object-类的常见方法有哪些？" class="headerlink" title="2.1 Object 类的常见方法有哪些？"></a>2.1 Object 类的常见方法有哪些？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于创建并返回当前对象的一份拷贝。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实例被垃圾回收器回收的时候触发的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-和-equals-的区别？"><a href="#2-2-和-equals-的区别？" class="headerlink" title="2.2 == 和 equals() 的区别？"></a>2.2 <code>==</code> 和 <code>equals()</code> 的区别？</h3><p><code>==</code> 对基本类型和引用类型的作用是不同的：</p>
<ul>
<li>对基本数据类型， <code>==</code> 比较的是值</li>
<li>对引用数据类型， <code>==</code> 比较的是对象的内存地址</li>
</ul>
<blockquote>
<p>Java 只有值传递，所以对 <code>==</code> 来说，不管是基本数据类型还是引用数据类型，其本质都是比较值。</p>
</blockquote>
<p><code>equals()</code> 不能用于基本数据类型的判断。 <code>equals()</code> 存在于 <code>Object</code> 类中， 因此所有的类都有 <code>equals()</code> 方法。</p>
<p><code>equals()</code> 方法存在两种使用情况：</p>
<ul>
<li>类没有重写： 等价于通过 <code>==</code> 比较对象。</li>
<li>类重写了： 一般都重写 <code>equals()</code> 方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 <code>true</code> (即认为这两个对象相等)。</li>
</ul>
<p><code>String</code> 中的 <code>equals</code> 方法是被重写过的，因为 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址，而 <code>String</code> 的 <code>equals</code> 方法比较的是对象的值。</p>
<p>当创建 <code>String</code> 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 <code>String</code> 对象。</p>
<p><code>String</code> 类 <code>equals()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object anObject)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">anotherString</span> <span class="operator">=</span> (String)anObject;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="type">char</span> v1[] = value;</span><br><span class="line">            <span class="type">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-hashcode-有什么用？"><a href="#2-3-hashcode-有什么用？" class="headerlink" title="2.3 hashcode() 有什么用？"></a>2.3 <code>hashcode()</code> 有什么用？</h3><p><code>hashcode()</code> 的作用是获取哈希值（ <code>int</code> 整形 ）， 也称为散列码，用于确定该对象在哈希表中的索引位置。</p>
<p><code>hashCode()</code> 定义在 JDK 的 <code>Object</code> 类中，这就意味着 <code>Java</code> 中的任何类都包含有 <code>hashCode()</code> 函数。另外需要注意的是： <code>Object</code> 的 <code>hashCode()</code> 方法是本地方法，也就是用 <code>C</code> 语言或 <code>C++</code> 实现的。</p>
<p>散列表存储的是键值对( key-value )，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p>
<h3 id="2-4-为什么要有-hashcode-？"><a href="#2-4-为什么要有-hashcode-？" class="headerlink" title="2.4 为什么要有 hashcode() ？"></a>2.4 为什么要有 <code>hashcode()</code> ？</h3><blockquote>
<p>当把对象加入 <code>HashSet</code> 时， <code>HashSet</code> 会先计算对象的 <code>hashCode</code> 值来判断对象加入的位置，同时也会与其他已经加入的对象的 <code>hashCode</code> 值作比较，如果没有相符的 <code>hashCode</code> ， <code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashCode</code> 值的对象，这时会调用 <code>equals()</code> 方法来检查 <code>hashCode</code> 相等的对象是否真的相同。如果两者相同， <code>HashSet</code> 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 <code>equals</code> 的次数，相应就大大提高了执行速度。<br>—— Head First Java</p>
</blockquote>
<p><code>hashCode()</code> 和 <code>equals()</code> 都是用于比较两个对象是否相等。</p>
<h4 id="2-4-1-为什么-JDK-还要同时提供这两个方法呢？"><a href="#2-4-1-为什么-JDK-还要同时提供这两个方法呢？" class="headerlink" title="2.4.1 为什么 JDK 还要同时提供这两个方法呢？"></a>2.4.1 为什么 JDK 还要同时提供这两个方法呢？</h4><p>在一些容器（比如 <code>HashMap</code> 、 <code>HashSet</code> ）中，有了 <code>hashCode()</code> 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进 <code>HashSet</code> 的过程）</p>
<p>在前面也提到了添加元素进 <code>HashSet</code> 的过程，如果 <code>HashSet</code> 在对比的时候，同样的 <code>hashCode</code> 有多个对象，它会继续使用 <code>equals()</code> 来判断是否真的相同。也就是说 <code>hashCode</code> 帮助我们大大缩小了查找成本。</p>
<h4 id="2-4-2-为什么不只提供-hashCode-方法呢？"><a href="#2-4-2-为什么不只提供-hashCode-方法呢？" class="headerlink" title="2.4.2 为什么不只提供 hashCode() 方法呢？"></a>2.4.2 为什么不只提供 <code>hashCode()</code> 方法呢？</h4><p>因为两个对象的 hashCode 值相等并不代表两个对象就相等。</p>
<p><code>hashCode()</code> 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（ 所谓哈希碰撞也就是指的是不同的对象得到相同的 <code>hashCode</code> )。</p>
<p>总结：</p>
<ul>
<li>两个对象的 <code>hashcode</code> 值相等， 两个对象不一定相等。</li>
<li>两个对象的 <code>hashcode</code> 值相等且 <code>equals()</code> 方法返回 <code>true</code> ，才认为两个对象相等。</li>
<li>两个对象的 <code>hashcode</code> 不相等， 可以直接认为两个对象不相等。</li>
</ul>
<h3 id="2-5-为什么重写-equals-方法时必须重写-hashcode-方法？"><a href="#2-5-为什么重写-equals-方法时必须重写-hashcode-方法？" class="headerlink" title="2.5 为什么重写 equals() 方法时必须重写 hashcode() 方法？"></a>2.5 为什么重写 <code>equals()</code> 方法时必须重写 <code>hashcode()</code> 方法？</h3><p>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p>
<p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象， <code>hashCode</code> 值却不相等。</p>
<p><strong>思考</strong> ： 重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话，使用 <code>HashMap</code> 可能会出现什么问题。</p>
<p>答案：</p>
<p>基础：</p>
<p>会出现 <code>equals</code> 判断相同的对象由于 <code>hashcode</code> 不同导致 <code>hashmap</code> 中存在多个相同的对象。</p>
<p>Deepseek 优化：</p>
<p>当重写 <code>equals()</code> 而未重写 <code>hashCode()</code> 时，使用 <code>HashMap</code> 可能引发以下问题：</p>
<ul>
<li><p>哈希冲突误判： <code>HashMap</code> 通过 <code>hashCode()</code> 确定键值对的存储桶位置。若两个逻辑相等的对象（ <code>equals()</code> 为 <code>true</code> ）产生不同哈希值，它们会被错误分配到不同存储桶，导致 <code>HashMap</code> 无法识别其等价性。</p>
</li>
<li><p>数据重复存储：本应覆盖的键值对会作为不同键被重复存储，例如 <code>map.put(a,1)</code> 和 <code>map.put(b,1)</code> 会形成两个独立条目（ 尽管 <code>a.equals(b) == true</code> ）。</p>
</li>
<li><p>检索数据失败：通过等价对象查询时（ 如 <code>map.get(b)</code> 查询已存入的 <code>a</code> ），由于哈希定位到错误存储桶，可能返回 <code>null</code> 而非预期值。</p>
</li>
<li><p>破坏契约原则：违反 Java 对象契约（ <code>equal</code> 对象必须有相同 <code>hashCode</code> ），导致所有依赖哈希机制的集合类（ <code>HashSet</code> 、 <code>HashTable</code> 等）行为异常。</p>
</li>
</ul>
<p><strong>总结</strong> ：</p>
<ul>
<li><p><code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p>
</li>
<li><p>两个对象有相同的 <code>hashCode</code> 值，他们也不一定是相等的（哈希碰撞）。</p>
</li>
</ul>
<h2 id="3-String"><a href="#3-String" class="headerlink" title="3. String"></a>3. String</h2><h3 id="3-1-String-StringBuffer-StringBuilder-的区别？"><a href="#3-1-String-StringBuffer-StringBuilder-的区别？" class="headerlink" title="3.1 String , StringBuffer , StringBuilder 的区别？"></a>3.1 String , StringBuffer , StringBuilder 的区别？</h3><p><strong>可变性</strong>：</p>
<p><code>String</code> 是不可变的。</p>
<p><code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，最关键的是 <code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法，比如 <code>append</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, CharSequence &#123;</span><br><span class="line">    <span class="type">char</span>[] value;</span><br><span class="line">    <span class="keyword">public</span> AbstractStringBuilder <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> appendNull();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">        ensureCapacityInternal(count + len);</span><br><span class="line">        str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">        count += len;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>线程安全性</strong> ：</p>
<p><code>String</code> 中的对象是不可变的，也就可以理解为常量，<strong>线程安全</strong>。 <code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code> 、 <code>append</code> 、 <code>insert</code> 、 <code>indexOf</code> 等公共方法。 <code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是<strong>线程安全</strong>的。 <code>StringBuilder</code> 并没有对方法进行加同步锁，所以是<strong>非线程安全</strong>的。</p>
<p><strong>性能</strong> ：</p>
<p>每次对 <code>String</code> 类型进行改变时都会生成一个新的 <code>String</code> 对象，然后将指针指向新的对象。 <code>StringBuffer</code> 每次都会对对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10% ~ 15% 的性能提升，但却要冒多线程不安全的风险。</p>
<p>总结：</p>
<ul>
<li>操作少量数据： 用 <code>String</code></li>
<li>单线程操作字符串缓冲区下操作大量数据： <code>StringBuilder</code></li>
<li>多线程操作字符串缓冲区下操作大量数据： <code>StringBuffer</code></li>
</ul>
<h3 id="3-2-String-为什么不可变？"><a href="#3-2-String-为什么不可变？" class="headerlink" title="3.2 String 为什么不可变？"></a>3.2 String 为什么不可变？</h3><p><code>String</code> 类中使用 <code>fianl</code> 关键字修饰字符数组来保存字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：<strong>被 <code>fianl</code> 修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象</strong>。<br>因此， <code>fianl</code> 修饰的数组保存字符串<strong>并不是 <code>String</code> 不可变的根本原因</strong>， 因为这个数组保存的字符串是可变的（ <code>final</code> 修饰引用类型变量的情况）。</p>
</blockquote>
<p><code>String</code> 真正不可变的原因：</p>
<ol>
<li>保存字符串的数组被 <code>final</code> 修饰且为私有的，并且 <code>String</code> 类没有提供&#x2F;暴露修改这个字符串的方法。</li>
<li><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</li>
</ol>
<blockquote>
<p>补充：<br>在 Java 9 之后， <code>String</code> <code>StringBuilder</code> 与 <code>StringBuffer</code> 的实现被改用 <code>byte</code> 数组存储字符串。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable,Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">// @Stable 注解表示变量最多被修改一次，称为“稳定的”。</span></span><br><span class="line">    <span class="meta">@Stable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, CharSequence &#123;</span><br><span class="line">    <span class="type">byte</span>[] value;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Java-9-为何要将-String-的底层实现由-char-改成了-byte"><a href="#Java-9-为何要将-String-的底层实现由-char-改成了-byte" class="headerlink" title="Java 9 为何要将 String 的底层实现由 char[] 改成了 byte[] ?"></a>Java 9 为何要将 <code>String</code> 的底层实现由 <code>char[]</code> 改成了 <code>byte[]</code> ?</h4><p>新版的 <code>String</code> 支持两个编码方案： <code>Latin-1</code> 和 <code>UTF-16</code> 。如果字符串中包含的汉字没有超过 <code>Latin-1</code> 可表示范围内的字符，那就会使用 <code>Latin-1</code> 。 <code>Latin-1</code> 编码方案下， <code>byte</code> 占一个字节（ 8 位 ）， <code>char</code> 占用 2 个字节（ 16 ）， <code>byte</code> 相较 <code>char</code> 节省一半的内存空间。</p>
<img src="./asserts/JavaSE pt 2/002.png">

<p>如果字符串中包含的汉字超过 Latin-1 可表示范围内的字符，byte 和 char 所占用的空间是一样的。</p>
<p><a target="_blank" rel="noopener" href="https://openjdk.org/jeps/254">官方介绍</a></p>
<h3 id="3-3-字符串拼接用-还是-StringBuilder-？"><a href="#3-3-字符串拼接用-还是-StringBuilder-？" class="headerlink" title="3.3 字符串拼接用 + 还是 StringBuilder ？"></a>3.3 字符串拼接用 <code>+</code> 还是 <code>StringBuilder</code> ？</h3><p>Java 语言本身不支持运算符重载， <strong>“+”和“+&#x3D;”是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的运算符</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;he&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;llo&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> str1 + str2 + str3;</span><br></pre></td></tr></table></figure>

<p>对应字节码：</p>
<img src="./asserts/JavaSE pt 2/003.png">

<p>可以看出，字符串对象通过“+”的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</p>
<p>不过，在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：<strong>编译器不会创建单个 <code>StringBuilder</code> 以复用，会导致创建过多的 <code>StringBuilder</code> 对象</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">&quot;he&quot;</span>, <span class="string">&quot;llo&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    s += arr[i];</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure>

<p><code>StringBuilder</code> 对象是在循环内部被创建的，这意味着每循环一次就会创建一个 <code>StringBuilder</code> 对象。</p>
<img src="./asserts/JavaSE pt 2/004.png">

<p>如果直接使用 <code>StringBuilder</code> 对象进行字符串拼接的话，就不会存在这个问题了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">&quot;he&quot;</span>, <span class="string">&quot;llo&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="keyword">for</span> (String value : arr) &#123;</span><br><span class="line">    s.append(value);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure>

<img src="./asserts/JavaSE pt 2/005.png">

<p>在 JDK 9 中，字符串相加“+”改为用动态方法 <code>makeConcatWithConstants()</code> 来实现，通过提前分配空间从而减少了部分临时对象的创建。然而这种优化主要针对简单的字符串拼接，如： <code>a+b+c</code> 。对于循环中的大量拼接操作，仍然会逐个动态分配内存（类似于两个两个 <code>append</code> 的概念），并不如手动使用 <code>StringBuilder</code> 来进行拼接效率高。</p>
<h3 id="3-4-String-equals-和-Object-equals-有什么区别？"><a href="#3-4-String-equals-和-Object-equals-有什么区别？" class="headerlink" title="3.4 String equals() 和 Object equals() 有什么区别？"></a>3.4 String equals() 和 Object equals() 有什么区别？</h3><p>String 中的 equals 方法是被重写过的，比较的是 String 字符串的值是否相等。 Object 的 equals 方法是比较的对象的内存地址。</p>
<h3 id="3-5-字符串常量池的作用？"><a href="#3-5-字符串常量池的作用？" class="headerlink" title="3.5 字符串常量池的作用？"></a>3.5 字符串常量池的作用？</h3><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（ <code>String</code> 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在字符串常量池中创建字符串对象 ”ab“</span></span><br><span class="line"><span class="comment">// 将字符串对象 ”ab“ 的引用赋值给 aa</span></span><br><span class="line"><span class="type">String</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象 ”ab“，赋值给引用 bb</span></span><br><span class="line"><span class="type">String</span> <span class="variable">bb</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">System.out.println(aa==bb); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="3-6-String-s1-new-String-“abc”-这句话创建了几个字符串对象？"><a href="#3-6-String-s1-new-String-“abc”-这句话创建了几个字符串对象？" class="headerlink" title="3.6 String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象？"></a>3.6 String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象？</h3><p>答案：<strong>会创建 1 或 2 个字符串对象</strong>。</p>
<ol>
<li>字符串常量池中不存在 “abc”：会创建 2 个 字符串对象。一个在字符串常量池中，由 ldc 指令触发创建。一个在堆中，由 new String() 创建，并使用常量池中的 “abc” 进行初始化。</li>
<li>字符串常量池中已存在 “abc”：会创建 1 个 字符串对象。该对象在堆中，由 new String() 创建，并使用常量池中的 “abc” 进行初始化。</li>
</ol>
<p>分析：</p>
<ol>
<li>如果字符串常量池中不存在字符串对象 “abc”，那么它首先会在字符串常量池中创建字符串对象 “abc”，然后在堆内存中再创建其中一个字符串对象 “abc”。</li>
</ol>
<p>字节码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在堆内存中分配一个尚未初始化的 String 对象。</span></span><br><span class="line"><span class="comment">// #2 是常量池中的一个符号引用，指向 java/lang/String 类。</span></span><br><span class="line"><span class="comment">// 在类加载的解析阶段，这个符号引用会被解析成直接引用，即指向实际的 java/lang/String 类。</span></span><br><span class="line"><span class="number">0</span> <span class="keyword">new</span> #<span class="number">2</span> &lt;java/lang/String&gt;</span><br><span class="line"><span class="comment">// 复制栈顶的 String 对象引用，为后续的构造函数调用做准备。</span></span><br><span class="line"><span class="comment">// 此时操作数栈中有两个相同的对象引用：一个用于传递给构造函数，另一个用于保持对新对象的引用，后续将其存储到局部变量表。</span></span><br><span class="line"><span class="number">3</span> dup</span><br><span class="line"><span class="comment">// JVM 先检查字符串常量池中是否存在 &quot;abc&quot;。</span></span><br><span class="line"><span class="comment">// 如果常量池中已存在 &quot;abc&quot;，则直接返回该字符串的引用；</span></span><br><span class="line"><span class="comment">// 如果常量池中不存在 &quot;abc&quot;，则 JVM 会在常量池中创建该字符串字面量并返回它的引用。</span></span><br><span class="line"><span class="comment">// 这个引用被压入操作数栈，用作构造函数的参数。</span></span><br><span class="line"><span class="number">4</span> ldc #<span class="number">3</span> &lt;abc&gt;</span><br><span class="line"><span class="comment">// 调用构造方法，使用从常量池中加载的 &quot;abc&quot; 初始化堆中的 String 对象</span></span><br><span class="line"><span class="comment">// 新的 String 对象将包含与常量池中的 &quot;abc&quot; 相同的内容，但它是一个独立的对象，存储于堆中。</span></span><br><span class="line"><span class="number">6</span> invokespecial #<span class="number">4</span> &lt;java/lang/String.&lt;init&gt; : (Ljava/lang/String;)V&gt;</span><br><span class="line"><span class="comment">// 将堆中的 String 对象引用存储到局部变量表</span></span><br><span class="line"><span class="number">9</span> astore_1</span><br><span class="line"><span class="comment">// 返回，结束方法</span></span><br><span class="line"><span class="number">10</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<h3 id="3-7-String-intern-方法有什么用？"><a href="#3-7-String-intern-方法有什么用？" class="headerlink" title="3.7 String intern 方法有什么用？"></a>3.7 String intern 方法有什么用？</h3><p><code>String.intern()</code> 是一个 <code>native</code> 方法，用于处理字符串常量池中的对象引用。工作流程：</p>
<ol>
<li><strong>常量池中已有相同内容的字符串对象</strong> ： 如果字符串常量池中已经有一个与调用 <code>intern()</code> 方法的字符串内容相同的对象， <code>intern()</code> 返回常量池中该对象的引用。</li>
<li><strong>常量池中没有相同内容的字符串对象</strong> ： <code>intern()</code> 方法会将当前字符串对象的引用添加到字符串常量池中，并返回该引用。</li>
</ol>
<p>总结：</p>
<ul>
<li><code>intern()</code> 方法的主要作用是确保字符串引用在常量池中的唯一性。</li>
<li>当调用 <code>intern()</code> 时，如果常量池中已经存在相同内容的字符串，则返回常量池中已有对象的引用；否则，将该字符串添加到常量池并返回其引用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s1 指向字符串常量池中的 &quot;Java&quot; 对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Java&quot;</span>;</span><br><span class="line"><span class="comment">// s2 也指向字符串常量池中的 &quot;Java&quot; 对象，和 s1 是同一个对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.intern();</span><br><span class="line"><span class="comment">// 在堆中创建一个新的 &quot;Java&quot; 对象，s3 指向它</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line"><span class="comment">// s4 指向字符串常量池中的 &quot;Java&quot; 对象，和 s1 是同一个对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s3.intern();</span><br><span class="line"><span class="comment">// s1 和 s2 指向的是同一个常量池中的对象</span></span><br><span class="line">System.out.println(s1 == s2); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// s3 指向堆中的对象，s4 指向常量池中的对象，所以不同</span></span><br><span class="line">System.out.println(s3 == s4); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// s1 和 s4 都指向常量池中的同一个对象</span></span><br><span class="line">System.out.println(s1 == s4); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="3-8-String-类型的变量和常量做-“-”-运算时发生了什么？"><a href="#3-8-String-类型的变量和常量做-“-”-运算时发生了什么？" class="headerlink" title="3.8 String 类型的变量和常量做 “+” 运算时发生了什么？"></a>3.8 String 类型的变量和常量做 “+” 运算时发生了什么？</h3><p><strong>不加 <code>final</code> 关键词</strong> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> str1 + str2;</span><br><span class="line"><span class="type">String</span> <span class="variable">str5</span> <span class="operator">=</span> <span class="string">&quot;string&quot;</span>;</span><br><span class="line">System.out.println(str3 == str4);<span class="comment">//false</span></span><br><span class="line">System.out.println(str3 == str5);<span class="comment">//true</span></span><br><span class="line">System.out.println(str4 == str5);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong> ：比较 String 字符串的值是否相等，可以使用 <code>equals()</code> 方法。 String 中的 <code>equals</code> 方法是被重写过的。 Object 的 equals 方法是比较的对象的<strong>内存地址</strong>，而 String 的 equals 方法比较的是<strong>字符串的值是否相等</strong>。如果你使用 &#x3D;&#x3D; 比较两个字符串是否相等的话，IDEA 还是提示你使用 equals() 方法替换。</p>
</blockquote>
<p><strong>对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。</strong></p>
<p>在编译过程中，Javac 编译器（下文中统称为编译器）会进行一个叫做 常量折叠(Constant Folding) 的代码优化。</p>
<p>常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。</p>
<p>对于 <code>String str3 = &quot;str&quot; + &quot;ing&quot;;</code> 编译器会优化成 <code>String str3 = &quot;string&quot;;</code> 。</p>
<p>并不是所有的常量都会进行折叠，只有编译器在程序编译期就可以确定值的常量才可以：</p>
<ul>
<li>基本数据类型( byte、boolean、short、char、int、float、long、double)以及字符串常量。</li>
<li>final 修饰的基本数据类型和字符串变量</li>
<li>字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（&lt;&lt;、&gt;&gt;、&gt;&gt;&gt; ）</li>
</ul>
<p><strong>引用的值在程序编译期是无法确定的，编译器无法对其进行优化。</strong></p>
<p>对象引用和“+”的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>().append(str1).append(str2).toString();</span><br></pre></td></tr></table></figure>

<p>在平时写代码的时候，尽量避免多个字符串对象拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 <code>StringBuilder</code> 或者 <code>StringBuffer</code> 。</p>
<p>不过，<strong>字符串使用 final 关键字声明之后</strong>，可以让编译器当做常量来处理 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"><span class="comment">// 下面两个表达式其实是等价的</span></span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;<span class="comment">// 常量池中的对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> str1 + str2; <span class="comment">// 常量池中的对象</span></span><br><span class="line">System.out.println(c == d);<span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>被 <code>final</code> 关键字修饰之后的 <code>String</code> 会被编译器当做常量来处理，编译器在程序编译期就可以确定它的值，其效果就相当于访问常量。</p>
<h2 id="NEXT"><a href="#NEXT" class="headerlink" title="NEXT"></a>NEXT</h2><p><a href="JavaSE%20pt.3.md">JavaSE pt.3</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-03-10T14:42:26.000Z" title="2025/3/10 22:42:26">2025-03-10</time>发表</span><span class="level-item"><time dateTime="2025-04-06T14:51:24.561Z" title="2025/4/6 22:51:24">2025-04-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%85%AB%E8%82%A1/">八股</a><span> / </span><a class="link-muted" href="/categories/%E5%85%AB%E8%82%A1/JavaSE/">JavaSE</a></span><span class="level-item">1 小时读完 (大约9587个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/03/10/%E5%85%AB%E8%82%A1/Java/Java%E5%9F%BA%E7%A1%80/JavaSE%20pt.1/">JavaSE pt.1</a></p><div class="content"><p>First tip：<br>根据 <strong>JavaGuide</strong> 和 <strong>Deepseek</strong> 内容整理</p>
<h2 id="1-基础概念与常识"><a href="#1-基础概念与常识" class="headerlink" title="1. 基础概念与常识"></a>1. 基础概念与常识</h2><h3 id="1-1-Java-语言有哪些特点？"><a href="#1-1-Java-语言有哪些特点？" class="headerlink" title="1.1 Java 语言有哪些特点？"></a>1.1 Java 语言有哪些特点？</h3><ol>
<li>简单易学（语法简单，容易上手）</li>
<li>面向对象（封装、继承、多态）</li>
<li>平台无关（Java 虚拟机）</li>
<li>支持多线程</li>
<li>可靠性（异常处理、GC）</li>
<li>安全性（访问权限修饰符、限制程序直接访问系统资源）</li>
<li>高效性（通过 <strong>JIT</strong>[^JIT] 编译器等技术优化）</li>
<li>支持网络编程</li>
<li>编译与解释并存</li>
</ol>
<p>[^JIT]: <strong>JIT</strong> 即 “Just in Time”</p>
<blockquote>
<p>拓展：<br>“Write once, Run everywhere” ，即跨平台这一特点已经不再是 Java 的主要特点了（ <strong>Docker</strong> 等技术的出现使跨平台相当轻松）。Java 的优势转变为了其强大的生态。</p>
</blockquote>
<h3 id="1-2-JavaSE-和-JavaEE"><a href="#1-2-JavaSE-和-JavaEE" class="headerlink" title="1.2 JavaSE 和 JavaEE"></a>1.2 JavaSE 和 JavaEE</h3><ul>
<li><p>JavaSE ( <em>Java Platform, Standard Edition</em> )： Java 编程语言的基础，包含了支持 Java 程序开发和运行的核心类库以及 JVM 等核心组件。可以用于构建桌面应用程序或简单的服务器应用程序。</p>
</li>
<li><p>JavaEE ( <em>Java Platform, Enterprise Edition</em> )：建立在 JavaSE 的基础上，包含了支持企业级应用开发和部署的标准与规范（ Servlet、 JSP、 EJB、 JDBC、 JPA、 JTA 等）。可以用于构建分布式、可移植、健壮、可伸缩和安全的服务端 Java 应用程序。</p>
</li>
</ul>
<p>简单来说，Java SE 是 Java 的基础版本，Java EE 是 Java 的高级版本。Java SE 更适合开发桌面应用程序或简单的服务器应用程序，Java EE 更适合开发复杂的企业级应用程序或 Web 应用程序。</p>
<h3 id="1-3-JVM、JDK、JRE"><a href="#1-3-JVM、JDK、JRE" class="headerlink" title="1.3 JVM、JDK、JRE"></a>1.3 JVM、JDK、JRE</h3><h4 id="1-3-1-JVM"><a href="#1-3-1-JVM" class="headerlink" title="1.3.1 JVM"></a>1.3.1 JVM</h4><p>JVM ( <em>Java Virtual Machine</em> ) 是运行 <strong>Java 字节码</strong> 的虚拟机。JVM 有针对不同系统的实现，目的是使用相同的字节码得到相同的结果。字节码和 JVM 是实现 Java 语言 “Write once, Run everywhere” 的关键。</p>
<p><strong>JVM 不止一种，只要满足 JVM 规范，每个公司、组织或者个人都可以开发自己的专属 JVM。</strong> 我们平时接触到的 <em>HotSpotVM</em> 只是 JVM 规范的一种实现。</p>
<p>除了 HotSpotVM 外，还有 <em>J9 VM, Zing VM, JRockit VM</em> 等实现。</p>
<h4 id="1-3-2-JDK-和-JRE"><a href="#1-3-2-JDK-和-JRE" class="headerlink" title="1.3.2 JDK 和 JRE"></a>1.3.2 JDK 和 JRE</h4><p>JDK( <em>Java Development Kit</em> )是 Java 开发工具包，用于创建和编译 Java 程序。它包含了 JRE ( <em>Java Runtime Environment</em> ) 以及编译器 Javac 和其他工具 ( <em>javadoc, jdb（调试器）, jconsole（监控工具）, javap(反编译工具)</em> )。</p>
<p>JRE 是运行已编译的 Java 程序所需的环境，包括：</p>
<ul>
<li>JVM</li>
<li>Java 基础类库 ( <em>Class Library</em> )：一组标准类库，提供常用的功能和 API（如 <em>I&#x2F;O 操作、 网络通信、 数据结构</em> 等）</li>
</ul>
<p>简单来说，JRE 只包含运行 Java 程序所需的环境和类库，而 JDK 不仅包含 JRE ，还包括用于开发和调试的工具。</p>
<p>不过，从 JDK 9 开始，就不需要区分 JDK 和 JRE 的关系了，取而代之的是模块系统（ JDK 被重新组织成 94 个模块）+ <a target="_blank" rel="noopener" href="https://openjdk.org/jeps/282">jlink</a> 工具 (随 Java 9 一起发布的新命令行工具，用于生成自定义 Java 运行时映像，该映像仅包含给定应用程序所需的模块) 。并且，从 JDK 11 开始，Oracle 不再提供单独的 JRE 下载。</p>
<p>可以用 jlink 根据自己的需求，创建一个更小的 runtime ，而不是都使用同样的 JRE 。</p>
<p>定制的、模块化的 Java 运行时映像有助于简化 Java 应用的部署和节省内存、增强安全性和可维护性。</p>
<h3 id="1-4-什么是字节码？采用字节码的好处是什么？"><a href="#1-4-什么是字节码？采用字节码的好处是什么？" class="headerlink" title="1.4 什么是字节码？采用字节码的好处是什么？"></a>1.4 什么是字节码？采用字节码的好处是什么？</h3><p>在 Java 中，能被 JVM 理解的代码（即扩展名为 <code>.class</code> 的文件）就是字节码，它不面向任何特定的处理器，只面向虚拟机。字节码在一定程度上解决了传统解释型语言执行效率低的问题，保留了解释型语言可移植的特点。因此 Java 程序无需重新编译便可在多种不同操作系统上运行。</p>
<img src="./asserts/JavaSE pt 1/001.png">

<p><code>.class -&gt; 机器码</code> 这一步 JVM 类加载器 首先加载字节码文件，然后通过解释器逐行解释执行，这种方式执行速度相对较慢。而且，有些方法和代码块经常需要被调用（即热点代码），所以后来引进了 <strong>JIT</strong> ( <em>Just In Time Compilation</em> )编译器， 而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。这也解释了为什么经常说 <strong>Java 是编译与解释共存的语言</strong>。</p>
<img src="./asserts/JavaSE pt 1/002.png">

<blockquote>
<p>HotSpot 采用了<strong>惰性评估 ( Lazy Evaluation )</strong> 的做法，根据二八定律，消耗大部分系统资源的只有一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。</p>
</blockquote>
<img src="./asserts/JavaSE pt 1/003.png">

<img src="./asserts/JavaSE pt 1/004.png">

<h3 id="1-5-为什么说-Java-语言-“编译与解释并存”-？"><a href="#1-5-为什么说-Java-语言-“编译与解释并存”-？" class="headerlink" title="1.5 为什么说 Java 语言 “编译与解释并存” ？"></a>1.5 为什么说 Java 语言 “编译与解释并存” ？</h3><p>该问题在 <a href="#14-%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E8%8A%82%E7%A0%81%E9%87%87%E7%94%A8%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88">上一问</a> 已经提到过。</p>
<h4 id="1-5-1-分类"><a href="#1-5-1-分类" class="headerlink" title="1.5.1 分类"></a>1.5.1 分类</h4><p>我们可以将高级语言按照程序的执行方式分为两类：</p>
<ul>
<li><p><strong>编译型</strong>： <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%B7%A8%E8%AD%AF%E8%AA%9E%E8%A8%80">编译型语言</a> 会通过 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%B7%A8%E8%AD%AF%E5%99%A8">编译器</a> 将源代码一次性翻译成机器码。一般编译型语言执行速度较快，开发效率较低。</p>
</li>
<li><p><strong>解释型</strong>： <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%9B%B4%E8%AD%AF%E8%AA%9E%E8%A8%80">解释型语言</a> 会通过 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%9B%B4%E8%AD%AF%E5%99%A8">解释器</a> 一句一句的将代码解释（interpret）为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。</p>
</li>
</ul>
<blockquote>
<p>为了改善解释语言的效率而发展出的即时编译技术，已经缩小了这两种语言间的差距。这种技术混合了编译语言与解释型语言的优点，它像编译语言一样，先把程序源代码编译成字节码。到执行期时，再将字节码直译，之后执行。Java 与 LLVM 是这种技术的代表产物。</p>
</blockquote>
<h4 id="1-5-2-为什么说-Java-语言-“编译与解释并存”-？"><a href="#1-5-2-为什么说-Java-语言-“编译与解释并存”-？" class="headerlink" title="1.5.2 为什么说 Java 语言 “编译与解释并存” ？"></a>1.5.2 为什么说 Java 语言 “编译与解释并存” ？</h4><p>这是因为 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（.class 文件），这种字节码必须由 Java 解释器来解释执行。</p>
<h3 id="1-6-AOT-有什么优点？为什么不全部使用-AOT-？"><a href="#1-6-AOT-有什么优点？为什么不全部使用-AOT-？" class="headerlink" title="1.6 AOT 有什么优点？为什么不全部使用 AOT ？"></a>1.6 AOT 有什么优点？为什么不全部使用 AOT ？</h3><p>JDK9 引入了新的编译模式 <strong>AOT</strong> ( <em>Ahead Of Time Compilation</em> ) 。 和 JIT 不同的是，这种编译模式会在程序被执行前就将其编译成机器码，属于静态编译（ C、C++、Rust、Go 等语言就是静态编译）。AOT 避免了 JIT 预热等各方面的开销，可以提高 Java 程序的启动速度，避免预热时间过长。并且， AOT 还能减少内存占用和增强 Java 程序的安全性 （ AOT 编译后的代码不容易被反编译和修改）， 特别适合云原生场景。</p>
<img src="./asserts/JavaSE pt 1/005.png">

<p>可以看出， AOT 的主要优势在于启动时间、内存占用和打包体积。 JIT 的主要优势在于具备更高的极限处理能力，可以降低请求的最大延迟。</p>
<h4 id="1-6-1-既然-AOT-有那么多优点，为什么不全部使用-AOT-？"><a href="#1-6-1-既然-AOT-有那么多优点，为什么不全部使用-AOT-？" class="headerlink" title="1.6.1 既然 AOT 有那么多优点，为什么不全部使用 AOT ？"></a>1.6.1 既然 AOT 有那么多优点，为什么不全部使用 AOT ？</h4><p>JIT 和 AOT 各有优点， AOT 更适合云原生场景，对微服务架构的支持也比较友好。除此之外， AOT 编译无法支持 Java 的一些动态特性，如反射、动态代理、动态加载、 JNI ( <em>Java Native Interface</em> ) 等。然而，很多框架和库（如 <em>Spring</em> 、 <em>CGLIB</em> ）都用到了这些特性。如果只使用 AOT 编译，那就无法使用这些库和框架了，或者说需要针对性地去做适配和优化。</p>
<h3 id="1-7-Oracle-JDK-和-OpenJDK"><a href="#1-7-Oracle-JDK-和-OpenJDK" class="headerlink" title="1.7 Oracle JDK 和 OpenJDK"></a>1.7 Oracle JDK 和 OpenJDK</h3><p>Oracle 官方在 2012 年的博客：</p>
<blockquote>
<p>问：OpenJDK 存储库中的源代码与用于构建 Oracle JDK 的代码之间有什么区别？<br>答：非常接近 - 我们的 Oracle JDK 版本构建过程基于 OpenJDK 7 构建，只添加了几个部分，例如部署代码，其中包括 Oracle 的 Java 插件和 Java WebStart 的实现，以及一些闭源的第三方组件，如图形光栅化器，一些开源的第三方组件，如 Rhino，以及一些零碎的东西，如附加文档或第三方字体。展望未来，我们的目的是开源 Oracle JDK 的所有部分，除了我们考虑商业功能的部分。</p>
</blockquote>
<p>OracleJDK 和 OpenJDK 的区别：</p>
<ol>
<li><p>是否开源： OpenJDK 是一个完全开源的参考模型，而 Oracle JDK 是基于 OpenJDK 实现的，并非完全开源。OpenJDK 开源项目：<a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk">Github</a> 。</p>
</li>
<li><p>是否免费： OracleJDK 提供免费版本，但一般有时间限制。 JDK17 之后的版本可以免费分发和商用，但仅有 3 年时间， 3 年后无法免费商用。不过，JDK8u221 之前只要不升级可以无限期免费。 OpenJDK 是完全免费的。</p>
</li>
<li><p>功能性： OracleJDK 在 OpenJDK 的基础上添加了一些特有的功能和工具，比如 <em>Java Flight Recorder ( JFR ， 一种监控工具 )</em> 、 <em>Java Mission Control ( JMC ，一种监控工具 )</em> 等工具。不过，在 Java 11 之后， OracleJDK 和 OpenJDK 的功能基本一致，之前 OracleJDK 中的私有组件大部分也已经被捐赠给开源组织。</p>
</li>
<li><p>稳定性： OpenJDK 不提供 LTS 服务， 而 OracleJDK 大概每三年都会推出一个 LTS 版本进行长期支持。不过，很多公司都基于 OpenJDK 提供了对应的和 OracleJDK 周期相同的 LTS 版本。因此，两者的稳定性其实差不多。</p>
</li>
<li><p>协议： OracleJDK 使用 BCL&#x2F;OTN 协议， 而 OpenJDK 根据 GPLv2 许可获得许可。</p>
</li>
</ol>
<blockquote>
<p>既然 Oracle JDK 这么好，那为什么还要有 OpenJDK？</p>
<ol>
<li>OpenJDK 是开源的，开源意味着你可以对它根据你自己的需要进行修改、优化，比如 Alibaba 基于 OpenJDK 开发了 <a target="_blank" rel="noopener" href="https://github.com/alibaba/dragonwell8">Dragonwell8</a>。</li>
<li>OpenJDK 是商业免费的（这也是为什么通过 yum 包管理器上默认安装的 JDK 是 OpenJDK 而不是 Oracle JDK）。虽然 Oracle JDK 也是商业免费（比如 JDK 8），但并不是所有版本都是免费的。</li>
<li>OpenJDK 更新频率更快。Oracle JDK 一般是每 6 个月发布一个新版本，而 OpenJDK 一般是每 3 个月发布一个新版本。（现在你知道为啥 Oracle JDK 更稳定了吧，先在 OpenJDK 试试水，把大部分问题都解决掉了才在 Oracle JDK 上发布）</li>
</ol>
</blockquote>
<h4 id="1-7-1-Oracle-JDK-和-OpenJDK-如何选择？"><a href="#1-7-1-Oracle-JDK-和-OpenJDK-如何选择？" class="headerlink" title="1.7.1 Oracle JDK 和 OpenJDK 如何选择？"></a>1.7.1 Oracle JDK 和 OpenJDK 如何选择？</h4><p>建议选择 OpenJDK 或者基于 OpenJDK 的发行版，比如 AWS 的 Amazon Corretto，阿里巴巴的 Alibaba Dragonwell。</p>
<h3 id="1-8-C-和-Java-的区别？"><a href="#1-8-C-和-Java-的区别？" class="headerlink" title="1.8 C++ 和 Java 的区别？"></a>1.8 C++ 和 Java 的区别？</h3><p>虽然 Java 和 C++ 都是面向对象的语言，但是它们有挺多不同的地方：</p>
<ul>
<li>Java 不提供指针直接访问内存，程序内存更安全。</li>
<li>Java 是单继承的， C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以。</li>
<li>Java 有自动内存管理垃圾回收机制（GC），不需要程序员手动释放无用内存。</li>
<li>C++ 同时支持方法重载和操作符重载， Java 只支持方法重载（操作符重载增加了复杂性）。</li>
</ul>
<h2 id="2-基本语法"><a href="#2-基本语法" class="headerlink" title="2. 基本语法"></a>2. 基本语法</h2><h3 id="2-1-注释有哪几种形式？"><a href="#2-1-注释有哪几种形式？" class="headerlink" title="2.1 注释有哪几种形式？"></a>2.1 注释有哪几种形式？</h3><ol>
<li>单行注释</li>
<li>多行注释</li>
<li>文档注释</li>
</ol>
<p>用得较多的是<strong>单行注释和文档注释</strong>，多行注释在开发中使用的相对较少。</p>
<blockquote>
<p><strong>代码的注释不是越详细越好。实际上好的代码本身就是注释，我们要尽量规范和美化自己的代码来减少不必要的注释。</strong><br><strong>若编程语言足够有表达力，就不需要注释，尽量通过代码来阐述。</strong><br>例子：<br>去掉下面复杂的注释，只需要创建一个与注释所言同一事物的函数即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// check to see if the employee is eligible for full benefits</span></span><br><span class="line"><span class="keyword">if</span> ((employee.flags &amp; HOURLY_FLAG) &amp;&amp; (employee.age &gt; <span class="number">65</span>))</span><br></pre></td></tr></table></figure>

<p>应替换为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (employee.isEligibleForFullBenefits())</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="2-2-标识符和关键字的区别是什么？"><a href="#2-2-标识符和关键字的区别是什么？" class="headerlink" title="2.2 标识符和关键字的区别是什么？"></a>2.2 标识符和关键字的区别是什么？</h3><p>简单来说，<strong>标识符就是一个名字</strong>。</p>
<p>有一些标识符， Java 语言已经赋予其特殊的含义，只能在特定的地方使用，这些标识符就是 <strong>关键字</strong> 。 简单来说， <strong>关键字就是被赋予特殊含义的标识符</strong>。</p>
<h4 id="2-2-1-Java-语言的关键字有哪些？"><a href="#2-2-1-Java-语言的关键字有哪些？" class="headerlink" title="2.2.1 Java 语言的关键字有哪些？"></a>2.2.1 Java 语言的关键字有哪些？</h4><table>
<thead>
<tr>
<th>分类</th>
<th>关键 字</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>访问控制</td>
<td>private</td>
<td>protected</td>
<td>public</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>类、方法和变量修饰符</td>
<td>abstract</td>
<td>class</td>
<td>extends</td>
<td>final</td>
<td>implements</td>
<td>interface</td>
<td>native</td>
</tr>
<tr>
<td></td>
<td>new</td>
<td>static</td>
<td>strictfp</td>
<td>synchronized</td>
<td>transient</td>
<td>volatile</td>
<td>enum</td>
</tr>
<tr>
<td>程序控制</td>
<td>break</td>
<td>continue</td>
<td>return</td>
<td>do</td>
<td>while</td>
<td>if</td>
<td>else</td>
</tr>
<tr>
<td></td>
<td>for</td>
<td>instanceof</td>
<td>switch</td>
<td>case</td>
<td>default</td>
<td>assert</td>
<td></td>
</tr>
<tr>
<td>错误处理</td>
<td>try</td>
<td>catch</td>
<td>throw</td>
<td>throws</td>
<td>finally</td>
<td></td>
<td></td>
</tr>
<tr>
<td>包相关</td>
<td>import</td>
<td>package</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>基本类型</td>
<td>boolean</td>
<td>byte</td>
<td>char</td>
<td>double</td>
<td>float</td>
<td>int</td>
<td>long</td>
</tr>
<tr>
<td></td>
<td>short</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>变量引用</td>
<td>super</td>
<td>this</td>
<td>void</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>保留字</td>
<td>goto</td>
<td>const</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>Tips: 所有的关键字都是小写的，在 IDE 中以特殊颜色显示<br><code>default</code> 这个关键字既属于程序控制，也属于类、方法和变量修饰符。</p>
<ul>
<li>在程序控制中，当在 <code>switch</code> 中匹配不到任何情况时，可以使用 <code>default</code> 编写默认匹配的情况。</li>
<li>在类、方法和变量修饰符中，从 JDK8 开始引入了默认方法，可以使用 <code>default</code> 关键字来定义一个方法的默认实现。</li>
<li>在访问控制中，如果一个方法前没有任何修饰符，则默认会有一个修饰符 <code>default</code> ，但是这个修饰符加上就会报错。</li>
</ul>
</blockquote>
<p><strong>注意</strong>： 虽然 <code>true</code> , <code>false</code> 和 <code>null</code> 看起来像关键字但实际上它们只是字面量，不可以作为标识符使用。</p>
<p>官方文档：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html">https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html</a></p>
<h3 id="2-3-自增自减运算符"><a href="#2-3-自增自减运算符" class="headerlink" title="2.3 自增自减运算符"></a>2.3 自增自减运算符</h3><p>Java 提供了自增 ( <code>++</code> ) 和自减 ( <code>--</code> ) 运算符来简化操作。</p>
<p><code>++</code> 和 <code>--</code> 运算符可以放在变量前后：</p>
<ul>
<li><strong>前缀</strong>： 先自增（减）变量的值，然后再使用该变量。</li>
<li><strong>后缀</strong>： 先使用该变量，再自增（减）。</li>
</ul>
<p>笔试题：</p>
<p>运行该代码后 <code>a</code> , <code>b</code> , <code>c</code> , <code>d</code> 和 <code>e</code> 分别为？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line"><span class="comment">// 1 --&gt; a = 9</span></span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a++;</span><br><span class="line"><span class="comment">// 2 --&gt; a = 10 , b = 9</span></span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ++a;</span><br><span class="line"><span class="comment">// 3 --&gt; a = 11 , b = 9 , c = 11</span></span><br><span class="line"><span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> c--;</span><br><span class="line"><span class="comment">// 4 --&gt; a = 11 , b = 9 , c = 10 , d = 11</span></span><br><span class="line"><span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> --d;</span><br><span class="line"><span class="comment">// 5 --&gt; a = 11 , b = 9 , c = 10 , d = 10 , e = 10</span></span><br></pre></td></tr></table></figure>

<p>答案： <code>a = 11</code> 、<code>b = 9</code> 、 <code>c = 10</code> 、 <code>d = 10</code> 、 <code>e = 10</code> 。具体过程看注释。</p>
<h3 id="2-3-移位运算符"><a href="#2-3-移位运算符" class="headerlink" title="2.3 移位运算符"></a>2.3 移位运算符</h3><p>移位运算符是最基本的运算符之一，几乎每种编程语言都包含这一运算符。移位操作中，被操作的数据被视为二进制数，移位就是将其向左或向右移动若干位的运算。</p>
<p>移位运算符在各种框架以及 JDK 自身的源码中使用还是挺广泛的，HashMap（JDK1.8） 中的 hash 方法的源码就用到了移位运算符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class="line">    <span class="comment">// ^：按位异或</span></span><br><span class="line">    <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用移位运算符的主要原因：</strong></p>
<ol>
<li><strong>高效</strong> ： 移位运算符直接对应处理器的移位指令，这些指令通常在一个时钟周期内完成。</li>
<li><strong>节省内存</strong> ： 通过移位操作可以使一个整数存储多个布尔值或标志位。</li>
</ol>
<p>移位运算符最常用于快速乘以或除以 2 的幂次方。除此之外，它还在以下方面发挥着重要作用：</p>
<ul>
<li><strong>位字段管理</strong> ： 存储和操作多个布尔值。</li>
<li><strong>哈希算法和加密算法</strong> ： 通过移位和与、或等操作来混淆数据。</li>
<li><strong>数据压缩</strong> ： 如霍夫曼编码通过移位运算符可以快速处理和操作二进制数据，已生成紧凑的压缩格式。</li>
<li><strong>数据校验</strong> ： 如 CRC （循环冗余校验）通过移位和多项式除法生成和校验数据完整性。</li>
<li><strong>内存对齐</strong> ： 通过移位操作可以计算和调整数据的对齐地址。</li>
</ul>
<p>Java 中有三种移位运算符：</p>
<ul>
<li><code>&lt;&lt;</code> ： 左移运算符，向左移若干位，高位丢弃，低位补零，相当于乘 2^n（不溢出的情况下）。</li>
<li><code>&gt;&gt;</code> ： 带符号右移，高位补符号位，低位丢弃。相当于除 2^n 。</li>
<li><code>&gt;&gt;&gt;</code> ： 无符号右移，忽略符号位，空位补零。</li>
</ul>
<p>由于 <code>double</code> ， <code>float</code> 在二进制中的表现比较特殊，因此<strong>不能来进行移位操作</strong>。</p>
<p>移位操作符实际上支持的类型只有 <code>int</code> 和 <code>long</code> ，编译器在对 <code>short</code> 、 <code>byte</code> 、 <code>char</code> 类型进行移位前，都会<strong>将其转换为 <code>int</code> 类型再操作</strong>。</p>
<h4 id="2-3-1-如果移位的位数超过数值所占的位数会怎么样？"><a href="#2-3-1-如果移位的位数超过数值所占的位数会怎么样？" class="headerlink" title="2.3.1 如果移位的位数超过数值所占的位数会怎么样？"></a>2.3.1 如果移位的位数超过数值所占的位数会怎么样？</h4><p>当 int 类型左移&#x2F;右移位数大于等于 32 位操作时，会<strong>先求余（%）后再进行左移&#x2F;右移操作</strong>。也就是说<strong>左移&#x2F;右移 32 位相当于不进行移位操作（32%32&#x3D;0）</strong>，左移&#x2F;右移 42 位相当于左移&#x2F;右移 10 位（42%32&#x3D;10）。当 long 类型进行左移&#x2F;右移操作时，由于 long 对应的二进制是 64 位，因此求余操作的基数也变成了 64。</p>
<p>也就是说： <code>x&lt;&lt;42</code> 等同于 <code>x&lt;&lt;10</code> ， <code>x&gt;&gt;42</code> 等同于 <code>x&gt;&gt;10</code> ， <code>x &gt;&gt;&gt;42</code> 等同于 <code>x &gt;&gt;&gt; 10</code> 。</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;初始数据：&quot;</span> + i);</span><br><span class="line">System.out.println(<span class="string">&quot;初始数据对应的二进制字符串：&quot;</span> + Integer.toBinaryString(i));</span><br><span class="line">i &lt;&lt;= <span class="number">10</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;左移 10 位后的数据 &quot;</span> + i);</span><br><span class="line">System.out.println(<span class="string">&quot;左移 10 位后的数据对应的二进制字符 &quot;</span> + Integer.toBinaryString(i));</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">初始数据：-1</span><br><span class="line">初始数据对应的二进制字符串：11111111111111111111111111111111</span><br><span class="line">左移 10 位后的数据 -1024</span><br><span class="line">左移 10 位后的数据对应的二进制字符 11111111111111111111110000000000</span><br></pre></td></tr></table></figure>

<p>由于左移位数大于等于 32 位操作时，会先求余（%）后再进行左移操作，所以下面的代码左移 42 位相当于左移 10 位（42%32&#x3D;10），输出结果和前面的代码一样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;初始数据：&quot;</span> + i);</span><br><span class="line">System.out.println(<span class="string">&quot;初始数据对应的二进制字符串：&quot;</span> + Integer.toBinaryString(i));</span><br><span class="line">i &lt;&lt;= <span class="number">42</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;左移 10 位后的数据 &quot;</span> + i);</span><br><span class="line">System.out.println(<span class="string">&quot;左移 10 位后的数据对应的二进制字符 &quot;</span> + Integer.toBinaryString(i));</span><br></pre></td></tr></table></figure>

<p>右移运算符使用类似。</p>
<h3 id="2-4-continue-、-break-和-return-的区别是什么？"><a href="#2-4-continue-、-break-和-return-的区别是什么？" class="headerlink" title="2.4 continue 、 break 和 return 的区别是什么？"></a>2.4 continue 、 break 和 return 的区别是什么？</h3><ol>
<li><code>continue</code> ：跳出当前一次的循环，继续下一次循环。</li>
<li><code>break</code> ： 跳出整个循环体。</li>
</ol>
<p><code>return</code> 用于跳出当前方法。一般用于：</p>
<ol>
<li><code>return</code> ： 直接结束方法执行，没有返回值。</li>
<li><code>return value</code> ： 返回一个特定值。</li>
</ol>
<p>思考：</p>
<p>下列语句的结果是什么？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 1 --&gt; i = 0 , f = f , sout 0</span></span><br><span class="line">            System.out.println(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            <span class="comment">// i++ sout xixi</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 2 --&gt; i = 1 , f = f , sout 1</span></span><br><span class="line">            System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            <span class="comment">// i++</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// 3 --&gt; i = 2 , f = f , sout 2</span></span><br><span class="line">            System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// i++ f = t sout xixi</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="comment">// 4 --&gt; i = 3 , f = t , sout 3</span></span><br><span class="line">            System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">            <span class="comment">//break</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">4</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;xixi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        <span class="comment">// 5 --&gt; sout haha</span></span><br><span class="line">        System.out.println(<span class="string">&quot;haha&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;heihei&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">xixi</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">xixi</span><br><span class="line">3</span><br><span class="line">haha</span><br></pre></td></tr></table></figure>

<h2 id="3-基本数据类型"><a href="#3-基本数据类型" class="headerlink" title="3. 基本数据类型"></a>3. 基本数据类型</h2><h3 id="3-1-Java-中的几种基本数据类型？"><a href="#3-1-Java-中的几种基本数据类型？" class="headerlink" title="3.1 Java 中的几种基本数据类型？"></a>3.1 Java 中的几种基本数据类型？</h3><ul>
<li>6 种数字类型<ul>
<li>4 种整数型： <code>byte</code> , <code>short</code> , <code>int</code> , <code>long</code></li>
<li>2 种浮点型： <code>float</code> , <code>double</code></li>
</ul>
</li>
<li>1 种字符型： <code>char</code></li>
<li>1 种布尔型： <code>boolean</code></li>
</ul>
<p>基本数据类型的默认值和所占空间：</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>位数</th>
<th>字节</th>
<th>默认值</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td><code>byte</code></td>
<td>8</td>
<td>1</td>
<td>0</td>
<td>-128 ~ 127</td>
</tr>
<tr>
<td><code>short</code></td>
<td>16</td>
<td>2</td>
<td>0</td>
<td>-2 ^ 15 ~ 2 ^ 15 - 1</td>
</tr>
<tr>
<td><code>int</code></td>
<td>32</td>
<td>4</td>
<td>0</td>
<td>-2 ^ 31 ~ 2 ^ 31 - 1</td>
</tr>
<tr>
<td><code>long</code></td>
<td>64</td>
<td>8</td>
<td>0L</td>
<td>-2 ^ 63 ~ 2 ^ 63 - 1</td>
</tr>
<tr>
<td><code>char</code></td>
<td>16</td>
<td>2</td>
<td>‘u0000’</td>
<td>0 ~ 2 ^ 16 - 1</td>
</tr>
<tr>
<td><code>float</code></td>
<td>32</td>
<td>4</td>
<td>0f</td>
<td>1.4 E -45 ~ 3.4028235 E 38</td>
</tr>
<tr>
<td><code>double</code></td>
<td>64</td>
<td>8</td>
<td>0d</td>
<td>4.9 E -324 ~ 1.7976931348623157 E 308</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td>1</td>
<td></td>
<td>false</td>
<td>true , false</td>
</tr>
</tbody></table>
<p>对于 <code>boolean</code> ，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。逻辑上理解是占用 1 位，但是实际中会考虑计算机高效存储因素。</p>
<p>Java 的每种基本类型所占存储空间的大小<strong>不会像其他大多数语言那样随机器硬件架构的变化而变化</strong>。这种所占存储空间大小的不变性是 Java 程序比用其他大多数语言编写的程序更具可移植性的原因之一。</p>
<p>注意：</p>
<ol>
<li>Java 里使用 <code>long</code> 类型的数据一定要加上 <strong>L</strong> ， 否则将作为整形解析。</li>
<li>Java 里使用 <code>float</code> 类型一定要加上 <strong>f 或 F</strong> ， 否则无法通过编译。</li>
<li><code>char = h</code> char 单引号 <code>String a = &quot;hello&quot;</code> String 双引号。</li>
</ol>
<p>这八种基本类型都有对应的包装类分别为： <code>Byte</code> 、 <code>Short</code> 、 <code>Integer</code> 、 <code>Long</code> 、 <code>Float</code> 、 <code>Double</code> 、 <code>Character</code> 、 <code>Boolean</code> 。</p>
<h3 id="3-2-基本类型和包装类型的区别？"><a href="#3-2-基本类型和包装类型的区别？" class="headerlink" title="3.2 基本类型和包装类型的区别？"></a>3.2 基本类型和包装类型的区别？</h3><ul>
<li><strong>用途</strong> ： 除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。并且，<strong>包装类型可用于泛型，而基本类型不可以</strong>。</li>
<li><strong>存储方式</strong> ： 基本数据类型的局部变量存放在 <strong>Java 虚拟机栈中的局部变量表</strong>中，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 <strong>Java 虚拟机的堆</strong>中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于<strong>堆</strong>中。</li>
<li><strong>占用空间</strong> ： 相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。</li>
<li><strong>默认值</strong> ： 成员变量包装类型不赋值就是 null ，而基本类型有默认值且不是 null。</li>
<li><strong>比较方式</strong> ： 对于基本数据类型来说，<code>==</code> 比较的是值。对于包装数据类型来说，<code>==</code> 比较的是<strong>对象的内存地址</strong>。所有整型包装类对象之间值的比较，<strong>全部使用 <code>equals()</code> 方法</strong>。</li>
</ul>
<p><strong>为什么说是几乎所有对象实例都存在于堆中呢？</strong></p>
<p>这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存</p>
<p><strong>注意：</strong></p>
<p>基本数据类型存放在栈中是一个常见的误区！ 基本数据类型的存储位置取决于它们的<strong>作用和声明方式</strong>。如果它们是<strong>局部变量</strong>，那么它们会存放在<strong>栈</strong>中；如果它们是<strong>成员变量</strong>，那么们会存放在<strong>堆&#x2F;方法区&#x2F;元空间</strong>中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="comment">// 成员变量，存放在堆中</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 被 static 修饰的成员变量，JDK 1.7 及之前位于方法区，1.8 后存放于元空间，均不存放于堆中。</span></span><br><span class="line">    <span class="comment">// 变量属于类，不属于对象。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 局部变量，存放在栈中</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">40</span>; <span class="comment">// 编译错误，不能在方法中使用 static 修饰局部变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-包装类型的缓存机制"><a href="#3-3-包装类型的缓存机制" class="headerlink" title="3.3 包装类型的缓存机制"></a>3.3 包装类型的缓存机制</h3><p><code>Byte</code> , <code>Short</code> , <code>Integer</code> , <code>Long</code> 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据， <code>Character</code> 创建了数值在 [0,127] 范围的缓存数据， <code>Boolean</code> 直接返回 <code>True</code> or <code>False</code> 。</p>
<p>Integer 缓存源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntegerCache</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Character 缓存源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Character <span class="title function_">valueOf</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c &lt;= <span class="number">127</span>) &#123; <span class="comment">// must cache</span></span><br><span class="line">      <span class="keyword">return</span> CharacterCache.cache[(<span class="type">int</span>)c];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Character</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CharacterCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">CharacterCache</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Character cache[] = <span class="keyword">new</span> <span class="title class_">Character</span>[<span class="number">127</span> + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cache.length; i++)</span><br><span class="line">            cache[i] = <span class="keyword">new</span> <span class="title class_">Character</span>((<span class="type">char</span>)i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Boolean 缓存源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title function_">valueOf</span><span class="params">(<span class="type">boolean</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (b ? TRUE : FALSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是<strong>在性能和资源之间的权衡</strong>。</p>
<p>两种浮点数类型的包装类<strong>没有实现缓存机制</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">33</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">33</span>;</span><br><span class="line">System.out.println(i1 == i2);<span class="comment">// 输出 true</span></span><br><span class="line"></span><br><span class="line"><span class="type">Float</span> <span class="variable">i11</span> <span class="operator">=</span> <span class="number">333f</span>;</span><br><span class="line"><span class="type">Float</span> <span class="variable">i22</span> <span class="operator">=</span> <span class="number">333f</span>;</span><br><span class="line">System.out.println(i11 == i22);<span class="comment">// 输出 false</span></span><br><span class="line"></span><br><span class="line"><span class="type">Double</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">1.2</span>;</span><br><span class="line"><span class="type">Double</span> <span class="variable">i4</span> <span class="operator">=</span> <span class="number">1.2</span>;</span><br><span class="line">System.out.println(i3 == i4);<span class="comment">// 输出 false</span></span><br></pre></td></tr></table></figure>

<p>问题：下面的代码的输出结果是 true 还是 false ？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">40</span>);</span><br><span class="line">System.out.println(i1==i2);</span><br></pre></td></tr></table></figure>

<p><code>Integer i1=40</code> 这一行代码会发生装箱，也就是说这行代码等价于 <code>Integer i1=Integer.valueOf(40)</code> 。因此， <code>i1</code> 直接使用的是缓存中的对象。而 <code>Integer i2 = new Integer(40)</code> 会直接创建新的对象。</p>
<p>因此，答案是 <code>false</code> 。</p>
<p><strong>所有整型包装类对象之间值的比较，全部使用 equals 方法比较。</strong></p>
<h3 id="3-4-自动装箱与自动拆箱？原理？"><a href="#3-4-自动装箱与自动拆箱？原理？" class="headerlink" title="3.4 自动装箱与自动拆箱？原理？"></a>3.4 自动装箱与自动拆箱？原理？</h3><p>自动拆装箱？</p>
<ul>
<li><strong>装箱</strong> ： 将基本类型用对应的引用类型包装起来。</li>
<li><strong>拆箱</strong> ： 将包装类型转换为基本数据类型。</li>
</ul>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;  <span class="comment">//装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i;   <span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure>

<p>字节码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">L1</span><br><span class="line"></span><br><span class="line"> LINENUMBER 8 L1</span><br><span class="line"></span><br><span class="line"> ALOAD 0</span><br><span class="line"></span><br><span class="line"> BIPUSH 10</span><br><span class="line"></span><br><span class="line"> INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;</span><br><span class="line"></span><br><span class="line"> PUTFIELD AutoBoxTest.i : Ljava/lang/Integer;</span><br><span class="line"></span><br><span class="line">L2</span><br><span class="line"></span><br><span class="line"> LINENUMBER 9 L2</span><br><span class="line"></span><br><span class="line"> ALOAD 0</span><br><span class="line"></span><br><span class="line"> ALOAD 0</span><br><span class="line"></span><br><span class="line"> GETFIELD AutoBoxTest.i : Ljava/lang/Integer;</span><br><span class="line"></span><br><span class="line"> INVOKEVIRTUAL java/lang/Integer.intValue ()I</span><br><span class="line"></span><br><span class="line"> PUTFIELD AutoBoxTest.n : I</span><br><span class="line"></span><br><span class="line"> RETURN</span><br></pre></td></tr></table></figure>

<p>从字节码中，可以发现装箱其实就是调用了包装类的 <code>valueOf()</code> 方法，拆箱其实就是调用了 <code>xxxValue()</code> 方法。</p>
<p>因此，</p>
<ul>
<li><code>Integer i = 10</code> 等价于 <code>Integer i = Integer.valueOf(10)</code></li>
<li><code>int n = i</code> 等价于 <code>int n = i.intValue()</code></li>
</ul>
<p>注意： <strong>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">sum</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 应该使用 long 而不是 Long</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= Integer.MAX_VALUE; i++)</span><br><span class="line">        sum += i;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-5-为什么浮点数运算会有精度丢失？"><a href="#3-5-为什么浮点数运算会有精度丢失？" class="headerlink" title="3.5 为什么浮点数运算会有精度丢失？"></a>3.5 为什么浮点数运算会有精度丢失？</h3><p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2.0f</span> - <span class="number">1.9f</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1.8f</span> - <span class="number">1.7f</span>;</span><br><span class="line">System.out.printf(<span class="string">&quot;%.9f&quot;</span>,a);<span class="comment">// 0.100000024</span></span><br><span class="line">System.out.println(b);<span class="comment">// 0.099999905</span></span><br><span class="line">System.out.println(a == b);<span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>精度丢失和计算机保存浮点数的机制有很大关系。计算机是二进制的，且计算机在保存一个数字时，宽度是有限的，无限循环的小数存储时只能被截断，所以会出现小数精度丢失的情况。</p>
<p>比如：<br>十进制下的 0.2 就没办法精确转化为二进制小数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0.2 转换为二进制数的过程为，不断乘以 2，直到不存在小数为止，</span></span><br><span class="line"><span class="comment">// 在这个计算过程中，得到的整数部分从上到下排列就是二进制的结果。</span></span><br><span class="line"><span class="number">0.2</span> * <span class="number">2</span> = <span class="number">0.4</span> -&gt; <span class="number">0</span></span><br><span class="line"><span class="number">0.4</span> * <span class="number">2</span> = <span class="number">0.8</span> -&gt; <span class="number">0</span></span><br><span class="line"><span class="number">0.8</span> * <span class="number">2</span> = <span class="number">1.6</span> -&gt; <span class="number">1</span></span><br><span class="line"><span class="number">0.6</span> * <span class="number">2</span> = <span class="number">1.2</span> -&gt; <span class="number">1</span></span><br><span class="line"><span class="number">0.2</span> * <span class="number">2</span> = <span class="number">0.4</span> -&gt; <span class="number">0</span>（发生循环）</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>关于浮点数，具体看 <a target="_blank" rel="noopener" href="http://kaito-kidd.com/2018/08/08/computer-system-float-point/">计算机系统基础</a> 这篇博客。</p>
<h3 id="3-6-如何解决浮点数运算精度丢失？"><a href="#3-6-如何解决浮点数运算精度丢失？" class="headerlink" title="3.6 如何解决浮点数运算精度丢失？"></a>3.6 如何解决浮点数运算精度丢失？</h3><p><code>BigDecimal</code> 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算的场景都是通过 <code>BigDecimal</code> 实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.00&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// BigDecimal 的 subtract 方法用于执行精确的减法运算。</span></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">x</span> <span class="operator">=</span> a.subtract(c);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">y</span> <span class="operator">=</span> b.subtract(c);</span><br><span class="line"></span><br><span class="line">System.out.println(x); <span class="comment">/* 0.2 */</span></span><br><span class="line">System.out.println(y); <span class="comment">/* 0.20 */</span></span><br><span class="line"><span class="comment">// 比较内容，不是比较值</span></span><br><span class="line">System.out.println(Objects.equals(x, y)); <span class="comment">/* false */</span></span><br><span class="line"><span class="comment">// 比较值相等用相等compareTo，相等返回0</span></span><br><span class="line">System.out.println(<span class="number">0</span> == x.compareTo(y)); <span class="comment">/* true */</span></span><br></pre></td></tr></table></figure>

<p><code>BigDecimal</code> 的详细介绍在 <a href="%E5%85%B6%E4%BB%96%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9.md">重要知识点</a> 里。</p>
<h3 id="3-7-超过-long-整型的数据如何表示？"><a href="#3-7-超过-long-整型的数据如何表示？" class="headerlink" title="3.7 超过 long 整型的数据如何表示？"></a>3.7 超过 <code>long</code> 整型的数据如何表示？</h3><p>在 Java 中，64 位 long 整型是最大的整数类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> Long.MAX_VALUE;</span><br><span class="line">System.out.println(l + <span class="number">1</span>); <span class="comment">// -9223372036854775808</span></span><br><span class="line">System.out.println(l + <span class="number">1</span> == Long.MIN_VALUE); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>BigInteger 内部使用 int[] 数组来存储任意大小的整形数据。</p>
<p>注意：</p>
<p>相对于常规整数类型的运算来说，BigInteger 运算的效率会相对较低。</p>
<h2 id="4-变量"><a href="#4-变量" class="headerlink" title="4. 变量"></a>4. 变量</h2><h3 id="4-1-成员变量与局部变量的区别？"><a href="#4-1-成员变量与局部变量的区别？" class="headerlink" title="4.1 成员变量与局部变量的区别？"></a>4.1 成员变量与局部变量的区别？</h3><ul>
<li><p><strong>语法形式</strong> ： 成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或参数；成员变量可以被 <code>public</code> , <code>private</code> , <code>static</code> 等修饰符修饰，而局部变量不能被访问控制修饰符及 <code>static</code> 修饰；但是成员变量和局部变量都能被 <code>final</code> 修饰。</p>
</li>
<li><p><strong>存储方式</strong> ： 如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有，这个成员变量是属于实例的。对象存储在堆内存，局部变量存储在栈内存。</p>
</li>
<li><p><strong>生存时间</strong> ： 成员变量是对象的一部分，随着对象的创建而存在，局部变量随方法的调用而自动生成，随方法的调用结束而消亡。</p>
</li>
<li><p><strong>默认值</strong> ： 成员变量如果没有被赋初值，则会自动以类型的默认值赋值（ 例外：被 <code>fianl</code> 修饰必须显式赋值 ），而局部变量不会自动赋值。</p>
</li>
</ul>
<h4 id="4-1-1-为什么成员变量有默认值？"><a href="#4-1-1-为什么成员变量有默认值？" class="headerlink" title="4.1.1 为什么成员变量有默认值？"></a>4.1.1 为什么成员变量有默认值？</h4><ol>
<li><p>如果没有默认值？ –&gt; 变量存储的是内存地址对应的任意随机值，程序读取该值运行会出现意外。</p>
</li>
<li><p>默认值有两种设置方式：手动和自动，根据第一点，没有手动赋值一定要自动赋值。成员变量在运行时可借助反射等方法手动赋值，而局部变量不行。</p>
</li>
<li><p>对于编译器（ javac ）来说，局部变量没赋值很好判断，可以直接报错。而成员变量可能是运行时赋值，无法判断，误报“没默认值”又会影响用户体验，所以采用自动赋默认值。</p>
</li>
</ol>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VariableExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员变量</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法中的局部变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 栈中分配的局部变量</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello, world!&quot;</span>; <span class="comment">// 栈中分配的局部变量</span></span><br><span class="line">        System.out.println(num1);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带参数的方法中的局部变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(<span class="type">int</span> num2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> num2 + <span class="number">10</span>; <span class="comment">// 栈中分配的局部变量</span></span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法中的局部变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">VariableExample</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name; <span class="comment">// 对成员变量进行赋值</span></span><br><span class="line">        <span class="built_in">this</span>.age = age; <span class="comment">// 对成员变量进行赋值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num3</span> <span class="operator">=</span> <span class="number">20</span>; <span class="comment">// 栈中分配的局部变量</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;Hello, &quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot;!&quot;</span>; <span class="comment">// 栈中分配的局部变量</span></span><br><span class="line">        System.out.println(num3);</span><br><span class="line">        System.out.println(str2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-静态变量有什么用？"><a href="#4-2-静态变量有什么用？" class="headerlink" title="4.2 静态变量有什么用？"></a>4.2 静态变量有什么用？</h3><p>静态变量也就是被 static 关键字修饰的变量。它可以被类的所有实例共享，无论一个类创建了多少个对象，它们都共享同一份静态变量。静态变量只会被分配一次内存，即使创建多个对象，这样可以节省内存。</p>
<p>通常情况下，静态变量会被 <code>final</code> 关键字<strong>修饰成为常量</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConstantVariableExample</span> &#123;</span><br><span class="line">    <span class="comment">// 常量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">constantVar</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-字符型常量和字符串型常量的区别？"><a href="#4-3-字符型常量和字符串型常量的区别？" class="headerlink" title="4.3 字符型常量和字符串型常量的区别？"></a>4.3 字符型常量和字符串型常量的区别？</h3><ul>
<li><p><strong>形式</strong> ： 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符。</p>
</li>
<li><p><strong>含义</strong> ： 字符常量相当于<strong>一个整型值 ( ASCII 值)</strong> ,可以参加表达式运算; 字符串常量代表<strong>一个地址值</strong> ( 该字符串在内存中存放位置 ) 。</p>
</li>
<li><p><strong>占内存大小</strong> ： 字符常量只占 2 个字节; 字符串常量占若干个字节。</p>
</li>
</ul>
<p>注意： <code>char</code> 在 Java 中占<strong>两个字节</strong>。</p>
<h2 id="5-方法"><a href="#5-方法" class="headerlink" title="5. 方法"></a>5. 方法</h2><h3 id="5-1-什么是方法的返回值？-方法有哪几种类型？"><a href="#5-1-什么是方法的返回值？-方法有哪几种类型？" class="headerlink" title="5.1 什么是方法的返回值？ 方法有哪几种类型？"></a>5.1 什么是方法的返回值？ 方法有哪几种类型？</h3><p><strong>方法的返回值</strong> 是指获取到的某个方法体执行后产生的结果。</p>
<p>可以按照方法的返回值和参数类型分类：</p>
<ol>
<li><p>无参数无返回值方法</p>
</li>
<li><p>有参数无返回值的方法</p>
</li>
<li><p>有返回值无参数的方法</p>
</li>
<li><p>有返回值有参数的方法</p>
</li>
</ol>
<h3 id="5-2-静态方法为什么不能调用非静态成员？"><a href="#5-2-静态方法为什么不能调用非静态成员？" class="headerlink" title="5.2 静态方法为什么不能调用非静态成员？"></a>5.2 静态方法为什么不能调用非静态成员？</h3><p>需要结合 JVM 的相关知识，主要原因如下：</p>
<ol>
<li><p>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</p>
</li>
<li><p>在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</p>
</li>
</ol>
<h3 id="5-3-静态方法和实例方法有何不同？"><a href="#5-3-静态方法和实例方法有何不同？" class="headerlink" title="5.3 静态方法和实例方法有何不同？"></a>5.3 静态方法和实例方法有何不同？</h3><ol>
<li><p><strong>调用方式</strong> ：<br>在外部调用静态方法时，可以使用 <code>类名.方法名</code> 的方式，也可以使用 <code>对象.方法名</code> 的方式，而实例方法只有后面这种方式。也就是说，<strong>调用静态方法可以无需创建对象</strong>。<br>不过，需要注意的是一般<strong>不建议使用 <code>对象.方法名</code> 的方式来调用静态方法</strong>。这种方式非常容易造成混淆，静态方法不属于类的某个对象而是属于这个类。<br>因此，一般建议使用 <code>类名.方法名</code> 的方式来调用静态方法。</p>
</li>
<li><p><strong>访问类成员是否存在限制</strong> ：<br>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。</p>
</li>
</ol>
<h3 id="5-4-重载和重写有什么区别？"><a href="#5-4-重载和重写有什么区别？" class="headerlink" title="5.4 重载和重写有什么区别？"></a>5.4 重载和重写有什么区别？</h3><blockquote>
<p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理<br>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，就要覆盖父类方法</p>
</blockquote>
<h4 id="5-4-1-重载"><a href="#5-4-1-重载" class="headerlink" title="5.4.1 重载"></a>5.4.1 重载</h4><p>发生在同一个类中（或者父类和子类之间），方法名<strong>必须相同</strong>，<strong>参数类型不同、个数不同、顺序不同</strong>，方法返回值和访问修饰符<strong>可以不同</strong>。</p>
<p>综上：重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</p>
<h4 id="5-4-2-重写"><a href="#5-4-2-重写" class="headerlink" title="5.4.2 重写"></a>5.4.2 重写</h4><p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p>
<ol>
<li><p><strong>方法名、参数列表必须相同</strong>，子类方法返回值类型应比父类方法返回值类型<strong>更小或相等</strong>，抛出的异常范围<strong>小于等于父类</strong>，访问修饰符范围<strong>大于等于父类</strong>。</p>
</li>
<li><p>如果父类方法访问修饰符为 <code>private</code> &#x2F; <code>final</code> &#x2F; <code>static</code> 则子类就不能重写该方法，但是被 <code>static</code> 修饰的方法能够被再次声明。</p>
</li>
<li><p>构造方法无法被重写</p>
</li>
</ol>
<h4 id="5-4-3-总结"><a href="#5-4-3-总结" class="headerlink" title="5.4.3 总结"></a>5.4.3 总结</h4><p>综上：<strong>重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。</strong></p>
<table>
<thead>
<tr>
<th>区别点</th>
<th>重载</th>
<th>重写</th>
</tr>
</thead>
<tbody><tr>
<td>发生范围</td>
<td>同一个类</td>
<td>子类</td>
</tr>
<tr>
<td>参数列表</td>
<td>必须修改</td>
<td>一定不能改</td>
</tr>
<tr>
<td>返回类型</td>
<td>可修改</td>
<td>比父类方法返回值类型更小或相等</td>
</tr>
<tr>
<td>异常</td>
<td>可修改</td>
<td>比父类方法声明抛出的异常类更小或相等</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>可修改</td>
<td>一定不能做更严格的限制（可以降低限制）</td>
</tr>
<tr>
<td>发生阶段</td>
<td>编译期</td>
<td>运行期</td>
</tr>
</tbody></table>
<p>补充： 如果方法的返回类型是 <strong><code>void</code> 和基本数据类型</strong>，则返回值重写时<strong>不可修改</strong>。但是如果方法的返回值是<strong>引用类型</strong>，重写时是<strong>可以返回该引用类型的子类</strong>的。</p>
<h3 id="5-5-什么是可变长参数？"><a href="#5-5-什么是可变长参数？" class="headerlink" title="5.5 什么是可变长参数？"></a>5.5 什么是可变长参数？</h3><p>从 Java5 开始，Java 支持定义可变长参数，可变长参数就是允许在调用方法时传入不定长度的参数。就比如下面这个方法就可以接受 0 个或者多个参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(String... args)</span> &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>可变参数<strong>只能作为函数的最后一个参数</strong>，但其前面可以有也<strong>可以没有任何其他参数</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(String arg1, String... args)</span> &#123; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-5-1-遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？"><a href="#5-5-1-遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？" class="headerlink" title="5.5.1 遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？"></a>5.5.1 遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？</h4><p>会优先匹配固定参数的方法，因为固定参数的方法匹配度更高。</p>
<p>Java 的可变参数编译后实际会被转换成一个数组，看编译后生成的 class 文件就可以看出来了。</p>
<h2 id="NEXT"><a href="#NEXT" class="headerlink" title="NEXT"></a>NEXT</h2><p><a href="JavaSE%20pt.2.md">JavaSE pt.2</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-03-10T13:55:29.000Z" title="2025/3/10 21:55:29">2025-03-10</time>发表</span><span class="level-item"><time dateTime="2025-03-10T13:57:40.689Z" title="2025/3/10 21:57:40">2025-03-10</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%85%AB%E8%82%A1/">八股</a><span> / </span><a class="link-muted" href="/categories/%E5%85%AB%E8%82%A1/JavaSE/">JavaSE</a></span><span class="level-item">几秒读完 (大约0个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/03/10/%E5%85%AB%E8%82%A1/Java/Java%E5%9F%BA%E7%A1%80/%E5%85%B6%E4%BB%96%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/">重要知识点</a></p><div class="content"></div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.jpg" alt="Rossignol"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Rossignol</p><p class="is-size-6 is-block">NaN</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Mars</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives/"><p class="title">24</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories/"><p class="title">15</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags/"><p class="title">16</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/0xRossignol" target="_blank" rel="me noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/0xRossignol"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Golang/"><span class="level-start"><span class="level-item">Golang</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/Golang/basics/"><span class="level-start"><span class="level-item">basics</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/Java/basics/"><span class="level-start"><span class="level-item">basics</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/Java/basics/Thinking-in-Java/"><span class="level-start"><span class="level-item">Thinking in Java</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/Linux/Arch-Linux/"><span class="level-start"><span class="level-item">Arch Linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/OS/"><span class="level-start"><span class="level-item">OS</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Software-Construction/"><span class="level-start"><span class="level-item">Software Construction</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul><li><a class="level is-mobile" href="/categories/Software-Construction/MIT6-031/"><span class="level-start"><span class="level-item">MIT6.031</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/TypeScript/"><span class="level-start"><span class="level-item">TypeScript</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/test/"><span class="level-start"><span class="level-item">test</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/toy-projects/"><span class="level-start"><span class="level-item">toy projects</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%85%AB%E8%82%A1/"><span class="level-start"><span class="level-item">八股</span></span><span class="level-end"><span class="level-item tag">4</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%85%AB%E8%82%A1/JavaSE/"><span class="level-start"><span class="level-item">JavaSE</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-04-06T14:45:19.961Z">2025-04-06</time></p><p class="title"><a href="/2025/04/06/%E5%85%AB%E8%82%A1/Java/IO/IO%20%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-04-06T14:45:19.961Z">2025-04-06</time></p><p class="title"><a href="/2025/04/06/%E5%85%AB%E8%82%A1/Java/IO/IO%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-04-06T14:45:19.961Z">2025-04-06</time></p><p class="title"><a href="/2025/04/06/%E5%85%AB%E8%82%A1/Java/IO/NIO%20%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-04-06T14:45:06.006Z">2025-04-06</time></p><p class="title"><a href="/2025/04/06/%E5%85%AB%E8%82%A1/Java/IO/IO%20%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-04-06T13:55:29.000Z">2025-04-06</time></p><p class="title"><a href="/2025/04/06/%E5%85%AB%E8%82%A1/Java/Java%E5%9F%BA%E7%A1%80/JavaSE%20pt.3/">JavaSE pt.3</a></p><p class="categories"><a href="/categories/%E5%85%AB%E8%82%A1/">八股</a> / <a href="/categories/%E5%85%AB%E8%82%A1/JavaSE/">JavaSE</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2025/04/"><span class="level-start"><span class="level-item">四月 2025</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/03/"><span class="level-start"><span class="level-item">三月 2025</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/02/"><span class="level-start"><span class="level-item">二月 2025</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/01/"><span class="level-start"><span class="level-item">一月 2025</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/12/"><span class="level-start"><span class="level-item">十二月 2024</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Arch-Linux/"><span class="tag">Arch Linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/English/"><span class="tag">English</span><span class="tag">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Golang/"><span class="tag">Golang</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OS/"><span class="tag">OS</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Software-Construction/"><span class="tag">Software Construction</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TypeScript/"><span class="tag">TypeScript</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/git/"><span class="tag">git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/python/"><span class="tag">python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/test/"><span class="tag">test</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/toy-projects/"><span class="tag">toy projects</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%B8%AD%E6%96%87/"><span class="tag">中文</span><span class="tag">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%85%AB%E8%82%A1/"><span class="tag">八股</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B1%87%E7%BC%96/"><span class="tag">汇编</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BF%BB%E8%AF%91/"><span class="tag">翻译</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="MyBlog" height="28"></a><p class="is-size-7"><span>&copy; 2025 Rossignol</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>