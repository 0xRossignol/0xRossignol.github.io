<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>标签: 中文 - MyBlog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="MyBlog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="MyBlog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="MyBlog"><meta property="og:url" content="http://example.com/"><meta property="og:site_name" content="MyBlog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:author" content="Rossignol"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"MyBlog","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"Rossignol"},"publisher":{"@type":"Organization","name":"MyBlog","logo":{"@type":"ImageObject","url":"http://example.com/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="MyBlog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/0xRossignol"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags/">标签</a></li><li class="is-active"><a href="#" aria-current="page">中文</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-05-17T13:55:29.000Z" title="2025/5/17 21:55:29">2025-05-17</time>发表</span><span class="level-item"><time dateTime="2025-05-17T13:29:19.072Z" title="2025/5/17 21:29:19">2025-05-17</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%85%AB%E8%82%A1/">八股</a><span> / </span><a class="link-muted" href="/categories/%E5%85%AB%E8%82%A1/Java%E9%9B%86%E5%90%88/">Java集合</a></span><span class="level-item">34 分钟读完 (大约5047个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/05/17/%E5%85%AB%E8%82%A1/Java/%E9%9B%86%E5%90%88/%E9%9B%86%E5%90%88%20pt%201/">集合 pt.1</a></p><div class="content"><h2 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h2><h3 id="Java-集合概述"><a href="#Java-集合概述" class="headerlink" title="Java 集合概述"></a>Java 集合概述</h3><p>Java 集合，也叫作容器，主要是由两大接口派生而来：一个是 <code>Collection</code> 接口，主要用于存放单一元素；另一个是 <code>Map</code> 接口，主要用于存放键值对。对于 <code>Collection</code> 接口，下面又有三个主要的子接口： <code>List</code> 、 <code>Set</code> 、 <code>Queue</code> 。</p>
<p><img src="/./assert/pt%201/001.png" alt="1"></p>
<blockquote>
<p>注：图中只列举了主要的继承派生关系，并没有列举所有关系。比方省略了 AbstractList, NavigableSet 等抽象类以及其他的一些辅助类，如想深入了解，可自行查看源码。</p>
</blockquote>
<h3 id="List-、-Set-、-Queue-、-Map-的区别？"><a href="#List-、-Set-、-Queue-、-Map-的区别？" class="headerlink" title="List 、 Set 、 Queue 、 Map 的区别？"></a>List 、 Set 、 Queue 、 Map 的区别？</h3><ul>
<li><p><code>List</code>: （顺序） 存储的元素是 <strong>有序的、可重复的</strong> 。</p>
</li>
<li><p><code>Set</code>: （去重） 存储的元素是 <strong>不可重复的</strong> 。</p>
</li>
<li><p><code>Queue</code>: （排队功能） 按特定的排队顺序确定先后顺序，存储的元素是 <strong>有序的、可重复的</strong> 。</p>
</li>
<li><p><code>Map</code>: （key-value） 使用键值对存储。</p>
<ul>
<li>key 是 <strong>无序的、不可重复的</strong></li>
<li>value 是 <strong>无序的、可重复的</strong><br>每个键最多映射到 <strong>一个值</strong> 。</li>
</ul>
</li>
</ul>
<h3 id="集合框架底层数据结构总结"><a href="#集合框架底层数据结构总结" class="headerlink" title="集合框架底层数据结构总结"></a>集合框架底层数据结构总结</h3><h4 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h4><h5 id="List"><a href="#List" class="headerlink" title="List"></a>List</h5><ul>
<li><p><code>ArrayList</code> ： <code>Object[]</code> 数组。详细看：<a href="./%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/ArrayList%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md">ArrayList 源码</a>。</p>
</li>
<li><p><code>Vector</code> ： <code>Object[]</code> 数组。</p>
</li>
<li><p><code>LinkedList</code> ： 双向链表（ JDK1.6 前为循环链表， JDK 1.7 取消循环 ）。详细看：<a href="./%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/LinkedList%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md">LinkedList 源码</a>。</p>
</li>
</ul>
<h5 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h5><ul>
<li><p><code>HashSet</code> （无序、唯一） ： 基于 <code>HashMap</code> 实现，底层采用 <code>HashMap</code> 保存元素。</p>
</li>
<li><p><code>LinkedHashSet</code> ： <code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，而且其内部是通过 <code>LinkedHashMap</code> 实现的。</p>
</li>
<li><p><code>TreeSet</code> （有序、唯一） ： <strong>红黑树</strong>（自平衡的排序二叉树）。</p>
</li>
</ul>
<h5 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h5><ul>
<li><p><code>PriorityQueue</code> ： <code>Object[]</code> 数组实现 <strong>小顶堆</strong> 。详细看：<a href="./%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/PriorityQueue%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md">PriorityQueue 源码</a></p>
</li>
<li><p><code>DelayQueue</code> ： <code>PriorityQueue</code>。详细看：<a href="./%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/DelayQueue%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md">DelayQueue 源码</a></p>
</li>
<li><p><code>ArrryDeque</code> ： 可扩容动态双向数组。</p>
</li>
</ul>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><ul>
<li><p><code>HashMap</code> ： JDK 1.8 之前 <code>HashMap</code> 由 <strong>数组加链表</strong> 组成，数组是 <code>HashMap</code> 的主体，链表则是为了 <strong>解决哈希冲突</strong> 。 JDK 1.8 后在解决哈希冲突时有了较大的变化，当链表长度<strong>大于阈值（默认为 8）</strong>（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为 <strong>红黑树</strong> ，以减少搜索时间。详细查看：<a href="./%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/HashMap%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md">HashMap 源码</a>。</p>
</li>
<li><p><code>LinkedHashMap</code> ： <code>LinkedHashMap</code> 继承自 <code>HashMap</code> ，所以底层仍然是 <strong>基于拉链式散列结构（即由数组和链表或红黑树）</strong> 组成。另外， <code>LinkedHashMap</code> 在上面的结构的基础上增加了一条双向链表，使上面的结构可以保持插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细查看：<a href="./%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/LinkedHashMap%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md">LinkedHashMap 源码</a>。</p>
</li>
<li><p><code>Hashtable</code> ： 数组+链表组成，数组是 <code>Hashtable</code> 的主体，链表则是为了 <strong>解决哈希冲突</strong> 。</p>
</li>
<li><p><code>TreeMap</code> ： 红黑树。</p>
</li>
</ul>
<h3 id="如何选择集合？"><a href="#如何选择集合？" class="headerlink" title="如何选择集合？"></a>如何选择集合？</h3><p>主要根据集合的特点。如；</p>
<ul>
<li><p>需要根据键值获取到元素值时就选用 <code>Map</code> 接口下的集合，需要排序时选择 <code>TreeMap</code> ,不需要排序时就选择 <code>HashMap</code> ,需要保证线程安全就选用 <code>ConcurrentHashMap</code> 。</p>
</li>
<li><p>只需要存放元素值时，就选择实现 <code>Collection</code> 接口的集合，需要保证元素唯一时选择实现 <code>Set</code> 接口的集合比如 <code>TreeSet</code> 或 <code>HashSet</code> ，不需要就选择实现 <code>List</code> 接口的比如 <code>ArrayList</code> 或 <code>LinkedList</code> ，然后再根据实现这些接口的集合的特点来选用。</p>
</li>
</ul>
<h3 id="为什么要用集合？"><a href="#为什么要用集合？" class="headerlink" title="为什么要用集合？"></a>为什么要用集合？</h3><p>需要存储一组类型相同的数据时，数组是最常用且最基本的容器之一。但是，使用 <strong>数组存储对象存在不足之处</strong> ，因为在实际开发中，存储的数据类型多种多样且数量不确定。这时，Java 集合就派上用场了。与数组相比，Java 集合提供了更灵活、更有效的方法来存储多个数据对象。Java 集合框架中的各种集合类和接口可以 <strong>存储不同类型和数量的对象</strong> ，同时还具有 <strong>多样化的操作方式</strong> 。相较于数组，Java 集合的优势在于它们的 <strong>大小可变、支持泛型、具有内建算法等</strong> 。总的来说，Java 集合 <strong>提高了数据的存储和处理灵活性</strong> ，可以更好地适应现代软件开发中多样化的数据需求，并支持高质量的代码编写。</p>
<h2 id="List-1"><a href="#List-1" class="headerlink" title="List"></a>List</h2><h3 id="ArrayList-和-Array-（数组）-的区别"><a href="#ArrayList-和-Array-（数组）-的区别" class="headerlink" title="ArrayList 和 Array （数组） 的区别"></a>ArrayList 和 Array （数组） 的区别</h3><p><code>ArrayList</code> 内部基于<strong>动态数组</strong>实现，比 <code>Array</code> 使用起来更加灵活：</p>
<ul>
<li><p><code>ArrayList</code> 会根据实际储存的元素进行<strong>动态扩容或缩容</strong>，而 <code>Array</code> 被创建后就不能改变长度了。</p>
</li>
<li><p><code>ArrayList</code> <strong>允许使用泛型</strong>确保类型安全， <code>Array</code> 不可以。</p>
</li>
<li><p><code>ArrayList</code> 中<strong>只能储存对象</strong>。 <code>Array</code> 可以既可以存储基本数据类型，也可以储存对象。</p>
</li>
<li><p><code>ArrayList</code> 支持<strong>插入、删除、遍历</strong>等常见操作，且提供了丰富的 API 操作，如 <code>add()</code> 、<code>remove()</code> 等。 <code>Array</code> 只是一个固定长度的数组，只能按照下标访问其中的元素，不具备动态添加、删除元素的能力。</p>
</li>
<li><p><code>ArrayList</code> 创建时不需要指定大小，而 <code>Array</code> 必须指定大小。</p>
</li>
</ul>
<h3 id="（了解）-ArrayList-和-Vector-的区别"><a href="#（了解）-ArrayList-和-Vector-的区别" class="headerlink" title="（了解） ArrayList 和 Vector 的区别"></a>（了解） ArrayList 和 Vector 的区别</h3><ul>
<li><p><code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层使用 <code>Object[]</code> 存储，适合频繁的查找工作，<strong>线程不安全</strong>。</p>
</li>
<li><p><code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用 Object[] 存储，<strong>线程安全</strong>。</p>
</li>
</ul>
<h3 id="（了解）-Vector-和-Stack-的区别"><a href="#（了解）-Vector-和-Stack-的区别" class="headerlink" title="（了解） Vector 和 Stack 的区别"></a>（了解） Vector 和 Stack 的区别</h3><ul>
<li><p><code>Vector</code> 和 <code>Stack</code> 两者<strong>都是线程安全</strong>的，都是使用 <code>synchronized</code> 关键字进行同步处理。</p>
</li>
<li><p><code>Stack</code> 继承自 <code>Vector</code> ，是一个<strong>后进先出的栈</strong>，而 <code>Vector</code> 是一个<strong>列表</strong>。</p>
</li>
</ul>
<p>随着 Java 并发编程的发展， <code>Vector</code> 和 <code>Stack</code> 已经<strong>被淘汰</strong>，推荐使用并发集合类（例如 <code>ConcurrentHashMap</code> 、 <code>CopyOnWriteArrayList</code> 等）或者手动实现线程安全的方法来提供安全的多线程操作支持。</p>
<h3 id="ArrayList-可以添加-null-值吗？"><a href="#ArrayList-可以添加-null-值吗？" class="headerlink" title="ArrayList 可以添加 null 值吗？"></a>ArrayList 可以添加 null 值吗？</h3><p>ArrayList 中可以存储任何类型的对象，包括 <code>null</code> 值。但是<strong>不建议</strong>添加 <code>null</code> ，会让代码变的难以维护，比如忘记做判空处理就会导致空指针异常。</p>
<h3 id="ArrayList-插入-删除的时间复杂度"><a href="#ArrayList-插入-删除的时间复杂度" class="headerlink" title="ArrayList 插入 &#x2F; 删除的时间复杂度"></a>ArrayList 插入 &#x2F; 删除的时间复杂度</h3><p>插入：</p>
<ul>
<li><p>头部插入： 需要将所有元素后移一位，时间复杂度为 <strong>O(n)</strong></p>
</li>
<li><p>尾部插入：</p>
<ul>
<li><code>ArrayList</code> 容量未达到极限时，时间复杂度为 <strong>O(1)</strong> ，它只需要在数组末尾添加一个元素</li>
<li><code>ArrayList</code> 容量达到极限且需要扩容时，时间复杂度为：<strong>一次 O(n) 操作将数组复制到新的更大的数组中，一次 O(1) 操作添加元素</strong></li>
</ul>
</li>
<li><p>指定位置插入： 将目标位置后的所有元素后移一位，再插入新元素，时间复杂度为 <strong>O(n)</strong></p>
</li>
</ul>
<p>删除</p>
<ul>
<li><p>头部删除： 需要将所有元素前移一位，时间复杂度为 <strong>O(n)</strong></p>
</li>
<li><p>尾部删除： 删除的元素位于列表末尾时，时间复杂度为 <strong>O(1)</strong></p>
</li>
<li><p>指定位置删除： 将目标位置后的所有元素前移一位，时间复杂度为 <strong>O(n)</strong></p>
</li>
</ul>
<h3 id="LinkedList-插入-删除的时间复杂度"><a href="#LinkedList-插入-删除的时间复杂度" class="headerlink" title="LinkedList 插入 &#x2F; 删除的时间复杂度"></a>LinkedList 插入 &#x2F; 删除的时间复杂度</h3><ul>
<li><p>头部插入 &#x2F; 删除： 只需修改头结点指针，时间复杂度为 <strong>O(1)</strong></p>
</li>
<li><p>尾部插入 &#x2F; 删除： 只需修改尾结点指针，时间复杂度为 <strong>O(1)</strong></p>
</li>
<li><p>指定位置插入 &#x2F; 删除： 先移动到指定位置，再修改， 时间复杂度为 <strong>O(n)</strong></p>
</li>
</ul>
<h3 id="LinkedList-为什么不能实现-RandomAccess-接口？"><a href="#LinkedList-为什么不能实现-RandomAccess-接口？" class="headerlink" title="LinkedList 为什么不能实现 RandomAccess 接口？"></a>LinkedList 为什么不能实现 RandomAccess 接口？</h3><p><code>RandomAccess</code> 接口是一个标记接口，表明实现该接口的类支持随机访问（通过索引快速访问）。由于 <code>LinkedList</code> 底层是链表，内存地址不连续，只能通过指针定位，所以不能实现 <code>RandomAccess</code> 接口。</p>
<h3 id="ArrayList-与-LinkedList-的区别"><a href="#ArrayList-与-LinkedList-的区别" class="headerlink" title="ArrayList 与 LinkedList 的区别"></a>ArrayList 与 LinkedList 的区别</h3><ul>
<li><p>是否线程安全： <code>ArrayList</code> 和 <code>LinkedList</code> 都是<strong>不同步</strong>的（不保证线程安全）</p>
</li>
<li><p>底层数据结构： <code>ArrayList</code> 使用 <code>Object[]</code> ； <code>LinkedList</code> 使用 <strong>双向链表</strong></p>
</li>
<li><p>插入和删除元素是否受位置影响： 见上文<br>总结：</p>
<ul>
<li><code>ArrayList</code> 受</li>
<li><code>LinkedList</code> 头尾不受</li>
</ul>
</li>
<li><p>是否支持快速随机访问：</p>
<ul>
<li><code>ArrayList</code> 支持</li>
<li><code>LinkedList</code> 不支持</li>
</ul>
</li>
<li><p>内存空间占用：</p>
<ul>
<li><code>ArrayList</code> 空间浪费主要体现在在 list 列表的结尾会 <strong>预留</strong> 一定的容量空间</li>
<li><code>LinkedList</code> 空间花费则体现在它的 <strong>每一个元素</strong> 都需要消耗比 <code>ArrayList</code> 更多的空间 （双向链表的前驱和后继）</li>
</ul>
</li>
</ul>
<h3 id="补充：-RandomAccess-接口"><a href="#补充：-RandomAccess-接口" class="headerlink" title="补充： RandomAccess 接口"></a>补充： RandomAccess 接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RandomAccess</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看源码发现实际上 <code>RandomAccess</code> 接口中什么都没有定义。所以， <code>RandomAccess</code> 接口不过是一个标识。标识实现这个接口的类具有随机访问功能。</p>
<p>在 <code>binarySearch()</code> 方法中，它要判断传入的 list 是否 <code>RandomAccess</code> 的实例，如果是，调用 <code>indexedBinarySearch()</code> 方法，如果不是，那么调用 <code>iteratorBinarySearch()</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;</span><br><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(List&lt;? extends Comparable&lt;? <span class="built_in">super</span> T&gt;&gt; list, T key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)</span><br><span class="line">        <span class="keyword">return</span> Collections.indexedBinarySearch(list, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> Collections.iteratorBinarySearch(list, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ArrayList-的扩容机制"><a href="#ArrayList-的扩容机制" class="headerlink" title="ArrayList 的扩容机制"></a>ArrayList 的扩容机制</h3><p><a href="./%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/ArrayList%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md">ArrayList 源码</a></p>
<h3 id="集合中的-fail-fast-和-fail-safe-是什么"><a href="#集合中的-fail-fast-和-fail-safe-是什么" class="headerlink" title="集合中的 fail-fast 和 fail-safe 是什么"></a>集合中的 fail-fast 和 fail-safe 是什么</h3><h4 id="fail-fast"><a href="#fail-fast" class="headerlink" title="fail-fast"></a>fail-fast</h4><blockquote>
<p>Fail-fast systems are designed to immediately stop functioning upon encountering an unexpected condition. This immediate failure helps to catch errors early, making debugging more straightforward.</p>
</blockquote>
<p>快速失败的思想即针对可能发生的异常进行<strong>提前表明故障并停止运行</strong>，通过尽早的发现和停止错误，降低故障系统级联的风险。</p>
<p>在 <code>java.util</code> 包下的大部分集合是不支持线程安全的，为了能够提前发现并发操作导致线程安全风险，提出通过维护一个 <code>modCount</code> 记录修改的次数，迭代期间通过比对预期修改次数 <code>expectedModCount</code> 和 <code>modCount</code> 是否一致来判断是否存在并发操作，从而实现快速失败，由此保证在避免在异常时执行非必要的复杂代码。</p>
<p>扩展视频：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1XhNSeYEVy/?share_source=copy_web&vd_source=c9d78ecc83243d6ccc5316b0dbf41247">（b 站）迭代器模式 + ArrayList 源码</a></p>
<h4 id="fail-safe"><a href="#fail-safe" class="headerlink" title="fail-safe"></a>fail-safe</h4><blockquote>
<p>Fail-safe systems take a different approach, aiming to recover and continue even in the face of unexpected conditions. This makes them particularly suited for uncertain or volatile environments.</p>
</blockquote>
<p>fail-safe 就是安全失败的含义，它旨在即使<strong>面对意外情况也能恢复并继续运行</strong>，这使得它特别适用于不确定或者不稳定的环境。</p>
<p>该思想常运用于并发容器，最经典的实现就是 <code>CopyOnWriteArrayList</code> 的实现，通过写时复制的思想保证在进行修改操作时复制出一份快照，基于这份快照完成添加或者删除操作后，将 <code>CopyOnWriteArrayList</code> 底层的数组引用指向这个新的数组空间，由此避免迭代时被并发修改所干扰所导致并发操作安全问题，当然这种做法也存缺点，即进行遍历操作时<strong>无法获得实时结果</strong>。</p>
<p><code>CopyOnWriteArrayList</code> 实现 fail-safe 的核心代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取原有数组</span></span><br><span class="line">            Object[] elements = getArray();</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">            <span class="comment">//基于原有数组复制出一份内存快照</span></span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//进行添加操作</span></span><br><span class="line">            newElements[len] = e;</span><br><span class="line">            <span class="comment">//array指向新的数组</span></span><br><span class="line">            setArray(newElements);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Set-1"><a href="#Set-1" class="headerlink" title="Set"></a>Set</h2><h3 id="Comparable-和-Comparator-的区别"><a href="#Comparable-和-Comparator-的区别" class="headerlink" title="Comparable 和 Comparator 的区别"></a>Comparable 和 Comparator 的区别</h3><p><code>Comparable</code> 接口和 <code>Comparator</code> 接口都是 Java 中用于排序的接口，它们在实现类对象之间比较大小、排序等方面发挥了重要作用：</p>
<ul>
<li><p><code>Comparable</code> 接口实际上是出自 <code>java.lang</code> 包 它有一个 <code>compareTo(Object obj)</code> 方法用来排序</p>
</li>
<li><p><code>Comparator</code> 接口实际上是出自 <code>java.util</code> 包它有一个 <code>compare(Object obj1, Object obj2)</code> 方法用来排序</p>
</li>
</ul>
<p>一般我们需要对一个集合使用自定义排序时，我们就要重写 <code>compareTo()</code> 方法或 <code>compare()</code> 方法，当我们需要对某一个集合实现两种排序方式，比如一个 song 对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写 <code>compareTo()</code> 方法和使用自制的 <code>Comparator</code> 方法或者以两个 Comparator 来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的 <code>Collections.sort()</code> 。</p>
<h3 id="无序性和不可重复性的含义"><a href="#无序性和不可重复性的含义" class="headerlink" title="无序性和不可重复性的含义"></a>无序性和不可重复性的含义</h3><ul>
<li><p>无序性 <strong>不等于随机性</strong> ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是 <strong>根据数据的哈希值决定</strong> 的。</p>
</li>
<li><p>不可重复性是指添加的元素按照 <code>equals()</code> 判断时 ，返回 <code>false</code> ，需要同时重写 <code>equals()</code> 方法和 <code>hashCode()</code> 方法。</p>
</li>
</ul>
<h3 id="比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h3><ul>
<li><p><code>HashSet</code> 、 <code>LinkedHashSet</code> 和 <code>TreeSet</code> 都是 Set 接口的实现类，都能 <strong>保证元素唯一</strong> ，并且都 <strong>不是线程安全</strong> 的。</p>
</li>
<li><p><code>HashSet</code> 、 <code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于 <strong>底层数据结构</strong> 不同。 <code>HashSet</code> 的底层数据结构是 <strong>哈希表（基于 <code>HashMap</code> 实现）</strong> 。 <code>LinkedHashSet</code> 的底层数据结构是 <strong>链表和哈希表</strong> ，元素的插入和取出顺序满足 <em>FIFO</em> 。 <code>TreeSet</code> 底层数据结构是 <strong>红黑树</strong> ，元素是 <strong>有序</strong> 的，排序的方式有自然排序和定制排序。</p>
</li>
<li><p>底层数据结构不同又导致这三者的 <strong>应用场景</strong> 不同。 <code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景， <code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景， <code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</p>
</li>
</ul>
<h2 id="Queue-1"><a href="#Queue-1" class="headerlink" title="Queue"></a>Queue</h2><h3 id="Queue-与-Deque-的区别"><a href="#Queue-与-Deque-的区别" class="headerlink" title="Queue 与 Deque 的区别"></a>Queue 与 Deque 的区别</h3><p><code>Queue</code> 是 <strong>单端队列</strong> ，只能从一端插入元素，另一端删除元素，实现上一般遵循 <strong>先进先出（FIFO）</strong> 规则。</p>
<p><code>Queue</code> 扩展了 <code>Collection</code> 的接口，根据 <strong>因为容量问题而导致操作失败后处理方式的不同</strong> 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。</p>
<table>
<thead>
<tr>
<th>Queue 接口</th>
<th>抛出异常</th>
<th>返回特殊值</th>
</tr>
</thead>
<tbody><tr>
<td>插入队尾</td>
<td>add(E e)</td>
<td>offer(E e)</td>
</tr>
<tr>
<td>删除队首</td>
<td>remove()</td>
<td>poll()</td>
</tr>
<tr>
<td>查询队首元素</td>
<td>element()</td>
<td>peek()</td>
</tr>
</tbody></table>
<p><code>Deque</code> 是 <strong>双端队列</strong> ，在队列的两端均可以插入或删除元素。</p>
<p><code>Deque</code> 扩展了 <code>Queue</code> 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：</p>
<table>
<thead>
<tr>
<th>Deque 接口</th>
<th>抛出异常</th>
<th>返回特殊值</th>
</tr>
</thead>
<tbody><tr>
<td>插入队首</td>
<td>addFirst(E e)</td>
<td>offerFirst(E e)</td>
</tr>
<tr>
<td>插入队尾</td>
<td>addLast(E e)</td>
<td>offerLast(E e)</td>
</tr>
<tr>
<td>删除队首</td>
<td>removeFirst()</td>
<td>pollFirst()</td>
</tr>
<tr>
<td>删除队尾</td>
<td>removeLast()</td>
<td>pollLast()</td>
</tr>
<tr>
<td>查询队首元素</td>
<td>getFirst()</td>
<td>peekFirst()</td>
</tr>
<tr>
<td>查询队尾元素</td>
<td>getLast()</td>
<td>peekLast()</td>
</tr>
</tbody></table>
<p>事实上，Deque 还提供有 push() 和 pop() 等其他方法，可用于模拟栈。</p>
<h3 id="ArrayDeque-与-LinkedList-的区别"><a href="#ArrayDeque-与-LinkedList-的区别" class="headerlink" title="ArrayDeque 与 LinkedList 的区别"></a><code>ArrayDeque</code> 与 <code>LinkedList</code> 的区别</h3><p><code>ArrayDeque</code> 和 <code>LinkedList</code> 都实现了 <code>Deque</code> 接口，两者都具有队列的功能，但两者有什么区别呢？</p>
<ul>
<li><p><code>ArrayDeque</code> 是基于 <strong>可变长的数组和双指针</strong> 来实现，而 <code>LinkedList</code> 则通过 <strong>链表</strong> 来实现。</p>
</li>
<li><p><code>ArrayDeque</code> <strong>不支持存储 <code>NULL</code> 数据</strong> ，但 <code>LinkedList</code> 支持。</p>
</li>
<li><p><code>ArrayDeque</code> 是在 JDK1.6 才被引入的，而 <code>LinkedList</code> 早在 JDK1.2 时就已经存在。</p>
</li>
<li><p><code>ArrayDeque</code> 插入时可能 <strong>存在扩容过程</strong> , 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</p>
</li>
</ul>
<p>从性能的角度上，选用 <code>ArrayDeque</code> 来实现队列要比 <code>LinkedList</code> 更好。此外， <code>ArrayDeque</code> 也可以用于实现栈。</p>
<h3 id="说一说-PriorityQueue"><a href="#说一说-PriorityQueue" class="headerlink" title="说一说 PriorityQueue"></a>说一说 PriorityQueue</h3><p><code>PriorityQueue</code> 是在 JDK1.5 中被引入的, 其与 <code>Queue</code> 的区别在于元素出队顺序是 <strong>与优先级相关</strong> 的，即总是 <strong>优先级最高的元素先出队</strong> 。</p>
<ul>
<li><p><code>PriorityQueue</code> 利用了 <strong>二叉堆</strong> 的数据结构来实现的，底层使用 <strong>可变长的数组</strong> 来存储数据</p>
</li>
<li><p><code>PriorityQueue</code> 通过堆元素的上浮和下沉，实现了在 <strong>O(logn)</strong> 的时间复杂度内插入元素和删除堆顶元素。</p>
</li>
<li><p><code>PriorityQueue</code> 是 <strong>非线程安全</strong> 的，且 <strong>不支持存储 <code>NULL</code> 和 <code>non-comparable</code> 的对象</strong> 。</p>
</li>
<li><p><code>PriorityQueue</code> <strong>默认是小顶堆</strong> ，但可以接收一个 <code>Comparator</code> 作为构造参数，从而来自定义元素优先级的先后。</p>
</li>
</ul>
<h3 id="什么是-BlockingQueue"><a href="#什么是-BlockingQueue" class="headerlink" title="什么是 BlockingQueue"></a>什么是 BlockingQueue</h3><p><code>BlockingQueue</code> （阻塞队列）是一个接口，继承自 <code>Queue</code> 。 <code>BlockingQueue</code> 阻塞的原因是其支持当队列 <strong>没有元素时一直阻塞</strong> ，直到有元素；还支持 <strong>如果队列已满，一直等到队列可以放入新元素时再放入</strong> 。</p>
<p><code>BlockingQueue</code> 常用于生产者-消费者模型中，生产者线程会向队列中添加数据，而消费者线程会从队列中取出数据进行处理。</p>
<h3 id="BlockingQueue-的实现类有哪些"><a href="#BlockingQueue-的实现类有哪些" class="headerlink" title="BlockingQueue 的实现类有哪些"></a>BlockingQueue 的实现类有哪些</h3><p><img src="/./assert/pt%201/002.png" alt="BlockingQueue 的实现类"></p>
<p>Java 中常用的阻塞队列实现类有以下几种：</p>
<ol>
<li><p><code>ArrayBlockingQueue</code> ：使用数组实现的有界阻塞队列。在创建时需要指定容量大小，并支持公平和非公平两种方式的锁访问机制。</p>
</li>
<li><p><code>LinkedBlockingQueue</code> ：使用单向链表实现的可选有界阻塞队列。在创建时可以指定容量大小，如果不指定则默认为 <code>Integer.MAX_VALUE</code> 。和 <code>ArrayBlockingQueue</code> 不同的是， 它仅支持非公平的锁访问机制。</p>
</li>
<li><p><code>PriorityBlockingQueue</code> ：支持优先级排序的无界阻塞队列。元素必须实现 <code>Comparable</code> 接口或者在构造函数中传入 <code>Comparator</code> 对象，并且不能插入 <code>null</code> 元素。</p>
</li>
<li><p><code>SynchronousQueue</code> ：同步队列，是一种不存储元素的阻塞队列。每个插入操作都必须等待对应的删除操作，反之删除操作也必须等待插入操作。因此， <code>SynchronousQueue</code> 通常用于线程之间的直接传递数据。</p>
</li>
<li><p><code>DelayQueue</code> ：延迟队列，其中的元素只有到了其指定的延迟时间，才能够从队列中出队。</p>
</li>
<li><p>……</p>
</li>
</ol>
<h3 id="ArrayBlockingQueue-和-LinkedBlockingQueue-有什么区别"><a href="#ArrayBlockingQueue-和-LinkedBlockingQueue-有什么区别" class="headerlink" title="ArrayBlockingQueue 和 LinkedBlockingQueue 有什么区别"></a>ArrayBlockingQueue 和 LinkedBlockingQueue 有什么区别</h3><p><code>ArrayBlockingQueue</code> 和 <code>LinkedBlockingQueue</code> 是 Java 并发包中常用的两种阻塞队列实现，它们都是 <strong>线程安全</strong> 的。不过，不过它们之间也存在下面这些区别：</p>
<ul>
<li><p>底层实现： <code>ArrayBlockingQueue</code> 基于 <strong>数组</strong> 实现，而 <code>LinkedBlockingQueue</code> 基于 <strong>链表</strong> 实现。</p>
</li>
<li><p>是否有界： <code>ArrayBlockingQueue</code> 是 <strong>有界队列</strong> ，必须在创建时指定容量大小。 <code>LinkedBlockingQueue</code> 创建时可以不指定容量大小，默认是 <code>Integer.MAX_VALUE</code> ，也就是无界的。但也 <strong>可以指定队列大小，从而成为有界</strong> 的。</p>
</li>
<li><p>锁是否分离： <code>ArrayBlockingQueue</code> 中的锁是 <strong>没有分离</strong> 的，即生产和消费用的是同一个锁； <code>LinkedBlockingQueue</code> 中的锁是 <strong>分离</strong> 的，即生产用的是 <code>putLock</code> ，消费是 <code>takeLock</code> ，这样可以防止生产者和消费者线程之间的锁争夺。</p>
</li>
<li><p>内存占用： <code>ArrayBlockingQueue</code> 需要 <strong>提前分配数组内存</strong> ，而 <code>LinkedBlockingQueue</code> 则是 <strong>动态分配链表节点内存</strong> 。这意味着， <code>ArrayBlockingQueue</code> 在创建时就会占用一定的内存空间，且往往申请的内存比实际所用的内存更大，而 <code>LinkedBlockingQueue</code> 则是根据元素的增加而逐渐占用内存空间。</p>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-05-17T08:55:26.000Z" title="2025/5/17 16:55:26">2025-05-17</time>发表</span><span class="level-item"><time dateTime="2025-05-17T08:55:08.894Z" title="2025/5/17 16:55:08">2025-05-17</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Rust/">Rust</a><span> / </span><a class="link-muted" href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></span><span class="level-item">12 分钟读完 (大约1803个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/05/17/Rust/The%20Rust%20Programming%20Language/03.5%20%E6%8E%A7%E5%88%B6%E6%B5%81/">3.5 控制流</a></p><div class="content"><h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><h3 id="if-表达式"><a href="#if-表达式" class="headerlink" title="if 表达式"></a><code>if</code> 表达式</h3><p><code>if</code> 表达式允许根据条件执行不同的代码分支。你提供一个条件并表示 “如果条件满足，运行这段代码；如果条件不满足，不运行这段代码。”</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> number &lt; <span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;condition was true&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;condition was false&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有的 <code>if</code> 表达式都以 <code>if</code> 关键字开头，其后跟一个条件。在这个例子中，条件检查变量 <code>number</code> 的值是否小于 5。在条件为 <code>true</code> 时希望执行的代码块位于紧跟条件之后的大括号中。<code>if</code> 表达式中与条件关联的代码块有时被叫做 <em>arms</em>，就像第二章部分中讨论到的 <code>match</code> 表达式中的分支一样。</p>
<p>也可以包含一个可选的 <code>else</code> 表达式来提供一个在条件为 <code>false</code> 时应当执行的代码块，这里我们就这么做了。如果不提供 <code>else</code> 表达式并且条件为 <code>false</code> 时，程序会直接忽略 <code>if</code> 代码块并继续执行下面的代码。</p>
<p>另外值得注意的是代码中的条件<strong>必须</strong>是 <code>bool</code> 值。如果条件不是 <code>bool</code> 值，我们将得到一个错误。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> number &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;number was three&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里 <code>if</code> 条件的值是 <code>3</code>，Rust 抛出了一个错误：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">   Compiling branches v0.1.0 (file:///projects/branches)</span><br><span class="line">error[E0308]: mismatched types</span><br><span class="line"><span class="meta prompt_"> --&gt; </span><span class="language-bash">src/main.rs:4:8</span></span><br><span class="line">  |</span><br><span class="line">4 |     if number &#123;</span><br><span class="line">  |        ^^^^^^ expected `bool`, found integer</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0308`.</span><br><span class="line">error: could not compile `branches` (bin &quot;branches&quot;) due to 1 previous error</span><br></pre></td></tr></table></figure>

<p>这个错误表明 Rust 期望一个 <code>bool</code> 却得到了一个整数。不像 Ruby 或 JavaScript 这样的语言， <strong>Rust 并不会尝试自动地将非布尔值转换为布尔值</strong> 。必须总是显式地使用布尔值作为 <code>if</code> 的条件。例如，如果想要 <code>if</code> 代码块只在一个数字不等于 <code>0</code> 时执行，可以把 <code>if</code> 表达式修改成下面这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> number != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;number was something other than zero&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行代码会打印出 <code>number was something other than zero</code>。</p>
<h4 id="使用-else-if-处理多重条件"><a href="#使用-else-if-处理多重条件" class="headerlink" title="使用 else if 处理多重条件"></a>使用 <code>else if</code> 处理多重条件</h4><p>可以将 <code>else if</code> 表达式与 <code>if</code> 和 <code>else</code> 组合来实现多重条件。</p>
<p>使用过多的 <code>else if</code> 表达式会使代码显得杂乱无章，所以如果有多于一个 <code>else if</code> 表达式，最好重构代码。为此，第六章会介绍一个强大的 Rust 分支结构（branching construct），叫做 <code>match</code>。</p>
<h4 id="在-let-语句中使用-if"><a href="#在-let-语句中使用-if" class="headerlink" title="在 let 语句中使用 if"></a>在 <code>let</code> 语句中使用 <code>if</code></h4><p>因为 <code>if</code> 是一个表达式，我们可以在 <code>let</code> 语句的右侧使用它，例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">condition</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = <span class="keyword">if</span> condition &#123; <span class="number">5</span> &#125; <span class="keyword">else</span> &#123; <span class="number">6</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of number is: &#123;number&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码块的值是其最后一个表达式的值，而数字本身就是一个表达式。在这个例子中，整个 <code>if</code> 表达式的值取决于哪个代码块被执行。这意味着 <code>if</code> 的每个分支的可能的返回值都必须是相同类型；</p>
<h3 id="使用循环重复执行"><a href="#使用循环重复执行" class="headerlink" title="使用循环重复执行"></a>使用循环重复执行</h3><p>Rust 有三种循环：<code>loop</code>、<code>while</code> 和 <code>for</code>。</p>
<h4 id="使用-loop-重复执行代码"><a href="#使用-loop-重复执行代码" class="headerlink" title="使用 loop 重复执行代码"></a>使用 <code>loop</code> 重复执行代码</h4><p><code>loop</code> 关键字告诉 Rust 一遍又一遍地执行一段代码直到你明确要求停止。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;again!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当运行这个程序时，我们会看到连续的反复打印 <code>again!</code>，直到我们手动停止程序。大部分终端都支持键盘快捷键 ctrl-c 来终止一个陷入无限循环的程序。</p>
<h4 id="从循环返回值"><a href="#从循环返回值" class="headerlink" title="从循环返回值"></a>从循环返回值</h4><p><code>loop</code> 的一个用例是重试可能会失败的操作，比如检查线程是否完成了任务。然而你可能会需要将操作的结果传递给其它的代码。要实现这一点，可以在用于停止循环的 <code>break</code> 表达式后添加你希望返回的值；这个值就会作为循环的返回值返回，这样你就可以使用它，如下所示：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">counter</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="keyword">loop</span> &#123;</span><br><span class="line">        counter += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> counter == <span class="number">10</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> counter * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The result is &#123;result&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在循环之前，我们声明了一个名为 <code>counter</code> 的变量并初始化为 <code>0</code>。接着声明了一个名为 <code>result</code> 来存放循环的返回值。在循环的每一次迭代中，我们将 <code>counter</code> 变量加 <code>1</code>，接着检查计数是否等于 <code>10</code>。当相等时，使用 <code>break</code> 关键字返回值 <code>counter * 2</code>。循环之后，我们通过分号结束赋值给 <code>result</code> 的语句。最后打印出 <code>result</code> 的值，也就是 <code>20</code>。</p>
<h4 id="循环标签：在多个循环之间消除歧义"><a href="#循环标签：在多个循环之间消除歧义" class="headerlink" title="循环标签：在多个循环之间消除歧义"></a>循环标签：在多个循环之间消除歧义</h4><p>如果存在嵌套循环，<code>break</code> 和 <code>continue</code> 应用于此时最内层的循环。你可以选择在一个循环上指定一个 <strong>循环标签</strong>（<em>loop label</em>），然后将标签与 <code>break</code> 或 <code>continue</code> 一起使用，使这些关键字应用于已标记的循环而不是最内层的循环。下面是一个包含两个嵌套循环的示例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">count</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="string">&#x27;counting_up: loop &#123;</span></span><br><span class="line"><span class="string">        println!(&quot;count = &#123;count&#125;&quot;);</span></span><br><span class="line"><span class="string">        let mut remaining = 10;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        loop &#123;</span></span><br><span class="line"><span class="string">            println!(&quot;remaining = &#123;remaining&#125;&quot;);</span></span><br><span class="line"><span class="string">            if remaining == 9 &#123;</span></span><br><span class="line"><span class="string">                break;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">            if count == 2 &#123;</span></span><br><span class="line"><span class="string">                break &#x27;</span>counting_up;</span><br><span class="line">            &#125;</span><br><span class="line">            remaining -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;End count = &#123;count&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>外层循环有一个标签 <code>counting_up</code>，它将从 0 数到 2。没有标签的内部循环从 10 向下数到 9。第一个没有指定标签的 <code>break</code> 将只退出内层循环。<code>break &#39;counting_up;</code> 语句将退出外层循环。</p>
<h4 id="while-条件循环"><a href="#while-条件循环" class="headerlink" title="while 条件循环"></a><code>while</code> 条件循环</h4><p>在程序中计算循环的条件也很常见。当条件为 <code>true</code>，执行循环。当条件不再为 <code>true</code>，调用 <code>break</code> 停止循环。这个循环类型可以通过组合 <code>loop</code>、<code>if</code>、<code>else</code> 和 <code>break</code> 来实现；如果你喜欢的话，现在就可以在程序中试试。然而，这个模式太常用了，Rust 为此内置了一个语言结构，它被称为 <code>while</code> 循环。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">number</span> = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> number != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;number&#125;!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        number -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;LIFTOFF!!!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种结构消除了很多使用 <code>loop</code>、<code>if</code>、<code>else</code> 和 <code>break</code> 时所必须的嵌套，这样更加清晰。当条件为 <code>true</code> 就执行，否则退出循环。</p>
<h4 id="使用-for-遍历集合"><a href="#使用-for-遍历集合" class="headerlink" title="使用 for 遍历集合"></a>使用 <code>for</code> 遍历集合</h4><p>可以使用 <code>while</code> 结构来遍历集合中的元素，比如数组。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">index</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> index &lt; <span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;the value is: &#123;&#125;&quot;</span>, a[index]);</span><br><span class="line"></span><br><span class="line">        index += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">element</span> <span class="keyword">in</span> a &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;the value is: &#123;element&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是一个使用 <code>for</code> 循环来倒计时的例子，它还使用了一个我们还未讲到的方法，<code>rev</code>，用来反转 range。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">number</span> <span class="keyword">in</span> (<span class="number">1</span>..<span class="number">4</span>).<span class="title function_ invoke__">rev</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;number&#125;!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;LIFTOFF!!!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码看起来更帅气不是吗？</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch03-05-control-flow.html#%E6%80%BB%E7%BB%93">总结</a></h2><p>你做到了！这是一个大章节：你学习了变量、标量和复合数据类型、函数、注释、 <code>if</code> 表达式和循环！</p>
<p>当你准备好继续的时候，让我们讨论一个其他语言中<strong>并不</strong>常见的概念：所有权（ownership）。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-05-17T08:42:26.000Z" title="2025/5/17 16:42:26">2025-05-17</time>发表</span><span class="level-item"><time dateTime="2025-05-17T08:42:23.704Z" title="2025/5/17 16:42:23">2025-05-17</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Rust/">Rust</a><span> / </span><a class="link-muted" href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></span><span class="level-item">1 分钟读完 (大约213个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/05/17/Rust/The%20Rust%20Programming%20Language/03.4%20%E6%B3%A8%E9%87%8A/">3.4 注释</a></p><div class="content"><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>在 Rust 中，惯用的注释样式是以两个斜杠开始注释，并持续到本行的结尾。对于超过一行的注释，需要在每一行前都加上 <code>//</code>，像这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// So we’re doing something complicated here, long enough that we need</span></span><br><span class="line"><span class="comment">// multiple lines of comments to do it! Whew! Hopefully, this comment will</span></span><br><span class="line"><span class="comment">// explain what’s going on.</span></span><br></pre></td></tr></table></figure>

<p>注释也可以放在包含代码的行的末尾：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">lucky_number</span> = <span class="number">7</span>; <span class="comment">// I&#x27;m feeling lucky today</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过你更经常看到的是以这种格式使用它们，也就是位于它所解释的代码行的上面一行：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// I&#x27;m feeling lucky today</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">lucky_number</span> = <span class="number">7</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Rust 还有另一种注释，称为文档注释，我们将在 14 章的 [“将 crate 发布到 Crates.io” ](.&#x2F;14.2 将 crate 发布到 Crates.io)部分讨论它。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-05-17T08:40:26.000Z" title="2025/5/17 16:40:26">2025-05-17</time>发表</span><span class="level-item"><time dateTime="2025-05-17T08:40:38.008Z" title="2025/5/17 16:40:38">2025-05-17</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Rust/">Rust</a><span> / </span><a class="link-muted" href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></span><span class="level-item">14 分钟读完 (大约2104个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/05/17/Rust/The%20Rust%20Programming%20Language/03.3%20%E5%87%BD%E6%95%B0/">3.3 函数</a></p><div class="content"><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数在 Rust 代码中非常普遍。你已经见过语言中最重要的函数之一：<code>main</code> 函数，它是很多程序的入口点。你也见过 <code>fn</code> 关键字，它用来声明新函数。</p>
<p>Rust 代码中的函数和变量名使用 <em>snake case</em> 规范风格。在 snake case 中，所有字母都是小写并使用下划线分隔单词。这是一个包含函数定义示例的程序：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">another_function</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">another_function</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Another function.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在 Rust 中通过输入 <code>fn</code> 后面跟着函数名和一对圆括号来定义函数。大括号告诉编译器哪里是函数体的开始和结尾。</p>
<p>可以使用函数名后跟圆括号来调用我们定义过的任意函数。因为程序中已定义 <code>another_function</code> 函数，所以可以在 <code>main</code> 函数中调用它。注意，源码中 <code>another_function</code> 定义在 <code>main</code> 函数 <strong>之后</strong>；也可以定义在之前。 <strong>Rust 不关心函数定义所在的位置</strong> ，只要函数被调用时出现在调用之处可见的作用域内就行。</p>
<p><code>main</code> 函数中的代码会按顺序执行。首先，打印 “Hello, world!” 信息，然后调用 <code>another_function</code> 函数并打印它的信息。</p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>我们可以定义为拥有 <strong>参数</strong>（<em>parameters</em>）的函数，参数是特殊变量，是函数签名的一部分。当函数拥有参数（形参）时，可以为这些参数提供具体的值（实参）。技术上讲，这些具体值被称为参数（<em>arguments</em>），但是在日常交流中，人们倾向于不区分使用 <em>parameter</em> 和 <em>argument</em> 来表示函数定义中的变量或调用函数时传入的具体值。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">another_function</span>(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">another_function</span>(x: <span class="type">i32</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尝试运行程序，将会输出如下内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">   Compiling functions v0.1.0 (file:///projects/functions)</span><br><span class="line">    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.21s</span><br><span class="line">     Running `target/debug/functions`</span><br><span class="line">The value of x is: 5</span><br></pre></td></tr></table></figure>

<p><code>another_function</code> 的声明中有一个命名为 <code>x</code> 的参数。<code>x</code> 的类型被指定为 <code>i32</code>。当我们将 <code>5</code> 传给 <code>another_function</code> 时，<code>println!</code> 宏会把 <code>5</code> 放在格式字符串中包含 <code>x</code> 的那对花括号的位置。</p>
<p>在函数签名中，<strong>必须</strong> 声明每个参数的类型。这是 Rust 设计中一个经过慎重考虑的决定：要求在函数定义中提供类型注解，意味着编译器再也不需要你在代码的其他地方注明类型来指出你的意图。而且，在知道函数需要什么类型后，编译器就能够给出更有用的错误消息。</p>
<p>当定义多个参数时，使用逗号分隔，像这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">print_labeled_measurement</span>(<span class="number">5</span>, <span class="string">&#x27;h&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print_labeled_measurement</span>(value: <span class="type">i32</span>, unit_label: <span class="type">char</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The measurement is: &#123;value&#125;&#123;unit_label&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子创建了一个名为 <code>print_labeled_measurement</code> 的函数，它有两个参数。第一个参数名为 <code>value</code>，类型是 <code>i32</code>。第二个参数是 <code>unit_label</code> ，类型是 <code>char</code>。然后，该函数打印包含 <code>value</code> 和 <code>unit_label</code> 的文本。</p>
<p>尝试运行代码。使用上面的例子替换当前 <em>functions</em> 项目的 <em>src&#x2F;main.rs</em> 文件，并用 <code>cargo run</code> 运行它：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">   Compiling functions v0.1.0 (file:///projects/functions)</span><br><span class="line">    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s</span><br><span class="line">     Running `target/debug/functions`</span><br><span class="line">The measurement is: 5h</span><br></pre></td></tr></table></figure>

<p>因为我们使用 <code>5</code> 作为 <code>value</code> 的值，<code>h</code> 作为 <code>unit_label</code> 的值来调用函数，所以程序输出包含这些值。</p>
<h3 id="语句和表达式"><a href="#语句和表达式" class="headerlink" title="语句和表达式"></a>语句和表达式</h3><p>语句不返回值。因此，不能把 <code>let</code> 语句赋值给另一个变量，比如下面的例子尝试做的，会产生一个错误：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = (<span class="keyword">let</span> <span class="variable">y</span> = <span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>let y = 6</code> 语句并不返回值，所以没有可以绑定到 <code>x</code> 上的值。这与其他语言不同，例如 C 和 Ruby，它们的赋值语句会返回所赋的值。在这些语言中，可以这么写 <code>x = y = 6</code>，这样 <code>x</code> 和 <code>y</code> 的值都是 <code>6</code>；Rust 中不能这样写。</p>
<p>表达式会计算出一个值，并且你将编写的大部分 Rust 代码是由表达式组成的。考虑一个数学运算，比如 <code>5 + 6</code>，这是一个表达式并计算出值 <code>11</code>。表达式可以是语句的一部分：语句 <code>let y = 6;</code> 中的 <code>6</code> 是一个表达式，它计算出的值是 <code>6</code>。函数调用是一个表达式。宏调用是一个表达式。用大括号创建的一个新的块作用域也是一个表达式，例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// equals let y = 4;</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">3</span>;</span><br><span class="line">        x + <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of y is: &#123;y&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个表达式：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">3</span>;</span><br><span class="line">    x + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是一个代码块，它的值是 <code>4</code>。这个值作为 <code>let</code> 语句的一部分被绑定到 <code>y</code> 上。注意 <code>x + 1</code> 这一行在结尾没有分号，与你见过的大部分代码行不同。 <strong>表达式的结尾没有分号</strong> 。<u>如果在表达式的结尾加上分号，它就变成了语句，而语句不会返回值。</u>在接下来探索具有返回值的函数和表达式时要谨记这一点。</p>
<h3 id="具有返回值的函数"><a href="#具有返回值的函数" class="headerlink" title="具有返回值的函数"></a>具有返回值的函数</h3><p>函数可以向调用它的代码返回值。我们并不对返回值命名，但要在 <strong>箭头（<code>-&gt;</code>）后声明它的类型</strong> 。在 Rust 中，函数的返回值等同于函数体最后一个表达式的值。使用 <code>return</code> 关键字和指定值，可从函数中提前返回；但大部分函数隐式的返回最后的表达式。这是一个有返回值的函数的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">five</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">five</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>five</code> 函数中没有函数调用、宏、甚至没有 <code>let</code> 语句 —— 只有数字 <code>5</code>。这在 Rust 中是一个完全有效的函数。注意，也指定了函数返回值的类型，就是 <code>-&gt; i32</code>。尝试运行代码；输出应该看起来像这样：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">   Compiling functions v0.1.0 (file:///projects/functions)</span><br><span class="line">    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s</span><br><span class="line">     Running `target/debug/functions`</span><br><span class="line">The value of x is: 5</span><br></pre></td></tr></table></figure>

<p><code>five</code> 函数的返回值是 <code>5</code>，所以返回值类型是 <code>i32</code>。让我们仔细检查一下这段代码。有两个重要的部分：首先，<code>let x = five();</code> 这一行表明我们使用函数的返回值初始化一个变量。因为 <code>five</code> 函数返回 <code>5</code>，这一行与如下代码相同：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>其次，<code>five</code> 函数没有参数并定义了返回值类型，不过函数体只有单单一个 <code>5</code> 也没有分号，因为这是一个表达式，我们想要返回它的值。</p>
<p>让我们看看另一个例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">plus_one</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">plus_one</span>(x: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    x + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行代码会打印出 <code>The value of x is: 6</code>。但如果在包含 <code>x + 1</code> 的行尾加上一个分号，把它从表达式变成语句，我们将看到一个错误。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">plus_one</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">plus_one</span>(x: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行代码会产生一个错误，如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">   Compiling functions v0.1.0 (file:///projects/functions)</span><br><span class="line">error[E0308]: mismatched types</span><br><span class="line"><span class="meta prompt_"> --&gt; </span><span class="language-bash">src/main.rs:7:24</span></span><br><span class="line">  |</span><br><span class="line">7 | fn plus_one(x: i32) -&gt; i32 &#123;</span><br><span class="line">  |    --------            ^^^ expected `i32`, found `()`</span><br><span class="line">  |    |</span><br><span class="line">  |    implicitly returns `()` as its body has no tail or `return` expression</span><br><span class="line">8 |     x + 1;</span><br><span class="line">  |          - help: remove this semicolon to return this value</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0308`.</span><br><span class="line">error: could not compile `functions` (bin &quot;functions&quot;) due to 1 previous error</span><br></pre></td></tr></table></figure>

<p>主要的错误信息，“mismatched types”（类型不匹配），揭示了代码的核心问题。函数 <code>plus_one</code> 的定义说明它要返回一个 <code>i32</code> 类型的值，不过语句并不会返回值，使用单位类型 <code>()</code> 表示不返回值。因为不返回值与函数定义相矛盾，从而出现一个错误。在输出中，Rust 提供了一条信息，可能有助于纠正这个错误：它建议删除分号，这会修复这个错误。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-05-17T08:29:26.000Z" title="2025/5/17 16:29:26">2025-05-17</time>发表</span><span class="level-item"><time dateTime="2025-05-17T08:29:33.720Z" title="2025/5/17 16:29:33">2025-05-17</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Rust/">Rust</a><span> / </span><a class="link-muted" href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></span><span class="level-item">23 分钟读完 (大约3462个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/05/17/Rust/The%20Rust%20Programming%20Language/03.2%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">3.2 数据类型</a></p><div class="content"><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>在 Rust 中，每一个值都有一个特定 <strong>数据类型</strong>（<em>data type</em>），这告诉 Rust 它被指定为何种数据，以便明确数据处理方式。我们将看到两类数据类型子集：标量（scalar）和复合（compound）。</p>
<p>记住，Rust 是 <strong>静态类型</strong>（<em>statically typed</em>）语言，也就是说在编译时就必须知道所有变量的类型。根据值及其使用方式，编译器通常可以推断出我们想要用的类型。当多种类型均有可能时，比如第二章使用 <code>parse</code> 将 <code>String</code> 转换为数字时，必须增加类型注解，像这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">guess</span>: <span class="type">u32</span> = <span class="string">&quot;42&quot;</span>.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Not a number!&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>如果不像上面的代码这样添加类型注解 <code>: u32</code>，Rust 会显示如下错误，这说明编译器需要我们提供更多信息，来了解我们想要的类型：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo build</span></span><br><span class="line">   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)</span><br><span class="line">error[E0284]: type annotations needed</span><br><span class="line"><span class="meta prompt_"> --&gt; </span><span class="language-bash">src/main.rs:2:9</span></span><br><span class="line">  |</span><br><span class="line">2 |     let guess = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);</span><br><span class="line">  |         ^^^^^        ----- type must be known at this point</span><br><span class="line">  |</span><br><span class="line">  = note: cannot satisfy `&lt;_ as FromStr&gt;::Err == _`</span><br><span class="line">help: consider giving `guess` an explicit type</span><br><span class="line">  |</span><br><span class="line">2 |     let guess: /* Type */ = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);</span><br><span class="line">  |              ++++++++++++</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0284`.</span><br><span class="line">error: could not compile `no_type_annotations` (bin &quot;no_type_annotations&quot;) due to 1 previous error</span><br></pre></td></tr></table></figure>

<p>你会看到其它数据类型的各种类型注解。</p>
<h3 id="标量类型"><a href="#标量类型" class="headerlink" title="标量类型"></a>标量类型</h3><p><strong>标量</strong>（<em>scalar</em>）类型代表一个单独的值。Rust 有四种基本的标量类型： <strong>整型、浮点型、布尔类型和字符类型</strong> 。你可能在其他语言中见过它们。让我们深入了解它们在 Rust 中是如何工作的。</p>
<h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><p><strong>整型</strong> 是一个没有小数部分的数字。我们在第二章使用过 <code>u32</code> 整数类型。该类型声明表明，它关联的值应该是一个占据 32 比特位的无符号整数（有符号整数类型以 <code>i</code> 开头而不是 <code>u</code>）。表格展示了 Rust 内建的整数类型。我们可以使用其中的任一个来声明一个整数值的类型。</p>
<table>
<thead>
<tr>
<th>长度</th>
<th>有符号</th>
<th>无符号</th>
</tr>
</thead>
<tbody><tr>
<td>8-bit</td>
<td><code>i8</code></td>
<td><code>u8</code></td>
</tr>
<tr>
<td>16-bit</td>
<td><code>i16</code></td>
<td><code>u16</code></td>
</tr>
<tr>
<td>32-bit</td>
<td><code>i32</code></td>
<td><code>u32</code></td>
</tr>
<tr>
<td>64-bit</td>
<td><code>i64</code></td>
<td><code>u64</code></td>
</tr>
<tr>
<td>128-bit</td>
<td><code>i128</code></td>
<td><code>u128</code></td>
</tr>
<tr>
<td>架构相关</td>
<td><code>isize</code></td>
<td><code>usize</code></td>
</tr>
</tbody></table>
<p>另外，<code>isize</code> 和 <code>usize</code> 类型依赖运行程序的计算机架构：64 位架构上它们是 64 位的，32 位架构上它们是 32 位的。</p>
<p>可以使用表格中的任何一种形式编写数字字面值。请注意可以是多种数字类型的数字字面值允许使用类型后缀，例如 <code>57u8</code> 来指定类型，同时也允许使用 <code>_</code> 做为分隔符以方便读数，例如<code>1_000</code>，它的值与你指定的 <code>1000</code> 相同。</p>
<table>
<thead>
<tr>
<th>数字字面值</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>Decimal (十进制)</td>
<td><code>98_222</code></td>
</tr>
<tr>
<td>Hex (十六进制)</td>
<td><code>0xff</code></td>
</tr>
<tr>
<td>Octal (八进制)</td>
<td><code>0o77</code></td>
</tr>
<tr>
<td>Binary (二进制)</td>
<td><code>0b1111_0000</code></td>
</tr>
<tr>
<td>Byte (单字节字符)(仅限于<code>u8</code>)</td>
<td><code>b&#39;A&#39;</code></td>
</tr>
</tbody></table>
<p>Rust 的默认整型默认是 <code>i32</code>。<code>isize</code> 或 <code>usize</code> 主要作为某些集合的索引。</p>
<h5 id="整型溢出"><a href="#整型溢出" class="headerlink" title="整型溢出"></a>整型溢出</h5><p>比方说有一个 <code>u8</code> ，它可以存放从零到 <code>255</code> 的值。那么当你将其修改为 <code>256</code> 时就会发生 <strong>整型溢出</strong>（<em>integer overflow</em> ），这会导致以下两种行为之一的发生。当在 debug 模式编译时，Rust 检查这类问题并使程序 <em>panic</em>。<em>panic</em> 这个术语被 Rust 用来表明程序因错误而退出。第九章会详细介绍 panic。</p>
<p>使用 <code>--release</code> flag 在 release 模式中构建时，Rust <strong>不会</strong>检测会导致 panic 的整型溢出。相反发生整型溢出时，Rust 会进行一种被称为二进制补码 wrapping（<em>two’s complement wrapping</em>）的操作。简而言之，比此类型能容纳最大值还大的值会 <strong>回绕到最小值</strong> ，值 <code>256</code> 变成 <code>0</code>，值 <code>257</code> 变成 <code>1</code>，依此类推。程序不会 panic，不过变量可能也不会是你所期望的值。依赖整型溢出 wrapping 的行为被认为是一种错误。</p>
<p>为了显式地处理溢出的可能性，可以使用这几类标准库提供的原始数字类型方法：</p>
<ul>
<li>所有模式下都可以使用 <code>wrapping_*</code> 方法进行 wrapping，如 <code>wrapping_add</code></li>
<li>如果 <code>checked_*</code> 方法出现溢出，则返回 <code>None</code>值</li>
<li>用 <code>overflowing_*</code> 方法返回值和一个布尔值，表示是否出现溢出</li>
<li>用 <code>saturating_*</code> 方法在值的最小值或最大值处进行饱和处理</li>
</ul>
<h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><p>Rust 有两个原生的 <strong>浮点数</strong>（<em>floating-point numbers</em>）类型，它们是带小数点的数字。Rust 的浮点数类型是 <code>f32</code> 和 <code>f64</code>，分别占 32 位和 64 位。默认类型是 <code>f64</code>，因为在现代 CPU 中，它与 <code>f32</code> 速度几乎一样，不过精度更高。所有的浮点型都是有符号的。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">2.0</span>; <span class="comment">// f64</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span>: <span class="type">f32</span> = <span class="number">3.0</span>; <span class="comment">// f32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>浮点数采用 IEEE-754 标准表示。（<code>f32</code> 是单精度浮点数，<code>f64</code> 是双精度浮点数。）</p>
<h4 id="数值运算"><a href="#数值运算" class="headerlink" title="数值运算"></a>数值运算</h4><p>Rust 中的所有数字类型都支持基本数学运算：加法、减法、乘法、除法和取余。整数除法会向零舍入到最接近的整数。下面的代码展示了如何在 <code>let</code> 语句中使用各种数值运算：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// addition</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sum</span> = <span class="number">5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// subtraction</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">difference</span> = <span class="number">95.5</span> - <span class="number">4.3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// multiplication</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">product</span> = <span class="number">4</span> * <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// division</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">quotient</span> = <span class="number">56.7</span> / <span class="number">32.2</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">truncated</span> = -<span class="number">5</span> / <span class="number">3</span>; <span class="comment">// 结果为 -1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// remainder</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">remainder</span> = <span class="number">43</span> % <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些语句中的每个表达式使用了一个数学运算符并计算出了一个值，然后绑定给一个变量。[附录 B](.&#x2F;22.2 B) 包含 Rust 提供的所有运算符的列表。</p>
<h4 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h4><p>如其他大部分编程语言一样，Rust 中的布尔类型有两个可能的值：<code>true</code> 和 <code>false</code>。Rust 中的布尔类型使用 <code>bool</code> 表示。例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span>: <span class="type">bool</span> = <span class="literal">false</span>; <span class="comment">// with explicit type annotation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用布尔值的主要场景是条件表达式，例如 <code>if</code> 表达式。在 [“控制流”（“Control Flow”）](.&#x2F;03.5 控制流) 部分将介绍 <code>if</code> 表达式在 Rust 中如何工作。</p>
<h4 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h4><p>Rust 的 <code>char</code> 类型是语言中最原始的字母类型。下面是一些声明 <code>char</code> 值的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">z</span>: <span class="type">char</span> = <span class="string">&#x27;ℤ&#x27;</span>; <span class="comment">// with explicit type annotation</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">heart_eyed_cat</span> = <span class="string">&#x27;😻&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，我们用 <strong>单引号</strong> 声明 <code>char</code> 字面值，而与之相反的是，使用 <strong>双引号声明字符串</strong> 字面值。Rust 的 <code>char</code> 类型的大小为 <strong>四个字节</strong>  (four bytes)，并代表了一个 Unicode 标量值（Unicode Scalar Value），这意味着它可以比 ASCII 表示更多内容。在 Rust 中，带变音符号的字母（Accented letters），中文、日文、韩文等字符，emoji（绘文字）以及零长度的空白字符都是有效的 <code>char</code> 值。Unicode 标量值包含从 <code>U+0000</code> 到 <code>U+D7FF</code> 和 <code>U+E000</code> 到 <code>U+10FFFF</code> 在内的值。不过，“字符” 并不是一个 Unicode 中的概念，所以人直觉上的 “字符” 可能与 Rust 中的 <code>char</code> 并不符合。第八章的 [“使用字符串储存 UTF-8 编码的文本”](.&#x2F;08.2 使用字符串储存 UTF-8 编码的文本) 中将详细讨论这个主题。</p>
<h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><p><strong>复合类型</strong>（<em>Compound types</em>）可以将多个值组合成一个类型。Rust 有两个原生的复合类型：元组（tuple）和数组（array）。</p>
<h4 id="元组类型"><a href="#元组类型" class="headerlink" title="元组类型"></a>元组类型</h4><p>元组是一个将多个不同类型的值组合进一个复合类型的主要方式。元组长度固定：一旦声明，其 <strong>长度不会增大或缩小</strong> 。</p>
<p>我们使用包含在圆括号中的逗号分隔的值列表来创建一个元组。元组中的每一个位置都有一个类型，而且这些不同值的类型也不必是相同的。这个例子中使用了可选的类型注解：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tup</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tup</code> 变量绑定到整个元组上，因为元组是一个单独的复合元素。为了从元组中获取单个值，可以使用模式匹配（pattern matching）来解构（destructure）元组值，像这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tup</span> = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (x, y, z) = tup;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of y is: &#123;y&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序首先创建了一个元组并绑定到 <code>tup</code> 变量上。接着使用了 <code>let</code> 和一个模式将 <code>tup</code> 分成了三个不同的变量，<code>x</code>、<code>y</code> 和 <code>z</code>。这叫做 <strong>解构</strong>（<em>destructuring</em>），因为它将一个元组拆成了三个部分。最后，程序打印出了 <code>y</code> 的值，也就是 <code>6.4</code>。</p>
<p>我们也可以使用点号（<code>.</code>）后跟值的索引来直接访问所需的元组元素。例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">five_hundred</span> = x.<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">six_point_four</span> = x.<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">one</span> = x.<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序创建了一个元组，<code>x</code>，然后使用其各自的索引访问元组中的每个元素。跟大多数编程语言一样，元组的第一个索引值是 0。</p>
<p>不带任何值的元组有个特殊的名称，叫做 <strong>单元（unit）</strong> 元组。这种值以及对应的类型都写作 <code>()</code>，表示空值或空的返回类型。如果 <strong>表达式不返回任何其他值，则会隐式返回单元值</strong> 。</p>
<h4 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h4><p>另一个包含多个值的方式是 <strong>数组</strong>（<em>array</em>）。与元组不同，数组中的每个元素的类型必须相同。Rust 中的数组与一些其他语言中的数组不同，Rust 中的 <strong>数组长度是固定的</strong> 。</p>
<p>我们将数组的值写成在方括号内，用逗号分隔的列表：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当你想要在栈（stack）而不是在堆（heap）上为数据分配空间（[第四章](.&#x2F;04.1 什么是所有权)将讨论栈与堆的更多内容），或者是想要确保总是有固定数量的元素时，数组非常有用。但是数组并不如 vector 类型灵活。vector 类型是标准库提供的一个 <strong>允许增长和缩小长度</strong> 的类似数组的集合类型。当不确定是应该使用数组还是 vector 的时候，那么很可能应该使用 vector。[第八章](.&#x2F;08.1 使用 Vector 储存列表)会详细讨论 vector。</p>
<p>然而，当你确定元素个数不会改变时，数组会更有用。例如，当你在一个程序中使用月份名字时，你更应趋向于使用数组而不是 vector，因为你确定只会有 12 个元素。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">months</span> = [<span class="string">&quot;January&quot;</span>, <span class="string">&quot;February&quot;</span>, <span class="string">&quot;March&quot;</span>, <span class="string">&quot;April&quot;</span>, <span class="string">&quot;May&quot;</span>, <span class="string">&quot;June&quot;</span>, <span class="string">&quot;July&quot;</span>,</span><br><span class="line">              <span class="string">&quot;August&quot;</span>, <span class="string">&quot;September&quot;</span>, <span class="string">&quot;October&quot;</span>, <span class="string">&quot;November&quot;</span>, <span class="string">&quot;December&quot;</span>];</span><br></pre></td></tr></table></figure>

<p>可以像这样编写数组的类型：在方括号中包含每个元素的类型，后跟分号，再后跟数组元素的数量。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span>: [<span class="type">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<p>这里，<code>i32</code> 是每个元素的类型。分号之后，数字 <code>5</code> 表明该数组包含五个元素。</p>
<p>你还可以通过在方括号中指定初始值加分号再加元素个数的方式来创建一个每个元素都为相同值的数组：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">3</span>; <span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<p>变量名为 <code>a</code> 的数组将包含 <code>5</code> 个元素，这些元素的值最初都将被设置为 <code>3</code>。这种写法与 <code>let a = [3, 3, 3, 3, 3];</code> 效果相同，但更简洁。</p>
<h5 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h5><p>数组是可以在栈 (stack) 上分配的已知固定大小的单个内存块。可以使用索引来访问数组的元素，像这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">first</span> = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">second</span> = a[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，叫做 <code>first</code> 的变量的值是 <code>1</code>，因为它是数组索引 <code>[0]</code> 的值。变量 <code>second</code> 将会是数组索引 <code>[1]</code> 的值 <code>2</code>。</p>
<h5 id="无效的数组元素访问"><a href="#无效的数组元素访问" class="headerlink" title="无效的数组元素访问"></a>无效的数组元素访问</h5><p>让我们看看如果我们访问数组结尾之后的元素会发生什么呢？比如你执行以下代码，它使用类似于第 2 章中的猜数字游戏的代码从用户那里获取数组索引：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Please enter an array index.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">index</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    io::<span class="title function_ invoke__">stdin</span>()</span><br><span class="line">        .<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> index)</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to read line&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">index</span>: <span class="type">usize</span> = index</span><br><span class="line">        .<span class="title function_ invoke__">trim</span>()</span><br><span class="line">        .<span class="title function_ invoke__">parse</span>()</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Index entered was not a number&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">element</span> = a[index];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of the element at index &#123;index&#125; is: &#123;element&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此代码编译成功。如果您使用 <code>cargo run</code> 运行此代码并输入 <code>0</code>、<code>1</code>、<code>2</code>、<code>3</code> 或 <code>4</code>，程序将在数组中的索引处打印出相应的值。如果你输入一个超过数组末端的数字，如 10，你会看到这样的输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread &#x27;main&#x27; panicked at src/main.rs:19:19:</span><br><span class="line">index out of bounds: the len is 5 but the index is 10</span><br><span class="line">note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace</span><br></pre></td></tr></table></figure>

<p>程序在索引操作中使用一个无效的值时导致 <strong>运行时</strong> 错误。程序带着错误信息退出，并且没有执行最后的 <code>println!</code> 语句。当尝试用索引访问一个元素时，Rust 会检查指定的索引是否小于数组的长度。如果索引超出了数组长度，Rust 会 <em>panic</em>，这是 Rust 术语，它用于程序因为错误而退出的情况。这种检查必须在运行时进行，特别是在这种情况下，因为编译器不可能知道用户在以后运行代码时将输入什么值。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-05-17T08:02:26.000Z" title="2025/5/17 16:02:26">2025-05-17</time>发表</span><span class="level-item"><time dateTime="2025-05-17T08:03:19.310Z" title="2025/5/17 16:03:19">2025-05-17</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Rust/">Rust</a><span> / </span><a class="link-muted" href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></span><span class="level-item">14 分钟读完 (大约2155个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/05/17/Rust/The%20Rust%20Programming%20Language/03.1%20%E5%8F%98%E9%87%8F%E4%B8%8E%E5%8F%AF%E5%8F%98%E6%80%A7/">3.1 变量与可变性</a></p><div class="content"><h2 id="变量和可变性"><a href="#变量和可变性" class="headerlink" title="变量和可变性"></a>变量和可变性</h2><p>正如第二章中提到的那样，变量默认是 **不可改变 ** 的（immutable）。这是 Rust 提供给你的众多优势之一，让你得以充分利用 Rust 提供的安全性和简单并发性来编写代码。不过，你仍然可以使用可变变量。让我们探讨一下 Rust 为何及如何鼓励你利用不可变性，以及何时你会选择禁用它。</p>
<p>当变量不可变时，一旦值被绑定一个名称上，你就不能改变这个值。为了对此进行说明，使用 <code>cargo new variables</code> 命令在 <em>projects</em> 目录生成一个叫做 <em>variables</em> 的新项目。</p>
<p>接着，在新建的 <em>variables</em> 目录，打开 <em>src&#x2F;main.rs</em> 并将代码替换为如下代码，这些代码还不能编译，我们会首次检查到不可变错误（immutability error）：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;x&#125;&quot;</span>);</span><br><span class="line">    x = <span class="number">6</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>保存并使用 <code>cargo run</code> 运行程序。应该会看到一条与不可变性有关的错误信息，如下输出所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">   Compiling variables v0.1.0 (file:///projects/variables)</span><br><span class="line">error[E0384]: cannot assign twice to immutable variable `x`</span><br><span class="line"><span class="meta prompt_"> --&gt; </span><span class="language-bash">src\main.rs:4:5</span></span><br><span class="line">  |</span><br><span class="line">2 |     let x = 5;</span><br><span class="line">  |         - first assignment to `x`</span><br><span class="line">3 |     println!(&quot;The value of x is: &#123;&#125;&quot;, x);</span><br><span class="line">4 |     x = 6;</span><br><span class="line">  |     ^^^^^ cannot assign twice to immutable variable</span><br><span class="line">  |</span><br><span class="line">help: consider making this binding mutable</span><br><span class="line">  |</span><br><span class="line">2 |     let mut x = 5;</span><br><span class="line">  |         +++</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0384`.</span><br><span class="line">error: could not compile `variables` (bin &quot;variables&quot;) due to 1 previous error</span><br></pre></td></tr></table></figure>

<p>这个例子展示了编译器如何帮助你找出程序中的错误。虽然编译错误令人沮丧，但那只是表示程序不能安全的完成你想让它完成的工作；并 <strong>不能</strong> 说明你不是一个好程序员！经验丰富的 Rustacean 们一样会遇到编译错误。</p>
<p>错误信息指出错误的原因是 <code>不能对不可变变量 x 二次赋值</code>（<code>cannot assign twice to immutable variable </code>x<code> </code>），因为你尝试对不可变变量 <code>x</code> 赋第二个值。</p>
<p>不过可变性也是非常有用的，可以用来更方便地编写代码。尽管变量默认是不可变的，你仍然可以在变量名前添加 <code>mut</code> 来使其可变，正如在第二章所做的那样。<code>mut</code> 也向读者表明了其他代码将会改变这个变量值的意图。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;x&#125;&quot;</span>);</span><br><span class="line">    x = <span class="number">6</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在运行这个程序，会出现如下内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">   Compiling variables v0.1.0 (file:///projects/variables)</span><br><span class="line">    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s</span><br><span class="line">     Running `target/debug/variables`</span><br><span class="line">The value of x is: 5</span><br><span class="line">The value of x is: 6</span><br></pre></td></tr></table></figure>

<p>通过 <code>mut</code>，允许把绑定到 <code>x</code> 的值从 <code>5</code> 改成 <code>6</code>。是否让变量可变的最终决定权仍然在你，取决于在某个特定情况下，你是否认为变量可变会让代码更加清晰明了。</p>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>类似于不可变变量，<em>常量 (constants)</em> 是绑定到一个名称的不允许改变的值，不过 <strong>常量与变量还是有一些区别</strong> 。</p>
<p>首先，不允许对常量使用 <code>mut</code>。常量不光默认不可变，它总是不可变。声明常量使用 <code>const</code> 关键字而不是 <code>let</code>，并且 <em>必须</em> 注明值的类型。在下一部分，[“数据类型”](.&#x2F;03.2 数据类型) 中会介绍类型和类型注解，现在无需关心这些细节，记住总是标注类型即可。</p>
<p>常量可以在任何作用域中声明，包括全局作用域，这在一个值需要被很多部分的代码用到时很有用。</p>
<p>最后一个区别是，常量只能被设置为常量表达式，而不可以是其他任何只能在运行时计算出的值。</p>
<p>下面是一个声明常量的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> THREE_HOURS_IN_SECONDS: <span class="type">u32</span> = <span class="number">60</span> * <span class="number">60</span> * <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>常量的名称是 <code>THREE_HOURS_IN_SECONDS</code>，它的值被设置为 60（一分钟内的秒数）乘以 60（一小时内的分钟数）再乘以 3（我们在这个程序中要计算的小时数）的结果。Rust 对常量的命名约定是在单词之间使用全大写加下划线。编译器能够在编译时计算一组有限的操作，这使我们可以选择以更容易理解和验证的方式写出此值，而不是将此常量设置为值 10,800。有关声明常量时可以使用哪些操作的详细信息，请参阅 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/reference/const_eval.html">Rust Reference 的常量求值部分</a>。</p>
<p>在声明它的作用域之中，常量在整个程序生命周期中都有效，此属性使得常量可以作为多处代码使用的全局范围的值，例如一个游戏中所有玩家可以获取的最高分或者光速。</p>
<p>将遍布于应用程序中的硬编码值声明为常量，能帮助后来的代码维护人员了解值的意图。如果将来需要修改硬编码值，也只需修改汇聚于一处的硬编码值。</p>
<h3 id="遮蔽"><a href="#遮蔽" class="headerlink" title="遮蔽"></a>遮蔽</h3><p>正如在猜数字游戏中所讲，我们可以定义一个与之前变量同名的新变量。Rustacean 们称之为第一个变量被第二个 <strong>遮蔽（Shadowing）</strong> 了，这意味着当您使用变量的名称时，编译器将看到第二个变量。实际上，第二个变量遮蔽了第一个变量，此时任何使用该变量名的行为中都会视为是在使用第二个变量，直到第二个变量自己也被遮蔽或第二个变量的作用域结束。可以用相同变量名称来遮蔽一个变量，以及重复使用 <code>let</code> 关键字来多次遮蔽，如下所示：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = x + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = x * <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;The value of x in the inner scope is: &#123;x&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序首先将 <code>x</code> 绑定到值 <code>5</code> 上。接着通过 <code>let x =</code> 创建了一个新变量 <code>x</code>，获取初始值并加 <code>1</code>，这样 <code>x</code> 的值就变成 <code>6</code> 了。然后，在使用花括号创建的 <strong>内部作用域</strong> 内，第三个 <code>let</code> 语句也遮蔽了 <code>x</code> 并创建了一个新的变量，将之前的值乘以 <code>2</code>，<code>x</code> 得到的值是 <code>12</code>。当该作用域结束时，内部遮蔽的作用域也结束了，<code>x</code> 又返回到 <code>6</code>。运行这个程序，它会有如下输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">   Compiling variables v0.1.0 (file:///projects/variables)</span><br><span class="line">    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s</span><br><span class="line">     Running `target/debug/variables`</span><br><span class="line">The value of x in the inner scope is: 12</span><br><span class="line">The value of x is: 6</span><br></pre></td></tr></table></figure>

<p>遮蔽与将变量标记为 <code>mut</code> 是有区别的。当不小心尝试对变量重新赋值时，如果没有使用 <code>let</code> 关键字，就会导致编译时错误。通过使用 <code>let</code>，我们可以用这个值进行一些计算，不过计算完之后变量仍然是不可变的。</p>
<p><code>mut</code> 与遮蔽的另一个区别是，当再次使用 <code>let</code> 时，实际上创建了一个新变量，我们可以改变值的类型，并且复用这个名字。例如，假设程序请求用户输入空格字符来说明希望在文本之间显示多少个空格，接下来我们想将输入存储成数字（多少个空格）：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">spaces</span> = <span class="string">&quot;   &quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">spaces</span> = spaces.<span class="title function_ invoke__">len</span>();</span><br></pre></td></tr></table></figure>

<p>第一个 <code>spaces</code> 变量是字符串类型，第二个 <code>spaces</code> 变量是数字类型。遮蔽使我们不必使用不同的名字，如 <code>spaces_str</code> 和 <code>spaces_num</code>；相反，我们可以复用 <code>spaces</code> 这个更简单的名字。然而，如果尝试使用 <code>mut</code>，将会得到一个编译时错误，如下所示：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">spaces</span> = <span class="string">&quot;   &quot;</span>;</span><br><span class="line">spaces = spaces.<span class="title function_ invoke__">len</span>();</span><br></pre></td></tr></table></figure>

<p>这个错误说明，我们不能改变变量的类型：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">   Compiling variables v0.1.0 (file:///projects/variables)</span><br><span class="line">error[E0308]: mismatched types</span><br><span class="line"><span class="meta prompt_"> --&gt; </span><span class="language-bash">src/main.rs:3:14</span></span><br><span class="line">  |</span><br><span class="line">2 |     let mut spaces = &quot;   &quot;;</span><br><span class="line">  |                      ----- expected due to this value</span><br><span class="line">3 |     spaces = spaces.len();</span><br><span class="line">  |              ^^^^^^^^^^^^ expected `&amp;str`, found `usize`</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0308`.</span><br><span class="line">error: could not compile `variables` (bin &quot;variables&quot;) due to 1 previous error</span><br></pre></td></tr></table></figure>

<p>现在我们已经了解了变量如何工作，让我们看看变量可以拥有的更多数据类型。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-05-16T14:02:26.000Z" title="2025/5/16 22:02:26">2025-05-16</time>发表</span><span class="level-item"><time dateTime="2025-05-16T14:57:39.098Z" title="2025/5/16 22:57:39">2025-05-16</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Rust/">Rust</a><span> / </span><a class="link-muted" href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></span><span class="level-item">1 小时读完 (大约7356个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/05/16/Rust/The%20Rust%20Programming%20Language/02%20%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E7%8C%9C%E6%95%B0%E6%B8%B8%E6%88%8F/">2 猜数小游戏</a></p><div class="content"><h2 id="准备项目"><a href="#准备项目" class="headerlink" title="准备项目"></a>准备项目</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo new guessing_game</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> guessing_game</span></span><br></pre></td></tr></table></figure>

<h2 id="处理一次猜测"><a href="#处理一次猜测" class="headerlink" title="处理一次猜测"></a>处理一次猜测</h2><p>猜数字程序的第一部分请求和处理用户输入，并检查输入是否符合预期的格式。</p>
<p>首先，我们会允许玩家输入一个猜测。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Guess the number!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Please input your guess.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">guess</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    io::<span class="title function_ invoke__">stdin</span>()</span><br><span class="line">        .<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> guess)</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to read line&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;You guessed: &#123;guess&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了获取用户输入并打印结果作为输出，我们需要将 <code>io</code> 输入&#x2F;输出库引入当前作用域。<code>io</code> 库来自于标准库，也被称为 <code>std</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br></pre></td></tr></table></figure>

<p>默认情况下，Rust 设定了若干个会自动导入到每个程序作用域中的标准库内容，这组内容被称为 <em>预导入（prelude）</em> 内容。可以在<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/prelude/index.html">标准库文档</a>中查看预导入的所有内容。</p>
<p>如果需要的类型不在预导入内容中，就必须使用 <code>use</code> 语句显式地将其引入作用域。<code>std::io</code> 库提供很多有用的功能，包括接收用户输入的功能。</p>
<h3 id="使用变量存储值"><a href="#使用变量存储值" class="headerlink" title="使用变量存储值"></a>使用变量存储值</h3><p>接下来，创建一个 <strong>变量</strong>（<em>variable</em>）来储存用户输入：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">guess</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br></pre></td></tr></table></figure>

<p>我们使用 <code>let</code> 语句来创建变量。</p>
<p>在 Rust 中，变量默认是 **不可变 ** 的，这意味着一旦我们给变量赋值，这个值就不可以再修改了。我们将会在第三章的 [“变量与可变性”](.&#x2F;03.1 变量与可变性) 部分详细讨论这个概念。在变量名前使用 <code>mut</code> 来使一个变量可变。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">apples</span> = <span class="number">5</span>; <span class="comment">// 不可变</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">bananas</span> = <span class="number">5</span>; <span class="comment">// 可变</span></span><br></pre></td></tr></table></figure>

<p><code>::new</code> 那一行的 <code>::</code> 语法表明 <code>new</code> 是 <code>String</code> 类型的一个 <strong>关联函数</strong>（<em>associated function</em>）。关联函数是针对某个类型实现的函数，在这个例子中是 <code>String</code>。这个 <code>new</code> 函数创建了一个新的空字符串。你会发现许多类型上都有一个 <code>new</code> 函数，因为这是为某种类型创建新值的常用函数名。</p>
<p>总的来说，<code>let mut guess = String::new();</code> 这一行创建了一个可变变量，当前它绑定到一个新的 <code>String</code> 空实例上。</p>
<h3 id="接收用户输入"><a href="#接收用户输入" class="headerlink" title="接收用户输入"></a>接收用户输入</h3><p>我们在程序的第一行使用 <code>use std::io;</code> 从标准库中引入了输入&#x2F;输出功能。现在调用 <code>io</code> 库中的函数 <code>stdin</code>，这允许我们处理用户输入：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">io::<span class="title function_ invoke__">stdin</span>()</span><br><span class="line">    .<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> guess)</span><br></pre></td></tr></table></figure>

<p>如果程序的开头没有使用 <code>use std::io;</code> 引入 <code>io</code> 库，我们仍可以通过把函数调用写成 <code>std::io::stdin</code> 来使用该函数。<code>stdin</code> 函数返回一个 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/io/struct.Stdin.html"><code>std::io::Stdin</code></a> 的实例，这是一种代表终端标准输入句柄的类型。</p>
<p>接下来，代码中的 <code>.read_line(&amp;mut guess)</code> 调用了标准输入句柄上的 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/io/struct.Stdin.html#method.read_line"><code>read_line</code></a> 方法，以获取用户输入。我们还将 <code>&amp;mut guess</code> 作为参数传递给 <code>read_line</code> 函数，让其将用户输入储存到这个字符串中。<code>read_line</code> 的工作是，无论用户在标准输入中键入什么内容，都将其<strong>追加</strong>（不会覆盖其原有内容）到一个字符串中，因此它需要字符串作为参数。这个字符串参数应该是<strong>可变</strong>的，以便 <code>read_line</code> 将用户输入附加上去。</p>
<p><code>&amp;</code> 表示这个参数是一个 <strong>引用</strong>（<em>reference</em>），它允许多处代码访问同一处数据，而无需在内存中多次拷贝。引用是一个复杂的特性，Rust 的一个主要优势就是安全而简单的操纵引用。现在，我们只需知道它像变量一样，默认是不可变的。因此，需要写成 <code>&amp;mut guess</code> 来使其可变，而不是 <code>&amp;guess</code>。（第四章会更全面地讲解引用。）</p>
<h3 id="使用-Result-类型来处理潜在的错误"><a href="#使用-Result-类型来处理潜在的错误" class="headerlink" title="使用 Result 类型来处理潜在的错误"></a>使用 <code>Result</code> 类型来处理潜在的错误</h3><p>我们还没有完全分析完这行代码。虽然我们已经讲到了第三行代码，但要注意：它仍是逻辑行（虽然换行了但仍是语句）的一部分。后一部分是这个方法（method）：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to read line&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>我们也可以将代码这样写：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io::<span class="title function_ invoke__">stdin</span>().<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> guess).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to read line&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>不过，过长的代码行难以阅读，所以最好拆开来写。通常来说，当使用 <code>.method_name()</code> 语法调用方法时引入换行符和空格将长的代码行拆开是明智的。现在来看看这行代码干了什么。</p>
<p>之前提到了 <code>read_line</code> 会将用户输入附加到传递给它的字符串中，不过它也会返回一个类型为 <code>Result</code> 的值。<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a> 是一种<a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch06-00-enums.html"><em>枚举类型</em></a>，通常也写作 <em>enum</em>，它可以是多种可能状态中的一个。我们把每种可能的状态称为一种 <strong>枚举成员</strong>（<em>variant</em>）。</p>
<p><strong>第六章</strong> 将介绍枚举的更多细节。这里的 <code>Result</code> 类型将用来编码错误处理的信息。</p>
<p><code>Result</code> 的成员是 <code>Ok</code> 和 <code>Err</code>，<code>Ok</code> 成员表示操作成功，内部包含成功时产生的值。<code>Err</code> 成员则意味着操作失败，并且 <code>Err</code> 中包含有关操作失败的原因或方式的信息。</p>
<p><code>Result</code> 类型的值，像其他类型一样，拥有定义于其实例上的方法。<code>Result</code> 的实例拥有 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/result/enum.Result.html#method.expect"><code>expect</code> 方法</a>。如果 <code>io::Result</code> 实例的值是 <code>Err</code>，<code>expect</code> 会导致程序崩溃，并输出当做参数传递给 <code>expect</code> 的信息。所以当 <code>read_line</code> 方法返回 <code>Err</code>，则可能是来源于底层操作系统错误的结果。如果 <code>Result</code> 实例的值是 <code>Ok</code>，<code>expect</code> 会获取 <code>Ok</code> 中的值并原样返回。在本例中，这个值是用户输入到标准输入中的字节数。</p>
<p>如果不调用 <code>expect</code>，程序也能编译，不过会出现一个警告：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo build</span></span><br><span class="line">   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)</span><br><span class="line">warning: unused `Result` that must be used</span><br><span class="line"><span class="meta prompt_">  --&gt; </span><span class="language-bash">src/main.rs:10:5</span></span><br><span class="line">   |</span><br><span class="line">10 |     io::stdin().read_line(&amp;mut guess);</span><br><span class="line">   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span><br><span class="line">   |</span><br><span class="line">   = note: this `Result` may be an `Err` variant, which should be handled</span><br><span class="line">   = note: `#[warn(unused_must_use)]` on by default</span><br><span class="line">help: use `let _ = ...` to ignore the resulting value</span><br><span class="line">   |</span><br><span class="line">10 |     let _ = io::stdin().read_line(&amp;mut guess);</span><br><span class="line">   |     +++++++</span><br><span class="line"></span><br><span class="line">warning: `guessing_game` (bin &quot;guessing_game&quot;) generated 1 warning</span><br><span class="line">    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.59s</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Rust 警告我们没有使用 <code>read_line</code> 的返回值 <code>Result</code>，说明有一个可能的错误没有处理。</p>
<p>消除警告的正确做法是实际去编写错误处理代码，不过由于我们就是希望程序在出现问题时立即崩溃，所以直接使用 <code>expect</code>。<a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch09-02-recoverable-errors-with-result.html">第九章</a> 会学习如何从错误中恢复。</p>
<h3 id="使用-println-占位符打印值"><a href="#使用-println-占位符打印值" class="headerlink" title="使用 println! 占位符打印值"></a>使用 <code>println!</code> 占位符打印值</h3><p>除了位于结尾的右花括号，目前为止就只有这一行代码值得讨论一下了：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;You guessed: &#123;guess&#125;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这行代码现在打印了存储用户输入的字符串。<code>&#123;&#125;</code> 这对大括号是一个占位符。当打印变量的值时，变量名可以写进大括号中。当打印表达式的执行结果时，格式化字符串（format string）中大括号中留空，格式化字符串后跟逗号分隔的需要打印的表达式列表，其顺序与每一个空大括号占位符的顺序一致。在一个 <code>println!</code> 调用中打印变量和表达式的值看起来像这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;x = &#123;x&#125; and y + 2 = &#123;&#125;&quot;</span>, y + <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>这行代码会打印出 <code>x = 5 and y + 2 = 12</code>。</p>
<h3 id="测试第一部分"><a href="#测试第一部分" class="headerlink" title="测试第一部分"></a>测试第一部分</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)</span><br><span class="line">    Finished `dev` profile [unoptimized + debuginfo] target(s) in 6.44s</span><br><span class="line">     Running `target/debug/guessing_game`</span><br><span class="line">Guess the number!</span><br><span class="line">Please input your guess.</span><br><span class="line">6</span><br><span class="line">You guessed: 6</span><br></pre></td></tr></table></figure>

<h2 id="生成一个数字"><a href="#生成一个数字" class="headerlink" title="生成一个数字"></a>生成一个数字</h2><h3 id="使用-crate-增加更多功能"><a href="#使用-crate-增加更多功能" class="headerlink" title="使用 crate 增加更多功能"></a>使用 <code>crate</code> 增加更多功能</h3><p>crate 是一组 Rust 源代码文件。我们正在构建的项目是一个 <em>二进制 crate</em>，它生成一个可执行文件。 <code>rand</code> crate 是一个 <em>库 crate</em>，库 crate 可以包含任意能被其他程序使用的代码，但是无法独立执行。</p>
<p>Cargo 对外部 crate 的运用是其真正的亮点所在。在我们使用 <code>rand</code> 编写代码之前，需要修改 <em>Cargo.toml</em> 文件，引入一个 <code>rand</code> 依赖。现在打开这个文件并将下面这一行添加到 <code>[dependencies]</code> section 标题之下。在当前版本下，请确保按照我们这里的方式指定 <code>rand</code>，否则本教程中的示例代码可能无法工作。</p>
<p>文件名：Cargo.toml</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">rand</span> = <span class="string">&quot;0.8.5&quot;</span></span><br></pre></td></tr></table></figure>

<p>在 <em>Cargo.toml</em> 文件中，标题以及之后的内容属同一个 section，直到遇到下一个标题才开始新的 section。<code>[dependencies]</code> section 告诉 Cargo 本项目依赖了哪些外部 crate 及其版本。本例中，我们使用语义化版本 <code>0.8.5</code> 来指定 <code>rand</code> crate。Cargo 理解 <a target="_blank" rel="noopener" href="http://semver.org/">语义化版本（Semantic Versioning）</a>（有时也称为 <em>SemVer</em>），这是一种定义版本号的标准。<code>0.8.5</code> 事实上是 <code>^0.8.5</code> 的简写，它表示任何<strong>至少是 <code>0.8.5</code> 但小于 <code>0.9.0</code> 的版本</strong>。</p>
<p>Cargo 认为这些版本与 <code>0.8.5</code> 版本的公有 API 相兼容，这样的版本指定确保了我们可以获取能使本章代码编译的最新的补丁（patch）版本。任何大于等于 <code>0.9.0</code> 的版本不能保证和接下来的示例采用了相同的 API。</p>
<p>现在，不修改任何代码，构建项目。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo build</span></span><br><span class="line">  Updating crates.io index</span><br><span class="line">   Locking 15 packages to latest Rust 1.85.0 compatible versions</span><br><span class="line">    Adding rand v0.8.5 (available: v0.9.0)</span><br><span class="line"> Compiling proc-macro2 v1.0.93</span><br><span class="line"> Compiling unicode-ident v1.0.17</span><br><span class="line"> Compiling libc v0.2.170</span><br><span class="line"> Compiling cfg-if v1.0.0</span><br><span class="line"> Compiling byteorder v1.5.0</span><br><span class="line"> Compiling getrandom v0.2.15</span><br><span class="line"> Compiling rand_core v0.6.4</span><br><span class="line"> Compiling quote v1.0.38</span><br><span class="line"> Compiling syn v2.0.98</span><br><span class="line"> Compiling zerocopy-derive v0.7.35</span><br><span class="line"> Compiling zerocopy v0.7.35</span><br><span class="line"> Compiling ppv-lite86 v0.2.20</span><br><span class="line"> Compiling rand_chacha v0.3.1</span><br><span class="line"> Compiling rand v0.8.5</span><br><span class="line"> Compiling guessing_game v0.1.0 (file:///projects/guessing_game)</span><br><span class="line">  Finished `dev` profile [unoptimized + debuginfo] target(s) in 2.48s</span><br></pre></td></tr></table></figure>

<p>可能会出现不同的版本号（多亏了语义化版本，它们与代码是兼容的！），并且显示的行数可能会有所不同（取决于操作系统），行的顺序也可能会不同。</p>
<p>现在我们有了一个外部依赖，Cargo 从 <em>registry</em> 上获取所有包的最新版本信息，这是一份来自 <a target="_blank" rel="noopener" href="https://crates.io/">Crates.io</a> 的数据副本。Crates.io 是 Rust 生态系统中，人们发布其开源 Rust 项目的平台，供他人使用。</p>
<p>在更新完 <em>registry</em> 后，Cargo 检查 <code>[dependencies]</code> section 并下载列表中包含但还未下载的 crate。本例中，虽然只声明了 <code>rand</code> 一个依赖，然而 Cargo 还是额外获取了 <code>rand</code> 所需要的其他 crate，因为 <code>rand</code> 依赖它们来正常工作。下载完成后，Rust 编译依赖，然后使用这些依赖编译项目。</p>
<p>如果不做任何修改，立刻再次运行 <code>cargo build</code>，则不会看到任何除了 <code>Finished</code> 行之外的输出。Cargo 知道它已经下载并编译了依赖，同时 <em>Cargo.toml</em> 文件也没有变动。Cargo 还知道代码也没有任何修改，所以它不会重新编译代码。因为无事可做，它会简单地退出。</p>
<h4 id="Cargo-lock-文件确保可重现构建"><a href="#Cargo-lock-文件确保可重现构建" class="headerlink" title="Cargo.lock 文件确保可重现构建"></a><em>Cargo.lock</em> 文件确保可重现构建</h4><p>Cargo 有一个机制，确保无论是你还是其他人在任何时候重新构建代码，都会生成相同的构建产物：Cargo 只会使用你指定的依赖版本，除非你明确指定其他版本。例如，如果下周 <code>rand</code> crate 的 <code>0.8.6</code> 版本出来了，该版本包含了一个重要的 bug 修复，但同时也引入了一个会破坏你代码的回归问题。为了解决这个问题，Rust 在你第一次运行 <code>cargo build</code> 时创建了 <em>Cargo.lock</em> 文件，我们现在可以在 <em>guessing_game</em> 目录找到它。</p>
<p>当第一次构建项目时，Cargo 计算出所有符合要求的依赖版本并写入 <em>Cargo.lock</em> 文件。当将来构建项目时，Cargo 会发现 <em>Cargo.lock</em> 已存在并使用其中指定的版本，而不是再次计算所有的版本。这使得你拥有了一个自动化的可重现构建（reproducible build）。换句话说，项目会持续使用 <code>0.8.5</code> 直到你显式升级，多亏有了 <em>Cargo.lock</em> 文件。由于 <em>Cargo.lock</em> 文件对于可重现构建非常重要，因此它通常会和项目中的其余代码一样提交到版本控制系统中。</p>
<h4 id="更新-crate-到一个新版本"><a href="#更新-crate-到一个新版本" class="headerlink" title="更新 crate 到一个新版本"></a>更新 crate 到一个新版本</h4><p>当你 <strong>确实</strong> 需要升级 crate 时，Cargo 提供了这样一个命令，<code>update</code>，它会忽略 <em>Cargo.lock</em> 文件，并计算出所有符合 <em>Cargo.toml</em> 声明的最新版本。Cargo 接下来会把这些版本写入 <em>Cargo.lock</em> 文件。不过，Cargo 默认只会寻找大于 <code>0.8.5</code> 而小于 <code>0.9.0</code> 的版本。如果 <code>rand</code> crate 发布了两个新版本，<code>0.8.6</code> 和 <code>0.9.0</code>，在运行 <code>cargo update</code> 时会出现如下内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo update</span></span><br><span class="line">    Updating crates.io index</span><br><span class="line">     Locking 1 package to latest Rust 1.85.0 compatible version</span><br><span class="line">    Updating rand v0.8.5 -&gt; v0.8.6 (available: v0.9.0)</span><br></pre></td></tr></table></figure>

<p>Cargo 忽略了 <code>0.9.0</code> 版本。这时，你也会注意到的 <em>Cargo.lock</em> 文件中的变化无外乎现在使用的 <code>rand</code> crate 版本是 <code>0.8.6</code> 。如果想要使用 <code>0.9.0</code> 版本的 <code>rand</code> 或是任何 <code>0.9.x</code> 系列的版本，必须像这样更新 <em>Cargo.toml</em> 文件：</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">rand</span> = <span class="string">&quot;0.9.0&quot;</span></span><br></pre></td></tr></table></figure>

<p>下一次运行 <code>cargo build</code> 时，Cargo 会更新可用 crate 的 registry，并根据你指定的新版本重新评估 <code>rand</code> 的要求。</p>
<p>第十四章会讲到 <a target="_blank" rel="noopener" href="http://doc.crates.io/">Cargo</a> 及其<a target="_blank" rel="noopener" href="http://doc.crates.io/crates-io.html">生态系统</a> 的更多内容，不过目前你只需要了解这么多。通过 Cargo 复用库文件非常容易，因此 Rustacean 能够编写出由很多包组装而成的更轻巧的项目。</p>
<h3 id="生成一个随机数"><a href="#生成一个随机数" class="headerlink" title="生成一个随机数"></a>生成一个随机数</h3><p>让我们开始使用 <code>rand</code> 来生成一个要猜测的数字。下一步是更新 <em>src&#x2F;main.rs</em> 。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> rand::Rng;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Guess the number!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">secret_number</span> = rand::<span class="title function_ invoke__">thread_rng</span>().<span class="title function_ invoke__">gen_range</span>(<span class="number">1</span>..=<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The secret number is: &#123;secret_number&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Please input your guess.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">guess</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    io::<span class="title function_ invoke__">stdin</span>()</span><br><span class="line">        .<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> guess)</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to read line&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;You guessed: &#123;guess&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，我们新增了一行 <code>use rand::Rng;</code>。<code>Rng</code> 是一个 trait，它定义了随机数生成器应实现的方法，想使用这些方法的话，此 trait 必须在作用域中。第十章会详细介绍 trait。</p>
<p>接下来，我们在中间还新增加了两行。第一行调用了 <code>rand::thread_rng</code> 函数提供实际使用的随机数生成器：它位于当前执行线程的本地环境中，并从操作系统获取 seed。接着调用随机数生成器的 <code>gen_range</code> 方法。这个方法由 <code>use rand::Rng</code> 语句引入到作用域的 <code>Rng</code> trait 定义。<code>gen_range</code> 方法获取一个范围表达式（range expression）作为参数，并生成一个在此范围之间的随机数。这里使用的这类范围表达式使用了 <code>start..=end</code> 这样的形式，它对上下边界<strong>均为闭区间</strong>，所以需要指定 <code>1..=100</code> 来请求一个 1 和 100 之间的数。</p>
<p>新增加的第二行代码打印出了秘密数字。这在开发程序时很有用，因为可以测试它，不过在最终版本中会删掉它。如果游戏一开始就打印出结果就没什么可玩的了！</p>
<p>尝试运行程序几次：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)</span><br><span class="line">    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.02s</span><br><span class="line">     Running `target/debug/guessing_game`</span><br><span class="line">Guess the number!</span><br><span class="line">The secret number is: 7</span><br><span class="line">Please input your guess.</span><br><span class="line">4</span><br><span class="line">You guessed: 4</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.02s</span><br><span class="line">     Running `target/debug/guessing_game`</span><br><span class="line">Guess the number!</span><br><span class="line">The secret number is: 83</span><br><span class="line">Please input your guess.</span><br><span class="line">5</span><br><span class="line">You guessed: 5</span><br></pre></td></tr></table></figure>

<h2 id="比较猜测的数字和秘密数字"><a href="#比较猜测的数字和秘密数字" class="headerlink" title="比较猜测的数字和秘密数字"></a>比较猜测的数字和秘密数字</h2><p>现在有了用户输入和一个随机数，我们可以比较它们。注意这段代码还<strong>不能通过编译</strong>，我们稍后会解释。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cmp::Ordering;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> rand::Rng;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;You guessed: &#123;guess&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> guess.<span class="title function_ invoke__">cmp</span>(&amp;secret_number) &#123;</span><br><span class="line">        Ordering::Less =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Too small!&quot;</span>),</span><br><span class="line">        Ordering::Greater =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Too big!&quot;</span>),</span><br><span class="line">        Ordering::Equal =&gt; <span class="built_in">println!</span>(<span class="string">&quot;You win!&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先我们增加了另一个 <code>use</code> 声明，从标准库引入了一个叫做 <code>std::cmp::Ordering</code> 的类型到作用域中。 <code>Ordering</code> 也是一个枚举，不过它的成员是 <code>Less</code>、<code>Greater</code> 和 <code>Equal</code>。这是比较两个值时可能出现的三种结果。</p>
<p>接着，底部的五行新代码使用了 <code>Ordering</code> 类型，<code>cmp</code> 方法用来比较两个值并可以在任何可比较的值上调用。它获取一个被比较值的引用：这里是把 <code>guess</code> 与 <code>secret_number</code> 做比较。然后它会返回一个刚才通过 <code>use</code> 引入作用域的 <code>Ordering</code> 枚举的成员。使用一个 [<code>match</code>](.&#x2F;06.2 match 控制流结构) 表达式，根据对 <code>guess</code> 和 <code>secret_number</code> 调用 <code>cmp</code> 返回的 <code>Ordering</code> 成员来决定接下来做什么。</p>
<p>一个 <code>match</code> 表达式由 <strong>分支（arms）</strong> 构成。一个分支包含一个 <strong>模式</strong>（<em>pattern</em>）和表达式开头的值与分支模式相匹配时应该执行的代码。Rust 获取提供给 <code>match</code> 的值并挨个检查每个分支的模式。<code>match</code> 结构和模式是 Rust 中强大的功能，它体现了代码可能遇到的多种情形，并确保对所有情况作出处理。这些功能将分别在第六章和第十九章详细介绍。</p>
<p>让我们看看使用 <code>match</code> 表达式的例子。假设用户猜了 50，这时随机生成的秘密数字是 38。</p>
<p>比较 50 与 38 时，因为 50 比 38 要大，<code>cmp</code> 方法会返回 <code>Ordering::Greater</code>。<code>Ordering::Greater</code> 是 <code>match</code> 表达式得到的值。它检查第一个分支的模式，<code>Ordering::Less</code> 与 <code>Ordering::Greater</code>并不匹配，所以它忽略了这个分支的代码并来到下一个分支。下一个分支的模式是 <code>Ordering::Greater</code>，<strong>正确</strong> 匹配！这个分支关联的代码被执行，在屏幕打印出 <code>Too big!</code>。<code>match</code> 表达式会在第一次成功匹配后终止，因此在这种情况下不会查看最后一个分支。</p>
<p>然而，代码目前并不能编译，可以尝试一下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo build</span></span><br><span class="line">   Compiling libc v0.2.86</span><br><span class="line">   Compiling getrandom v0.2.2</span><br><span class="line">   Compiling cfg-if v1.0.0</span><br><span class="line">   Compiling ppv-lite86 v0.2.10</span><br><span class="line">   Compiling rand_core v0.6.2</span><br><span class="line">   Compiling rand_chacha v0.3.0</span><br><span class="line">   Compiling rand v0.8.5</span><br><span class="line">   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)</span><br><span class="line">error[E0308]: mismatched types</span><br><span class="line"><span class="meta prompt_">  --&gt; </span><span class="language-bash">src/main.rs:23:21</span></span><br><span class="line">   |</span><br><span class="line">23 |     match guess.cmp(&amp;secret_number) &#123;</span><br><span class="line">   |                 --- ^^^^^^^^^^^^^^ expected `&amp;String`, found `&amp;&#123;integer&#125;`</span><br><span class="line">   |                 |</span><br><span class="line">   |                 arguments to this method are incorrect</span><br><span class="line">   |</span><br><span class="line">   = note: expected reference `&amp;String`</span><br><span class="line">              found reference `&amp;&#123;integer&#125;`</span><br><span class="line">note: method defined here</span><br><span class="line"><span class="meta prompt_">  --&gt; </span><span class="language-bash">/rustc/4eb161250e340c8f48f66e2b929ef4a5bed7c181/library/core/src/cmp.rs:964:8</span></span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0308`.</span><br><span class="line">error: could not compile `guessing_game` (bin &quot;guessing_game&quot;) due to 1 previous error</span><br></pre></td></tr></table></figure>

<p>错误的核心表明这里有 <strong>不匹配的类型</strong>（<em>mismatched types</em>）。Rust 有一个静态强类型系统，同时也有类型推断。当我们写出 <code>let guess = String::new()</code> 时，Rust 推断出 <code>guess</code> 应该是 <code>String</code> 类型，并不需要我们写出类型。另一方面，<code>secret_number</code>，是数字类型。几个数字类型拥有 1 到 100 之间的值：32 位数字 <code>i32</code>；32 位无符号数字 <code>u32</code>；64 位数字 <code>i64</code> 等等。Rust 默认使用 <code>i32</code>，所以它是 <code>secret_number</code> 的类型，除非增加类型信息，或任何能让 Rust 推断出不同数值类型的信息。这里错误的原因在于 Rust 不会比较字符串类型和数字类型。</p>
<p>所以我们必须把从输入中读取到的 <code>String</code> 转换为一个数字类型，才好与秘密数字进行比较。这可以通过在 <code>main</code> 函数体中增加如下代码来实现：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">guess</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">io::<span class="title function_ invoke__">stdin</span>()</span><br><span class="line">    .<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> guess)</span><br><span class="line">    .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to read line&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">guess</span>: <span class="type">u32</span> = guess.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Please type a number!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;You guessed: &#123;guess&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> guess.<span class="title function_ invoke__">cmp</span>(&amp;secret_number) &#123;</span><br><span class="line">    Ordering::Less =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Too small!&quot;</span>),</span><br><span class="line">    Ordering::Greater =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Too big!&quot;</span>),</span><br><span class="line">    Ordering::Equal =&gt; <span class="built_in">println!</span>(<span class="string">&quot;You win!&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这行新代码是：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">guess</span>: <span class="type">u32</span> = guess.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Please type a number!&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这里创建了一个叫做 <code>guess</code> 的变量。不过等等，不是已经有了一个叫做 <code>guess</code> 的变量了吗？确实如此，不过 Rust 允许用一个新值来 <strong>遮蔽</strong> （<em>Shadowing</em>） <code>guess</code> 之前的值。这个功允许我们复用 <code>guess</code> 变量的名字，而不是被迫创建两个不同变量，诸如 <code>guess_str</code> 和 <code>guess</code> 之类。[第三章](.&#x2F;03.1 变量与可变性)会介绍 shadowing 的更多细节，现在只需知道这个功能经常用于将一个类型的值转换为另一个类型的值。</p>
<p>我们将这个新变量绑定到 <code>guess.trim().parse()</code> 表达式上。表达式中的 <code>guess</code> 指的是包含输入的字符串类型 <code>guess</code> 变量。<code>String</code> 实例的 <code>trim</code> 方法会 <strong>去除字符串开头和结尾的空白字符</strong> ，我们必须执行此方法才能将字符串与 <code>u32</code> 比较，因为 <code>u32</code> 只能包含数值型数据。用户必须输入 enter 键才能让 <code>read_line</code> 返回并输入他们的猜想，这将会在字符串中 <strong>增加一个换行（newline）符</strong> 。例如，用户输入 5 并按下 enter（在 Windows 上，按下 enter 键会得到一个回车符和一个换行符，<code>\r\n</code>），<code>guess</code> 看起来像这样：<code>5\n</code> 或者 <code>5\r\n</code>。<code>\n</code> 代表 “换行”，回车键；<code>\r</code> 代表 “回车”，回车键。<code>trim</code> 方法会消除 <code>\n</code> 或者 <code>\r\n</code>，结果只留下 <code>5</code>。</p>
<p><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/primitive.str.html#method.parse">字符串的 <code>parse</code> 方法</a> 将字符串转换成其他类型。这里用它来把字符串转换为数值。我们需要告诉 Rust 具体的数字类型，这里通过 <code>let guess: u32</code> 指定。<code>guess</code> 后面的冒号（<code>:</code>）告诉 Rust 我们指定了变量的类型。Rust 有一些内建的数字类型；<code>u32</code> 是一个无符号的 32 位整型。对于不大的正整数来说，它是不错的默认类型，[第三章](.&#x2F;03.2 数据类型)还会讲到其他数字类型。</p>
<p>另外，程序中的 <code>u32</code> 注解以及与 <code>secret_number</code> 的比较，意味着 Rust 会推断出 <code>secret_number</code> 也是 <code>u32</code> 类型。现在可以使用相同类型比较两个值了！</p>
<p><code>parse</code> 方法只有在字符逻辑上可以转换为数字的时候才能工作，所以非常容易出错。例如，字符串中包含 <code>A👍%</code>，就无法将其转换为一个数字。因此，<code>parse</code> 方法返回一个 <code>Result</code> 类型。像之前 [“使用 <code>Result</code> 类型来处理潜在的错误”](# 使用 <code>Result</code> 类型来处理潜在的错误) 讨论的 <code>read_line</code> 方法那样，再次按部就班的用 <code>expect</code> 方法处理即可。如果 <code>parse</code> 不能从字符串生成一个数字，返回一个 <code>Result</code> 的 <code>Err</code> 成员时，<code>expect</code> 会使游戏崩溃并打印附带的信息。如果 <code>parse</code> 成功地将字符串转换为一个数字，它会返回 <code>Result</code> 的 <code>Ok</code> 成员，然后 <code>expect</code> 会返回 <code>Ok</code> 值中的数字。</p>
<p>现在让我们运行程序！</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)</span><br><span class="line">    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.26s</span><br><span class="line">     Running `target/debug/guessing_game`</span><br><span class="line">Guess the number!</span><br><span class="line">The secret number is: 58</span><br><span class="line">Please input your guess.</span><br><span class="line">  76</span><br><span class="line">You guessed: 76</span><br><span class="line">Too big!</span><br></pre></td></tr></table></figure>

<p>漂亮！即便是在猜测之前添加了空格，程序依然能判断出用户猜测了 76。多运行程序几次，输入不同的数字来检验不同的行为：猜一个正确的数字，猜一个过大的数字和猜一个过小的数字。</p>
<p>现在游戏已经大体上能玩了，不过用户只能猜一次。增加一个循环来改变它吧！</p>
<h2 id="使用循环来允许多次猜测"><a href="#使用循环来允许多次猜测" class="headerlink" title="使用循环来允许多次猜测"></a>使用循环来允许多次猜测</h2><p><code>loop</code> 关键字创建了一个无限循环。我们会增加循环来给用户更多机会猜数字：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The secret number is: &#123;secret_number&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Please input your guess.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">match</span> guess.<span class="title function_ invoke__">cmp</span>(&amp;secret_number) &#123;</span><br><span class="line">            Ordering::Less =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Too small!&quot;</span>),</span><br><span class="line">            Ordering::Greater =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Too big!&quot;</span>),</span><br><span class="line">            Ordering::Equal =&gt; <span class="built_in">println!</span>(<span class="string">&quot;You win!&quot;</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上所示，我们将提示用户猜测之后的所有内容移动到了循环中。确保 loop 循环中的代码多缩进四个空格，再次运行程序。注意这里有一个新问题，程序现在会不断地要求用户输入新的猜测。用户好像无法退出啊！</p>
<h3 id="猜测正确后退出"><a href="#猜测正确后退出" class="headerlink" title="猜测正确后退出"></a>猜测正确后退出</h3><p>让我们增加一个 <code>break</code> 语句，在用户猜对时退出游戏：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">match</span> guess.<span class="title function_ invoke__">cmp</span>(&amp;secret_number) &#123;</span><br><span class="line">            Ordering::Less =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Too small!&quot;</span>),</span><br><span class="line">            Ordering::Greater =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Too big!&quot;</span>),</span><br><span class="line">            Ordering::Equal =&gt; &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;You win!&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过在 <code>You win!</code> 之后增加一行 <code>break</code>，用户猜对了神秘数字后会退出循环。退出循环也意味着退出程序，因为循环是 <code>main</code> 的最后一部分。</p>
<h3 id="处理无效输入"><a href="#处理无效输入" class="headerlink" title="处理无效输入"></a>处理无效输入</h3><p>为了进一步改善游戏性，不要在用户输入非数字时崩溃，需要忽略非数字，让用户可以继续猜测。可以通过修改 <code>guess</code> 将 <code>String</code> 转化为 <code>u32</code> 那部分代码来实现：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">io::<span class="title function_ invoke__">stdin</span>()</span><br><span class="line">    .<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> guess)</span><br><span class="line">    .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to read line&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">guess</span>: <span class="type">u32</span> = <span class="keyword">match</span> guess.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(num) =&gt; num,</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(_) =&gt; <span class="keyword">continue</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;You guessed: &#123;guess&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// --snip--</span></span><br></pre></td></tr></table></figure>

<p>我们将 <code>expect</code> 调用换成 <code>match</code> 语句，以从遇到错误就崩溃转换为处理错误。须知 <code>parse</code> 返回一个 <code>Result</code> 类型，而 <code>Result</code> 是一个拥有 <code>Ok</code> 或 <code>Err</code> 成员的枚举。这里使用的 <code>match</code> 表达式，和之前处理 <code>cmp</code> 方法返回 <code>Ordering</code> 时用的一样。</p>
<p>如果 <code>parse</code> 能够成功地将字符串转换为一个数字，它会返回一个包含结果数字的 <code>Ok</code>。这个 <code>Ok</code> 值与 <code>match</code> 第一个分支的模式相匹配，该分支对应的动作返回 <code>Ok</code> 值中的数字 <code>num</code>，最后如愿变成新创建的 <code>guess</code> 变量。</p>
<p>如果 <code>parse</code> <strong>不</strong>能将字符串转换为一个数字，它会返回一个包含更多错误信息的 <code>Err</code>。<code>Err</code> 值不能匹配第一个 <code>match</code> 分支的 <code>Ok(num)</code> 模式，但是会匹配第二个分支的 <code>Err(_)</code> 模式：<code>_</code> 是一个通配符值，本例中用来匹配所有 <code>Err</code> 值，不管其中有何种信息。所以程序会执行第二个分支的动作，<code>continue</code> 意味着进入 <code>loop</code> 的下一次循环，请求另一个猜测。这样程序就有效的忽略了 <code>parse</code> 可能遇到的所有错误！</p>
<p>现在程序中的一切都应该如预期般工作了。让我们试试吧：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)</span><br><span class="line">    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.13s</span><br><span class="line">     Running `target/debug/guessing_game`</span><br><span class="line">Guess the number!</span><br><span class="line">The secret number is: 61</span><br><span class="line">Please input your guess.</span><br><span class="line">10</span><br><span class="line">You guessed: 10</span><br><span class="line">Too small!</span><br><span class="line">Please input your guess.</span><br><span class="line">99</span><br><span class="line">You guessed: 99</span><br><span class="line">Too big!</span><br><span class="line">Please input your guess.</span><br><span class="line">foo</span><br><span class="line">Please input your guess.</span><br><span class="line">61</span><br><span class="line">You guessed: 61</span><br><span class="line">You win!</span><br></pre></td></tr></table></figure>

<p>太棒了！再有最后一个小的修改，就能完成猜数字游戏了：还记得程序依然会打印出秘密数字。在测试时还好，但正式发布时会毁了游戏体验。删掉打印秘密数字的 <code>println!</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cmp::Ordering;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> rand::Rng;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Guess the number!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">secret_number</span> = rand::<span class="title function_ invoke__">thread_rng</span>().<span class="title function_ invoke__">gen_range</span>(<span class="number">1</span>..=<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Please input your guess.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">guess</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">        io::<span class="title function_ invoke__">stdin</span>()</span><br><span class="line">            .<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> guess)</span><br><span class="line">            .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to read line&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">guess</span>: <span class="type">u32</span> = <span class="keyword">match</span> guess.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(num) =&gt; num,</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(_) =&gt; <span class="keyword">continue</span>,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;You guessed: &#123;guess&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">match</span> guess.<span class="title function_ invoke__">cmp</span>(&amp;secret_number) &#123;</span><br><span class="line">            Ordering::Less =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Too small!&quot;</span>),</span><br><span class="line">            Ordering::Greater =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Too big!&quot;</span>),</span><br><span class="line">            Ordering::Equal =&gt; &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;You win!&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时此刻，你顺利完成了猜数字游戏。恭喜！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本项目通过动手实践，向你介绍了 Rust 新概念：<code>let</code>、<code>match</code>、函数、使用外部 crate 等等，接下来的几章，你会继续深入学习这些概念。第三章介绍大部分编程语言都有的概念，比如变量、数据类型和函数，以及如何在 Rust 中使用它们。第四章探索所有权（ownership），这是一个 Rust 同其他语言大不相同的特性。第五章讨论结构体和方法的语法，而第六章解释枚举。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-05-16T06:42:26.000Z" title="2025/5/16 14:42:26">2025-05-16</time>发表</span><span class="level-item"><time dateTime="2025-05-16T13:57:13.079Z" title="2025/5/16 21:57:13">2025-05-16</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Rust/">Rust</a><span> / </span><a class="link-muted" href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></span><span class="level-item">13 分钟读完 (大约1924个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/05/16/Rust/The%20Rust%20Programming%20Language/01.3%20Hello%20Cargo/">1.3 Hello,Cargo!</a></p><div class="content"><h2 id="使用-Cargo-创建项目"><a href="#使用-Cargo-创建项目" class="headerlink" title="使用 Cargo 创建项目"></a>使用 Cargo 创建项目</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo new hello_cargo</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> hello_cargo</span></span><br></pre></td></tr></table></figure>

<p>第一行命令新建了名为 <em>hello_cargo</em> 的目录和项目。我们将项目命名为 <em>hello_cargo</em>，同时 Cargo 在一个同名目录中创建项目文件。</p>
<p>进入 <em>hello_cargo</em> 目录并列出文件。将会看到 Cargo 生成了两个文件和一个目录：<strong>一个 <em>Cargo.toml</em> 文件，一个 <em>src</em> 目录，以及位于 <em>src</em> 目录中的 <em>main.rs</em> 文件</strong>。</p>
<p>这也会在 <em>hello_cargo</em> 目录<strong>初始化了一个 git 仓库</strong>，以及一个 <em>.gitignore</em> 文件。如果在一个已经存在的 git 仓库中运行 <code>cargo new</code>，则这些 git 相关文件则不会生成；可以通过运行 <code>cargo new --vcs=git</code> 来覆盖这些行为。</p>
<h3 id="初始化创建的-Cargo-toml-文件"><a href="#初始化创建的-Cargo-toml-文件" class="headerlink" title="初始化创建的 Cargo.toml 文件"></a>初始化创建的 Cargo.toml 文件</h3><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;hello_cargo&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2024&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br></pre></td></tr></table></figure>

<p>这个文件使用 <a target="_blank" rel="noopener" href="https://toml.io/"><em>TOML</em></a> (<em>Tom’s Obvious, Minimal Language</em>) 格式，这是 Cargo 配置文件的格式。</p>
<p>第一行，<code>[package]</code>，是一个片段 section 标题，表明下面的语句用来配置一个包。随着我们在这个文件增加更多的信息，还将增加其他 section。</p>
<p>接下来的三行设置了 Cargo 编译程序所需的配置：项目的名称、项目的版本以及要使用的 Rust 版本。[附录 E](.&#x2F;22.5 E.md) 会介绍 <code>edition</code> 的值。</p>
<p>最后一行，<code>[dependencies]</code>，是罗列项目依赖的 section 的开始。在 Rust 中，代码包被称为 <em>crates</em>。这个项目并不需要其他的 crate，不过在第二章的第一个项目会用到依赖，那时会用得上这个 section。</p>
<h3 id="src-main-rs"><a href="#src-main-rs" class="headerlink" title="src&#x2F;main.rs"></a>src&#x2F;main.rs</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Cargo 生成了一个 “Hello, world!” 程序，正如我们之前编写的示例 1-1！目前为止，我们的项目与 Cargo 生成项目的区别是 Cargo 将代码放在 <em>src</em> 目录，同时项目根目录包含一个 <em>Cargo.toml</em> 配置文件。</p>
<p>Cargo 期望源文件存放在 <em>src</em> 目录中。项目根目录只存放 README、license 信息、配置文件和其他跟代码无关的文件。使用 Cargo 帮助你保持项目干净整洁。一切各得其所，井井有条。</p>
<p>如果没有使用 Cargo 开始项目，比如我们创建的 “Hello, world!” 项目，你可以将其转换为使用 Cargo 的项目。将项目代码移入 <em>src</em> 目录，并创建一个合适的 <em>Cargo.toml</em> 文件。一个简单的创建 <em>Cargo.toml</em> 文件的方法是运行 <code>cargo init</code>，它会自动为你创建该文件。</p>
<h2 id="构建并运行-Cargo-项目"><a href="#构建并运行-Cargo-项目" class="headerlink" title="构建并运行 Cargo 项目"></a>构建并运行 Cargo 项目</h2><p>在 <em>hello_cargo</em> 目录下，输入下面的命令来构建项目：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo build</span></span><br><span class="line">   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)</span><br><span class="line">    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.52s</span><br></pre></td></tr></table></figure>

<p>这个命令会创建一个可执行文件 <em>target&#x2F;debug&#x2F;hello_cargo</em> （在 Windows 上是 <em>target\debug\hello_cargo.exe</em>），而不是放在目前目录下。由于<strong>默认的构建方法是调试构建（debug build）</strong>，Cargo 会将可执行文件放在名为 <em>debug</em> 的目录中。可以通过这个命令运行可执行文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./target/debug/hello_cargo <span class="comment"># 或者在 Windows 下为 .\target\debug\hello_cargo.exe</span></span></span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure>

<p>首次运行 <code>cargo build</code> 时，也会使 Cargo 在项目根目录创建一个新文件：<em>Cargo.lock</em>。这个文件记录项目依赖的实际版本。这个项目并没有依赖，所以其内容比较少。你永远也不需要手动编辑该文件；<code>Cargo</code> 会为你管理它。</p>
<p>我们刚刚使用 <code>cargo build</code> 构建了项目，并使用 <code>./target/debug/hello_cargo</code> 运行了程序，也可以使用 <code>cargo run</code> 在一个命令中同时编译并运行生成的可执行文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs</span><br><span class="line">     Running `target/debug/hello_cargo`</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure>

<p>比起要记得运行 <code>cargo build</code> 之后再用可执行文件的完整路径来运行程序，使用 <code>cargo run</code> 更方便，所以大多数开发者会使用 <code>cargo run</code>。</p>
<p>注意这一次并没有出现表明 Cargo 正在编译 <code>hello_cargo</code> 的输出。Cargo 发现文件并没有被改变，所以它并没有重新构建，而是直接运行了二进制文件。如果修改了源文件的话，Cargo 会在运行之前重新构建项目。</p>
<p>Cargo 还提供了一个叫 <code>cargo check</code> 的命令。该命令快速检查代码确保其可以编译，但并不产生可执行文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo check</span></span><br><span class="line">    Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)</span><br><span class="line">    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.11s</span><br></pre></td></tr></table></figure>

<p>通常 <code>cargo check</code> 要比 <code>cargo build</code> 快得多，因为它<strong>省略了生成可执行文件的步骤</strong>。如果你在编写代码时持续的进行检查，<code>cargo check</code> 可以让你<strong>快速了解现在的代码能不能正常通过编译</strong>！为此很多 Rustaceans 编写代码时定期运行 <code>cargo check</code> 确保它们可以编译。当准备好使用可执行文件时才运行 <code>cargo build</code>。</p>
<p>回顾下已学习的 Cargo 内容：</p>
<ul>
<li>可以使用 <code>cargo new</code> 创建项目。</li>
<li>可以使用 <code>cargo build</code> 构建项目。</li>
<li>可以使用 <code>cargo run</code> 一步构建并运行项目。</li>
<li>可以使用 <code>cargo check</code> 在不生成二进制文件的情况下构建项目来检查错误。</li>
<li>有别于将构建结果放在与源码相同的目录，Cargo 会将其放到 <em>target&#x2F;debug</em> 目录。</li>
</ul>
<p>使用 Cargo 的一个额外的优点是，不论你使用什么操作系统，其<strong>命令都是一样的</strong>。所以从现在开始本书将不再分别为 Linux 和 macOS 以及 Windows 提供相应的命令。</p>
<h2 id="发布（-release-）构建"><a href="#发布（-release-）构建" class="headerlink" title="发布（ release ）构建"></a>发布（ release ）构建</h2><p>当项目最终准备好发布时，可以使用 <code>cargo build --release</code> 来<strong>优化编译项目</strong>。这会在 <u><em>target&#x2F;release</em></u> 而不是 <em>target&#x2F;debug</em> 下生成可执行文件。这些优化可以<strong>让 Rust 代码运行的更快</strong>，不过启用这些优化也需要消耗<strong>更长的编译时间</strong>。这也就是为什么会有两种不同的配置：一种是为了开发，你需要快速且频繁地重新构建；另一种是为用户构建最终程序，它们不会经常重新构建，并且希望程序运行得越快越好。如果你在<strong>基准测试代码的运行时间</strong>，请确保运行 <code>cargo build --release</code> 并使用 <em>target&#x2F;release</em> 下的可执行文件进行测试。</p>
<h2 id="把-Cargo-当成习惯"><a href="#把-Cargo-当成习惯" class="headerlink" title="把 Cargo 当成习惯"></a>把 Cargo 当成习惯</h2><p>对于简单项目，Cargo 并不比 <code>rustc</code> 提供了更多的优势，但随着程序变得更复杂，其价值会逐渐显现。一旦程序壮大到由多个文件组成，亦或者是需要其他的依赖，让 Cargo 协调构建过程就会简单得多。</p>
<p>其实，要在任何已存在的项目上工作时，可以使用如下命令通过 Git 检出代码，移动到该项目目录并构建：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> example.org/someproject</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> someproject</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo build</span></span><br></pre></td></tr></table></figure>

<p>关于更多 Cargo 的信息，请查阅 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/cargo/">其文档 ( The Cargo Book )</a>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本章中，你学习了如何：</p>
<ul>
<li>使用 <code>rustup</code> 安装最新稳定版的 Rust</li>
<li>更新到新版的 Rust</li>
<li>打开本地安装的文档</li>
<li>直接通过 <code>rustc</code> 编写并运行 Hello, world! 程序</li>
<li>使用 Cargo 创建并运行新项目</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-04-06T13:55:29.000Z" title="2025/4/6 21:55:29">2025-04-06</time>发表</span><span class="level-item"><time dateTime="2025-04-06T14:50:55.437Z" title="2025/4/6 22:50:55">2025-04-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%85%AB%E8%82%A1/">八股</a><span> / </span><a class="link-muted" href="/categories/%E5%85%AB%E8%82%A1/JavaSE/">JavaSE</a></span><span class="level-item">34 分钟读完 (大约5092个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/04/06/%E5%85%AB%E8%82%A1/Java/Java%E5%9F%BA%E7%A1%80/JavaSE%20pt.3/">JavaSE pt.3</a></p><div class="content"><h2 id="1-异常"><a href="#1-异常" class="headerlink" title="1. 异常"></a>1. 异常</h2><p><strong>Java 异常类层次结构：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">    Throwable --&gt;Exception;</span><br><span class="line">    Throwable --&gt;Error;</span><br><span class="line"></span><br><span class="line">    Exception --&gt;CheckedException;</span><br><span class="line">    Exception --&gt;UncheckedException;</span><br><span class="line"></span><br><span class="line">    Error --&gt; Errors;</span><br><span class="line"></span><br><span class="line">    subgraph CheckedException [Checked Exceptions]</span><br><span class="line">        direction TB;</span><br><span class="line">        IOException;</span><br><span class="line">        ClassNotFoundException;</span><br><span class="line">        SQLException;</span><br><span class="line">        FileNotFoundException;</span><br><span class="line">        ......;</span><br><span class="line">    end</span><br><span class="line">    CheckedException --&gt; IOException;</span><br><span class="line">    CheckedException --&gt; ClassNotFoundException;</span><br><span class="line">    CheckedException --&gt; SQLException;</span><br><span class="line">    CheckedException --&gt; FileNotFoundException;</span><br><span class="line"></span><br><span class="line">    subgraph UncheckedException [Unchecked Exceptions]</span><br><span class="line">        direction TB;</span><br><span class="line">        ArithmeticException;</span><br><span class="line">        ClassCastException;</span><br><span class="line">        IllegalThreadStateException;</span><br><span class="line">        IndexOutOfBoundsException;</span><br><span class="line">        ......;</span><br><span class="line">    end</span><br><span class="line">    UncheckedException --&gt; ArithmeticException;</span><br><span class="line">    UncheckedException --&gt; ClassCastException;</span><br><span class="line">    UncheckedException --&gt; IllegalThreadStateException;</span><br><span class="line">    UncheckedException --&gt; IndexOutOfBoundsException;</span><br><span class="line"></span><br><span class="line">    subgraph Errors [Errors]</span><br><span class="line">        direction TB;</span><br><span class="line">        OutOfMemoryError;</span><br><span class="line">        VirtualMachineError;</span><br><span class="line">        StackOverflowError;</span><br><span class="line">        AssertionError;</span><br><span class="line">        IOError;</span><br><span class="line">        ......;</span><br><span class="line">    end</span><br><span class="line">    Errors --&gt; OutOfMemoryError;</span><br><span class="line">    Errors --&gt; VirtualMachineError;</span><br><span class="line">    Errors --&gt; StackOverflowError;</span><br><span class="line">    Errors --&gt; AssertionError;</span><br><span class="line">    Errors --&gt; IOError;</span><br></pre></td></tr></table></figure>

<h3 id="1-1-Exception-和-Error-有什么区别？"><a href="#1-1-Exception-和-Error-有什么区别？" class="headerlink" title="1.1 Exception 和 Error 有什么区别？"></a>1.1 Exception 和 Error 有什么区别？</h3><p>在 Java 中， 所有的异常都有一个共同的祖先 ： <code>java.lang</code> 包下的 <code>Throwable</code> 类。 <code>Throwable</code> 类有两个重要的子类:</p>
<ul>
<li><code>Exception</code> ： 程序本身可以处理的异常，通常可以通过 <code>catch</code> 来捕获。 <code>Exception</code> 又可以分为 Checked Exception （ 受检查异常， <strong>必须处理</strong> ） 和 Unchecked Exception （ 不受检查异常， <strong>可以不处理</strong> ）。</li>
<li><code>Error</code> ： <code>Error</code> 属于程序无法处理的错误，不建议通过 <code>catch</code> 捕获。如 Java 虚拟机运行错误 （ <code>Virtural MachineError</code> ） 、 虚拟机内存不够错误 （ <code>OutOfMemoryError</code> ） 、 类定义错误 （ <code>NoClassDefFoundError</code> ） 等。这类异常发生时， JVM 一般会选择线程终止。</li>
</ul>
<h3 id="1-2-Checked-Exception-和-Unchecked-Exception-有什么区别？"><a href="#1-2-Checked-Exception-和-Unchecked-Exception-有什么区别？" class="headerlink" title="1.2 Checked Exception 和 Unchecked Exception 有什么区别？"></a>1.2 Checked Exception 和 Unchecked Exception 有什么区别？</h3><p><strong>Checked Exception</strong> 即 <strong>受检查异常</strong> ，Java 代码在编译过程中，如果受检查异常没有被 <code>catch</code> 或者 <code>throws</code> 关键字处理的话，就<strong>没办法通过编译</strong>。</p>
<p>除了 <code>RuntimeException</code> 及其子类以外，其他的 <code>Exception</code> 类及其子类都属于受检查异常 。常见的受检查异常有：<strong>IO 相关的异常、ClassNotFoundException、SQLException</strong> …。</p>
<p><code>Unchecked Exception</code> 即 <strong>不受检查异常</strong> ，Java 代码在编译过程中 ，我们即使不处理不受检查异常<strong>也可以正常通过编译</strong>。</p>
<p>RuntimeException 及其子类都统称为非受检查异常，常见的有：</p>
<ul>
<li><code>NullPointerException</code>(空指针错误)</li>
<li><code>IllegalArgumentException</code>(参数错误比如方法入参类型错误)</li>
<li><code>NumberFormatException</code>（字符串转换为数字格式错误，<code>IllegalArgumentException</code> 的子类）</li>
<li><code>ArrayIndexOutOfBoundsException</code>（数组越界错误）</li>
<li><code>ClassCastException</code>（类型转换错误）</li>
<li><code>ArithmeticException</code>（算术错误）</li>
<li><code>SecurityException</code> （安全错误比如权限不够）</li>
<li><code>UnsupportedOperationException</code> (不支持的操作错误比如重复创建同一用户)</li>
<li>……</li>
</ul>
<h3 id="1-3-Throwable-类常用方法有哪些？"><a href="#1-3-Throwable-类常用方法有哪些？" class="headerlink" title="1.3 Throwable 类常用方法有哪些？"></a>1.3 Throwable 类常用方法有哪些？</h3><ul>
<li><code>String getMessage()</code> : 返回异常发生时的详细信息</li>
<li><code>String toString()</code> : 返回异常发生时的简要描述</li>
<li><code>String getLocalizedMessage()</code> : 返回异常对象的本地化信息。使用 <code>Throwable</code> 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage()</code> 返回的结果相同</li>
<li><code>void printStackTrace()</code> : 在控制台上打印 <code>Throwable</code> 对象封装的异常信息</li>
</ul>
<h3 id="1-4-try-catch-finally-如何使用？"><a href="#1-4-try-catch-finally-如何使用？" class="headerlink" title="1.4 try-catch-finally 如何使用？"></a>1.4 try-catch-finally 如何使用？</h3><ul>
<li>try 块：用于捕获异常。其后可接零个或多个 catch 块，<strong>如果没有 catch 块，则必须跟一个 finally 块</strong>。</li>
<li>catch 块：用于处理 try 捕获到的异常。</li>
<li>finally 块：<strong>无论是否捕获或处理异常</strong>，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在<strong>方法返回之前被执行</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Try to do something&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;RuntimeException&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Catch Exception -&gt; &quot;</span> + e.getMessage());</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Finally&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Try to do something</span><br><span class="line">Catch Exception -&gt; RuntimeException</span><br><span class="line">Finally</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：**<em>不要在 finally 语句块中使用 return !</em>** 当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。这是因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(f(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value * value;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure>

<h3 id="1-5-finally-中的代码一定会执行吗？"><a href="#1-5-finally-中的代码一定会执行吗？" class="headerlink" title="1.5 finally 中的代码一定会执行吗？"></a>1.5 finally 中的代码一定会执行吗？</h3><p><strong><em>不一定。</em></strong></p>
<p>如： finally 之前虚拟机被终止， finally 中的代码就不会执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Try to do something&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;RuntimeException&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Catch Exception -&gt; &quot;</span> + e.getMessage());</span><br><span class="line">    <span class="comment">// 终止当前正在运行的Java虚拟机</span></span><br><span class="line">    System.exit(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Finally&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Try to do something</span><br><span class="line">Catch Exception -&gt; RuntimeException</span><br></pre></td></tr></table></figure>

<p>另外，在以下 2 种特殊情况下，finally 块的代码也不会被执行：</p>
<ol>
<li>程序所在线程死亡。</li>
<li>关闭 CPU 。</li>
</ol>
<h3 id="1-6-如何使用-try-with-resources-代替-try-catch-finally？"><a href="#1-6-如何使用-try-with-resources-代替-try-catch-finally？" class="headerlink" title="1.6 如何使用 try-with-resources 代替 try-catch-finally？"></a>1.6 如何使用 try-with-resources 代替 try-catch-finally？</h3><ol>
<li><strong>适用范围 （资源定义）</strong> ： 任何实现 <code>java.lang.AutoCloseable</code> 或者 <code>java.io.Closeable</code> 的对象。</li>
<li><strong>关闭资源和 finally 块的执行顺序</strong> ： 在 <code>try-catch-resources</code> 语句中，任何 catch 或 finally 块在声明的资源关闭后运行。</li>
</ol>
<p>Effective Java 中指出；</p>
<blockquote>
<p>面对必须要关闭的资源，我们总是应该优先使用 <code>try-with-resources</code> 而不是<code>try-finally</code> 。随之产生的代码更简短，更清晰，产生的异常对我们也更有用。 <code>try-with-resources</code> 语句让我们更容易编写必须要关闭的资源的代码，若采用 <code>try-finally</code> 则几乎做不到这点。</p>
</blockquote>
<p>Java 中类似于 <code>InputStream</code> 、 <code>OutputStream</code> 、 <code>Scanner</code> 、 <code>PrintWriter</code> 等的资源都需要我们调用 <code>close()</code> 方法来手动关闭，一般情况下我们都是通过 <code>try-catch-finally</code> 语句来实现这个需求，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取文本文件的内容</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    scanner = <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D://read.txt&quot;</span>));</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (scanner != <span class="literal">null</span>) &#123;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 Java 7 之后的 <code>try-with-resources</code> 语句改造上面的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>))) &#123;</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException fnfe) &#123;</span><br><span class="line">    fnfe.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多个资源需要关闭的时候，使用 <code>try-with-resources</code> 实现起来也非常简单，如果还是用 <code>try-catch-finally</code> 可能会带来很多问题。</p>
<p>通过使用分号分隔，可以在 try-with-resources 块中声明多个资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (</span><br><span class="line">    <span class="type">BufferedInputStream</span> <span class="variable">bin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>)));</span><br><span class="line">    <span class="type">BufferedOutputStream</span> <span class="variable">bout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;out.txt&quot;</span>)))</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="keyword">while</span> ((b = bin.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        bout.write(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-7-异常使用有哪些需要注意的地方？"><a href="#1-7-异常使用有哪些需要注意的地方？" class="headerlink" title="1.7 异常使用有哪些需要注意的地方？"></a>1.7 异常使用有哪些需要注意的地方？</h3><ul>
<li><strong>不要把异常定义为静态变量</strong>，因为这样会导致异常栈信息错乱。每次手动抛出异常，我们都需要手动 new 一个异常对象抛出。</li>
<li>抛出的异常信息一定要<strong>有意义</strong>。</li>
<li>建议<strong>抛出更加具体的异常</strong>，比如字符串转换为数字格式错误的时候应该抛出 NumberFormatException 而不是其父类 IllegalArgumentException。</li>
<li><strong>避免重复记录日志</strong>：如果在捕获异常的地方已经记录了足够的信息（包括异常类型、错误信息和堆栈跟踪等），那么在业务代码中再次抛出这个异常时，就不应该再次记录相同的错误信息。重复记录日志会使得日志文件膨胀，并且可能会掩盖问题的实际原因，使得问题更难以追踪和解决。</li>
<li>……</li>
</ul>
<h2 id="2-泛型"><a href="#2-泛型" class="headerlink" title="2. 泛型"></a>2. 泛型</h2><h3 id="2-1-什么是泛型？有什么作用？"><a href="#2-1-什么是泛型？有什么作用？" class="headerlink" title="2.1 什么是泛型？有什么作用？"></a>2.1 什么是泛型？有什么作用？</h3><p><strong>Java 泛型 （ Generics ）</strong> 是 JDK 5 引入的新特性。使用泛型可以增强代码的可读性和稳定性。</p>
<p>编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。比如 <code>ArrayList&lt;Person&gt; persons = new ArrayList&lt;Person&gt;()</code> 这行代码就指明了该 <code>ArrayList</code> 对象只能传入 <code>Person</code> 对象，如果传入其他类型的对象就会报错。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br></pre></td></tr></table></figure>

<p>并且，原生 List 返回类型是 Object ，需要手动转换类型才能使用，使用泛型后编译器自动转换。</p>
<h3 id="2-2-泛型的使用方式有哪几种？"><a href="#2-2-泛型的使用方式有哪几种？" class="headerlink" title="2.2 泛型的使用方式有哪几种？"></a>2.2 泛型的使用方式有哪几种？</h3><p>泛型一般有三种使用方式: <strong>泛型类、泛型接口、泛型方法</strong> 。</p>
<ol>
<li><p><strong>泛型类</strong> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line"><span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Generic</span>&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Generic</span><span class="params">(T key)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getKey</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何实例化泛型类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Generic&lt;Integer&gt; genericInteger = <span class="keyword">new</span> <span class="title class_">Generic</span>&lt;Integer&gt;(<span class="number">123456</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>泛型接口</strong> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Generator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现泛型接口，不指定类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GeneratorImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;T&gt;&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> T <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现泛型接口，指定类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GeneratorImpl</span> <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;String&gt; &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>泛型方法</strong> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt; E &gt; <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">( E[] inputArray )</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">for</span> ( E element : inputArray )&#123;</span><br><span class="line">        System.out.printf( <span class="string">&quot;%s &quot;</span>, element );</span><br><span class="line">     &#125;</span><br><span class="line">     System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建不同类型数组：Integer, Double 和 Character</span></span><br><span class="line">Integer[] intArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">String[] stringArray = &#123; <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span> &#125;;</span><br><span class="line">printArray( intArray  );</span><br><span class="line">printArray( stringArray  );</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>注意: <code>public static &lt; E &gt; void printArray( E[] inputArray )</code> 一般被称为<strong>静态泛型方法</strong>;在 java 中泛型只是一个占位符，必须在传递类型后才能使用。类在实例化时才能真正的传递类型参数，由于静态方法的加载先于类的实例化，也就是说类中的泛型还没有传递真正的类型参数，静态的方法的加载就已经完成了，所以静态泛型方法是没有办法使用类上声明的泛型的。只能使用自己声明的 <code>&lt;E&gt;</code></p>
</blockquote>
<h3 id="2-3-项目中哪里用到了泛型？"><a href="#2-3-项目中哪里用到了泛型？" class="headerlink" title="2.3 项目中哪里用到了泛型？"></a>2.3 项目中哪里用到了泛型？</h3><ul>
<li>自定义接口通用返回结果 <code>CommonResult&lt;T&gt;</code> 通过参数 T 可根据具体的返回类型动态指定结果的数据类型</li>
<li>定义 Excel 处理类 <code>ExcelUtil&lt;T&gt;</code> 用于动态指定 Excel 导出的数据类型</li>
<li>构建集合工具类（参考 Collections 中的 sort, binarySearch 方法）。</li>
<li>……</li>
</ul>
<h2 id="3-反射"><a href="#3-反射" class="headerlink" title="3. 反射"></a>3. 反射</h2><p>详细解读见 <a href="./%E5%85%B6%E4%BB%96%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9.md">其他重要知识点</a></p>
<h3 id="3-1-什么是反射？"><a href="#3-1-什么是反射？" class="headerlink" title="3.1 什么是反射？"></a>3.1 什么是反射？</h3><p>反射之所以被称为框架的灵魂，主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。</p>
<h3 id="3-2-反射的优缺点？"><a href="#3-2-反射的优缺点？" class="headerlink" title="3.2 反射的优缺点？"></a>3.2 反射的优缺点？</h3><p>反射可以让我们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利。</p>
<p>不过，反射让我们在运行时有了分析操作类的能力的同时，也增加了安全问题，比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。</p>
<p>相关阅读：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/1392351/java-reflection-why-is-it-so-slow">Java Reflection: Why is it so slow?</a> 。</p>
<h3 id="3-3-反射的应用场景？"><a href="#3-3-反射的应用场景？" class="headerlink" title="3.3 反射的应用场景？"></a>3.3 反射的应用场景？</h3><p>像 <code>Spring/Spring Boot、MyBatis</code> 等等框架中都大量使用了反射机制。</p>
<p><strong>这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。</strong></p>
<p>比如下面是通过 JDK 实现动态代理的示例代码，其中就使用了反射类 <code>Method</code> 来调用指定的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DebugInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理类中的真实对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DebugInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before method &quot;</span> + method.getName());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;after method &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外， <strong>注解</strong> 的实现也用到了反射。为什么使用 Spring 的时候 ，一个 <code>@Component</code> 注解就声明了一个类为 Spring Bean 呢？为什么通过一个 <code>@Value</code> 注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？这些都是因为你可以基于反射分析类，然后获取到类&#x2F;属性&#x2F;方法&#x2F;方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。</p>
<h2 id="4-注解"><a href="#4-注解" class="headerlink" title="4. 注解"></a>4. 注解</h2><h3 id="4-1-注解是什么？"><a href="#4-1-注解是什么？" class="headerlink" title="4.1 注解是什么？"></a>4.1 注解是什么？</h3><p><code>Annotation</code> 是 Java 5 开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类、方法或变量，提供某些信息供程序在编译或运行时使用。</p>
<p>注解本质时一个继承了 <code>Annotation</code> 的特殊接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Override</span> <span class="keyword">extends</span> <span class="title class_">Annotation</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK 提供了很多内置的注解 （ <code>@Override , @Deprecated</code> ），同时，我们还可以自定义注解。</p>
<h3 id="4-2-注解的解析方式有几种？"><a href="#4-2-注解的解析方式有几种？" class="headerlink" title="4.2 注解的解析方式有几种？"></a>4.2 注解的解析方式有几种？</h3><p>注解只有被解析之后才会生效，常见的解析方法有两种：</p>
<ul>
<li><p><strong>编译期直接扫描</strong> ：　编译器在编译 Java 代码时扫描对应的注解并处理，比如某个方法使用　<code>@Override</code> 注解，编译器在编译时就会检测当前的方法是否重写了父类对应的方法。</p>
</li>
<li><p><strong>运行期通过反射代理</strong> ： 像框架中自带的注解 （如 Spring 框架的 <code>@Value</code>, <code>@Component</code> ）都是通过反射来进行处理的。</p>
</li>
</ul>
<h2 id="5-SPI"><a href="#5-SPI" class="headerlink" title="5. SPI"></a>5. SPI</h2><p>关于 SPI 的详细解读，请看<a href="./%E5%85%B6%E4%BB%96%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9.md">其他重要知识点</a></p>
<h3 id="5-1-什么是-SPI"><a href="#5-1-什么是-SPI" class="headerlink" title="5.1 什么是 SPI"></a>5.1 什么是 SPI</h3><p>SPI 即 Service Provider Interface ， 字面意思就是“ 服务提供者的接口 ”， 可指：专门提供给服务提供者或者扩展框架功能的开发者去使用的一个接口。</p>
<p>SPI 将服务接口和具体的服务实现分离开，将服务调用方和服务实现者解耦，能提升程序的扩展性、可维护性。修改或替换服务并不需要修改调用方。</p>
<p>很多框架都使用了 Java 的 SPI 机制，如 Spring框架、数据库加载驱动、日志接口以及 Dubbo 的扩展实现等等。</p>
<h3 id="5-2-SPI-和-API-的区别？"><a href="#5-2-SPI-和-API-的区别？" class="headerlink" title="5.2 SPI 和 API 的区别？"></a>5.2 SPI 和 API 的区别？</h3><p><img src="/./asserts/JavaSE%20pt%203/01.png" alt="区别"></p>
<p>一般模块之间都是通过接口进行通讯，因此在服务调用方和服务实现方（也称服务提供者）之间引入一个“接口”。</p>
<ul>
<li><p>当<strong>实现方提供了接口和实现</strong>，我们可以通过调用实现方的接口从而拥有实现方给我们提供的能力，这就是 API。这种情况下，接口和实现都是放在实现方的包中。调用方通过接口调用实现方的功能，而不需要关心具体的实现细节。</p>
</li>
<li><p>当<strong>接口存在于调用方这边时</strong>，这就是 SPI 。由接口调用方确定接口规则，然后由不同的厂商根据这个规则对这个接口进行实现，从而提供服务。</p>
</li>
</ul>
<p>例子： 公司 H 是一家科技公司，新设计了一款芯片，然后现在需要量产了，而市面上有好几家芯片制造业公司，这个时候，只要 H 公司指定好了这芯片生产的标准（定义好了接口标准），那么这些合作的芯片公司（服务提供者）就按照标准交付自家特色的芯片（提供不同方案的实现，但是给出来的结果是一样的）。</p>
<h3 id="5-3-SPI-的优缺点"><a href="#5-3-SPI-的优缺点" class="headerlink" title="5.3 SPI 的优缺点"></a>5.3 SPI 的优缺点</h3><p>通过 SPI 机制能够大大地提高接口设计的灵活性，但是 SPI 机制也存在一些缺点，比如：</p>
<ul>
<li><p>需要遍历加载所有的实现类，不能做到按需加载，这样效率相对较低。</p>
</li>
<li><p>当多个 ServiceLoader 同时 load 时，会有并发问题。</p>
</li>
</ul>
<h2 id="6-序列化和反序列化"><a href="#6-序列化和反序列化" class="headerlink" title="6. 序列化和反序列化"></a>6. 序列化和反序列化</h2><p><a href="./%E5%85%B6%E4%BB%96%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9.md">具体介绍</a></p>
<h3 id="6-1-什么是序列化和反序列化？"><a href="#6-1-什么是序列化和反序列化？" class="headerlink" title="6.1 什么是序列化和反序列化？"></a>6.1 什么是序列化和反序列化？</h3><ul>
<li><p><strong>序列化</strong> ： 将数据或对象转换成可以存储或传输的形式 （通常是二进制字节流， 也可以是 JSON 、 XML 等文本格式）</p>
</li>
<li><p><strong>反序列化</strong> ：将序列化过程中生成的数据转换为原始数据结构或对象的过程。</p>
</li>
</ul>
<p>常见应用场景：</p>
<ul>
<li><p>对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；</p>
</li>
<li><p>将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；</p>
</li>
<li><p>将对象存储到数据库（如 Redis）之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；</p>
</li>
<li><p>将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。</p>
</li>
</ul>
<h3 id="6-2-序列化协议对应-TCP-IP-4层模型的哪一层？"><a href="#6-2-序列化协议对应-TCP-IP-4层模型的哪一层？" class="headerlink" title="6.2 序列化协议对应 TCP&#x2F;IP 4层模型的哪一层？"></a>6.2 序列化协议对应 TCP&#x2F;IP 4层模型的哪一层？</h3><p><img src="/./asserts/JavaSE%20pt%203/02.png" alt="OSI 七层协议"></p>
<p>如上图所示，OSI 七层协议模型中，表示层做的事情主要就是对应用层的用户数据进行处理转换为二进制流。反过来的话，就是将二进制流转换成应用层的用户数据。</p>
<p>OSI 七层协议模型中的应用层、表示层和会话层对应的都是 TCP&#x2F;IP 四层模型中的应用层，所以序列化协议属于 TCP&#x2F;IP 协议应用层的一部分。</p>
<h3 id="6-3-如果有些字段不想序列化怎么办？"><a href="#6-3-如果有些字段不想序列化怎么办？" class="headerlink" title="6.3 如果有些字段不想序列化怎么办？"></a>6.3 如果有些字段不想序列化怎么办？</h3><p>对于不想进行序列化的变量，使用 <code>transient</code> 关键字修饰。</p>
<p><code>transient</code> 关键词的作用是： 阻止实例中使用此关键字的变量序列化；当对象被反序列化时，被 <code>transient</code> 修饰的关键字不会被持久化和恢复。</p>
<p>注意：</p>
<ul>
<li><code>transient</code> 只能修饰变量</li>
<li><code>transient</code> 修饰的变量，在反序列化后变量值会被设置成默认值。</li>
<li><code>static</code> 变量因为不属于任何对象，所以无论有没有 <code>transient</code> 修饰都不会被序列化。</li>
</ul>
<h3 id="6-4-常见的序列化协议"><a href="#6-4-常见的序列化协议" class="headerlink" title="6.4 常见的序列化协议"></a>6.4 常见的序列化协议</h3><p>JDK 自带的序列化方法一般不用，因为序列化效率低且存在安全问题。较常用的序列化协议有 Hession , Kryo , Protobuf , protoStuff ， 这些都是基于二进制的序列化协议。</p>
<p>像 JSON 和 XML 这种属于文本类序列化方式。虽然可读性比较好，但是性能较差，一般不会选择。</p>
<h3 id="6-5-为什么不推荐-JDK-自带的序列化？"><a href="#6-5-为什么不推荐-JDK-自带的序列化？" class="headerlink" title="6.5 为什么不推荐 JDK 自带的序列化？"></a>6.5 为什么不推荐 JDK 自带的序列化？</h3><ul>
<li><strong>不支持跨语言调用</strong></li>
<li><strong>性能差</strong> ： 相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。</li>
<li><strong>存在安全问题</strong> ： 序列化和反序列化本身并不存在问题。但当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码。</li>
</ul>
<h2 id="7-I-O"><a href="#7-I-O" class="headerlink" title="7. I&#x2F;O"></a>7. I&#x2F;O</h2><p><a href="../IO/IO%20%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93.md">基础</a><br><a href="../IO/IO%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93.md">设计模式</a><br><a href="../IO/IO%20%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3.md">模型</a></p>
<h2 id="8-语法糖"><a href="#8-语法糖" class="headerlink" title="8. 语法糖"></a>8. 语法糖</h2><h3 id="8-1-什么是语法糖？"><a href="#8-1-什么是语法糖？" class="headerlink" title="8.1 什么是语法糖？"></a>8.1 什么是语法糖？</h3><p>语法糖（Syntactic sugar） 代指的是编程语言为了方便程序员开发程序而设计的一种特殊语法，这种语法对编程语言的功能并没有影响。实现相同的功能，基于语法糖写出来的代码往往更简单简洁且更易阅读。</p>
<p>JVM 其实并不能识别语法糖，Java 语法糖要想被正确执行，需要先通过编译器进行解糖，也就是在程序编译阶段将其转换成 JVM 认识的基本语法。这也侧面说明，Java 中真正支持语法糖的是 Java 编译器而不是 JVM。如果去看 <code>com.sun.tools.javac.main.JavaCompiler</code> 的源码，会发现在 <code>compile()</code> 中有一个步骤就是调用 <code>desugar()</code> ，这个方法就是负责解语法糖的实现的。</p>
<h3 id="8-2-Java-中常见的语法糖"><a href="#8-2-Java-中常见的语法糖" class="headerlink" title="8.2 Java 中常见的语法糖"></a>8.2 Java 中常见的语法糖</h3><p><a href="./%E5%85%B6%E4%BB%96%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9.md">详解</a></p>
<h2 id="NEXT"><a href="#NEXT" class="headerlink" title="NEXT"></a>NEXT</h2><p><a href="./%E5%85%B6%E4%BB%96%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9.md">下一篇</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-03-25T13:00:29.000Z" title="2025/3/25 21:00:29">2025-03-25</time>发表</span><span class="level-item"><time dateTime="2025-04-06T14:51:14.670Z" title="2025/4/6 22:51:14">2025-04-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%85%AB%E8%82%A1/">八股</a><span> / </span><a class="link-muted" href="/categories/%E5%85%AB%E8%82%A1/JavaSE/">JavaSE</a></span><span class="level-item">1 小时读完 (大约7678个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/03/25/%E5%85%AB%E8%82%A1/Java/Java%E5%9F%BA%E7%A1%80/JavaSE%20pt.2/">JavaSE pt.2</a></p><div class="content"><h2 id="1-面向对象基础"><a href="#1-面向对象基础" class="headerlink" title="1. 面向对象基础"></a>1. 面向对象基础</h2><h3 id="1-1-面向对象和面向过程的区别？"><a href="#1-1-面向对象和面向过程的区别？" class="headerlink" title="1.1 面向对象和面向过程的区别？"></a>1.1 面向对象和面向过程的区别？</h3><p>面向过程（ Procedural-Oriented Programming , POP ） 和面向对象 （ Object-Oriented Programming , OOP ） 是两种常见的编程范式，两者的区别主要是解决问题的不同：</p>
<ul>
<li><strong>面向过程</strong> ： 将解决问题的过程拆成一个一个函数，通过函数的执行解决问题。</li>
<li><strong>面向对象</strong> ： 先抽象出对象，然后用对象执行方法的方式解决问题。</li>
</ul>
<p>相较于 POP ， OOP 程序一般具有以下优点：</p>
<ul>
<li><strong>易维护</strong> ： 由于良好的结构和封装性， OOP 程序通常更容易维护。</li>
<li><strong>易复用</strong> ： 通过继承和多态， OOP 设计使得代码更具复用性，方便扩展功能。</li>
<li><strong>易扩展</strong> ： 模块化设计使系统扩展变的更加容易和灵活。</li>
</ul>
<p>POP 的编程方式通常更为简单和直接，适合处理一些较简单的任务。</p>
<p>POP 和 OOP 的性能差异主要取决于它们的运行机制，而不仅仅是编程范式本身。因此，简单比较两者性能是一个常见误区。（ <a target="_blank" rel="noopener" href="https://github.com/Snailclimb/JavaGuide/issues/431">相关 issue</a> ）</p>
<h3 id="1-2-创建一个对象用什么运算符？对象实体与对象引用有何不同？"><a href="#1-2-创建一个对象用什么运算符？对象实体与对象引用有何不同？" class="headerlink" title="1.2 创建一个对象用什么运算符？对象实体与对象引用有何不同？"></a>1.2 创建一个对象用什么运算符？对象实体与对象引用有何不同？</h3><p><code>new</code> 运算符， <code>new</code> 对象创建对象实例（对象实例在堆内存中）， 对象引用指向对象实例（对象引用存放在栈内存中）。</p>
<ul>
<li>1 个对象引用可以指向 0 个或 1 个对象</li>
<li>一个对象可以有 n 个引用指向它</li>
</ul>
<h3 id="1-3-对象相等和引用相等的区别？"><a href="#1-3-对象相等和引用相等的区别？" class="headerlink" title="1.3 对象相等和引用相等的区别？"></a>1.3 对象相等和引用相等的区别？</h3><ul>
<li>对象的相等一般比较的是内存中查询放的内容是否相等。</li>
<li>引用相等一般比较的是它们指向的内存地址是否相等。</li>
</ul>
<h3 id="1-4-如果一个类没有声明构造方法，该程序能正确执行吗？"><a href="#1-4-如果一个类没有声明构造方法，该程序能正确执行吗？" class="headerlink" title="1.4 如果一个类没有声明构造方法，该程序能正确执行吗？"></a>1.4 如果一个类没有声明构造方法，该程序能正确执行吗？</h3><p>如果一个对象没有声明构造方法，也可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果自己添加了构造方法， Java 就不会添加默认的构造方法了。</p>
<p>如果重载了有参的构造方法，<strong>记得都要把无参的构造方法也写出来</strong>（无论是否用到），因为这可以帮助我们在创建对象的时候少踩坑。</p>
<h3 id="1-5-构造方法有哪些特点？是否可以被-override-？"><a href="#1-5-构造方法有哪些特点？是否可以被-override-？" class="headerlink" title="1.5 构造方法有哪些特点？是否可以被 override ？"></a>1.5 构造方法有哪些特点？是否可以被 <code>override</code> ？</h3><p>特点：</p>
<ul>
<li><strong>名称与类名相同</strong> ： 构造方法的名称必须与类名完全一致</li>
<li><strong>没有返回值</strong> ： 构造方法没有返回类型且不能用 <code>void</code> 声明</li>
<li><strong>自动执行</strong> ： 在生成类的对象时，构造方法会自动执行，无需显式调用</li>
</ul>
<p>构造方法 <strong>不能被重写 （ override ）</strong> ， 但 <strong>可以被重载 （ overload ）</strong> 。</p>
<h3 id="1-6-面向对象三大特征？"><a href="#1-6-面向对象三大特征？" class="headerlink" title="1.6 面向对象三大特征？"></a>1.6 面向对象三大特征？</h3><h4 id="1-6-1-封装"><a href="#1-6-1-封装" class="headerlink" title="1.6.1 封装"></a>1.6.1 封装</h4><p>封装是指将对象的状态信息 （属性） 隐藏在对象内部， 不允许外部对象直接访问。都是可以提供一些可被外界访问的方法来操作属性。</p>
<h4 id="1-6-2-继承"><a href="#1-6-2-继承" class="headerlink" title="1.6.2 继承"></a>1.6.2 继承</h4><p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p>
<p>注意：</p>
<ol>
<li>子类拥有父类对象的所有属性和方法（包括私有属性和方法），但是父类的私有属性和方法子类无法访问， <strong>只是拥有</strong> 。</li>
<li>子类可以拥有自己的属性和方法。</li>
<li>子类可以用自己的方式实现父类的方法。</li>
</ol>
<h4 id="1-6-3-多态"><a href="#1-6-3-多态" class="headerlink" title="1.6.3 多态"></a>1.6.3 多态</h4><p>多态表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</p>
<p>特点：</p>
<ul>
<li>对象类型和引用类型之间具有继承（类） &#x2F; 实现（接口） 关系</li>
<li>引用类型变量发出的方法调用的到底时哪个类中的方法，必须在程序运行期间才能确定</li>
<li>多态不能调用 “只在子类存在但父类不存在的方法”</li>
<li>如果子类重写了父类的方法，真正执行的是子类重写的方法，如果没有，执行的是父类的方法。</li>
</ul>
<h3 id="1-7-接口和抽象类的共同点和区别？"><a href="#1-7-接口和抽象类的共同点和区别？" class="headerlink" title="1.7 接口和抽象类的共同点和区别？"></a>1.7 接口和抽象类的共同点和区别？</h3><p>共同点：</p>
<ul>
<li><strong>实例化</strong> ： 接口和抽象类都不能直接实例化，只能被实现 （接口） 或继承 （抽象类） 后才能创建具体的对象。</li>
<li><strong>抽象方法</strong> ： 接口和抽象类都可以包含抽象方法，抽象方法没有方法体，必须在子类或实现类中实现。</li>
</ul>
<p>区别：</p>
<ul>
<li><strong>设计目的</strong> ：<br>接口主要用于对类的行为进行约束，实现接口就具有对应的行为。<br>抽象类主要用于代码复用，强调的是所属关系。</li>
<li><strong>继承和实现</strong> ：<br>一个类只能继承一个类 （包括抽象类）<br>一个类可以实现多个接口，一个接口也可以继承多个其他接口。</li>
<li><strong>成员变量</strong> ：<br>接口中的成员变量只能是 <code>public static final</code> 类型的，不能被修改且必须有初始值。<br>抽象类的成员变量可以有任何修饰符 （ <code>private</code> , <code>protected</code> , <code>public</code> ） 可以在子类中被重新定义或赋值。</li>
<li><strong>方法</strong> ：<ul>
<li>Java 8 之前，接口中的方法默认为 <code>public abstract</code> ， 也就是只能由方法声明。 自 Java 8 起，可以在接口中定义 <code>default</code> 方法和 <code>static</code> 方法，自 Java 9 起，接口可以包含 <code>private</code> 方法。</li>
<li>抽象类可以包含抽象方法和非抽象方法。抽象方法没有方法体，必须在子类中实现。非抽象方法有具体实现，可以直接在抽象类中使用或在子类中重写。</li>
</ul>
</li>
</ul>
<p>在 Java 8 及以上版本中，接口引入了新的方法类型： <code>default</code> 方法、 <code>static</code> 方法和 <code>private</code> 方法。这些方法让接口的使用更加灵活。</p>
<p>Java 8 引入的 <code>default</code> 方法用于提供接口方法的默认实现，可以在实现类中被覆盖。这样就可以在不修改实现类的情况下向现有接口添加新功能，从而增强接口的扩展性和向后兼容性。</p>
<p>Java 8 引入的 <code>static</code> 方法无法在实现类中被覆盖，只能通过接口名直接调用，类似于类中的静态方法。static 方法通常用于定义一些通用的、与接口相关的工具方法，一般很少用。</p>
<p>Java 9 允许在接口中使用 <code>private</code> 方法。 <code>private</code> 方法可以用于在接口内部共享代码，不对外暴露。</p>
<h3 id="1-8-深拷贝和浅拷贝的区别？什么是引用拷贝？"><a href="#1-8-深拷贝和浅拷贝的区别？什么是引用拷贝？" class="headerlink" title="1.8 深拷贝和浅拷贝的区别？什么是引用拷贝？"></a>1.8 深拷贝和浅拷贝的区别？什么是引用拷贝？</h3><p>深拷贝与浅拷贝的区别：</p>
<ul>
<li><strong>浅拷贝</strong> ： 浅拷贝会在堆上创建一个新的对象（区别与深拷贝的一点），不过，如果元对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，即拷贝对象和原对象共用同一个内部对象。</li>
<li><strong>深拷贝</strong> ： 深拷贝会完全复制整个对象，包括对象所包含的内部对象。</li>
</ul>
<p>实例：</p>
<h4 id="1-8-1-浅拷贝"><a href="#1-8-1-浅拷贝" class="headerlink" title="1.8.1 浅拷贝"></a>1.8.1 浅拷贝</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 省略构造函数、Getter&amp;Setter方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Address <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Address) <span class="built_in">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">    <span class="comment">// 省略构造函数、Getter&amp;Setter方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) <span class="built_in">super</span>.clone();</span><br><span class="line">            <span class="keyword">return</span> person;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;武汉&quot;</span>));</span><br><span class="line"><span class="type">Person</span> <span class="variable">person1Copy</span> <span class="operator">=</span> person1.clone();</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">System.out.println(person1.getAddress() == person1Copy.getAddress());</span><br></pre></td></tr></table></figure>

<p>从输出结构就可以看出， <code>person1</code> 的克隆对象和 <code>person1</code> 使用的仍然是同一个 <code>Address</code> 对象。</p>
<h4 id="1-8-2-深拷贝"><a href="#1-8-2-深拷贝" class="headerlink" title="1.8.2 深拷贝"></a>1.8.2 深拷贝</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Person <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) <span class="built_in">super</span>.clone();</span><br><span class="line">        person.setAddress(person.getAddress().clone());</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;武汉&quot;</span>));</span><br><span class="line"><span class="type">Person</span> <span class="variable">person1Copy</span> <span class="operator">=</span> person1.clone();</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line">System.out.println(person1.getAddress() == person1Copy.getAddress());</span><br></pre></td></tr></table></figure>

<p>从输出结构可以看出，显然 <code>person1</code> 的克隆对象和 <code>person1</code> 包含的 <code>Address</code> 对象已经是不同的了。</p>
<h4 id="1-8-3-引用拷贝"><a href="#1-8-3-引用拷贝" class="headerlink" title="1.8.3 引用拷贝"></a>1.8.3 引用拷贝</h4><p>引用拷贝就是两个不同的引用指向同一个对象。</p>
<img src="./asserts/JavaSE pt 2/001.png">

<h2 id="2-Object"><a href="#2-Object" class="headerlink" title="2. Object"></a>2. Object</h2><h3 id="2-1-Object-类的常见方法有哪些？"><a href="#2-1-Object-类的常见方法有哪些？" class="headerlink" title="2.1 Object 类的常见方法有哪些？"></a>2.1 Object 类的常见方法有哪些？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于创建并返回当前对象的一份拷贝。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实例被垃圾回收器回收的时候触发的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-和-equals-的区别？"><a href="#2-2-和-equals-的区别？" class="headerlink" title="2.2 == 和 equals() 的区别？"></a>2.2 <code>==</code> 和 <code>equals()</code> 的区别？</h3><p><code>==</code> 对基本类型和引用类型的作用是不同的：</p>
<ul>
<li>对基本数据类型， <code>==</code> 比较的是值</li>
<li>对引用数据类型， <code>==</code> 比较的是对象的内存地址</li>
</ul>
<blockquote>
<p>Java 只有值传递，所以对 <code>==</code> 来说，不管是基本数据类型还是引用数据类型，其本质都是比较值。</p>
</blockquote>
<p><code>equals()</code> 不能用于基本数据类型的判断。 <code>equals()</code> 存在于 <code>Object</code> 类中， 因此所有的类都有 <code>equals()</code> 方法。</p>
<p><code>equals()</code> 方法存在两种使用情况：</p>
<ul>
<li>类没有重写： 等价于通过 <code>==</code> 比较对象。</li>
<li>类重写了： 一般都重写 <code>equals()</code> 方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 <code>true</code> (即认为这两个对象相等)。</li>
</ul>
<p><code>String</code> 中的 <code>equals</code> 方法是被重写过的，因为 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址，而 <code>String</code> 的 <code>equals</code> 方法比较的是对象的值。</p>
<p>当创建 <code>String</code> 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 <code>String</code> 对象。</p>
<p><code>String</code> 类 <code>equals()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object anObject)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">anotherString</span> <span class="operator">=</span> (String)anObject;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="type">char</span> v1[] = value;</span><br><span class="line">            <span class="type">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-hashcode-有什么用？"><a href="#2-3-hashcode-有什么用？" class="headerlink" title="2.3 hashcode() 有什么用？"></a>2.3 <code>hashcode()</code> 有什么用？</h3><p><code>hashcode()</code> 的作用是获取哈希值（ <code>int</code> 整形 ）， 也称为散列码，用于确定该对象在哈希表中的索引位置。</p>
<p><code>hashCode()</code> 定义在 JDK 的 <code>Object</code> 类中，这就意味着 <code>Java</code> 中的任何类都包含有 <code>hashCode()</code> 函数。另外需要注意的是： <code>Object</code> 的 <code>hashCode()</code> 方法是本地方法，也就是用 <code>C</code> 语言或 <code>C++</code> 实现的。</p>
<p>散列表存储的是键值对( key-value )，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p>
<h3 id="2-4-为什么要有-hashcode-？"><a href="#2-4-为什么要有-hashcode-？" class="headerlink" title="2.4 为什么要有 hashcode() ？"></a>2.4 为什么要有 <code>hashcode()</code> ？</h3><blockquote>
<p>当把对象加入 <code>HashSet</code> 时， <code>HashSet</code> 会先计算对象的 <code>hashCode</code> 值来判断对象加入的位置，同时也会与其他已经加入的对象的 <code>hashCode</code> 值作比较，如果没有相符的 <code>hashCode</code> ， <code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashCode</code> 值的对象，这时会调用 <code>equals()</code> 方法来检查 <code>hashCode</code> 相等的对象是否真的相同。如果两者相同， <code>HashSet</code> 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 <code>equals</code> 的次数，相应就大大提高了执行速度。<br>—— Head First Java</p>
</blockquote>
<p><code>hashCode()</code> 和 <code>equals()</code> 都是用于比较两个对象是否相等。</p>
<h4 id="2-4-1-为什么-JDK-还要同时提供这两个方法呢？"><a href="#2-4-1-为什么-JDK-还要同时提供这两个方法呢？" class="headerlink" title="2.4.1 为什么 JDK 还要同时提供这两个方法呢？"></a>2.4.1 为什么 JDK 还要同时提供这两个方法呢？</h4><p>在一些容器（比如 <code>HashMap</code> 、 <code>HashSet</code> ）中，有了 <code>hashCode()</code> 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进 <code>HashSet</code> 的过程）</p>
<p>在前面也提到了添加元素进 <code>HashSet</code> 的过程，如果 <code>HashSet</code> 在对比的时候，同样的 <code>hashCode</code> 有多个对象，它会继续使用 <code>equals()</code> 来判断是否真的相同。也就是说 <code>hashCode</code> 帮助我们大大缩小了查找成本。</p>
<h4 id="2-4-2-为什么不只提供-hashCode-方法呢？"><a href="#2-4-2-为什么不只提供-hashCode-方法呢？" class="headerlink" title="2.4.2 为什么不只提供 hashCode() 方法呢？"></a>2.4.2 为什么不只提供 <code>hashCode()</code> 方法呢？</h4><p>因为两个对象的 hashCode 值相等并不代表两个对象就相等。</p>
<p><code>hashCode()</code> 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（ 所谓哈希碰撞也就是指的是不同的对象得到相同的 <code>hashCode</code> )。</p>
<p>总结：</p>
<ul>
<li>两个对象的 <code>hashcode</code> 值相等， 两个对象不一定相等。</li>
<li>两个对象的 <code>hashcode</code> 值相等且 <code>equals()</code> 方法返回 <code>true</code> ，才认为两个对象相等。</li>
<li>两个对象的 <code>hashcode</code> 不相等， 可以直接认为两个对象不相等。</li>
</ul>
<h3 id="2-5-为什么重写-equals-方法时必须重写-hashcode-方法？"><a href="#2-5-为什么重写-equals-方法时必须重写-hashcode-方法？" class="headerlink" title="2.5 为什么重写 equals() 方法时必须重写 hashcode() 方法？"></a>2.5 为什么重写 <code>equals()</code> 方法时必须重写 <code>hashcode()</code> 方法？</h3><p>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p>
<p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象， <code>hashCode</code> 值却不相等。</p>
<p><strong>思考</strong> ： 重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话，使用 <code>HashMap</code> 可能会出现什么问题。</p>
<p>答案：</p>
<p>基础：</p>
<p>会出现 <code>equals</code> 判断相同的对象由于 <code>hashcode</code> 不同导致 <code>hashmap</code> 中存在多个相同的对象。</p>
<p>Deepseek 优化：</p>
<p>当重写 <code>equals()</code> 而未重写 <code>hashCode()</code> 时，使用 <code>HashMap</code> 可能引发以下问题：</p>
<ul>
<li><p>哈希冲突误判： <code>HashMap</code> 通过 <code>hashCode()</code> 确定键值对的存储桶位置。若两个逻辑相等的对象（ <code>equals()</code> 为 <code>true</code> ）产生不同哈希值，它们会被错误分配到不同存储桶，导致 <code>HashMap</code> 无法识别其等价性。</p>
</li>
<li><p>数据重复存储：本应覆盖的键值对会作为不同键被重复存储，例如 <code>map.put(a,1)</code> 和 <code>map.put(b,1)</code> 会形成两个独立条目（ 尽管 <code>a.equals(b) == true</code> ）。</p>
</li>
<li><p>检索数据失败：通过等价对象查询时（ 如 <code>map.get(b)</code> 查询已存入的 <code>a</code> ），由于哈希定位到错误存储桶，可能返回 <code>null</code> 而非预期值。</p>
</li>
<li><p>破坏契约原则：违反 Java 对象契约（ <code>equal</code> 对象必须有相同 <code>hashCode</code> ），导致所有依赖哈希机制的集合类（ <code>HashSet</code> 、 <code>HashTable</code> 等）行为异常。</p>
</li>
</ul>
<p><strong>总结</strong> ：</p>
<ul>
<li><p><code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p>
</li>
<li><p>两个对象有相同的 <code>hashCode</code> 值，他们也不一定是相等的（哈希碰撞）。</p>
</li>
</ul>
<h2 id="3-String"><a href="#3-String" class="headerlink" title="3. String"></a>3. String</h2><h3 id="3-1-String-StringBuffer-StringBuilder-的区别？"><a href="#3-1-String-StringBuffer-StringBuilder-的区别？" class="headerlink" title="3.1 String , StringBuffer , StringBuilder 的区别？"></a>3.1 String , StringBuffer , StringBuilder 的区别？</h3><p><strong>可变性</strong>：</p>
<p><code>String</code> 是不可变的。</p>
<p><code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，最关键的是 <code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法，比如 <code>append</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, CharSequence &#123;</span><br><span class="line">    <span class="type">char</span>[] value;</span><br><span class="line">    <span class="keyword">public</span> AbstractStringBuilder <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> appendNull();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">        ensureCapacityInternal(count + len);</span><br><span class="line">        str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">        count += len;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>线程安全性</strong> ：</p>
<p><code>String</code> 中的对象是不可变的，也就可以理解为常量，<strong>线程安全</strong>。 <code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code> 、 <code>append</code> 、 <code>insert</code> 、 <code>indexOf</code> 等公共方法。 <code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是<strong>线程安全</strong>的。 <code>StringBuilder</code> 并没有对方法进行加同步锁，所以是<strong>非线程安全</strong>的。</p>
<p><strong>性能</strong> ：</p>
<p>每次对 <code>String</code> 类型进行改变时都会生成一个新的 <code>String</code> 对象，然后将指针指向新的对象。 <code>StringBuffer</code> 每次都会对对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10% ~ 15% 的性能提升，但却要冒多线程不安全的风险。</p>
<p>总结：</p>
<ul>
<li>操作少量数据： 用 <code>String</code></li>
<li>单线程操作字符串缓冲区下操作大量数据： <code>StringBuilder</code></li>
<li>多线程操作字符串缓冲区下操作大量数据： <code>StringBuffer</code></li>
</ul>
<h3 id="3-2-String-为什么不可变？"><a href="#3-2-String-为什么不可变？" class="headerlink" title="3.2 String 为什么不可变？"></a>3.2 String 为什么不可变？</h3><p><code>String</code> 类中使用 <code>fianl</code> 关键字修饰字符数组来保存字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：<strong>被 <code>fianl</code> 修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象</strong>。<br>因此， <code>fianl</code> 修饰的数组保存字符串<strong>并不是 <code>String</code> 不可变的根本原因</strong>， 因为这个数组保存的字符串是可变的（ <code>final</code> 修饰引用类型变量的情况）。</p>
</blockquote>
<p><code>String</code> 真正不可变的原因：</p>
<ol>
<li>保存字符串的数组被 <code>final</code> 修饰且为私有的，并且 <code>String</code> 类没有提供&#x2F;暴露修改这个字符串的方法。</li>
<li><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</li>
</ol>
<blockquote>
<p>补充：<br>在 Java 9 之后， <code>String</code> <code>StringBuilder</code> 与 <code>StringBuffer</code> 的实现被改用 <code>byte</code> 数组存储字符串。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable,Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">// @Stable 注解表示变量最多被修改一次，称为“稳定的”。</span></span><br><span class="line">    <span class="meta">@Stable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, CharSequence &#123;</span><br><span class="line">    <span class="type">byte</span>[] value;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Java-9-为何要将-String-的底层实现由-char-改成了-byte"><a href="#Java-9-为何要将-String-的底层实现由-char-改成了-byte" class="headerlink" title="Java 9 为何要将 String 的底层实现由 char[] 改成了 byte[] ?"></a>Java 9 为何要将 <code>String</code> 的底层实现由 <code>char[]</code> 改成了 <code>byte[]</code> ?</h4><p>新版的 <code>String</code> 支持两个编码方案： <code>Latin-1</code> 和 <code>UTF-16</code> 。如果字符串中包含的汉字没有超过 <code>Latin-1</code> 可表示范围内的字符，那就会使用 <code>Latin-1</code> 。 <code>Latin-1</code> 编码方案下， <code>byte</code> 占一个字节（ 8 位 ）， <code>char</code> 占用 2 个字节（ 16 ）， <code>byte</code> 相较 <code>char</code> 节省一半的内存空间。</p>
<img src="./asserts/JavaSE pt 2/002.png">

<p>如果字符串中包含的汉字超过 Latin-1 可表示范围内的字符，byte 和 char 所占用的空间是一样的。</p>
<p><a target="_blank" rel="noopener" href="https://openjdk.org/jeps/254">官方介绍</a></p>
<h3 id="3-3-字符串拼接用-还是-StringBuilder-？"><a href="#3-3-字符串拼接用-还是-StringBuilder-？" class="headerlink" title="3.3 字符串拼接用 + 还是 StringBuilder ？"></a>3.3 字符串拼接用 <code>+</code> 还是 <code>StringBuilder</code> ？</h3><p>Java 语言本身不支持运算符重载， <strong>“+”和“+&#x3D;”是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的运算符</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;he&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;llo&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> str1 + str2 + str3;</span><br></pre></td></tr></table></figure>

<p>对应字节码：</p>
<img src="./asserts/JavaSE pt 2/003.png">

<p>可以看出，字符串对象通过“+”的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</p>
<p>不过，在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：<strong>编译器不会创建单个 <code>StringBuilder</code> 以复用，会导致创建过多的 <code>StringBuilder</code> 对象</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">&quot;he&quot;</span>, <span class="string">&quot;llo&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    s += arr[i];</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure>

<p><code>StringBuilder</code> 对象是在循环内部被创建的，这意味着每循环一次就会创建一个 <code>StringBuilder</code> 对象。</p>
<img src="./asserts/JavaSE pt 2/004.png">

<p>如果直接使用 <code>StringBuilder</code> 对象进行字符串拼接的话，就不会存在这个问题了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">&quot;he&quot;</span>, <span class="string">&quot;llo&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="keyword">for</span> (String value : arr) &#123;</span><br><span class="line">    s.append(value);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure>

<img src="./asserts/JavaSE pt 2/005.png">

<p>在 JDK 9 中，字符串相加“+”改为用动态方法 <code>makeConcatWithConstants()</code> 来实现，通过提前分配空间从而减少了部分临时对象的创建。然而这种优化主要针对简单的字符串拼接，如： <code>a+b+c</code> 。对于循环中的大量拼接操作，仍然会逐个动态分配内存（类似于两个两个 <code>append</code> 的概念），并不如手动使用 <code>StringBuilder</code> 来进行拼接效率高。</p>
<h3 id="3-4-String-equals-和-Object-equals-有什么区别？"><a href="#3-4-String-equals-和-Object-equals-有什么区别？" class="headerlink" title="3.4 String equals() 和 Object equals() 有什么区别？"></a>3.4 String equals() 和 Object equals() 有什么区别？</h3><p>String 中的 equals 方法是被重写过的，比较的是 String 字符串的值是否相等。 Object 的 equals 方法是比较的对象的内存地址。</p>
<h3 id="3-5-字符串常量池的作用？"><a href="#3-5-字符串常量池的作用？" class="headerlink" title="3.5 字符串常量池的作用？"></a>3.5 字符串常量池的作用？</h3><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（ <code>String</code> 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在字符串常量池中创建字符串对象 ”ab“</span></span><br><span class="line"><span class="comment">// 将字符串对象 ”ab“ 的引用赋值给 aa</span></span><br><span class="line"><span class="type">String</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象 ”ab“，赋值给引用 bb</span></span><br><span class="line"><span class="type">String</span> <span class="variable">bb</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">System.out.println(aa==bb); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="3-6-String-s1-new-String-“abc”-这句话创建了几个字符串对象？"><a href="#3-6-String-s1-new-String-“abc”-这句话创建了几个字符串对象？" class="headerlink" title="3.6 String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象？"></a>3.6 String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象？</h3><p>答案：<strong>会创建 1 或 2 个字符串对象</strong>。</p>
<ol>
<li>字符串常量池中不存在 “abc”：会创建 2 个 字符串对象。一个在字符串常量池中，由 ldc 指令触发创建。一个在堆中，由 new String() 创建，并使用常量池中的 “abc” 进行初始化。</li>
<li>字符串常量池中已存在 “abc”：会创建 1 个 字符串对象。该对象在堆中，由 new String() 创建，并使用常量池中的 “abc” 进行初始化。</li>
</ol>
<p>分析：</p>
<ol>
<li>如果字符串常量池中不存在字符串对象 “abc”，那么它首先会在字符串常量池中创建字符串对象 “abc”，然后在堆内存中再创建其中一个字符串对象 “abc”。</li>
</ol>
<p>字节码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在堆内存中分配一个尚未初始化的 String 对象。</span></span><br><span class="line"><span class="comment">// #2 是常量池中的一个符号引用，指向 java/lang/String 类。</span></span><br><span class="line"><span class="comment">// 在类加载的解析阶段，这个符号引用会被解析成直接引用，即指向实际的 java/lang/String 类。</span></span><br><span class="line"><span class="number">0</span> <span class="keyword">new</span> #<span class="number">2</span> &lt;java/lang/String&gt;</span><br><span class="line"><span class="comment">// 复制栈顶的 String 对象引用，为后续的构造函数调用做准备。</span></span><br><span class="line"><span class="comment">// 此时操作数栈中有两个相同的对象引用：一个用于传递给构造函数，另一个用于保持对新对象的引用，后续将其存储到局部变量表。</span></span><br><span class="line"><span class="number">3</span> dup</span><br><span class="line"><span class="comment">// JVM 先检查字符串常量池中是否存在 &quot;abc&quot;。</span></span><br><span class="line"><span class="comment">// 如果常量池中已存在 &quot;abc&quot;，则直接返回该字符串的引用；</span></span><br><span class="line"><span class="comment">// 如果常量池中不存在 &quot;abc&quot;，则 JVM 会在常量池中创建该字符串字面量并返回它的引用。</span></span><br><span class="line"><span class="comment">// 这个引用被压入操作数栈，用作构造函数的参数。</span></span><br><span class="line"><span class="number">4</span> ldc #<span class="number">3</span> &lt;abc&gt;</span><br><span class="line"><span class="comment">// 调用构造方法，使用从常量池中加载的 &quot;abc&quot; 初始化堆中的 String 对象</span></span><br><span class="line"><span class="comment">// 新的 String 对象将包含与常量池中的 &quot;abc&quot; 相同的内容，但它是一个独立的对象，存储于堆中。</span></span><br><span class="line"><span class="number">6</span> invokespecial #<span class="number">4</span> &lt;java/lang/String.&lt;init&gt; : (Ljava/lang/String;)V&gt;</span><br><span class="line"><span class="comment">// 将堆中的 String 对象引用存储到局部变量表</span></span><br><span class="line"><span class="number">9</span> astore_1</span><br><span class="line"><span class="comment">// 返回，结束方法</span></span><br><span class="line"><span class="number">10</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<h3 id="3-7-String-intern-方法有什么用？"><a href="#3-7-String-intern-方法有什么用？" class="headerlink" title="3.7 String intern 方法有什么用？"></a>3.7 String intern 方法有什么用？</h3><p><code>String.intern()</code> 是一个 <code>native</code> 方法，用于处理字符串常量池中的对象引用。工作流程：</p>
<ol>
<li><strong>常量池中已有相同内容的字符串对象</strong> ： 如果字符串常量池中已经有一个与调用 <code>intern()</code> 方法的字符串内容相同的对象， <code>intern()</code> 返回常量池中该对象的引用。</li>
<li><strong>常量池中没有相同内容的字符串对象</strong> ： <code>intern()</code> 方法会将当前字符串对象的引用添加到字符串常量池中，并返回该引用。</li>
</ol>
<p>总结：</p>
<ul>
<li><code>intern()</code> 方法的主要作用是确保字符串引用在常量池中的唯一性。</li>
<li>当调用 <code>intern()</code> 时，如果常量池中已经存在相同内容的字符串，则返回常量池中已有对象的引用；否则，将该字符串添加到常量池并返回其引用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s1 指向字符串常量池中的 &quot;Java&quot; 对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Java&quot;</span>;</span><br><span class="line"><span class="comment">// s2 也指向字符串常量池中的 &quot;Java&quot; 对象，和 s1 是同一个对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.intern();</span><br><span class="line"><span class="comment">// 在堆中创建一个新的 &quot;Java&quot; 对象，s3 指向它</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line"><span class="comment">// s4 指向字符串常量池中的 &quot;Java&quot; 对象，和 s1 是同一个对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s3.intern();</span><br><span class="line"><span class="comment">// s1 和 s2 指向的是同一个常量池中的对象</span></span><br><span class="line">System.out.println(s1 == s2); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// s3 指向堆中的对象，s4 指向常量池中的对象，所以不同</span></span><br><span class="line">System.out.println(s3 == s4); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// s1 和 s4 都指向常量池中的同一个对象</span></span><br><span class="line">System.out.println(s1 == s4); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="3-8-String-类型的变量和常量做-“-”-运算时发生了什么？"><a href="#3-8-String-类型的变量和常量做-“-”-运算时发生了什么？" class="headerlink" title="3.8 String 类型的变量和常量做 “+” 运算时发生了什么？"></a>3.8 String 类型的变量和常量做 “+” 运算时发生了什么？</h3><p><strong>不加 <code>final</code> 关键词</strong> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> str1 + str2;</span><br><span class="line"><span class="type">String</span> <span class="variable">str5</span> <span class="operator">=</span> <span class="string">&quot;string&quot;</span>;</span><br><span class="line">System.out.println(str3 == str4);<span class="comment">//false</span></span><br><span class="line">System.out.println(str3 == str5);<span class="comment">//true</span></span><br><span class="line">System.out.println(str4 == str5);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong> ：比较 String 字符串的值是否相等，可以使用 <code>equals()</code> 方法。 String 中的 <code>equals</code> 方法是被重写过的。 Object 的 equals 方法是比较的对象的<strong>内存地址</strong>，而 String 的 equals 方法比较的是<strong>字符串的值是否相等</strong>。如果你使用 &#x3D;&#x3D; 比较两个字符串是否相等的话，IDEA 还是提示你使用 equals() 方法替换。</p>
</blockquote>
<p><strong>对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。</strong></p>
<p>在编译过程中，Javac 编译器（下文中统称为编译器）会进行一个叫做 常量折叠(Constant Folding) 的代码优化。</p>
<p>常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。</p>
<p>对于 <code>String str3 = &quot;str&quot; + &quot;ing&quot;;</code> 编译器会优化成 <code>String str3 = &quot;string&quot;;</code> 。</p>
<p>并不是所有的常量都会进行折叠，只有编译器在程序编译期就可以确定值的常量才可以：</p>
<ul>
<li>基本数据类型( byte、boolean、short、char、int、float、long、double)以及字符串常量。</li>
<li>final 修饰的基本数据类型和字符串变量</li>
<li>字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（&lt;&lt;、&gt;&gt;、&gt;&gt;&gt; ）</li>
</ul>
<p><strong>引用的值在程序编译期是无法确定的，编译器无法对其进行优化。</strong></p>
<p>对象引用和“+”的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>().append(str1).append(str2).toString();</span><br></pre></td></tr></table></figure>

<p>在平时写代码的时候，尽量避免多个字符串对象拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 <code>StringBuilder</code> 或者 <code>StringBuffer</code> 。</p>
<p>不过，<strong>字符串使用 final 关键字声明之后</strong>，可以让编译器当做常量来处理 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"><span class="comment">// 下面两个表达式其实是等价的</span></span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;<span class="comment">// 常量池中的对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> str1 + str2; <span class="comment">// 常量池中的对象</span></span><br><span class="line">System.out.println(c == d);<span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>被 <code>final</code> 关键字修饰之后的 <code>String</code> 会被编译器当做常量来处理，编译器在程序编译期就可以确定它的值，其效果就相当于访问常量。</p>
<h2 id="NEXT"><a href="#NEXT" class="headerlink" title="NEXT"></a>NEXT</h2><p><a href="JavaSE%20pt.3.md">JavaSE pt.3</a></p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/tags/%E4%B8%AD%E6%96%87/">上一页</a></div><div class="pagination-next"><a href="/tags/%E4%B8%AD%E6%96%87/page/3/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/tags/%E4%B8%AD%E6%96%87/">1</a></li><li><a class="pagination-link is-current" href="/tags/%E4%B8%AD%E6%96%87/page/2/">2</a></li><li><a class="pagination-link" href="/tags/%E4%B8%AD%E6%96%87/page/3/">3</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.jpg" alt="Rossignol"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Rossignol</p><p class="is-size-6 is-block">NaN</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Mars</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives/"><p class="title">55</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories/"><p class="title">15</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags/"><p class="title">13</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/0xRossignol" target="_blank" rel="me noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/0xRossignol"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Golang/"><span class="level-start"><span class="level-item">Golang</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/Golang/basics/"><span class="level-start"><span class="level-item">basics</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/Java/basics/"><span class="level-start"><span class="level-item">basics</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/Java/basics/Thinking-in-Java/"><span class="level-start"><span class="level-item">Thinking in Java</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/Linux/Arch-Linux/"><span class="level-start"><span class="level-item">Arch Linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/OS/"><span class="level-start"><span class="level-item">OS</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Rust/"><span class="level-start"><span class="level-item">Rust</span></span><span class="level-end"><span class="level-item tag">16</span></span></a><ul><li><a class="level is-mobile" href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">Rust程序设计语言</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/test/"><span class="level-start"><span class="level-item">test</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/toy-projects/"><span class="level-start"><span class="level-item">toy projects</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%85%AB%E8%82%A1/"><span class="level-start"><span class="level-item">八股</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%85%AB%E8%82%A1/JavaSE/"><span class="level-start"><span class="level-item">JavaSE</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%85%AB%E8%82%A1/Java%E9%9B%86%E5%90%88/"><span class="level-start"><span class="level-item">Java集合</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-05-22T06:30:26.000Z">2025-05-22</time></p><p class="title"><a href="/2025/05/22/Rust/The%20Rust%20Programming%20Language/06.3%20if%20let%20%E5%92%8C%20let%20else%20%E7%AE%80%E6%B4%81%E6%8E%A7%E5%88%B6%E6%B5%81/">6.3 if let 和 let else 简洁控制流</a></p><p class="categories"><a href="/categories/Rust/">Rust</a> / <a href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-05-22T06:30:26.000Z">2025-05-22</time></p><p class="title"><a href="/2025/05/22/Rust/The%20Rust%20Programming%20Language/06.2%20match%20%E6%8E%A7%E5%88%B6%E6%B5%81%E7%BB%93%E6%9E%84/">6.2 match 控制流结构</a></p><p class="categories"><a href="/categories/Rust/">Rust</a> / <a href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-05-22T05:50:26.000Z">2025-05-22</time></p><p class="title"><a href="/2025/05/22/Rust/The%20Rust%20Programming%20Language/06.1%20%E6%9E%9A%E4%B8%BE%E7%9A%84%E5%AE%9A%E4%B9%89/">6.1 枚举的定义</a></p><p class="categories"><a href="/categories/Rust/">Rust</a> / <a href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-05-21T14:52:17.934Z">2025-05-21</time></p><p class="title"><a href="/2025/05/21/Rust/The%20Rust%20Programming%20Language/07.2%20%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97%E6%9D%A5%E6%8E%A7%E5%88%B6%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E7%A7%81%E6%9C%89%E6%80%A7/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-05-21T14:50:26.000Z">2025-05-21</time></p><p class="title"><a href="/2025/05/21/Rust/The%20Rust%20Programming%20Language/05.3%20%E6%96%B9%E6%B3%95%E8%AF%AD%E6%B3%95/">5.3 方法语法</a></p><p class="categories"><a href="/categories/Rust/">Rust</a> / <a href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2025/05/"><span class="level-start"><span class="level-item">五月 2025</span></span><span class="level-end"><span class="level-item tag">35</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/04/"><span class="level-start"><span class="level-item">四月 2025</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/03/"><span class="level-start"><span class="level-item">三月 2025</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/02/"><span class="level-start"><span class="level-item">二月 2025</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/12/"><span class="level-start"><span class="level-item">十二月 2024</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Arch-Linux/"><span class="tag">Arch Linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/English/"><span class="tag">English</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Golang/"><span class="tag">Golang</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OS/"><span class="tag">OS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Rust/"><span class="tag">Rust</span><span class="tag">16</span></a></div><div class="control"><a class="tags has-addons" href="/tags/git/"><span class="tag">git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/python/"><span class="tag">python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/test/"><span class="tag">test</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/toy-projects/"><span class="tag">toy projects</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%B8%AD%E6%96%87/"><span class="tag">中文</span><span class="tag">27</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%85%AB%E8%82%A1/"><span class="tag">八股</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BF%BB%E8%AF%91/"><span class="tag">翻译</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="MyBlog" height="28"></a><p class="is-size-7"><span>&copy; 2025 Rossignol</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>