<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>标签: 中文 - MyBlog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="MyBlog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="MyBlog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="MyBlog"><meta property="og:url" content="http://example.com/"><meta property="og:site_name" content="MyBlog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:author" content="Rossignol"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"MyBlog","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"Rossignol"},"publisher":{"@type":"Organization","name":"MyBlog","logo":{"@type":"ImageObject","url":"http://example.com/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="MyBlog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/0xRossignol"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags/">标签</a></li><li class="is-active"><a href="#" aria-current="page">中文</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-03-10T14:42:26.000Z" title="2025/3/10 22:42:26">2025-03-10</time>发表</span><span class="level-item"><time dateTime="2025-03-10T14:44:24.762Z" title="2025/3/10 22:44:24">2025-03-10</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%85%AB%E8%82%A1/">八股</a><span> / </span><a class="link-muted" href="/categories/%E5%85%AB%E8%82%A1/JavaSE/">JavaSE</a></span><span class="level-item">1 小时读完 (大约9590个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/03/10/%E5%85%AB%E8%82%A1/Java%E5%9F%BA%E7%A1%80/JavaSE%20pt.1/">JavaSE pt.1</a></p><div class="content"><p>First tip：<br>根据 <strong>JavaGuide</strong> 和 <strong>Deepseek</strong> 内容整理</p>
<h2 id="1-基础概念与常识"><a href="#1-基础概念与常识" class="headerlink" title="1. 基础概念与常识"></a>1. 基础概念与常识</h2><h3 id="1-1-Java-语言有哪些特点？"><a href="#1-1-Java-语言有哪些特点？" class="headerlink" title="1.1 Java 语言有哪些特点？"></a>1.1 Java 语言有哪些特点？</h3><ol>
<li>简单易学（语法简单，容易上手）</li>
<li>面向对象（封装、继承、多态）</li>
<li>平台无关（Java 虚拟机）</li>
<li>支持多线程</li>
<li>可靠性（异常处理、GC）</li>
<li>安全性（访问权限修饰符、限制程序直接访问系统资源）</li>
<li>高效性（通过 <strong>JIT</strong>[^JIT] 编译器等技术优化）</li>
<li>支持网络编程</li>
<li>编译与解释并存</li>
</ol>
<p>[^JIT]: <strong>JIT</strong> 即 “Just in Time”</p>
<blockquote>
<p>拓展：<br>“Write once, Run everywhere” ，即跨平台这一特点已经不再是 Java 的主要特点了（ <strong>Docker</strong> 等技术的出现使跨平台相当轻松）。Java 的优势转变为了其强大的生态。</p>
</blockquote>
<h3 id="1-2-JavaSE-和-JavaEE"><a href="#1-2-JavaSE-和-JavaEE" class="headerlink" title="1.2 JavaSE 和 JavaEE"></a>1.2 JavaSE 和 JavaEE</h3><ul>
<li><p>JavaSE ( <em>Java Platform, Standard Edition</em> )： Java 编程语言的基础，包含了支持 Java 程序开发和运行的核心类库以及 JVM 等核心组件。可以用于构建桌面应用程序或简单的服务器应用程序。</p>
</li>
<li><p>JavaEE ( <em>Java Platform, Enterprise Edition</em> )：建立在 JavaSE 的基础上，包含了支持企业级应用开发和部署的标准与规范（ Servlet、 JSP、 EJB、 JDBC、 JPA、 JTA 等）。可以用于构建分布式、可移植、健壮、可伸缩和安全的服务端 Java 应用程序。</p>
</li>
</ul>
<p>简单来说，Java SE 是 Java 的基础版本，Java EE 是 Java 的高级版本。Java SE 更适合开发桌面应用程序或简单的服务器应用程序，Java EE 更适合开发复杂的企业级应用程序或 Web 应用程序。</p>
<h3 id="1-3-JVM、JDK、JRE"><a href="#1-3-JVM、JDK、JRE" class="headerlink" title="1.3 JVM、JDK、JRE"></a>1.3 JVM、JDK、JRE</h3><h4 id="1-3-1-JVM"><a href="#1-3-1-JVM" class="headerlink" title="1.3.1 JVM"></a>1.3.1 JVM</h4><p>JVM ( <em>Java Virtual Machine</em> ) 是运行 <strong>Java 字节码</strong> 的虚拟机。JVM 有针对不同系统的实现，目的是使用相同的字节码得到相同的结果。字节码和 JVM 是实现 Java 语言 “Write once, Run everywhere” 的关键。</p>
<p><strong>JVM 不止一种，只要满足 JVM 规范，每个公司、组织或者个人都可以开发自己的专属 JVM。</strong> 我们平时接触到的 <em>HotSpotVM</em> 只是 JVM 规范的一种实现。</p>
<p>除了 HotSpotVM 外，还有 <em>J9 VM, Zing VM, JRockit VM</em> 等实现。</p>
<h4 id="1-3-2-JDK-和-JRE"><a href="#1-3-2-JDK-和-JRE" class="headerlink" title="1.3.2 JDK 和 JRE"></a>1.3.2 JDK 和 JRE</h4><p>JDK( <em>Java Development Kit</em> )是 Java 开发工具包，用于创建和编译 Java 程序。它包含了 JRE ( <em>Java Runtime Environment</em> ) 以及编译器 Javac 和其他工具 ( <em>javadoc, jdb（调试器）, jconsole（监控工具）, javap(反编译工具)</em> )。</p>
<p>JRE 是运行已编译的 Java 程序所需的环境，包括：</p>
<ul>
<li>JVM</li>
<li>Java 基础类库 ( <em>Class Library</em> )：一组标准类库，提供常用的功能和 API（如 <em>I&#x2F;O 操作、 网络通信、 数据结构</em> 等）</li>
</ul>
<p>简单来说，JRE 只包含运行 Java 程序所需的环境和类库，而 JDK 不仅包含 JRE ，还包括用于开发和调试的工具。</p>
<p>不过，从 JDK 9 开始，就不需要区分 JDK 和 JRE 的关系了，取而代之的是模块系统（ JDK 被重新组织成 94 个模块）+ <a target="_blank" rel="noopener" href="https://openjdk.org/jeps/282">jlink</a> 工具 (随 Java 9 一起发布的新命令行工具，用于生成自定义 Java 运行时映像，该映像仅包含给定应用程序所需的模块) 。并且，从 JDK 11 开始，Oracle 不再提供单独的 JRE 下载。</p>
<p>可以用 jlink 根据自己的需求，创建一个更小的 runtime ，而不是都使用同样的 JRE 。</p>
<p>定制的、模块化的 Java 运行时映像有助于简化 Java 应用的部署和节省内存、增强安全性和可维护性。</p>
<h3 id="1-4-什么是字节码？采用字节码的好处是什么？"><a href="#1-4-什么是字节码？采用字节码的好处是什么？" class="headerlink" title="1.4 什么是字节码？采用字节码的好处是什么？"></a>1.4 什么是字节码？采用字节码的好处是什么？</h3><p>在 Java 中，能被 JVM 理解的代码（即扩展名为 <code>.class</code> 的文件）就是字节码，它不面向任何特定的处理器，只面向虚拟机。字节码在一定程度上解决了传统解释型语言执行效率低的问题，保留了解释型语言可移植的特点。因此 Java 程序无需重新编译便可在多种不同操作系统上运行。</p>
<img src="./asserts/JavaSE pt 1/001.png">

<p><code>.class -&gt; 机器码</code> 这一步 JVM 类加载器 首先加载字节码文件，然后通过解释器逐行解释执行，这种方式执行速度相对较慢。而且，有些方法和代码块经常需要被调用（即热点代码），所以后来引进了 <strong>JIT</strong> ( <em>Just In Time Compilation</em> )编译器， 而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。这也解释了为什么经常说 <strong>Java 是编译与解释共存的语言</strong>。</p>
<img src="./asserts/JavaSE pt 1/002.png">

<blockquote>
<p>HotSpot 采用了<strong>惰性评估 ( Lazy Evaluation )</strong> 的做法，根据二八定律，消耗大部分系统资源的只有一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。</p>
</blockquote>
<img src="./asserts/JavaSE pt 1/003.png">

<img src="./asserts/JavaSE pt 1/004.png">

<h3 id="1-5-为什么说-Java-语言-“编译与解释并存”-？"><a href="#1-5-为什么说-Java-语言-“编译与解释并存”-？" class="headerlink" title="1.5 为什么说 Java 语言 “编译与解释并存” ？"></a>1.5 为什么说 Java 语言 “编译与解释并存” ？</h3><p>该问题在 <a href="#14-%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E8%8A%82%E7%A0%81%E9%87%87%E7%94%A8%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88">上一问</a> 已经提到过。</p>
<h4 id="1-5-1-分类"><a href="#1-5-1-分类" class="headerlink" title="1.5.1 分类"></a>1.5.1 分类</h4><p>我们可以将高级语言按照程序的执行方式分为两类：</p>
<ul>
<li><p><strong>编译型</strong>： <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%B7%A8%E8%AD%AF%E8%AA%9E%E8%A8%80">编译型语言</a> 会通过 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%B7%A8%E8%AD%AF%E5%99%A8">编译器</a> 将源代码一次性翻译成机器码。一般编译型语言执行速度较快，开发效率较低。</p>
</li>
<li><p><strong>解释型</strong>： <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%9B%B4%E8%AD%AF%E8%AA%9E%E8%A8%80">解释型语言</a> 会通过 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%9B%B4%E8%AD%AF%E5%99%A8">解释器</a> 一句一句的将代码解释（interpret）为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。</p>
</li>
</ul>
<blockquote>
<p>为了改善解释语言的效率而发展出的即时编译技术，已经缩小了这两种语言间的差距。这种技术混合了编译语言与解释型语言的优点，它像编译语言一样，先把程序源代码编译成字节码。到执行期时，再将字节码直译，之后执行。Java 与 LLVM 是这种技术的代表产物。</p>
</blockquote>
<h4 id="1-5-2-为什么说-Java-语言-“编译与解释并存”-？"><a href="#1-5-2-为什么说-Java-语言-“编译与解释并存”-？" class="headerlink" title="1.5.2 为什么说 Java 语言 “编译与解释并存” ？"></a>1.5.2 为什么说 Java 语言 “编译与解释并存” ？</h4><p>这是因为 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（.class 文件），这种字节码必须由 Java 解释器来解释执行。</p>
<h3 id="1-6-AOT-有什么优点？为什么不全部使用-AOT-？"><a href="#1-6-AOT-有什么优点？为什么不全部使用-AOT-？" class="headerlink" title="1.6 AOT 有什么优点？为什么不全部使用 AOT ？"></a>1.6 AOT 有什么优点？为什么不全部使用 AOT ？</h3><p>JDK9 引入了新的编译模式 <strong>AOT</strong> ( <em>Ahead Of Time Compilation</em> ) 。 和 JIT 不同的是，这种编译模式会在程序被执行前就将其编译成机器码，属于静态编译（ C、C++、Rust、Go 等语言就是静态编译）。AOT 避免了 JIT 预热等各方面的开销，可以提高 Java 程序的启动速度，避免预热时间过长。并且， AOT 还能减少内存占用和增强 Java 程序的安全性 （ AOT 编译后的代码不容易被反编译和修改）， 特别适合云原生场景。</p>
<img src="./asserts/JavaSE pt 1/005.png">

<p>可以看出， AOT 的主要优势在于启动时间、内存占用和打包体积。 JIT 的主要优势在于具备更高的极限处理能力，可以降低请求的最大延迟。</p>
<h4 id="1-6-1-既然-AOT-有那么多优点，为什么不全部使用-AOT-？"><a href="#1-6-1-既然-AOT-有那么多优点，为什么不全部使用-AOT-？" class="headerlink" title="1.6.1 既然 AOT 有那么多优点，为什么不全部使用 AOT ？"></a>1.6.1 既然 AOT 有那么多优点，为什么不全部使用 AOT ？</h4><p>JIT 和 AOT 各有优点， AOT 更适合云原生场景，对微服务架构的支持也比较友好。除此之外， AOT 编译无法支持 Java 的一些动态特性，如反射、动态代理、动态加载、 JNI ( <em>Java Native Interface</em> ) 等。然而，很多框架和库（如 <em>Spring</em> 、 <em>CGLIB</em> ）都用到了这些特性。如果只使用 AOT 编译，那就无法使用这些库和框架了，或者说需要针对性地去做适配和优化。</p>
<h3 id="1-7-Oracle-JDK-和-OpenJDK"><a href="#1-7-Oracle-JDK-和-OpenJDK" class="headerlink" title="1.7 Oracle JDK 和 OpenJDK"></a>1.7 Oracle JDK 和 OpenJDK</h3><p>Oracle 官方在 2012 年的博客：</p>
<blockquote>
<p>问：OpenJDK 存储库中的源代码与用于构建 Oracle JDK 的代码之间有什么区别？<br>答：非常接近 - 我们的 Oracle JDK 版本构建过程基于 OpenJDK 7 构建，只添加了几个部分，例如部署代码，其中包括 Oracle 的 Java 插件和 Java WebStart 的实现，以及一些闭源的第三方组件，如图形光栅化器，一些开源的第三方组件，如 Rhino，以及一些零碎的东西，如附加文档或第三方字体。展望未来，我们的目的是开源 Oracle JDK 的所有部分，除了我们考虑商业功能的部分。</p>
</blockquote>
<p>OracleJDK 和 OpenJDK 的区别：</p>
<ol>
<li><p>是否开源： OpenJDK 是一个完全开源的参考模型，而 Oracle JDK 是基于 OpenJDK 实现的，并非完全开源。OpenJDK 开源项目：<a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk">Github</a> 。</p>
</li>
<li><p>是否免费： OracleJDK 提供免费版本，但一般有时间限制。 JDK17 之后的版本可以免费分发和商用，但仅有 3 年时间， 3 年后无法免费商用。不过，JDK8u221 之前只要不升级可以无限期免费。 OpenJDK 是完全免费的。</p>
</li>
<li><p>功能性： OracleJDK 在 OpenJDK 的基础上添加了一些特有的功能和工具，比如 <em>Java Flight Recorder ( JFR ， 一种监控工具 )</em> 、 <em>Java Mission Control ( JMC ，一种监控工具 )</em> 等工具。不过，在 Java 11 之后， OracleJDK 和 OpenJDK 的功能基本一致，之前 OracleJDK 中的私有组件大部分也已经被捐赠给开源组织。</p>
</li>
<li><p>稳定性： OpenJDK 不提供 LTS 服务， 而 OracleJDK 大概每三年都会推出一个 LTS 版本进行长期支持。不过，很多公司都基于 OpenJDK 提供了对应的和 OracleJDK 周期相同的 LTS 版本。因此，两者的稳定性其实差不多。</p>
</li>
<li><p>协议： OracleJDK 使用 BCL&#x2F;OTN 协议， 而 OpenJDK 根据 GPLv2 许可获得许可。</p>
</li>
</ol>
<blockquote>
<p>既然 Oracle JDK 这么好，那为什么还要有 OpenJDK？</p>
<ol>
<li>OpenJDK 是开源的，开源意味着你可以对它根据你自己的需要进行修改、优化，比如 Alibaba 基于 OpenJDK 开发了 <a target="_blank" rel="noopener" href="https://github.com/alibaba/dragonwell8">Dragonwell8</a>。</li>
<li>OpenJDK 是商业免费的（这也是为什么通过 yum 包管理器上默认安装的 JDK 是 OpenJDK 而不是 Oracle JDK）。虽然 Oracle JDK 也是商业免费（比如 JDK 8），但并不是所有版本都是免费的。</li>
<li>OpenJDK 更新频率更快。Oracle JDK 一般是每 6 个月发布一个新版本，而 OpenJDK 一般是每 3 个月发布一个新版本。（现在你知道为啥 Oracle JDK 更稳定了吧，先在 OpenJDK 试试水，把大部分问题都解决掉了才在 Oracle JDK 上发布）</li>
</ol>
</blockquote>
<h4 id="1-7-1-Oracle-JDK-和-OpenJDK-如何选择？"><a href="#1-7-1-Oracle-JDK-和-OpenJDK-如何选择？" class="headerlink" title="1.7.1 Oracle JDK 和 OpenJDK 如何选择？"></a>1.7.1 Oracle JDK 和 OpenJDK 如何选择？</h4><p>建议选择 OpenJDK 或者基于 OpenJDK 的发行版，比如 AWS 的 Amazon Corretto，阿里巴巴的 Alibaba Dragonwell。</p>
<h3 id="1-8-C-和-Java-的区别？"><a href="#1-8-C-和-Java-的区别？" class="headerlink" title="1.8 C++ 和 Java 的区别？"></a>1.8 C++ 和 Java 的区别？</h3><p>虽然 Java 和 C++ 都是面向对象的语言，但是它们有挺多不同的地方：</p>
<ul>
<li>Java 不提供指针直接访问内存，程序内存更安全。</li>
<li>Java 是单继承的， C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以。</li>
<li>Java 有自动内存管理垃圾回收机制（GC），不需要程序员手动释放无用内存。</li>
<li>C++ 同时支持方法重载和操作符重载， Java 只支持方法重载（操作符重载增加了复杂性）。</li>
</ul>
<h2 id="2-基本语法"><a href="#2-基本语法" class="headerlink" title="2. 基本语法"></a>2. 基本语法</h2><h3 id="2-1-注释有哪几种形式？"><a href="#2-1-注释有哪几种形式？" class="headerlink" title="2.1 注释有哪几种形式？"></a>2.1 注释有哪几种形式？</h3><ol>
<li>单行注释</li>
<li>多行注释</li>
<li>文档注释</li>
</ol>
<p>用得较多的是<strong>单行注释和文档注释</strong>，多行注释在开发中使用的相对较少。</p>
<blockquote>
<p><strong>代码的注释不是越详细越好。实际上好的代码本身就是注释，我们要尽量规范和美化自己的代码来减少不必要的注释。</strong><br><strong>若编程语言足够有表达力，就不需要注释，尽量通过代码来阐述。</strong><br>例子：<br>去掉下面复杂的注释，只需要创建一个与注释所言同一事物的函数即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// check to see if the employee is eligible for full benefits</span></span><br><span class="line"><span class="keyword">if</span> ((employee.flags &amp; HOURLY_FLAG) &amp;&amp; (employee.age &gt; <span class="number">65</span>))</span><br></pre></td></tr></table></figure>

<p>应替换为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (employee.isEligibleForFullBenefits())</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="2-2-标识符和关键字的区别是什么？"><a href="#2-2-标识符和关键字的区别是什么？" class="headerlink" title="2.2 标识符和关键字的区别是什么？"></a>2.2 标识符和关键字的区别是什么？</h3><p>简单来说，<strong>标识符就是一个名字</strong>。</p>
<p>有一些标识符， Java 语言已经赋予其特殊的含义，只能在特定的地方使用，这些标识符就是 <strong>关键字</strong> 。 简单来说， <strong>关键字就是被赋予特殊含义的标识符</strong>。</p>
<h4 id="2-2-1-Java-语言的关键字有哪些？"><a href="#2-2-1-Java-语言的关键字有哪些？" class="headerlink" title="2.2.1 Java 语言的关键字有哪些？"></a>2.2.1 Java 语言的关键字有哪些？</h4><table>
<thead>
<tr>
<th>分类</th>
<th>关键 字</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>访问控制</td>
<td>private</td>
<td>protected</td>
<td>public</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>类、方法和变量修饰符</td>
<td>abstract</td>
<td>class</td>
<td>extends</td>
<td>final</td>
<td>implements</td>
<td>interface</td>
<td>native</td>
</tr>
<tr>
<td></td>
<td>new</td>
<td>static</td>
<td>strictfp</td>
<td>synchronized</td>
<td>transient</td>
<td>volatile</td>
<td>enum</td>
</tr>
<tr>
<td>程序控制</td>
<td>break</td>
<td>continue</td>
<td>return</td>
<td>do</td>
<td>while</td>
<td>if</td>
<td>else</td>
</tr>
<tr>
<td></td>
<td>for</td>
<td>instanceof</td>
<td>switch</td>
<td>case</td>
<td>default</td>
<td>assert</td>
<td></td>
</tr>
<tr>
<td>错误处理</td>
<td>try</td>
<td>catch</td>
<td>throw</td>
<td>throws</td>
<td>finally</td>
<td></td>
<td></td>
</tr>
<tr>
<td>包相关</td>
<td>import</td>
<td>package</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>基本类型</td>
<td>boolean</td>
<td>byte</td>
<td>char</td>
<td>double</td>
<td>float</td>
<td>int</td>
<td>long</td>
</tr>
<tr>
<td></td>
<td>short</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>变量引用</td>
<td>super</td>
<td>this</td>
<td>void</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>保留字</td>
<td>goto</td>
<td>const</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>Tips: 所有的关键字都是小写的，在 IDE 中以特殊颜色显示<br><code>default</code> 这个关键字既属于程序控制，也属于类、方法和变量修饰符。</p>
<ul>
<li>在程序控制中，当在 <code>switch</code> 中匹配不到任何情况时，可以使用 <code>default</code> 编写默认匹配的情况。</li>
<li>在类、方法和变量修饰符中，从 JDK8 开始引入了默认方法，可以使用 <code>default</code> 关键字来定义一个方法的默认实现。</li>
<li>在访问控制中，如果一个方法前没有任何修饰符，则默认会有一个修饰符 <code>default</code> ，但是这个修饰符加上就会报错。</li>
</ul>
</blockquote>
<p><strong>注意</strong>： 虽然 <code>true</code> , <code>false</code> 和 <code>null</code> 看起来像关键字但实际上它们只是字面量，不可以作为标识符使用。</p>
<p>官方文档：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html">https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html</a></p>
<h3 id="2-3-自增自减运算符"><a href="#2-3-自增自减运算符" class="headerlink" title="2.3 自增自减运算符"></a>2.3 自增自减运算符</h3><p>Java 提供了自增 ( <code>++</code> ) 和自减 ( <code>--</code> ) 运算符来简化操作。</p>
<p><code>++</code> 和 <code>--</code> 运算符可以放在变量前后：</p>
<ul>
<li><strong>前缀</strong>： 先自增（减）变量的值，然后再使用该变量。</li>
<li><strong>后缀</strong>： 先使用该变量，再自增（减）。</li>
</ul>
<p>笔试题：</p>
<p>运行该代码后 <code>a</code> , <code>b</code> , <code>c</code> , <code>d</code> 和 <code>e</code> 分别为？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line"><span class="comment">// 1 --&gt; a = 9</span></span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a++;</span><br><span class="line"><span class="comment">// 2 --&gt; a = 10 , b = 9</span></span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ++a;</span><br><span class="line"><span class="comment">// 3 --&gt; a = 11 , b = 9 , c = 11</span></span><br><span class="line"><span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> c--;</span><br><span class="line"><span class="comment">// 4 --&gt; a = 11 , b = 9 , c = 10 , d = 11</span></span><br><span class="line"><span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> --d;</span><br><span class="line"><span class="comment">// 5 --&gt; a = 11 , b = 9 , c = 10 , d = 10 , e = 10</span></span><br></pre></td></tr></table></figure>

<p>答案： <code>a = 11</code> 、<code>b = 9</code> 、 <code>c = 10</code> 、 <code>d = 10</code> 、 <code>e = 10</code> 。具体过程看注释。</p>
<h3 id="2-3-移位运算符"><a href="#2-3-移位运算符" class="headerlink" title="2.3 移位运算符"></a>2.3 移位运算符</h3><p>移位运算符是最基本的运算符之一，几乎每种编程语言都包含这一运算符。移位操作中，被操作的数据被视为二进制数，移位就是将其向左或向右移动若干位的运算。</p>
<p>移位运算符在各种框架以及 JDK 自身的源码中使用还是挺广泛的，HashMap（JDK1.8） 中的 hash 方法的源码就用到了移位运算符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class="line">    <span class="comment">// ^：按位异或</span></span><br><span class="line">    <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用移位运算符的主要原因：</strong></p>
<ol>
<li><strong>高效</strong> ： 移位运算符直接对应处理器的移位指令，这些指令通常在一个时钟周期内完成。</li>
<li><strong>节省内存</strong> ： 通过移位操作可以使一个整数存储多个布尔值或标志位。</li>
</ol>
<p>移位运算符最常用于快速乘以或除以 2 的幂次方。除此之外，它还在以下方面发挥着重要作用：</p>
<ul>
<li><strong>位字段管理</strong> ： 存储和操作多个布尔值。</li>
<li><strong>哈希算法和加密算法</strong> ： 通过移位和与、或等操作来混淆数据。</li>
<li><strong>数据压缩</strong> ： 如霍夫曼编码通过移位运算符可以快速处理和操作二进制数据，已生成紧凑的压缩格式。</li>
<li><strong>数据校验</strong> ： 如 CRC （循环冗余校验）通过移位和多项式除法生成和校验数据完整性。</li>
<li><strong>内存对齐</strong> ： 通过移位操作可以计算和调整数据的对齐地址。</li>
</ul>
<p>Java 中有三种移位运算符：</p>
<ul>
<li><code>&lt;&lt;</code> ： 左移运算符，向左移若干位，高位丢弃，低位补零，相当于乘 2^n（不溢出的情况下）。</li>
<li><code>&gt;&gt;</code> ： 带符号右移，高位补符号位，低位丢弃。相当于除 2^n 。</li>
<li><code>&gt;&gt;&gt;</code> ： 无符号右移，忽略符号位，空位补零。</li>
</ul>
<p>由于 <code>double</code> ， <code>float</code> 在二进制中的表现比较特殊，因此<strong>不能来进行移位操作</strong>。</p>
<p>移位操作符实际上支持的类型只有 <code>int</code> 和 <code>long</code> ，编译器在对 <code>short</code> 、 <code>byte</code> 、 <code>char</code> 类型进行移位前，都会<strong>将其转换为 <code>int</code> 类型再操作</strong>。</p>
<h4 id="2-3-1-如果移位的位数超过数值所占的位数会怎么样？"><a href="#2-3-1-如果移位的位数超过数值所占的位数会怎么样？" class="headerlink" title="2.3.1 如果移位的位数超过数值所占的位数会怎么样？"></a>2.3.1 如果移位的位数超过数值所占的位数会怎么样？</h4><p>当 int 类型左移&#x2F;右移位数大于等于 32 位操作时，会<strong>先求余（%）后再进行左移&#x2F;右移操作</strong>。也就是说<strong>左移&#x2F;右移 32 位相当于不进行移位操作（32%32&#x3D;0）</strong>，左移&#x2F;右移 42 位相当于左移&#x2F;右移 10 位（42%32&#x3D;10）。当 long 类型进行左移&#x2F;右移操作时，由于 long 对应的二进制是 64 位，因此求余操作的基数也变成了 64。</p>
<p>也就是说： <code>x&lt;&lt;42</code> 等同于 <code>x&lt;&lt;10</code> ， <code>x&gt;&gt;42</code> 等同于 <code>x&gt;&gt;10</code> ， <code>x &gt;&gt;&gt;42</code> 等同于 <code>x &gt;&gt;&gt; 10</code> 。</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;初始数据：&quot;</span> + i);</span><br><span class="line">System.out.println(<span class="string">&quot;初始数据对应的二进制字符串：&quot;</span> + Integer.toBinaryString(i));</span><br><span class="line">i &lt;&lt;= <span class="number">10</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;左移 10 位后的数据 &quot;</span> + i);</span><br><span class="line">System.out.println(<span class="string">&quot;左移 10 位后的数据对应的二进制字符 &quot;</span> + Integer.toBinaryString(i));</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">初始数据：-1</span><br><span class="line">初始数据对应的二进制字符串：11111111111111111111111111111111</span><br><span class="line">左移 10 位后的数据 -1024</span><br><span class="line">左移 10 位后的数据对应的二进制字符 11111111111111111111110000000000</span><br></pre></td></tr></table></figure>

<p>由于左移位数大于等于 32 位操作时，会先求余（%）后再进行左移操作，所以下面的代码左移 42 位相当于左移 10 位（42%32&#x3D;10），输出结果和前面的代码一样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;初始数据：&quot;</span> + i);</span><br><span class="line">System.out.println(<span class="string">&quot;初始数据对应的二进制字符串：&quot;</span> + Integer.toBinaryString(i));</span><br><span class="line">i &lt;&lt;= <span class="number">42</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;左移 10 位后的数据 &quot;</span> + i);</span><br><span class="line">System.out.println(<span class="string">&quot;左移 10 位后的数据对应的二进制字符 &quot;</span> + Integer.toBinaryString(i));</span><br></pre></td></tr></table></figure>

<p>右移运算符使用类似。</p>
<h3 id="2-4-continue-、-break-和-return-的区别是什么？"><a href="#2-4-continue-、-break-和-return-的区别是什么？" class="headerlink" title="2.4 continue 、 break 和 return 的区别是什么？"></a>2.4 continue 、 break 和 return 的区别是什么？</h3><ol>
<li><code>continue</code> ：跳出当前一次的循环，继续下一次循环。</li>
<li><code>break</code> ： 跳出整个循环体。</li>
</ol>
<p><code>return</code> 用于跳出当前方法。一般用于：</p>
<ol>
<li><code>return</code> ： 直接结束方法执行，没有返回值。</li>
<li><code>return value</code> ： 返回一个特定值。</li>
</ol>
<p>思考：</p>
<p>下列语句的结果是什么？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 1 --&gt; i = 0 , f = f , sout 0</span></span><br><span class="line">            System.out.println(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            <span class="comment">// i++ sout xixi</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 2 --&gt; i = 1 , f = f , sout 1</span></span><br><span class="line">            System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            <span class="comment">// i++</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// 3 --&gt; i = 2 , f = f , sout 2</span></span><br><span class="line">            System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// i++ f = t sout xixi</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="comment">// 4 --&gt; i = 3 , f = t , sout 3</span></span><br><span class="line">            System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">            <span class="comment">//break</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">4</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;xixi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        <span class="comment">// 5 --&gt; sout haha</span></span><br><span class="line">        System.out.println(<span class="string">&quot;haha&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;heihei&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">xixi</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">xixi</span><br><span class="line">3</span><br><span class="line">haha</span><br></pre></td></tr></table></figure>

<h2 id="3-基本数据类型"><a href="#3-基本数据类型" class="headerlink" title="3. 基本数据类型"></a>3. 基本数据类型</h2><h3 id="3-1-Java-中的几种基本数据类型？"><a href="#3-1-Java-中的几种基本数据类型？" class="headerlink" title="3.1 Java 中的几种基本数据类型？"></a>3.1 Java 中的几种基本数据类型？</h3><ul>
<li>6 种数字类型<ul>
<li>4 种整数型： <code>byte</code> , <code>short</code> , <code>int</code> , <code>long</code></li>
<li>2 种浮点型： <code>float</code> , <code>double</code></li>
</ul>
</li>
<li>1 种字符型： <code>char</code></li>
<li>1 种布尔型： <code>boolean</code></li>
</ul>
<p>基本数据类型的默认值和所占空间：</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>位数</th>
<th>字节</th>
<th>默认值</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td><code>byte</code></td>
<td>8</td>
<td>1</td>
<td>0</td>
<td>-128 ~ 127</td>
</tr>
<tr>
<td><code>short</code></td>
<td>16</td>
<td>2</td>
<td>0</td>
<td>-2 ^ 15 ~ 2 ^ 15 - 1</td>
</tr>
<tr>
<td><code>int</code></td>
<td>32</td>
<td>4</td>
<td>0</td>
<td>-2 ^ 31 ~ 2 ^ 31 - 1</td>
</tr>
<tr>
<td><code>long</code></td>
<td>64</td>
<td>8</td>
<td>0L</td>
<td>-2 ^ 63 ~ 2 ^ 63 - 1</td>
</tr>
<tr>
<td><code>char</code></td>
<td>16</td>
<td>2</td>
<td>‘u0000’</td>
<td>0 ~ 2 ^ 16 - 1</td>
</tr>
<tr>
<td><code>float</code></td>
<td>32</td>
<td>4</td>
<td>0f</td>
<td>1.4 E -45 ~ 3.4028235 E 38</td>
</tr>
<tr>
<td><code>double</code></td>
<td>64</td>
<td>8</td>
<td>0d</td>
<td>4.9 E -324 ~ 1.7976931348623157 E 308</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td>1</td>
<td></td>
<td>false</td>
<td>true , false</td>
</tr>
</tbody></table>
<p>对于 <code>boolean</code> ，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。逻辑上理解是占用 1 位，但是实际中会考虑计算机高效存储因素。</p>
<p>Java 的每种基本类型所占存储空间的大小<strong>不会像其他大多数语言那样随机器硬件架构的变化而变化</strong>。这种所占存储空间大小的不变性是 Java 程序比用其他大多数语言编写的程序更具可移植性的原因之一。</p>
<p>注意：</p>
<ol>
<li>Java 里使用 <code>long</code> 类型的数据一定要加上 <strong>L</strong> ， 否则将作为整形解析。</li>
<li>Java 里使用 <code>float</code> 类型一定要加上 <strong>f 或 F</strong> ， 否则无法通过编译。</li>
<li><code>char = h</code> char 单引号 <code>String a = &quot;hello&quot;</code> String 双引号。</li>
</ol>
<p>这八种基本类型都有对应的包装类分别为： <code>Byte</code> 、 <code>Short</code> 、 <code>Integer</code> 、 <code>Long</code> 、 <code>Float</code> 、 <code>Double</code> 、 <code>Character</code> 、 <code>Boolean</code> 。</p>
<h3 id="3-2-基本类型和包装类型的区别？"><a href="#3-2-基本类型和包装类型的区别？" class="headerlink" title="3.2 基本类型和包装类型的区别？"></a>3.2 基本类型和包装类型的区别？</h3><ul>
<li><strong>用途</strong> ： 除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。并且，<strong>包装类型可用于泛型，而基本类型不可以</strong>。</li>
<li><strong>存储方式</strong> ： 基本数据类型的局部变量存放在 <strong>Java 虚拟机栈中的局部变量表</strong>中，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 <strong>Java 虚拟机的堆</strong>中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于<strong>堆</strong>中。</li>
<li><strong>占用空间</strong> ： 相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。</li>
<li><strong>默认值</strong> ： 成员变量包装类型不赋值就是 null ，而基本类型有默认值且不是 null。</li>
<li><strong>比较方式</strong> ： 对于基本数据类型来说，<code>==</code> 比较的是值。对于包装数据类型来说，<code>==</code> 比较的是<strong>对象的内存地址</strong>。所有整型包装类对象之间值的比较，<strong>全部使用 <code>equals()</code> 方法</strong>。</li>
</ul>
<p><strong>为什么说是几乎所有对象实例都存在于堆中呢？</strong></p>
<p>这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存</p>
<p><strong>注意：</strong></p>
<p>基本数据类型存放在栈中是一个常见的误区！ 基本数据类型的存储位置取决于它们的<strong>作用和声明方式</strong>。如果它们是<strong>局部变量</strong>，那么它们会存放在<strong>栈</strong>中；如果它们是<strong>成员变量</strong>，那么们会存放在<strong>堆&#x2F;方法区&#x2F;元空间</strong>中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="comment">// 成员变量，存放在堆中</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 被 static 修饰的成员变量，JDK 1.7 及之前位于方法区，1.8 后存放于元空间，均不存放于堆中。</span></span><br><span class="line">    <span class="comment">// 变量属于类，不属于对象。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 局部变量，存放在栈中</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">40</span>; <span class="comment">// 编译错误，不能在方法中使用 static 修饰局部变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-包装类型的缓存机制"><a href="#3-3-包装类型的缓存机制" class="headerlink" title="3.3 包装类型的缓存机制"></a>3.3 包装类型的缓存机制</h3><p><code>Byte</code> , <code>Short</code> , <code>Integer</code> , <code>Long</code> 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据， <code>Character</code> 创建了数值在 [0,127] 范围的缓存数据， <code>Boolean</code> 直接返回 <code>True</code> or <code>False</code> 。</p>
<p>Integer 缓存源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntegerCache</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Character 缓存源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Character <span class="title function_">valueOf</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c &lt;= <span class="number">127</span>) &#123; <span class="comment">// must cache</span></span><br><span class="line">      <span class="keyword">return</span> CharacterCache.cache[(<span class="type">int</span>)c];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Character</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CharacterCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">CharacterCache</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Character cache[] = <span class="keyword">new</span> <span class="title class_">Character</span>[<span class="number">127</span> + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cache.length; i++)</span><br><span class="line">            cache[i] = <span class="keyword">new</span> <span class="title class_">Character</span>((<span class="type">char</span>)i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Boolean 缓存源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title function_">valueOf</span><span class="params">(<span class="type">boolean</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (b ? TRUE : FALSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是<strong>在性能和资源之间的权衡</strong>。</p>
<p>两种浮点数类型的包装类<strong>没有实现缓存机制</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">33</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">33</span>;</span><br><span class="line">System.out.println(i1 == i2);<span class="comment">// 输出 true</span></span><br><span class="line"></span><br><span class="line"><span class="type">Float</span> <span class="variable">i11</span> <span class="operator">=</span> <span class="number">333f</span>;</span><br><span class="line"><span class="type">Float</span> <span class="variable">i22</span> <span class="operator">=</span> <span class="number">333f</span>;</span><br><span class="line">System.out.println(i11 == i22);<span class="comment">// 输出 false</span></span><br><span class="line"></span><br><span class="line"><span class="type">Double</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">1.2</span>;</span><br><span class="line"><span class="type">Double</span> <span class="variable">i4</span> <span class="operator">=</span> <span class="number">1.2</span>;</span><br><span class="line">System.out.println(i3 == i4);<span class="comment">// 输出 false</span></span><br></pre></td></tr></table></figure>

<p>问题：下面的代码的输出结果是 true 还是 false ？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">40</span>);</span><br><span class="line">System.out.println(i1==i2);</span><br></pre></td></tr></table></figure>

<p><code>Integer i1=40</code> 这一行代码会发生装箱，也就是说这行代码等价于 <code>Integer i1=Integer.valueOf(40)</code> 。因此， <code>i1</code> 直接使用的是缓存中的对象。而 <code>Integer i2 = new Integer(40)</code> 会直接创建新的对象。</p>
<p>因此，答案是 <code>false</code> 。</p>
<p><strong>所有整型包装类对象之间值的比较，全部使用 equals 方法比较。</strong></p>
<h3 id="3-4-自动装箱与自动拆箱？原理？"><a href="#3-4-自动装箱与自动拆箱？原理？" class="headerlink" title="3.4 自动装箱与自动拆箱？原理？"></a>3.4 自动装箱与自动拆箱？原理？</h3><p>自动拆装箱？</p>
<ul>
<li><strong>装箱</strong> ： 将基本类型用对应的引用类型包装起来。</li>
<li><strong>拆箱</strong> ： 将包装类型转换为基本数据类型。</li>
</ul>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;  <span class="comment">//装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i;   <span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure>

<p>字节码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">L1</span><br><span class="line"></span><br><span class="line"> LINENUMBER 8 L1</span><br><span class="line"></span><br><span class="line"> ALOAD 0</span><br><span class="line"></span><br><span class="line"> BIPUSH 10</span><br><span class="line"></span><br><span class="line"> INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;</span><br><span class="line"></span><br><span class="line"> PUTFIELD AutoBoxTest.i : Ljava/lang/Integer;</span><br><span class="line"></span><br><span class="line">L2</span><br><span class="line"></span><br><span class="line"> LINENUMBER 9 L2</span><br><span class="line"></span><br><span class="line"> ALOAD 0</span><br><span class="line"></span><br><span class="line"> ALOAD 0</span><br><span class="line"></span><br><span class="line"> GETFIELD AutoBoxTest.i : Ljava/lang/Integer;</span><br><span class="line"></span><br><span class="line"> INVOKEVIRTUAL java/lang/Integer.intValue ()I</span><br><span class="line"></span><br><span class="line"> PUTFIELD AutoBoxTest.n : I</span><br><span class="line"></span><br><span class="line"> RETURN</span><br></pre></td></tr></table></figure>

<p>从字节码中，可以发现装箱其实就是调用了包装类的 <code>valueOf()</code> 方法，拆箱其实就是调用了 <code>xxxValue()</code> 方法。</p>
<p>因此，</p>
<ul>
<li><code>Integer i = 10</code> 等价于 <code>Integer i = Integer.valueOf(10)</code></li>
<li><code>int n = i</code> 等价于 <code>int n = i.intValue()</code></li>
</ul>
<p>注意： <strong>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">sum</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 应该使用 long 而不是 Long</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= Integer.MAX_VALUE; i++)</span><br><span class="line">        sum += i;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-5-为什么浮点数运算会有精度丢失？"><a href="#3-5-为什么浮点数运算会有精度丢失？" class="headerlink" title="3.5 为什么浮点数运算会有精度丢失？"></a>3.5 为什么浮点数运算会有精度丢失？</h3><p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2.0f</span> - <span class="number">1.9f</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1.8f</span> - <span class="number">1.7f</span>;</span><br><span class="line">System.out.printf(<span class="string">&quot;%.9f&quot;</span>,a);<span class="comment">// 0.100000024</span></span><br><span class="line">System.out.println(b);<span class="comment">// 0.099999905</span></span><br><span class="line">System.out.println(a == b);<span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>精度丢失和计算机保存浮点数的机制有很大关系。计算机是二进制的，且计算机在保存一个数字时，宽度是有限的，无限循环的小数存储时只能被截断，所以会出现小数精度丢失的情况。</p>
<p>比如：<br>十进制下的 0.2 就没办法精确转化为二进制小数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0.2 转换为二进制数的过程为，不断乘以 2，直到不存在小数为止，</span></span><br><span class="line"><span class="comment">// 在这个计算过程中，得到的整数部分从上到下排列就是二进制的结果。</span></span><br><span class="line"><span class="number">0.2</span> * <span class="number">2</span> = <span class="number">0.4</span> -&gt; <span class="number">0</span></span><br><span class="line"><span class="number">0.4</span> * <span class="number">2</span> = <span class="number">0.8</span> -&gt; <span class="number">0</span></span><br><span class="line"><span class="number">0.8</span> * <span class="number">2</span> = <span class="number">1.6</span> -&gt; <span class="number">1</span></span><br><span class="line"><span class="number">0.6</span> * <span class="number">2</span> = <span class="number">1.2</span> -&gt; <span class="number">1</span></span><br><span class="line"><span class="number">0.2</span> * <span class="number">2</span> = <span class="number">0.4</span> -&gt; <span class="number">0</span>（发生循环）</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>关于浮点数，具体看 <a target="_blank" rel="noopener" href="http://kaito-kidd.com/2018/08/08/computer-system-float-point/">计算机系统基础</a> 这篇博客。</p>
<h3 id="3-6-如何解决浮点数运算精度丢失？"><a href="#3-6-如何解决浮点数运算精度丢失？" class="headerlink" title="3.6 如何解决浮点数运算精度丢失？"></a>3.6 如何解决浮点数运算精度丢失？</h3><p><code>BigDecimal</code> 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算的场景都是通过 <code>BigDecimal</code> 实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.00&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// BigDecimal 的 subtract 方法用于执行精确的减法运算。</span></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">x</span> <span class="operator">=</span> a.subtract(c);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">y</span> <span class="operator">=</span> b.subtract(c);</span><br><span class="line"></span><br><span class="line">System.out.println(x); <span class="comment">/* 0.2 */</span></span><br><span class="line">System.out.println(y); <span class="comment">/* 0.20 */</span></span><br><span class="line"><span class="comment">// 比较内容，不是比较值</span></span><br><span class="line">System.out.println(Objects.equals(x, y)); <span class="comment">/* false */</span></span><br><span class="line"><span class="comment">// 比较值相等用相等compareTo，相等返回0</span></span><br><span class="line">System.out.println(<span class="number">0</span> == x.compareTo(y)); <span class="comment">/* true */</span></span><br></pre></td></tr></table></figure>

<p><code>BigDecimal</code> 的详细介绍在 <a href="%E5%85%B6%E4%BB%96%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9.md">重要知识点</a> 里。</p>
<h3 id="3-7-超过-long-整型的数据如何表示？"><a href="#3-7-超过-long-整型的数据如何表示？" class="headerlink" title="3.7 超过 long 整型的数据如何表示？"></a>3.7 超过 <code>long</code> 整型的数据如何表示？</h3><p>在 Java 中，64 位 long 整型是最大的整数类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> Long.MAX_VALUE;</span><br><span class="line">System.out.println(l + <span class="number">1</span>); <span class="comment">// -9223372036854775808</span></span><br><span class="line">System.out.println(l + <span class="number">1</span> == Long.MIN_VALUE); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>BigInteger 内部使用 int[] 数组来存储任意大小的整形数据。</p>
<p>注意：</p>
<p>相对于常规整数类型的运算来说，BigInteger 运算的效率会相对较低。</p>
<h2 id="4-变量"><a href="#4-变量" class="headerlink" title="4. 变量"></a>4. 变量</h2><h3 id="4-1-成员变量与局部变量的区别？"><a href="#4-1-成员变量与局部变量的区别？" class="headerlink" title="4.1 成员变量与局部变量的区别？"></a>4.1 成员变量与局部变量的区别？</h3><ul>
<li><p><strong>语法形式</strong> ： 成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或参数；成员变量可以被 <code>public</code> , <code>private</code> , <code>static</code> 等修饰符修饰，而局部变量不能被访问控制修饰符及 <code>static</code> 修饰；但是成员变量和局部变量都能被 <code>final</code> 修饰。</p>
</li>
<li><p><strong>存储方式</strong> ： 如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有，这个成员变量是属于实例的。对象存储在堆内存，局部变量存储在栈内存。</p>
</li>
<li><p><strong>生存时间</strong> ： 成员变量是对象的一部分，随着对象的创建而存在，局部变量随方法的调用而自动生成，随方法的调用结束而消亡。</p>
</li>
<li><p><strong>默认值</strong> ： 成员变量如果没有被赋初值，则会自动以类型的默认值赋值（ 例外：被 <code>fianl</code> 修饰必须显式赋值 ），而局部变量不会自动赋值。</p>
</li>
</ul>
<h4 id="4-1-1-为什么成员变量有默认值？"><a href="#4-1-1-为什么成员变量有默认值？" class="headerlink" title="4.1.1 为什么成员变量有默认值？"></a>4.1.1 为什么成员变量有默认值？</h4><ol>
<li><p>如果没有默认值？ –&gt; 变量存储的是内存地址对应的任意随机值，程序读取该值运行会出现意外。</p>
</li>
<li><p>默认值有两种设置方式：手动和自动，根据第一点，没有手动赋值一定要自动赋值。成员变量在运行时可借助反射等方法手动赋值，而局部变量不行。</p>
</li>
<li><p>对于编译器（ javac ）来说，局部变量没赋值很好判断，可以直接报错。而成员变量可能是运行时赋值，无法判断，误报“没默认值”又会影响用户体验，所以采用自动赋默认值。</p>
</li>
</ol>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VariableExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员变量</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法中的局部变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 栈中分配的局部变量</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello, world!&quot;</span>; <span class="comment">// 栈中分配的局部变量</span></span><br><span class="line">        System.out.println(num1);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带参数的方法中的局部变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(<span class="type">int</span> num2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> num2 + <span class="number">10</span>; <span class="comment">// 栈中分配的局部变量</span></span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法中的局部变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">VariableExample</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name; <span class="comment">// 对成员变量进行赋值</span></span><br><span class="line">        <span class="built_in">this</span>.age = age; <span class="comment">// 对成员变量进行赋值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num3</span> <span class="operator">=</span> <span class="number">20</span>; <span class="comment">// 栈中分配的局部变量</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;Hello, &quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot;!&quot;</span>; <span class="comment">// 栈中分配的局部变量</span></span><br><span class="line">        System.out.println(num3);</span><br><span class="line">        System.out.println(str2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-静态变量有什么用？"><a href="#4-2-静态变量有什么用？" class="headerlink" title="4.2 静态变量有什么用？"></a>4.2 静态变量有什么用？</h3><p>静态变量也就是被 static 关键字修饰的变量。它可以被类的所有实例共享，无论一个类创建了多少个对象，它们都共享同一份静态变量。静态变量只会被分配一次内存，即使创建多个对象，这样可以节省内存。</p>
<p>通常情况下，静态变量会被 <code>final</code> 关键字<strong>修饰成为常量</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConstantVariableExample</span> &#123;</span><br><span class="line">    <span class="comment">// 常量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">constantVar</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-字符型常量和字符串型常量的区别？"><a href="#4-3-字符型常量和字符串型常量的区别？" class="headerlink" title="4.3 字符型常量和字符串型常量的区别？"></a>4.3 字符型常量和字符串型常量的区别？</h3><ul>
<li><p><strong>形式</strong> ： 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符。</p>
</li>
<li><p><strong>含义</strong> ： 字符常量相当于<strong>一个整型值 ( ASCII 值)</strong> ,可以参加表达式运算; 字符串常量代表<strong>一个地址值</strong> ( 该字符串在内存中存放位置 ) 。</p>
</li>
<li><p><strong>占内存大小</strong> ： 字符常量只占 2 个字节; 字符串常量占若干个字节。</p>
</li>
</ul>
<p>注意： <code>char</code> 在 Java 中占<strong>两个字节</strong>。</p>
<h2 id="5-方法"><a href="#5-方法" class="headerlink" title="5. 方法"></a>5. 方法</h2><h3 id="5-1-什么是方法的返回值？-方法有哪几种类型？"><a href="#5-1-什么是方法的返回值？-方法有哪几种类型？" class="headerlink" title="5.1 什么是方法的返回值？ 方法有哪几种类型？"></a>5.1 什么是方法的返回值？ 方法有哪几种类型？</h3><p><strong>方法的返回值</strong> 是指获取到的某个方法体执行后产生的结果。</p>
<p>可以按照方法的返回值和参数类型分类：</p>
<ol>
<li><p>无参数无返回值方法</p>
</li>
<li><p>有参数无返回值的方法</p>
</li>
<li><p>有返回值无参数的方法</p>
</li>
<li><p>有返回值有参数的方法</p>
</li>
</ol>
<h3 id="5-2-静态方法为什么不能调用非静态成员？"><a href="#5-2-静态方法为什么不能调用非静态成员？" class="headerlink" title="5.2 静态方法为什么不能调用非静态成员？"></a>5.2 静态方法为什么不能调用非静态成员？</h3><p>需要结合 JVM 的相关知识，主要原因如下：</p>
<ol>
<li><p>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</p>
</li>
<li><p>在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</p>
</li>
</ol>
<h3 id="5-3-静态方法和实例方法有何不同？"><a href="#5-3-静态方法和实例方法有何不同？" class="headerlink" title="5.3 静态方法和实例方法有何不同？"></a>5.3 静态方法和实例方法有何不同？</h3><ol>
<li><p><strong>调用方式</strong> ：<br>在外部调用静态方法时，可以使用 <code>类名.方法名</code> 的方式，也可以使用 <code>对象.方法名</code> 的方式，而实例方法只有后面这种方式。也就是说，<strong>调用静态方法可以无需创建对象</strong>。<br>不过，需要注意的是一般<strong>不建议使用 <code>对象.方法名</code> 的方式来调用静态方法</strong>。这种方式非常容易造成混淆，静态方法不属于类的某个对象而是属于这个类。<br>因此，一般建议使用 <code>类名.方法名</code> 的方式来调用静态方法。</p>
</li>
<li><p><strong>访问类成员是否存在限制</strong> ：<br>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。</p>
</li>
</ol>
<h3 id="5-4-重载和重写有什么区别？"><a href="#5-4-重载和重写有什么区别？" class="headerlink" title="5.4 重载和重写有什么区别？"></a>5.4 重载和重写有什么区别？</h3><blockquote>
<p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理<br>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，就要覆盖父类方法</p>
</blockquote>
<h4 id="5-4-1-重载"><a href="#5-4-1-重载" class="headerlink" title="5.4.1 重载"></a>5.4.1 重载</h4><p>发生在同一个类中（或者父类和子类之间），方法名<strong>必须相同</strong>，<strong>参数类型不同、个数不同、顺序不同</strong>，方法返回值和访问修饰符<strong>可以不同</strong>。</p>
<p>综上：重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</p>
<h4 id="5-4-2-重写"><a href="#5-4-2-重写" class="headerlink" title="5.4.2 重写"></a>5.4.2 重写</h4><p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p>
<ol>
<li><p><strong>方法名、参数列表必须相同</strong>，子类方法返回值类型应比父类方法返回值类型<strong>更小或相等</strong>，抛出的异常范围<strong>小于等于父类</strong>，访问修饰符范围<strong>大于等于父类</strong>。</p>
</li>
<li><p>如果父类方法访问修饰符为 <code>private</code> &#x2F; <code>final</code> &#x2F; <code>static</code> 则子类就不能重写该方法，但是被 <code>static</code> 修饰的方法能够被再次声明。</p>
</li>
<li><p>构造方法无法被重写</p>
</li>
</ol>
<h4 id="5-4-3-总结"><a href="#5-4-3-总结" class="headerlink" title="5.4.3 总结"></a>5.4.3 总结</h4><p>综上：<strong>重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。</strong></p>
<table>
<thead>
<tr>
<th>区别点</th>
<th>重载</th>
<th>重写</th>
</tr>
</thead>
<tbody><tr>
<td>发生范围</td>
<td>同一个类</td>
<td>子类</td>
</tr>
<tr>
<td>参数列表</td>
<td>必须修改</td>
<td>一定不能改</td>
</tr>
<tr>
<td>返回类型</td>
<td>可修改</td>
<td>比父类方法返回值类型更小或相等</td>
</tr>
<tr>
<td>异常</td>
<td>可修改</td>
<td>比父类方法声明抛出的异常类更小或相等</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>可修改</td>
<td>一定不能做更严格的限制（可以降低限制）</td>
</tr>
<tr>
<td>发生阶段</td>
<td>编译期</td>
<td>运行期</td>
</tr>
</tbody></table>
<p>补充： 如果方法的返回类型是 <strong><code>void</code> 和基本数据类型</strong>，则返回值重写时<strong>不可修改</strong>。但是如果方法的返回值是<strong>引用类型</strong>，重写时是<strong>可以返回该引用类型的子类</strong>的。</p>
<h3 id="5-5-什么是可变长参数？"><a href="#5-5-什么是可变长参数？" class="headerlink" title="5.5 什么是可变长参数？"></a>5.5 什么是可变长参数？</h3><p>从 Java5 开始，Java 支持定义可变长参数，可变长参数就是允许在调用方法时传入不定长度的参数。就比如下面这个方法就可以接受 0 个或者多个参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(String... args)</span> &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>可变参数<strong>只能作为函数的最后一个参数</strong>，但其前面可以有也<strong>可以没有任何其他参数</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(String arg1, String... args)</span> &#123; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-5-1-遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？"><a href="#5-5-1-遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？" class="headerlink" title="5.5.1 遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？"></a>5.5.1 遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？</h4><p>会优先匹配固定参数的方法，因为固定参数的方法匹配度更高。</p>
<p>Java 的可变参数编译后实际会被转换成一个数组，看编译后生成的 class 文件就可以看出来了。</p>
<p>下一篇：<br><a href="JavaSE%20pt.2.md">JavaSE pt.2</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-03-10T13:55:29.000Z" title="2025/3/10 21:55:29">2025-03-10</time>发表</span><span class="level-item"><time dateTime="2025-03-10T13:57:06.541Z" title="2025/3/10 21:57:06">2025-03-10</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%85%AB%E8%82%A1/">八股</a><span> / </span><a class="link-muted" href="/categories/%E5%85%AB%E8%82%A1/JavaSE/">JavaSE</a></span><span class="level-item">几秒读完 (大约0个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/03/10/%E5%85%AB%E8%82%A1/Java%E5%9F%BA%E7%A1%80/JavaSE%20pt.3/">JavaSE pt.3</a></p><div class="content"></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-03-10T13:55:29.000Z" title="2025/3/10 21:55:29">2025-03-10</time>发表</span><span class="level-item"><time dateTime="2025-03-10T13:57:12.631Z" title="2025/3/10 21:57:12">2025-03-10</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%85%AB%E8%82%A1/">八股</a><span> / </span><a class="link-muted" href="/categories/%E5%85%AB%E8%82%A1/JavaSE/">JavaSE</a></span><span class="level-item">几秒读完 (大约0个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/03/10/%E5%85%AB%E8%82%A1/Java%E5%9F%BA%E7%A1%80/JavaSE%20pt.2/">JavaSE pt.2</a></p><div class="content"></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-03-10T13:55:29.000Z" title="2025/3/10 21:55:29">2025-03-10</time>发表</span><span class="level-item"><time dateTime="2025-03-10T13:57:40.689Z" title="2025/3/10 21:57:40">2025-03-10</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%85%AB%E8%82%A1/">八股</a><span> / </span><a class="link-muted" href="/categories/%E5%85%AB%E8%82%A1/JavaSE/">JavaSE</a></span><span class="level-item">几秒读完 (大约0个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/03/10/%E5%85%AB%E8%82%A1/Java%E5%9F%BA%E7%A1%80/%E5%85%B6%E4%BB%96%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/">重要知识点</a></p><div class="content"></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-02-13T05:54:56.000Z" title="2025/2/13 13:54:56">2025-02-13</time>发表</span><span class="level-item"><time dateTime="2025-02-12T06:05:54.427Z" title="2025/2/12 14:05:54">2025-02-12</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/Java/basics/">basics</a><span> / </span><a class="link-muted" href="/categories/Java/basics/Thinking-in-Java/">Thinking in Java</a></span><span class="level-item">37 分钟读完 (大约5497个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/02/13/Thinking-in-Java/Thinking-in-Java-pt-5/">Thinking in Java pt.5</a></p><div class="content"><h2 id="Chapter-5-Initialization-Cleanup"><a href="#Chapter-5-Initialization-Cleanup" class="headerlink" title="Chapter 5 Initialization &amp; Cleanup"></a>Chapter 5 Initialization &amp; Cleanup</h2><p><strong><u>As the computer revolution progresses, “unsafe” programming has become one of the major culprits that makes programming expensive.</u></strong> </p>
<p>Two of these safety issues are <em><u>initialization</u></em> and <em><u>cleanup</u></em>. Many C bugs occur when the programmer forgets to initialize a variable. This is especially true with libraries when users don’t know how to initialize a library component, or even that they must. Cleanup is a special problem because it’s easy to forget about an element when you’re done with it, since it no longer concerns you. Thus, the resources used by that element are retained and you can easily end up running out of resources (most notably, memory). </p>
<p>C++ introduced the concept of a <strong>constructor</strong>, a special method automatically called when an object is created. Java also adopted the constructor, and in addition has a <strong>garbage collector</strong> that automatically releases memory resources when they’re no longer being used. This chapter examines the issues of initialization and cleanup, and their support in Java. </p>
<hr>

<h3 id="5-1-Guaranteed-initialization-with-the-constructor"><a href="#5-1-Guaranteed-initialization-with-the-constructor" class="headerlink" title="5.1 Guaranteed initialization with the constructor"></a>5.1 Guaranteed initialization with the constructor</h3><p>pass</p>
<hr>

<h3 id="5-2-Method-overloading"><a href="#5-2-Method-overloading" class="headerlink" title="5.2 Method overloading"></a>5.2 Method overloading</h3><p>pass</p>
<hr>

<h3 id="5-3-Default-constructors"><a href="#5-3-Default-constructors" class="headerlink" title="5.3 Default constructors"></a>5.3 Default constructors</h3><p>pass</p>
<hr>

<h3 id="5-4-The-this-keyword"><a href="#5-4-The-this-keyword" class="headerlink" title="5.4 The this keyword"></a>5.4 The <em><u>this</u></em> keyword</h3><p>pass</p>
<hr>

<h4 id="5-4-1-Calling-constructors-from-constructors"><a href="#5-4-1-Calling-constructors-from-constructors" class="headerlink" title="5.4.1 Calling constructors from constructors"></a>5.4.1 Calling constructors from constructors</h4><p>When you write several constructors for a class, there are times when you’d like to call one constructor from another to avoid duplicating code. You can make such a call by using the <strong>this</strong> keyword. </p>
<p>Normally, when you say <strong>this</strong>, it is in the sense of “this object” or “the current object,” and by itself it produces the reference to the current object. In a constructor, the <strong>this</strong> keyword takes on a different meaning when you give it an argument list. It makes an explicit call to the constructor that matches that argument list. Thus you have a straightforward way to call other constructors: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//: initialization/Flower.java</span></span><br><span class="line"><span class="comment">// Calling constructors with &quot;this&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> net.mindview.util.Print.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Flower</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">petalCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;initial value&quot;</span>;</span><br><span class="line">    Flower(<span class="type">int</span> petals) &#123;</span><br><span class="line">        petalCount = petals;</span><br><span class="line">        print(<span class="string">&quot;Constructor w/ int arg only, petalCount= &quot;</span></span><br><span class="line">              + petalCount);</span><br><span class="line">    &#125;</span><br><span class="line">    Flower(String ss) &#123;</span><br><span class="line">        print(<span class="string">&quot;Constructor w/ String arg only, s = &quot;</span> + ss);</span><br><span class="line">        s = ss;</span><br><span class="line">    &#125;</span><br><span class="line">    Flower(String s, <span class="type">int</span> petals) &#123;</span><br><span class="line">        <span class="built_in">this</span>(petals);</span><br><span class="line">        <span class="comment">//! this(s); // Can’t call two!</span></span><br><span class="line">        <span class="built_in">this</span>.s = s; <span class="comment">// Another use of &quot;this&quot;</span></span><br><span class="line">        print(<span class="string">&quot;String &amp; int args&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Flower() &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;hi&quot;</span>, <span class="number">47</span>);</span><br><span class="line">        print(<span class="string">&quot;default constructor (no args)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">printPetalCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//! this(11); // Not inside non-constructor!</span></span><br><span class="line">        print(<span class="string">&quot;petalCount = &quot;</span> + petalCount + <span class="string">&quot; s = &quot;</span>+ s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Flower</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Flower</span>();</span><br><span class="line">        x.printPetalCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Constructor w/ int arg only, petalCount= 47</span></span><br><span class="line"><span class="comment">String &amp; int args</span></span><br><span class="line"><span class="comment">default constructor (no args)</span></span><br><span class="line"><span class="comment">petalCount = 47 s = hi</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~ </span></span><br></pre></td></tr></table></figure>

<p>The constructor <strong>Flower(String s, int petals)</strong> shows that, while you can call one constructor using <strong>this</strong>, you cannot call two. In addition, the constructor call must be the first thing you do, or you’ll get a compiler error message. </p>
<p>This example also shows another way you’ll see <strong>this</strong> used. Since the name of the argument s and the name of the member data s are the same, there’s an ambiguity. You can resolve it using <strong>this.s</strong>, to say that you’re referring to the member data. You’ll often see this form used in Java code, and it’s used in numerous places in this book. </p>
<p>In <strong>printPetalCount( )</strong> you can see that the compiler won’t let you call a constructor from inside any method other than a constructor. </p>
<hr>

<h4 id="5-4-2-The-meaning-of-static"><a href="#5-4-2-The-meaning-of-static" class="headerlink" title="5.4.2 The meaning of static"></a>5.4.2 The meaning of static</h4><p>With the <strong>this</strong> keyword in mind, you can more fully understand what it means to make a method <strong>static</strong>. It means that <strong>there is no this for that particular method</strong>. <strong><u>You cannot call non-static methods from inside static methods</u></strong>[^1] (although the reverse is possible), and you can call a static method for the class itself, without any object. In fact, that’s primarily what a static method is for. It’s as if you’re creating the equivalent of a global method. However, global methods are not permitted in Java, and putting the static method inside a class allows it access to other static methods and to static fields. </p>
<p>[^1]: The one case in which this is possible occurs if you pass a reference to an object into the static method (the static method could also create its own object). Then, via the reference (which is now effectively this), you can call non-static methods and access non-static fields. But typically, if you want to do something like this, you’ll just make an ordinary, non-static method.</p>
<hr>

<h3 id="5-5-Cleanup-finalization-and-garbage-collection"><a href="#5-5-Cleanup-finalization-and-garbage-collection" class="headerlink" title="5.5 Cleanup: finalization and garbage collection"></a>5.5 Cleanup: finalization and garbage collection</h3><p>Programmers know about the importance of initialization, but often forget the importance of cleanup. After all, who needs to clean up an int? But with libraries, simply “letting go” of an object once you’re done with it is not always safe. Of course, Java has the garbage collector to reclaim the memory of objects that are no longer used. <strong>Now consider an unusual case: Suppose your object allocates “special” memory without using new. <u>The garbage collector only knows how to release memory allocated with new</u>, so it won’t know how to release the object’s “special” memory.</strong> To handle this case, Java provides a method called <strong>finalize( )</strong> that you can define for your class. Here’s how it’s supposed to work. When the garbage collector is ready to release the storage used for your object, it will first call finalize( ), and only on the next garbage-collection pass will it reclaim the object’s memory. <strong>So if you choose to use finalize( ), it gives you the ability to perform some important cleanup at the time of garbage collection.</strong> </p>
<p>In C++, objects always get destroyed (in a bug-free program), whereas in Java, objects do not always get garbage collected. Or, put another way: </p>
<ol>
<li><em>Your objects might not get garbage collected.</em> </li>
<li><em>Garbage collection is not destruction.</em></li>
</ol>
<p>You might find that the storage for an object never gets released because your program never nears the point of running out of storage. If your program completes and the garbage collector never gets around to releasing the storage for any of your objects, that storage will be returned to the operating system <em>en masse</em> as the program exits. This is a good thing, because garbage collection has some overhead, and if you never do it, you never incur that expense. </p>
<hr>

<h4 id="5-5-1-What-is-finalize-for"><a href="#5-5-1-What-is-finalize-for" class="headerlink" title="5.5.1 What is finalize() for?"></a>5.5.1 What is finalize() for?</h4><p>A third point to remember is: </p>
<ol start="3">
<li><em>Garbage collection is only about memory.</em></li>
</ol>
<p>That is, the sole reason for the existence of the garbage collector is to recover memory that your program is no longer using. So any activity that is associated with garbage collection, most notably your <strong>finalize( )</strong> method, must also be only about memory and its deallocation. </p>
<p>It would seem that <strong>finalize( )</strong> is in place because of the possibility that you’ll do something Clike by allocating memory using a mechanism other than the normal one in Java. <strong>This can happen primarily through native methods, which are a way to call non-Java code from Java</strong>. (<em>Native methods</em> are covered in Appendix B in the electronic 2nd edition of this book, available at <em><a target="_blank" rel="noopener" href="http://www.mindview.net/">www.MindView.net</a></em>.) C and C++ are the only languages currently supported by native methods, but since they can call subprograms in other languages, you can effectively call anything. Inside the non-Java code, C’s <strong>malloc( )</strong> family of functions might be called to allocate storage, and unless you call free( ), that storage will not be released, causing a memory leak. Of course, <strong>free( )</strong> is a C and C++ function, so you’d need to call it in a <em>native method</em> inside your <strong>finalize( )</strong>. </p>
<p>After reading this, you probably get the idea that <strong>you won’t use finalize( ) much</strong>.[^2] You’re correct; it is not the appropriate place for normal cleanup to occur. So where should normal cleanup be performed? </p>
<p>[^2]:Joshua Bloch goes further in his section titled “avoid finalizers”: “Finalizers are unpredictable, often dangerous, and generally unnecessary.” Effective JavaTM Programming Language Guide, p. 20 (Addison-Wesley, 2001).</p>
<hr>

<h4 id="5-5-2-You-must-perform-cleanup"><a href="#5-5-2-You-must-perform-cleanup" class="headerlink" title="5.5.2 You must perform cleanup"></a>5.5.2 You must perform cleanup</h4><p>To clean up an object, the user of that object must call a cleanup method at the point the cleanup is desired. This sounds pretty straightforward, but it collides a bit with the C++ concept of the destructor. In C++, all objects are destroyed. Or rather, all objects should be destroyed. If the C++ object is created as a local (i.e., on the stack—not possible in Java), then the destruction happens at the closing curly brace of the scope in which the object was created. If the object was created using <strong>new</strong> (like in Java), the destructor is called when the programmer calls the C++ operator <strong>delete</strong> (which doesn’t exist in Java). If the C++ programmer forgets to call <strong>delete</strong>, the destructor is never called, and you have a memory leak, plus the other parts of the object never get cleaned up. This kind of bug can be very difficult to track down, and is one of the compelling reasons to move from C++ to Java. </p>
<p>In contrast, Java doesn’t allow you to create local objects—you must always use <strong>new</strong>. But in Java, there’s no “delete” for releasing the object, because the garbage collector releases the storage for you. So from a simplistic standpoint, you could say that because of garbage collection, Java has no destructor. You’ll see as this book progresses, however, that the presence of a garbage collector does not remove the need for or the utility of destructors. (And you should never call <strong>finalize( )</strong> directly, so that’s not a solution.) If you want some kind of cleanup performed other than storage release, you must still explicitly call an appropriate method in Java, which is the equivalent of a C++ destructor without the convenience</p>
<p>Remember that neither garbage collection nor finalization is guaranteed. If the JVM isn’t close to running out of memory, then it might not waste time recovering memory through garbage collection. </p>
<hr>

<h4 id="5-5-3-The-termination-condition"><a href="#5-5-3-The-termination-condition" class="headerlink" title="5.5.3 The termination condition"></a>5.5.3 The termination condition</h4><p>In general, you can’t rely on <strong>finalize( )</strong> being called, and you must create separate “cleanup” methods and call them explicitly. So it appears that <strong>finalize( )</strong> is only useful for obscure memory cleanup that most programmers will never use. However, there is an interesting use of <strong>finalize( )</strong> that does not rely on it being called every time. This is the verification of the termination condition[^3] of an object. </p>
<p>[^3]: A term coined by Bill Venners (<a target="_blank" rel="noopener" href="http://www.artima.com/">www.Artima.com</a>) during a seminar that he and I were giving together.</p>
<p><strong>At the point that you’re no longer interested in an object—when it’s ready to be cleaned up— that object should be in a state whereby its memory can be safely released</strong>. For example, if the object represents an open file, that file should be closed by the programmer before the object is garbage collected. If any portions of the object are not properly cleaned up, then you have a bug in your program that can be very difficult to find. finalize( ) can be used to eventually discover this condition, even if it isn’t always called. If one of the finalizations happens to reveal the bug, then you discover the problem, which is all you really care about. </p>
<p>Here’s a simple example of how you might use it: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//: initialization/TerminationCondition.java</span></span><br><span class="line"><span class="comment">// Using finalize() to detect an object that</span></span><br><span class="line"><span class="comment">// hasn’t been properly cleaned up.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">checkedOut</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    Book(<span class="type">boolean</span> checkOut) &#123;</span><br><span class="line">        checkedOut = checkOut;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">checkIn</span><span class="params">()</span> &#123;</span><br><span class="line">        checkedOut = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(checkedOut)</span><br><span class="line">            System.out.println(<span class="string">&quot;Error: checked out&quot;</span>);</span><br><span class="line">        <span class="comment">// Normally, you’ll also do this:</span></span><br><span class="line">        <span class="comment">// super.finalize(); // Call the base-class version</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TerminationCondition</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Book</span> <span class="variable">novel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// Proper cleanup:</span></span><br><span class="line">        novel.checkIn();</span><br><span class="line">        <span class="comment">// Drop the reference, forget to clean up:</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Book</span>(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// Force garbage collection &amp; finalization:</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Error: checked out</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~ </span></span><br></pre></td></tr></table></figure>

<p>The termination condition is that all <strong>Book</strong> objects are supposed to be checked in before they are garbage collected, but in <strong>main( )</strong>, a programmer error doesn’t check in one of the books. Without <strong>finalize( )</strong> to verify the termination condition, this can be a difficult bug to find. </p>
<p>Note that <strong>System.gc( )</strong> is used to force finalization. But even if it isn’t, it’s highly probable that the errant Book will eventually be discovered through repeated executions of the program (assuming the program allocates enough storage to cause the garbage collector to execute). </p>
<p>You should generally assume that the base-class version of <strong>finalize( )</strong> will also be doing something important, and call it using super, as you can see in <strong>Book.finalize( )</strong>. In this case, it is commented out because it requires exception handling, which we haven’t covered yet. </p>
<hr>

<h4 id="5-5-4-How-a-garbage-collector-works"><a href="#5-5-4-How-a-garbage-collector-works" class="headerlink" title="5.5.4 How a garbage collector works"></a>5.5.4 How a garbage collector works</h4><p>If you come from a programming language where allocating objects on the heap is expensive, you may naturally assume that Java’s scheme of allocating everything (except primitives) on the heap is also expensive. However, it turns out that the garbage collector can have a significant impact on <strong>increasing the speed of object creation</strong>. This might sound a bit odd at first—that storage release affects storage allocation—but it’s the way some JVMs work, and <strong>it means that allocating storage for heap objects in Java can be nearly as fast as creating storage <em><u>on the stack</u></em> in other languages.</strong> </p>
<p>To understand garbage collection in Java, it’s helpful learn how garbage-collection schemes work in other systems. A simple but slow garbage-collection technique is called reference counting. This means that each object contains a reference counter, and every time a reference is attached to that object, the reference count is increased. Every time a reference goes out of scope or is set to null, the reference count is decreased. Thus, managing reference counts is a small but constant overhead that happens throughout the lifetime of your program. The garbage collector moves through the entire list of objects, and when it finds one with a reference count of zero it releases that storage (however, reference counting schemes often release an object as soon as the count goes to zero). The one drawback is that if objects circularly refer to each other they can have nonzero reference counts while still being garbage. Locating such self-referential groups requires significant extra work for the garbage collector. <strong>Reference counting is commonly used to explain one kind of garbage collection, but it doesn’t seem to be used in any JVM implementations.</strong> </p>
<p>In faster schemes, garbage collection is not based on reference counting. Instead, it is based on the idea that any non-dead object must ultimately be traceable back to a reference that lives either on the stack or in static storage. The chain might go through several layers of objects. Thus, if you start in the stack and in the static storage area and walk through all the references, you’ll find all the live objects. For each reference that you find, you must trace into the object that it points to and then follow all the references in that object, tracing into the objects they point to, etc., until you’ve moved through the entire Web that originated with the reference on the stack or in static storage. Each object that you move through must still be alive. Note that there is no problem with <strong>detached self-referential groups</strong>—these are simply not found, and are therefore automatically garbage. </p>
<p>In the approach described here, the JVM uses an <em>adaptive</em> garbage-collection scheme, and what it does with the live objects that it locates depends on the variant currently being used. One of these variants is <em><u>stop-and-copy</u></em>. This means that—for reasons that will become apparent—<strong>the program is first stopped (this is not a background collection scheme). Then, each live object is copied from one heap to another, leaving behind all the garbage.</strong> In addition, as the objects are copied into the new heap, they are <strong>packed end-to-end</strong>, thus compacting the new heap (and allowing new storage to simply be reeled off the end as previously described). </p>
<p>Of course, when an object is moved from one place to another, all references that point at the object must be changed. The reference that goes from the heap or the static storage area to the object can be changed right away, but there can be other references pointing to this object that will be encountered later during the “walk.” These are fixed up as they are found (you could imagine a table that maps old addresses to new ones). </p>
<p>There are two issues that make these so-called “copy collectors” inefficient. The first is the idea that you have two heaps and you slosh all the memory back and forth between these two separate heaps, maintaining twice as much memory as you actually need. <strong>Some JVMs deal with this by allocating the heap in chunks as needed and simply copying from one chunk to another.</strong> </p>
<p>The second issue is the copying process itself. Once your program becomes stable, it might be generating little or no garbage. Despite that, a copy collector will still copy all the memory from one place to another, which is wasteful. <strong>To prevent this, some JVMs detect that no new garbage is being generated and switch to a different scheme</strong> (this is the “*<u>adaptive</u>*” part). This other scheme is called <strong><u>mark-and-sweep</u></strong>, and it’s what <strong>earlier versions of Sun’s JVM used all the time</strong>. For general use, <em>mark-and-sweep</em> is fairly slow, but when you know you’re generating little or no garbage, it’s fast. </p>
<p>Mark-and-sweep follows the same logic of starting from the stack and static storage, and tracing through all the references to find live objects. However, each time it finds a live object, that object is marked by setting a flag in it, but the object isn’t collected yet. Only when the marking process is finished does the sweep occur. <strong>During the sweep, the dead objects are released. However, no copying happens, so if the collector chooses to compact a fragmented heap, it does so by shuffling objects around.</strong> </p>
<p>“Stop-and-copy” refers to the idea that this type of garbage collection is <strong>not done in the background</strong>; instead, the program is stopped while the garbage collection occurs. In the Sun literature you’ll find many references to garbage collection as a low-priority background process, but it turns out that the garbage collection was not implemented that way in earlier versions of the Sun JVM. Instead, the Sun garbage collector stopped the program when memory got low. <strong>Mark-and-sweep also requires that the program be stopped.</strong> </p>
<p>As previously mentioned, in the JVM described here memory is allocated in big blocks. If you allocate a large object, it gets its own block. Strict stop-and-copy requires copying every live object from the source heap to a new heap before you can free the old one, which translates to lots of memory. With blocks, the garbage collection can typically copy objects to dead blocks as it collects. Each block has a generation count to keep track of whether it’s alive. In the normal case, only the blocks created since the last garbage collection are compacted; all other blocks get their generation count bumped if they have been referenced from somewhere. This handles the normal case of lots of short-lived temporary objects. Periodically, a full sweep is made—large objects are still not copied (they just get their generation count bumped), and blocks containing small objects are copied and compacted. The JVM monitors the efficiency of garbage collection and if it becomes a waste of time because all objects are long-lived, then it switches to mark-andsweep. Similarly, the JVM keeps track of how successful mark-and-sweep is, and if the heap starts to become fragmented, it switches back to stop-and-copy. This is where the “adaptive” part comes in, so you end up with a mouthful: “Adaptive generational stop-and-copy mark-andsweep.” </p>
<p>There are a number of additional speedups possible in a JVM. An especially important one involves the operation of the loader and what is called a <strong>just-in-time (JIT) compiler</strong>. A JIT compiler <strong>partially or fully converts a program into native machine code so that it doesn’t need to be interpreted by the JVM and thus runs much faster</strong>. When a class must be loaded (typically, the first time you want to create an object of that class), the <strong>.class</strong> file is located, and the bytecodes for that class are brought into memory. At this point, <strong>one approach is to simply JIT compile all the code</strong>, but this has two <strong>drawbacks</strong>: It takes a little more time, which, compounded throughout the life of the program, can add up; and it increases the size of the executable (bytecodes are significantly more compact than expanded JIT code), and this might cause paging, which definitely slows down a program. <strong>An alternative approach is <em>lazy evaluation</em></strong>, which means that the code is not JIT compiled until necessary. Thus, code that never gets executed might never be JIT compiled. The Java HotSpot technologies in recent JDKs take a similar approach by increasingly optimizing a piece of code each time it is executed, so the more the code is executed, the faster it gets. </p>
<hr>

<h3 id="5-6-Member-initialization"><a href="#5-6-Member-initialization" class="headerlink" title="5.6 Member initialization"></a>5.6 Member initialization</h3><p>pass</p>
<hr>

<h4 id="5-6-1-Specifying-initialization"><a href="#5-6-1-Specifying-initialization" class="headerlink" title="5.6.1 Specifying initialization"></a>5.6.1 Specifying initialization</h4><p>pass</p>
<hr>

<h3 id="5-7-Constructor-initialization"><a href="#5-7-Constructor-initialization" class="headerlink" title="5.7 Constructor initialization"></a>5.7 Constructor initialization</h3><h4 id="5-7-1-Order-of-initialization"><a href="#5-7-1-Order-of-initialization" class="headerlink" title="5.7.1 Order of initialization"></a>5.7.1 Order of initialization</h4><p>Within a class, the order of initialization is determined by the order that the variables are defined within the class. The variable definitions may be scattered throughout and in between method definitions, but the variables are initialized before any methods can be called—even the constructor. For example: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//: initialization/OrderOfInitialization.java</span></span><br><span class="line"><span class="comment">// Demonstrates initialization order.</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> net.mindview.util.Print.*;</span><br><span class="line"><span class="comment">// When the constructor is called to create a</span></span><br><span class="line"><span class="comment">// Window object, you’ll see a message:</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span> &#123;</span><br><span class="line">    Window(<span class="type">int</span> marker) &#123; print(<span class="string">&quot;Window(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">House</span> &#123;</span><br><span class="line">    <span class="type">Window</span> <span class="variable">w1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Window</span>(<span class="number">1</span>); <span class="comment">// Before constructor</span></span><br><span class="line">    House() &#123;</span><br><span class="line">        <span class="comment">// Show that we’re in the constructor:</span></span><br><span class="line">        print(<span class="string">&quot;House()&quot;</span>);</span><br><span class="line">        w3 = <span class="keyword">new</span> <span class="title class_">Window</span>(<span class="number">33</span>); <span class="comment">// Reinitialize w3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Window</span> <span class="variable">w2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Window</span>(<span class="number">2</span>); <span class="comment">// After constructor</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123; print(<span class="string">&quot;f()&quot;</span>); &#125;</span><br><span class="line">    <span class="type">Window</span> <span class="variable">w3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Window</span>(<span class="number">3</span>); <span class="comment">// At end</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderOfInitialization</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">House</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">House</span>();</span><br><span class="line">        h.f(); <span class="comment">// Shows that construction is done</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Window(1)</span></span><br><span class="line"><span class="comment">Window(2)</span></span><br><span class="line"><span class="comment">Window(3)</span></span><br><span class="line"><span class="comment">House()</span></span><br><span class="line"><span class="comment">Window(33)</span></span><br><span class="line"><span class="comment">f()</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~ </span></span><br></pre></td></tr></table></figure>

<p>In House, the definitions of the Window objects are intentionally scattered about to prove that they’ll all get initialized before the constructor is entered or anything else can happen. In addition, w3 is reinitialized inside the constructor. </p>
<p>From the output, you can see that the w3 reference gets initialized twice: once before and once during the constructor call. (The first object is dropped, so it can be garbage collected later.) This might not seem efficient at first, but it guarantees proper initialization—what would happen if an overloaded constructor were defined that did not initialize w3 and there wasn’t a “default” initialization for w3 in its definition? </p>
<h4 id="5-7-2-static-data-initialization"><a href="#5-7-2-static-data-initialization" class="headerlink" title="5.7.2 static data initialization"></a>5.7.2 static data initialization</h4><p>There’s only a single piece of storage for a <strong>static</strong>, regardless of how many objects are created. <strong>You can’t apply the static keyword to local variables, so it only applies to fields.</strong> If a field is a static primitive and you don’t initialize it, it gets the <strong>standard initial value for its type</strong>. If it’s a reference to an object, the default initialization value is <strong>null</strong>. </p>
<p><strong>The order of initialization is statics first</strong>, if they haven’t already been initialized by a previous object creation, <strong>and then the non-static objects</strong>. </p>
<p>To summarize the process of creating an object, consider a class called <strong>Dog</strong>: </p>
<ol>
<li>Even though it doesn’t explicitly use the <strong>static</strong> keyword, <strong>the constructor is actually a static method</strong>. So the first time an object of type <strong>Dog</strong> is created, or the first time a static method or static field of class Dog is accessed, <strong>the Java interpreter must locate Dog.class</strong>, which it does by searching through the classpath. </li>
<li>As <strong>Dog.class</strong> is loaded (creating a <strong>Class</strong> object, which you’ll learn about later), all of its static initializers are run. Thus, <strong>static initialization takes place only once, as the Class object is loaded for the first time.</strong> </li>
<li>When you create a <strong>new Dog( )</strong>, the construction process for a <strong>Dog</strong> object first allocates enough storage for a Dog object on the heap.</li>
<li>This storage is wiped to zero, <strong>automatically setting all the primitives in that Dog object to their default values</strong> (zero for numbers and the equivalent for boolean and char) and the references to null. </li>
<li>Any <strong>initializations that occur at the point of field definition</strong> are executed. </li>
<li><strong>Constructors</strong> are executed. As you shall see in the Reusing Classes chapter, this might actually involve a fair amount of activity, especially when inheritance is involved.</li>
</ol>
<h4 id="5-7-3-Explicit-static-initialization"><a href="#5-7-3-Explicit-static-initialization" class="headerlink" title="5.7.3 Explicit static initialization"></a>5.7.3 Explicit static initialization</h4><p>Java allows you to group other <strong>static</strong> initializations inside a special “<strong>static clause</strong>” (sometimes called a static block) in a class. It looks like this: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//: initialization/Spoon.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Spoon</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">47</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">///:~ </span></span><br></pre></td></tr></table></figure>

<p>It appears to be a method, but it’s just the <strong>static</strong> keyword followed by a block of code. <strong>This code, like other static initializations, is executed only once</strong>: the first time you make an object of that class or the first time you access a static member of that class (even if you never make an object of that class).</p>
<h4 id="5-7-4-Non-static-instance-initialization"><a href="#5-7-4-Non-static-instance-initialization" class="headerlink" title="5.7.4 Non-static instance initialization"></a>5.7.4 Non-static instance initialization</h4><p>Java provides a similar syntax, called instance initialization, for initializing non-static variables for each object.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//: initialization/Mugs.java</span></span><br><span class="line"><span class="comment">// Java &quot;Instance Initialization.&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> net.mindview.util.Print.*;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mug</span> &#123;</span><br><span class="line">    Mug(<span class="type">int</span> marker) &#123;</span><br><span class="line">        print(<span class="string">&quot;Mug(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> marker)</span> &#123;</span><br><span class="line">        print(<span class="string">&quot;f(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mugs</span> &#123;</span><br><span class="line">    Mug mug1;</span><br><span class="line">    Mug mug2;</span><br><span class="line">    &#123;</span><br><span class="line">        mug1 = <span class="keyword">new</span> <span class="title class_">Mug</span>(<span class="number">1</span>);</span><br><span class="line">        mug2 = <span class="keyword">new</span> <span class="title class_">Mug</span>(<span class="number">2</span>);</span><br><span class="line">        print(<span class="string">&quot;mug1 &amp; mug2 initialized&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Mugs() &#123;</span><br><span class="line">        print(<span class="string">&quot;Mugs()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Mugs(<span class="type">int</span> i) &#123;</span><br><span class="line">        print(<span class="string">&quot;Mugs(int)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        print(<span class="string">&quot;Inside main()&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Mugs</span>();</span><br><span class="line">        print(<span class="string">&quot;new Mugs() completed&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Mugs</span>(<span class="number">1</span>);</span><br><span class="line">        print(<span class="string">&quot;new Mugs(1) completed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Inside main()</span></span><br><span class="line"><span class="comment">Mug(1)</span></span><br><span class="line"><span class="comment">Mug(2)</span></span><br><span class="line"><span class="comment">mug1 &amp; mug2 initialized</span></span><br><span class="line"><span class="comment">Mugs()</span></span><br><span class="line"><span class="comment">new Mugs() completed</span></span><br><span class="line"><span class="comment">Mug(1)</span></span><br><span class="line"><span class="comment">Mug(2)</span></span><br><span class="line"><span class="comment">mug1 &amp; mug2 initialized</span></span><br><span class="line"><span class="comment">Mugs(int)</span></span><br><span class="line"><span class="comment">new Mugs(1) completed</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~ </span></span><br></pre></td></tr></table></figure>

<p>You can see that the instance initialization clause: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    mug1 = <span class="keyword">new</span> <span class="title class_">Mug</span>(<span class="number">1</span>);</span><br><span class="line">    mug2 = <span class="keyword">new</span> <span class="title class_">Mug</span>(<span class="number">2</span>);</span><br><span class="line">    print(<span class="string">&quot;mug1 &amp; mug2 initialized&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>looks exactly like the static initialization clause except for the missing static keyword. This syntax is necessary to support the initialization of <strong>anonymous inner classes</strong> (see the Inner Classes chapter), but it also allows you to guarantee that certain operations occur regardless of which explicit constructor is called. From the output, you can see that the instance initialization clause is executed before either one of the constructors. </p>
<h3 id="5-8-Array-initialization"><a href="#5-8-Array-initialization" class="headerlink" title="5.8 Array initialization"></a>5.8 Array initialization</h3><p>An array is simply a sequence of either objects or primitives that are all the same type and are packaged together under one identifier name. Arrays are defined and used with the <em><u>squarebrackets indexing operator</u></em> [ ]. To define an array reference, you simply follow your type name with empty square brackets.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a1;</span><br><span class="line"><span class="comment">// You can also put the square brackets after the identifier to produce exactly the same</span></span><br><span class="line"><span class="comment">// meaning:</span></span><br><span class="line"><span class="type">int</span> a1[];</span><br></pre></td></tr></table></figure>

<p>This conforms to expectations from C and C++ programmers. The former style, however, is probably a more sensible syntax, since it says that the type is “an int array.” That style will be used in this book. </p>
<p>The compiler doesn’t allow you to tell it how big the array is. This brings us back to that issue of “references.” All that you have at this point is a reference to an array (you’ve allocated enough storage for that reference), and there’s been no space allocated for the array object itself. To create storage for the array, you must write an initialization expression. For arrays, initialization can appear anywhere in your code, but you can also use a special kind of initialization expression that must occur at the point where the array is created. This special initialization is a set of values surrounded by curly braces. The storage allocation (the equivalent of using <strong>new</strong>) is taken care of by the compiler in this case.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a1 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="comment">// So why would you ever define an array reference without an array?</span></span><br><span class="line"><span class="type">int</span>[] a2;</span><br><span class="line"><span class="comment">// Well, it’s possible to assign one array to another in Java, so you can say:</span></span><br><span class="line">a2 = a1;</span><br><span class="line"><span class="comment">// What you’re really doing is copying a reference, as demonstrated here:</span></span><br><span class="line"><span class="comment">//: initialization/ArraysOfPrimitives.java</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> net.mindview.util.Print.*; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArraysOfPrimitives</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] a1 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">        <span class="type">int</span>[] a2;</span><br><span class="line">        a2 = a1;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a2.length; i++)</span><br><span class="line">            a2[i] = a2[i] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a1.length; i++)</span><br><span class="line">            print(<span class="string">&quot;a1[&quot;</span> + i + <span class="string">&quot;] = &quot;</span> + a1[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">a1[0] = 2</span></span><br><span class="line"><span class="comment">a1[1] = 3</span></span><br><span class="line"><span class="comment">a1[2] = 4</span></span><br><span class="line"><span class="comment">a1[3] = 5</span></span><br><span class="line"><span class="comment">a1[4] = 6</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~ </span></span><br></pre></td></tr></table></figure>

<p>You can see that a1 is given an initialization value but a2 is not; a2 is assigned later—in this case, to another array. Since a2 and a1 are then aliased to the same array, the changes made via a2 are seen in a1. </p>
<p>What if you don’t know how many elements you’re going to need in your array while you’re writing the program? You simply use new to create the elements in the array. Here, new works even though it’s creating an array of primitives (new won’t create a non-array primitive): </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//: initialization/ArrayNew.java</span></span><br><span class="line"><span class="comment">// Creating arrays with new.</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> net.mindview.util.Print.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayNew</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] a;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">47</span>);</span><br><span class="line">        a = <span class="keyword">new</span> <span class="title class_">int</span>[rand.nextInt(<span class="number">20</span>)];</span><br><span class="line">        print(<span class="string">&quot;length of a = &quot;</span> + a.length);</span><br><span class="line">        print(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">length of a = 18</span></span><br><span class="line"><span class="comment">[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~ </span></span><br></pre></td></tr></table></figure>

<p>The size of the array is chosen at random by using the <strong>Random.nextInt( )</strong> method, which produces a value between zero and that of its argument. Because of the randomness, it’s clear that array creation is actually happening at run time. In addition, the output of this program shows that array elements of primitive types are automatically initialized to “empty” values. (For <strong>numerics</strong> and <strong>char</strong>, this is zero, and for <strong>boolean</strong>, it’s false.) </p>
<p>The <strong>Arrays.toString( )</strong> method, which is part of the standard java.util library, produces a printable version of a one-dimensional array. </p>
<p>Of course, in this case the array could also have been defined and initialized in the same statement:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[rand.nextInt(<span class="number">20</span>)]; </span><br></pre></td></tr></table></figure>

<hr>

<h4 id="5-8-1-Variable-argument-lists"><a href="#5-8-1-Variable-argument-lists" class="headerlink" title="5.8.1 Variable argument lists"></a>5.8.1 Variable argument lists</h4><p>pass</p>
<hr>

<h3 id="5-9-Enumerated-types"><a href="#5-9-Enumerated-types" class="headerlink" title="5.9 Enumerated types"></a>5.9 Enumerated types</h3><p>pass</p>
<hr>

<h3 id="5-10-Summary"><a href="#5-10-Summary" class="headerlink" title="5.10 Summary"></a>5.10 Summary</h3><p>This seemingly elaborate mechanism for initialization, the constructor, should give you a strong hint about the critical importance placed on initialization in the language. As Bjarne Stroustrup, the inventor of C++, was designing that language, one of the first observations he made about productivity in C was that improper initialization of variables causes a significant portion of programming problems. These kinds of bugs are hard to find, and similar issues apply to improper cleanup. Because constructors allow you to <em>guarantee</em> proper initialization and cleanup (the compiler will not allow an object to be created without the proper constructor calls), you get complete control and safety. </p>
<p>In C++, destruction is quite important because objects created with <strong>new</strong> must be explicitly destroyed. In Java, the garbage collector automatically releases the memory for all objects, so the equivalent cleanup method in Java isn’t necessary much of the time (but when it is, you must do it yourself). In cases where you don’t need destructor-like behavior, Java’s garbage collector greatly simplifies programming and adds much-needed safety in managing memory. Some garbage collectors can even clean up other resources like graphics and file handles. However, the garbage collector does add a runtime cost, the expense of which is difficult to put into perspective because of the historical slowness of Java interpreters. Although Java has had significant performance increases over time, the speed problem has taken its toll on the adoption of the language for certain types of programming problems. </p>
<p>Because of the guarantee that all objects will be constructed, there’s actually more to the constructor than what is shown here. In particular, when you create new classes using either <em><u>composition</u></em> or <em><u>inheritance</u></em>, the guarantee of construction also holds, and some additional syntax is necessary to support this. You’ll learn about composition, inheritance, and how they affect constructors in future chapters. </p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-02-12T05:54:56.000Z" title="2025/2/12 13:54:56">2025-02-12</time>发表</span><span class="level-item"><time dateTime="2025-02-12T02:38:29.476Z" title="2025/2/12 10:38:29">2025-02-12</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/Java/basics/">basics</a><span> / </span><a class="link-muted" href="/categories/Java/basics/Thinking-in-Java/">Thinking in Java</a></span><span class="level-item">8 分钟读完 (大约1128个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/02/12/Thinking-in-Java/Thinking-in-Java-pt-4/">Thinking in Java pt.4</a></p><div class="content"><h2 id="Chapter-4-Controlling-Execution"><a href="#Chapter-4-Controlling-Execution" class="headerlink" title="Chapter 4 Controlling Execution"></a>Chapter 4 Controlling Execution</h2><p><strong><u>Like a sentient creature, a program must manipulate its world and make choices during execution. In Java you make choices with execution control statements.</u></strong> </p>
<p>Java uses all of C’s execution control statements, so if you’ve programmed with C or C++, then most of what you see will be familiar. Most procedural programming languages have some kind of control statements, and there is often overlap among languages. In Java, <strong>the keywords include if-else, while, do-while, for, return, break, and a selection statement called switch</strong>. Java <strong>does not</strong>, however, support the much-maligned <strong>goto</strong> (which can still be the most expedient way to solve certain types of problems). You can still do <strong>a goto-like jump</strong>, but it is much more constrained than a typical <strong>goto</strong>. </p>
<hr>

<h3 id="4-1-true-and-false"><a href="#4-1-true-and-false" class="headerlink" title="4.1 true and false"></a>4.1 true and false</h3><p>pass</p>
<hr>

<h3 id="4-2-if-else"><a href="#4-2-if-else" class="headerlink" title="4.2 if-else"></a>4.2 if-else</h3><p>pass</p>
<hr>

<h3 id="4-3-Iteration"><a href="#4-3-Iteration" class="headerlink" title="4.3 Iteration"></a>4.3 Iteration</h3><p>pass</p>
<hr>

<h4 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h4><p>Write a program that prints values from 1 to 100. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">exer_1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise 2"></a>Exercise 2</h4><p>Write a program that generates 25 random int values. For each value, use an if-else statement to classify it as greater than, less than, or equal to a second randomly generated value. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">exer_2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> random.nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">25</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> random.nextInt();</span><br><span class="line">            <span class="keyword">if</span> (i1 &gt; i2) &#123;</span><br><span class="line">                System.out.println(i1 + <span class="string">&quot; &gt; &quot;</span> + i2);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i1 &lt; i2) &#123;</span><br><span class="line">                System.out.println(i1 + <span class="string">&quot; &lt; &quot;</span> + i2);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(i1 + <span class="string">&quot; = &quot;</span> + i2);</span><br><span class="line">            &#125;</span><br><span class="line">            i1 = i2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3:"></a>Exercise 3:</h4><p>Modify Exercise 2 so that your code is surrounded by an “infinite” while loop. It will then run until you interrupt it from the keyboard (typically by pressing ControlC). </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">exer_3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> random.nextInt();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> random.nextInt();</span><br><span class="line">            <span class="keyword">if</span> (i1 &gt; i2) &#123;</span><br><span class="line">                System.out.println(i1 + <span class="string">&quot; &gt; &quot;</span> + i2);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i1 &lt; i2) &#123;</span><br><span class="line">                System.out.println(i1 + <span class="string">&quot; &lt; &quot;</span> + i2);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(i1 + <span class="string">&quot; = &quot;</span> + i2);</span><br><span class="line">            &#125;</span><br><span class="line">            i1 = i2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4:"></a>Exercise 4:</h4><p>Write a program that uses two nested for loops and the modulus operator (%) to detect and print prime numbers (integral numbers that are not evenly divisible by any other numbers except for themselves and 1). </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">exer_4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i % j == <span class="number">0</span>) &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5:"></a>Exercise 5:</h4><p>Repeat Exercise 10 from the previous chapter, using the ternary operator and a bitwise test to display the ones and zeroes, instead of Integer.toBinaryString( ). </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pass</span><br></pre></td></tr></table></figure>

<hr>

<h3 id="4-4-Foreach-syntax"><a href="#4-4-Foreach-syntax" class="headerlink" title="4.4 Foreach syntax"></a>4.4 Foreach syntax</h3><p>pass</p>
<hr>

<h3 id="4-5-return"><a href="#4-5-return" class="headerlink" title="4.5 return"></a>4.5 return</h3><p>pass</p>
<hr>

<h3 id="4-6-break-and-continue"><a href="#4-6-break-and-continue" class="headerlink" title="4.6 break and continue"></a>4.6 break and continue</h3><p>pass</p>
<hr>

<h3 id="4-7-The-infamous-“goto”"><a href="#4-7-The-infamous-“goto”" class="headerlink" title="4.7 The infamous “goto”"></a>4.7 The infamous “goto”</h3><p>Although goto is a reserved word in Java, it is not used in the language; <strong><u>Java has no goto</u></strong>. However, it does have something that looks a bit like a jump tied in with the break and continue keywords. It’s not a jump but rather a way to break out of an iteration statement. The reason it’s often thrown in with discussions of goto is because it uses the same mechanism: a <strong>label</strong>. </p>
<p>A label is an identifier followed by a colon, like this: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label1: </span><br></pre></td></tr></table></figure>

<p>The only place a label is useful in Java is right before an iteration statement. And that means right before—it does no good to put any other statement between the label and the iteration. And the sole reason to put a label before an iteration is if you’re going to nest another iteration or a switch (which you’ll learn about shortly) inside it. That’s because the break and continue keywords will normally interrupt only the current loop, but when used with a label, <strong>they’ll interrupt the loops up to where the label exists</strong>: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">label1:</span><br><span class="line">outer-iteration &#123;</span><br><span class="line">    inner-iteration &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// (1)</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">continue</span>; <span class="comment">// (2)</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">continue</span> label1; <span class="comment">// (3)</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">break</span> label1; <span class="comment">// (4)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>In (1), the break breaks out of the inner iteration and you end up in the outer iteration. In (2), the continue moves back to the beginning of the inner iteration. But in (3), <strong>the continue label1 breaks out of the inner iteration and the outer iteration, all the way back to label1</strong>. Then it does in fact continue the iteration, but starting at the outer iteration. In (4), <strong>the break label1 also breaks all the way out to label1, but it does not reenter the iteration</strong>. It actually does break out of both iterations.</p>
<p>Here is an example using for loops:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// For loops with &quot;labeled break&quot; and &quot;labeled continue.&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> net.mindview.util.Print.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LabeledFor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        outer: <span class="comment">// Can’t have statements here</span></span><br><span class="line">        <span class="keyword">for</span>(; <span class="literal">true</span> ;) &#123; <span class="comment">// infinite loop</span></span><br><span class="line">            inner: <span class="comment">// Can’t have statements here</span></span><br><span class="line">            <span class="keyword">for</span>(; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                print(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">2</span>) &#123;</span><br><span class="line">                    print(<span class="string">&quot;continue&quot;</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">3</span>) &#123;</span><br><span class="line">                    print(<span class="string">&quot;break&quot;</span>);</span><br><span class="line">                    i++; <span class="comment">// Otherwise i never</span></span><br><span class="line">                    <span class="comment">// gets incremented.</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">7</span>) &#123;</span><br><span class="line">                    print(<span class="string">&quot;continue outer&quot;</span>);</span><br><span class="line">                    i++; <span class="comment">// Otherwise i never</span></span><br><span class="line">                    <span class="comment">// gets incremented.</span></span><br><span class="line">                    <span class="keyword">continue</span> outer;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">8</span>) &#123;</span><br><span class="line">                    print(<span class="string">&quot;break outer&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span> outer;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">5</span>; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(k == <span class="number">3</span>) &#123;</span><br><span class="line">                        print(<span class="string">&quot;continue inner&quot;</span>);</span><br><span class="line">                        <span class="keyword">continue</span> inner;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Can’t break or continue to labels here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">i = 0</span></span><br><span class="line"><span class="comment">continue inner</span></span><br><span class="line"><span class="comment">i = 1</span></span><br><span class="line"><span class="comment">continue inner</span></span><br><span class="line"><span class="comment">i = 2</span></span><br><span class="line"><span class="comment">continue</span></span><br><span class="line"><span class="comment">i = 3</span></span><br><span class="line"><span class="comment">break</span></span><br><span class="line"><span class="comment">i = 4</span></span><br><span class="line"><span class="comment">continue inner</span></span><br><span class="line"><span class="comment">i = 5</span></span><br><span class="line"><span class="comment">continue inner</span></span><br><span class="line"><span class="comment">i = 6</span></span><br><span class="line"><span class="comment">continue inner</span></span><br><span class="line"><span class="comment">i = 7</span></span><br><span class="line"><span class="comment">continue outer</span></span><br><span class="line"><span class="comment">i = 8</span></span><br><span class="line"><span class="comment">break outer </span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<p>The same rules hold true for <strong>while</strong>: </p>
<ol>
<li>A <strong>plain continue</strong> goes to the top of the innermost loop and continues. </li>
<li>A <strong>labeled continue</strong> goes to the label and reenters the loop right after that label. </li>
<li>A <strong>break</strong> “drops out of the bottom” of the loop. </li>
<li>A <strong>labeled break</strong> drops out of the bottom of the end of the loop denoted by the label.</li>
</ol>
<p>In Dijkstra’s “Goto considered harmful” paper, what he specifically objected to was the labels, not the goto. <strong>He observed that the number of bugs seems to increase with the number of labels in a program, and that labels and gotos make programs difficult to analyze.</strong> Note that Java labels don’t suffer from this problem, since they are constrained in their placement and can’t be used to transfer control in an ad hoc manner. It’s also interesting to note that this is a case where <strong>a language feature is made more useful by restricting the power of the statement.</strong> </p>
<hr>

<h3 id="4-8-switch"><a href="#4-8-switch" class="headerlink" title="4.8 switch"></a>4.8 switch</h3><p>pass</p>
<hr>

<h3 id="4-9-Summary"><a href="#4-9-Summary" class="headerlink" title="4.9 Summary"></a>4.9 Summary</h3><p>This chapter concludes the study of fundamental features that appear in most programming languages: calculation, operator precedence, type casting, and selection and iteration. Now you’re ready to begin taking steps that move you closer to the world of object-oriented programming. The next chapter will cover the important issues of initialization and cleanup of objects, followed in the subsequent chapter by the essential concept of implementation hiding. </p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-02-11T05:54:56.000Z" title="2025/2/11 13:54:56">2025-02-11</time>发表</span><span class="level-item"><time dateTime="2025-02-12T02:38:34.666Z" title="2025/2/12 10:38:34">2025-02-12</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/Java/basics/">basics</a><span> / </span><a class="link-muted" href="/categories/Java/basics/Thinking-in-Java/">Thinking in Java</a></span><span class="level-item">14 分钟读完 (大约2094个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/02/11/Thinking-in-Java/Thinking-in-Java-pt-3/">Thinking in Java pt.3</a></p><div class="content"><h2 id="Chapter-3-Operators"><a href="#Chapter-3-Operators" class="headerlink" title="Chapter 3 Operators"></a>Chapter 3 Operators</h2><p><u><strong>At the lowest level, data in Java is manipulated using operators.</strong></u> </p>
<p>If you’re familiar with C or C++ syntax, you can <strong>skim through this chapter and the next</strong>, looking for places where Java is different from those languages.</p>
<hr>

<h3 id="3-1-Simpler-print-statements"><a href="#3-1-Simpler-print-statements" class="headerlink" title="3.1 Simpler print statements"></a>3.1 Simpler print statements</h3><p>In the previous chapter, you were introduced to the Java print statement:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;Rather a lot to type&quot;</span>); </span><br></pre></td></tr></table></figure>

<p>The <em><u>Access Control</u></em> chapter introduces the concept of the <em>static</em> import that was added to Java SE5, and creates a tiny library to simplify writing print statements. However, you don’t need to know those details in order to begin using that library. We can rewrite the program from the last chapter using this new library: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//: operators/HelloDate.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> net.mindview.util.Print.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloDate</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        print(<span class="string">&quot;Hello, it’s: &quot;</span>);</span><br><span class="line">        print(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">/* Output: (55% match)</span></span><br><span class="line"><span class="comment">Hello, it’s:</span></span><br><span class="line"><span class="comment">Wed Oct 05 14:39:05 MDT 2005</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~ </span></span><br></pre></td></tr></table></figure>

<p>The results are much cleaner. Notice the insertion of the <strong>static</strong> keyword in the second <strong>import</strong> statement. </p>
<p>Although the use of <strong>net.mindview.util.Print</strong> nicely simplifies most code, it is not justifiable everywhere. If there are only a small number of print statements in a program, I forego the <strong>import</strong> and write out the full <strong>System.out.println( )</strong>. </p>
<hr>

<h4 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a><strong>Exercise 1</strong></h4><p>Write a program that uses the “short” and normal form of print statement. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// short version</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> net.mindview.util.Print.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">exer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        print(<span class="string">&quot;Hello, it’s: &quot;</span>);</span><br><span class="line">        print(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// normal version</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">exer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;Hello, it’s: &quot;</span>);</span><br><span class="line">        System.out.print(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>

<h3 id="3-2-Using-Java-operators"><a href="#3-2-Using-Java-operators" class="headerlink" title="3.2 Using Java operators"></a>3.2 Using Java operators</h3><p>pass</p>
<hr>

<h3 id="3-3-Precedence"><a href="#3-3-Precedence" class="headerlink" title="3.3 Precedence"></a>3.3 Precedence</h3><p>Operator precedence defines how an expression evaluates when several operators are present. Java has specific rules that determine the order of evaluation. The easiest one to remember is that <strong>multiplication and division happen before addition and subtraction</strong>. Programmers often forget the other precedence rules, so you should <strong>use parentheses to make the order of evaluation explicit</strong>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//: operators/Precedence.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Precedence</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>, y = <span class="number">2</span>, z = <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> x + y - <span class="number">2</span>/<span class="number">2</span> + z; <span class="comment">// (1)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> x + (y - <span class="number">2</span>)/(<span class="number">2</span> + z); <span class="comment">// (2)</span></span><br><span class="line">        System.out.println(<span class="string">&quot;a = &quot;</span> + a + <span class="string">&quot; b = &quot;</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">a = 5 b = 1</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~ </span></span><br></pre></td></tr></table></figure>

<p>These statements look roughly the same, but from the output you can see that they have very different meanings which depend on <strong>the use of parentheses</strong>. </p>
<p>Notice that the <strong>System.out.println( )</strong> statement involves the ‘**+<strong>’ operator. In this context, ‘+’ means “</strong><u>string concatenation</u>**” and, if necessary, “string conversion.” When the compiler sees a String followed by a ‘+’ followed by a non-String, it attempts to convert the nonString into a String. As you can see from the output, it successfully converts from int into String for a and b. </p>
<hr>

<h3 id="3-4-Assignment"><a href="#3-4-Assignment" class="headerlink" title="3.4 Assignment"></a>3.4 Assignment</h3><p>Whenever you manipulate an object, what you’re manipulating is the reference, so when you assign “<strong>from one object to another</strong>,” you’re actually copying a reference from one place to another. This means that if you say <strong>c &#x3D; d</strong> for objects, you end up with <strong>both c and d pointing to the object</strong> that, originally, only d pointed to. Here’s an example that demonstrates this behavior: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//: operators/Assignment.java</span></span><br><span class="line"><span class="comment">// Assignment with objects is a bit tricky.</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> net.mindview.util.Print.*;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tank</span> &#123;</span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Assignment</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Tank</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tank</span>();</span><br><span class="line">        <span class="type">Tank</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tank</span>();</span><br><span class="line">        t1.level = <span class="number">9</span>;</span><br><span class="line">        t2.level = <span class="number">47</span>;</span><br><span class="line">        print(<span class="string">&quot;1: t1.level: &quot;</span> + t1.level +</span><br><span class="line">              <span class="string">&quot;, t2.level: &quot;</span> + t2.level);</span><br><span class="line">        t1 = t2;</span><br><span class="line">        print(<span class="string">&quot;2: t1.level: &quot;</span> + t1.level +</span><br><span class="line">              <span class="string">&quot;, t2.level: &quot;</span> + t2.level);</span><br><span class="line">        t1.level = <span class="number">27</span>;</span><br><span class="line">        print(<span class="string">&quot;3: t1.level: &quot;</span> + t1.level +</span><br><span class="line">              <span class="string">&quot;, t2.level: &quot;</span> + t2.level);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">1: t1.level: 9, t2.level: 47</span></span><br><span class="line"><span class="comment">2: t1.level: 47, t2.level: 47</span></span><br><span class="line"><span class="comment">3: t1.level: 27, t2.level: 27</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~ </span></span><br></pre></td></tr></table></figure>

<p>This phenomenon is often called <strong>aliasing</strong>, and it’s a fundamental way that Java works with objects. But what if you don’t want aliasing to occur in this case? You could forego the assignment and say: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t1.level = t2.level; </span><br></pre></td></tr></table></figure>

<p>This retains the two separate objects instead of discarding one and tying t1 and t2 to the same object. You’ll soon realize that manipulating the fields within objects is messy and goes against good object-oriented design principles. This is a nontrivial topic, so you should keep in mind that assignment for objects can add surprises. </p>
<hr>

<h4 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise 2"></a>Exercise 2</h4><p>Create a class containing a float and use it to demonstrate aliasing. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tank</span> &#123;</span><br><span class="line">    <span class="type">float</span> level;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">exer_2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Tank</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tank</span>();</span><br><span class="line">        <span class="type">Tank</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tank</span>();</span><br><span class="line">        t1.level = <span class="number">9</span>;</span><br><span class="line">        t2.level = <span class="number">47</span>;</span><br><span class="line">        System.out.print(<span class="string">&quot;1: t1.level: &quot;</span> + t1.level +</span><br><span class="line">                <span class="string">&quot;, t2.level: &quot;</span> + t2.level);</span><br><span class="line">        t1 = t2;</span><br><span class="line">        System.out.print(<span class="string">&quot;2: t1.level: &quot;</span> + t1.level +</span><br><span class="line">                <span class="string">&quot;, t2.level: &quot;</span> + t2.level);</span><br><span class="line">        t1.level = <span class="number">27</span>;</span><br><span class="line">        System.out.print(<span class="string">&quot;3: t1.level: &quot;</span> + t1.level +</span><br><span class="line">                <span class="string">&quot;, t2.level: &quot;</span> + t2.level);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>

<h4 id="3-4-1-Aliasing-during-method-calls"><a href="#3-4-1-Aliasing-during-method-calls" class="headerlink" title="3.4.1 Aliasing during method calls"></a>3.4.1 Aliasing during method calls</h4><p>Aliasing will also occur when you <strong>pass an object into a method</strong>: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//: operators/PassObject.java</span></span><br><span class="line"><span class="comment">// Passing objects to methods may not be</span></span><br><span class="line"><span class="comment">// what you’re used to.</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> net.mindview.util.Print.*;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Letter</span> &#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PassObject</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(Letter y)</span> &#123;</span><br><span class="line">        y.c = ‘z’;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Letter</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Letter</span>();</span><br><span class="line">        x.c = ‘a’;</span><br><span class="line">        print(<span class="string">&quot;1: x.c: &quot;</span> + x.c);</span><br><span class="line">        f(x);</span><br><span class="line">        print(<span class="string">&quot;2: x.c: &quot;</span> + x.c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">1: x.c: a</span></span><br><span class="line"><span class="comment">2: x.c: z</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~ </span></span><br></pre></td></tr></table></figure>

<p>In many programming languages, the method f( ) would appear to be <strong>making a copy of its argument Letter y inside the scope of the method</strong>. But once again a <strong><u>reference</u></strong> is being passed, so the line </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y.c = ‘z’; </span><br></pre></td></tr></table></figure>

<p>is actually changing the object outside of f( ). </p>
<hr>

<h4 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3"></a>Exercise 3</h4><p>Create a class containing a float and use it to demonstrate aliasing during method calls. </p>
<p>pass</p>
<hr>

<h3 id="3-5-Mathematical-operators"><a href="#3-5-Mathematical-operators" class="headerlink" title="3.5 Mathematical operators"></a>3.5 Mathematical operators</h3><p>The basic mathematical operators are the same as the ones available in most programming languages: addition (+), subtraction (-), division (&#x2F;), multiplication (*) and modulus (%, which produces the remainder from integer division). <strong>Integer division truncates, rather than rounds, the result.</strong></p>
<p>Java also uses the shorthand notation from C&#x2F;C++ that performs an operation and an assignment at the same time. This is denoted by an operator followed by an equal sign, and is consistent with all the operators in the language (whenever it makes sense). For example, to add 4 to the variable x and assign the result to x, use: x +&#x3D; 4. </p>
<p>The program generates a number of different types of random numbers with the <strong>Random</strong> object simply by calling the methods <strong>nextInt( )</strong> and <strong>nextFloat( )</strong> (you can also call <strong>nextLong( )</strong> or <strong>nextDouble( )</strong>). The argument to <strong>nextInt( )</strong> sets the upper bound on the generated number. The lower bound is zero, which we don’t want because of the possibility of a divide-by-zero, so the result is offset by one.</p>
<hr>

<h4 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4"></a>Exercise 4</h4><p>Write a program that calculates velocity using a constant distance and a constant time. </p>
<p>pass</p>
<hr>

<h4 id="3-5-1-Unary-minus-and-plus-operators"><a href="#3-5-1-Unary-minus-and-plus-operators" class="headerlink" title="3.5.1 Unary minus and plus operators"></a>3.5.1 Unary minus and plus operators</h4><p>pass</p>
<hr>

<h3 id="3-6-Auto-increment-and-decrement"><a href="#3-6-Auto-increment-and-decrement" class="headerlink" title="3.6 Auto increment and decrement"></a>3.6 Auto increment and decrement</h3><p>Two of the nicer shortcuts are the increment and decrement operators (often referred to as the auto-increment and auto-decrement operators). The decrement operator is – and means “decrease by one unit.” The increment operator is ++ and means “increase by one unit.” If a is an int, for example, the expression ++a is equivalent to (a &#x3D; a + 1). Increment and decrement operators not only modify the variable, but also produce the value of the variable as a result. </p>
<p>There are two versions of each type of operator, often called the prefix and postfix versions. Preincrement means the ++ operator appears before the variable, and post-increment means the ++ operator appears after the variable. Similarly, pre-decrement means the – operator appears before the variable, and post-decrement means the – operator appears after the variable. For pre-increment and pre-decrement (i.e., ++a or –a), the operation is performed and the value is produced. For post-increment and post-decrement (i.e., a++ or a–), the value is produced, then the operation is performed.</p>
<hr>

<h3 id="3-7-Relational-operators"><a href="#3-7-Relational-operators" class="headerlink" title="3.7 Relational operators"></a>3.7 Relational operators</h3><p>Relational operators generate a boolean result. They evaluate the relationship between the values of the operands. A relational expression produces true if the relationship is true, and false if the relationship is untrue. The relational operators are less than (&lt;), greater than (&gt;), less than or equal to (&lt;&#x3D;), greater than or equal to (&gt;&#x3D;), equivalent (&#x3D;&#x3D;) and not equivalent (!&#x3D;). Equivalence and nonequivalence work with all primitives, but the other comparisons won’t work with type boolean. Because boolean values can only be true or false, “greater than” and “less than” doesn’t make sense. </p>
<hr>

<h4 id="3-7-1-Testing-object-equivalence"><a href="#3-7-1-Testing-object-equivalence" class="headerlink" title="3.7.1 Testing object equivalence"></a>3.7.1 Testing object equivalence</h4><p>The relational operators &#x3D;&#x3D; and !&#x3D; also work with all objects, but their meaning often confuses the first-time Java programmer.</p>
<hr>

<h4 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5"></a>Exercise 5</h4><p>Create a class called Dog containing two Strings: name and says. In main( ), create two dog objects with names “spot” (who says, “Ruff!”) and “scruffy” (who says, “Wurf!”). Then display their names and what they say. </p>
<p>pass</p>
<hr>

<h4 id="Exercise-6"><a href="#Exercise-6" class="headerlink" title="Exercise 6"></a>Exercise 6</h4><p>Following Exercise 5, create a new Dog reference and assign it to spot’s object. Test for comparison using &#x3D;&#x3D; and equals( ) for all references. </p>
<hr>

<h3 id="3-8-Logical-operators"><a href="#3-8-Logical-operators" class="headerlink" title="3.8 Logical operators"></a>3.8 Logical operators</h3><p>Each of the logical operators AND (&amp;&amp;), OR (||) and NOT (!) produces a boolean value of true or false based on the logical relationship of its arguments. </p>
<p>You can apply AND, OR, or NOT to boolean values only. <strong>You can’t use a non-boolean as if it were a boolean in a logical expression as you can in C and C++</strong>. You can see the failed attempts at doing this commented out with a ‘&#x2F;&#x2F;!’ (this comment syntax enables automatic removal of comments to facilitate testing). The subsequent expressions, however, produce boolean values using relational comparisons, then use logical operations on the results. </p>
<hr>

<h4 id="Exercise-7"><a href="#Exercise-7" class="headerlink" title="Exercise 7"></a>Exercise 7</h4><p>Write a program that simulates coin-flipping.</p>
<hr>

<h4 id="3-8-1-Short-circuiting"><a href="#3-8-1-Short-circuiting" class="headerlink" title="3.8.1 Short-circuiting"></a>3.8.1 Short-circuiting</h4><p>When dealing with logical operators, you run into a phenomenon called “short-circuiting.” This means that the expression will be evaluated only until the truth or falsehood of the entire expression can be unambiguously determined. As a result, the latter parts of a logical expression might not be evaluated.</p>
<hr>

<h3 id="3-9-Literals"><a href="#3-9-Literals" class="headerlink" title="3.9 Literals"></a>3.9 Literals</h3><p>pass</p>
<hr>

<h4 id="Exercise-8"><a href="#Exercise-8" class="headerlink" title="Exercise 8"></a>Exercise 8</h4><p>Show that hex and octal notations work with long values. Use Long.toBinaryString( ) to display the results. </p>
<p>pass</p>
<hr>

<h4 id="3-9-1-Exponential-notation"><a href="#3-9-1-Exponential-notation" class="headerlink" title="3.9.1 Exponential notation"></a>3.9.1 Exponential notation</h4><p>pass</p>
<hr>

<h4 id="Exercise-9"><a href="#Exercise-9" class="headerlink" title="Exercise 9"></a>Exercise 9</h4><p>Display the largest and smallest numbers for both float and double exponential notation.</p>
<p>pass</p>
<hr>

<h3 id="3-10-Bitwise-operators"><a href="#3-10-Bitwise-operators" class="headerlink" title="3.10 Bitwise operators"></a>3.10 Bitwise operators</h3><p>pass</p>
<hr>

<h4 id="Exercise-10"><a href="#Exercise-10" class="headerlink" title="Exercise 10"></a>Exercise 10</h4><p>Write a program with two constant values, one with alternating binary ones and zeroes, with a zero in the least-significant digit, and the second, also alternating, with a one in the least-significant digit (hint: It’s easiest to use hexadecimal constants for this). Take these two values and combine them in all possible ways using the bitwise operators, and display the results using Integer.toBinaryString( ). </p>
<hr>

<h3 id="3-11-Shift-operators"><a href="#3-11-Shift-operators" class="headerlink" title="3.11 Shift operators"></a>3.11 Shift operators</h3><p>pass</p>
<hr>

<h4 id="Exercise-11"><a href="#Exercise-11" class="headerlink" title="Exercise 11"></a>Exercise 11</h4><p>Start with a number that has a binary one in the most significant position (hint: Use a hexadecimal constant). Using the signed right-shift operator, right shift it all the way through all of its binary positions, each time displaying the result using Integer.toBinaryString( ). </p>
<p>pass</p>
<hr>

<h4 id="Exercise-12"><a href="#Exercise-12" class="headerlink" title="Exercise 12"></a>Exercise 12</h4><p>Start with a number that is all binary ones. Left shift it, then use the unsigned right-shift operator to right shift through all of its binary positions, each time displaying the result using Integer.toBinaryString( ). </p>
<p>pass</p>
<hr>

<h4 id="Exercise-13"><a href="#Exercise-13" class="headerlink" title="Exercise 13"></a>Exercise 13</h4><p>Write a method that displays char values in binary form. Demonstrate it using several different characters. </p>
<p>pass</p>
<hr>

<h3 id="3-12-Ternary-if-else-operator"><a href="#3-12-Ternary-if-else-operator" class="headerlink" title="3.12 Ternary if-else operator"></a>3.12 Ternary if-else operator</h3><p>pass</p>
<hr>

<h3 id="3-13-String-operator-and"><a href="#3-13-String-operator-and" class="headerlink" title="3.13 String operator + and +&#x3D;"></a>3.13 String operator + and +&#x3D;</h3><p>pass</p>
<hr>

<h3 id="3-14-Common-pitfalls-when-using-operators"><a href="#3-14-Common-pitfalls-when-using-operators" class="headerlink" title="3.14 Common pitfalls when using operators"></a>3.14 Common pitfalls when using operators</h3><p>pass</p>
<hr>

<h3 id="3-15-Casting-operators"><a href="#3-15-Casting-operators" class="headerlink" title="3.15 Casting operators"></a>3.15 Casting operators</h3><p>pass</p>
<hr>

<h4 id="3-15-1-Truncation-and-rounding"><a href="#3-15-1-Truncation-and-rounding" class="headerlink" title="3.15.1 Truncation and rounding"></a>3.15.1 Truncation and rounding</h4><p>pass</p>
<hr>

<h4 id="3-15-2-Promotion"><a href="#3-15-2-Promotion" class="headerlink" title="3.15.2 Promotion"></a>3.15.2 Promotion</h4><p><strong>You’ll discover that if you perform any mathematical or bitwise operations on primitive data types that are smaller than an int (that is, char, byte, or short), those values will be promoted to int before performing the operations, and the resulting value will be of type int</strong>. So if you want to assign back into the smaller type, you must use a cast. (And, since you’re assigning back into a smaller type, you might be losing information.) In general, the largest data type in an expression is the one that determines the size of the result of that expression; if you multiply a float and a double, the result will be double; if you add an int and a long, the result will be long. </p>
<hr>

<h3 id="3-16-Java-has-no-“sizeof”"><a href="#3-16-Java-has-no-“sizeof”" class="headerlink" title="3.16 Java has no “sizeof”"></a>3.16 Java has no “sizeof”</h3><p>pass</p>
<hr>

<h3 id="3-17-A-compendium-of-operators"><a href="#3-17-A-compendium-of-operators" class="headerlink" title="3.17 A compendium of operators"></a>3.17 A compendium of operators</h3><p>pass</p>
<hr>

<h3 id="3-18-Summary"><a href="#3-18-Summary" class="headerlink" title="3.18 Summary"></a>3.18 Summary</h3><p>pass</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-02-10T05:20:00.000Z" title="2025/2/10 13:20:00">2025-02-10</time>发表</span><span class="level-item"><time dateTime="2025-02-12T02:38:40.051Z" title="2025/2/12 10:38:40">2025-02-12</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/Java/basics/">basics</a><span> / </span><a class="link-muted" href="/categories/Java/basics/Thinking-in-Java/">Thinking in Java</a></span><span class="level-item">1 小时读完 (大约7753个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/02/10/Thinking-in-Java/Thinking-in-Java-pt-2/">Thinking in Java pt.2</a></p><div class="content"><h2 id="Chapter-2-Everything-Is-an-Object"><a href="#Chapter-2-Everything-Is-an-Object" class="headerlink" title="Chapter 2 Everything Is an Object"></a>Chapter 2 Everything Is an Object</h2><p><u><strong>Although it is based on C++, Java is more of a “pure” object-oriented language.</strong></u> </p>
<p>Both C++ and Java are hybrid languages, but in Java the designers felt that the hybridization was not as important as it was in C++. A hybrid language allows multiple programming styles; the reason C++ is hybrid is to support backward compatibility with the C language. Because C++ is a superset of the C language, it includes many of that language’s undesirable features, which can make some aspects of C++ overly complicated. </p>
<p>The Java language assumes that you want to do only object-oriented programming. This means that before you can begin you must shift your mindset into an object-oriented world (unless it’s already there). The benefit of this initial effort is the ability to program in a language that is simpler to learn and to use than many other OOP languages. In this chapter you’ll see the basic components of a Java program and learn that (almost) everything in Java is an object.</p>
<hr >

<h3 id="2-1-You-manipulate-objects-with-references"><a href="#2-1-You-manipulate-objects-with-references" class="headerlink" title="2.1 You manipulate objects with references"></a>2.1 You manipulate objects with references</h3><p>You treat everything as an object, using a single consistent syntax. Although you treat everything as an object, the identifier you manipulate is actually <u>a “reference” to an object</u>[^1]</p>
<p>You might imagine a television (the object) and a remote control (the reference). As long as you’re holding this reference, you have a connection to the television, but when someone says, “Change the channel” or “Lower the volume,” what you’re manipulating is the reference, which in turn modifies the object. If you want to move around the room and still control the television, you take the remote&#x2F;reference with you, not the television. </p>
<p>[^1]: This can be a flashpoint. There are those who say, “Clearly, it’s a pointer,” but this presumes an underlying implementation. Also, Java references are much more akin to C++ references than to pointers in their syntax. In the 1st edition of this book, I chose to invent a new term, “handle,” because C++ references and Java references have some important differences. I was coming out of C++ and did not want to confuse the C++ programmers whom I assumed would be the largest audience for Java. In the 2nd edition, I decided that “reference” was the more commonly used term, and that anyone changing from C++ would have a lot more to cope with than the terminology of references, so they might as well jump in with both feet. However, there are people who disagree even with the term “reference.” I read in one book where it was “completely wrong to say that Java supports pass by reference,” because Java object identifiers (according to that author) are actually “object references.” And (he goes on) everything is actually pass by value. So you’re not passing by reference, you’re “passing an object reference by value.” One could argue for the precision of such convoluted explanations, but I think my approach simplifies the understanding of the concept without hurting anything (well, the language lawyers may claim that I’m lying to you, but I’ll say that I’m providing an appropriate abstraction).</p>
<hr>

<h3 id="2-2-You-must-create-all-the-objects"><a href="#2-2-You-must-create-all-the-objects" class="headerlink" title="2.2 You must create all the objects"></a>2.2 You must create all the objects</h3><p>When you create a reference, you want to connect it with a new object. You do so, in general, with the <strong>new</strong> operator. The keyword <strong>new</strong> says, “Make me a new one of these objects.”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;asdf&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>Not only does this mean “Make me a new <strong>String</strong>,” but it also gives information about <em>how</em> to make the <strong>String</strong> by supplying an initial character string. </p>
<hr>

<h4 id="2-2-1-Where-storage-lives"><a href="#2-2-1-Where-storage-lives" class="headerlink" title="2.2.1 Where storage lives"></a>2.2.1 Where storage lives</h4><p>It’s useful to visualize some aspects of how things are laid out while the program is running— in particular how memory is arranged. There are five different places to store data: </p>
<ol>
<li><p><strong>Registers</strong>. This is the <strong>fastest</strong> storage because it exists in a place different from that of other storage: inside the processor. However, the number of registers is severely limited, so registers are allocated as they are needed. <strong>You don’t have direct control, nor do you see any evidence in your programs that registers even exist</strong> (C &amp; C++, on the other hand, allow you to suggest register allocation to the compiler). </p>
</li>
<li><p><strong>The stack</strong>. This lives in the general random-access memory (RAM) area, but has direct support from the processor via its <em><u>stack pointer</u></em>. The stack pointer is moved down to create new memory and moved up to release that memory. This is an extremely fast and efficient way to allocate storage, second only to registers. The Java system must know, while it is creating the program, the exact lifetime of all the items that are stored on the stack. This constraint places limits on the flexibility of your programs, <strong>so while some Java storage exists on the stack—in particular, object references—Java objects themselves are not placed on the stack.</strong> </p>
</li>
<li><p><strong>The heap</strong>. This is a general-purpose pool of memory (also in the RAM area) where <strong>all Java objects live</strong>. The nice thing about the heap is that, unlike the stack, <strong>the compiler doesn’t need to know how long that storage must stay on the heap</strong>. Thus, there’s a great deal of flexibility in using storage on the heap. Whenever you need an object, you simply write the code to create it by using <strong>new</strong>, and the storage is allocated on the heap when that code is executed. Of course there’s a price you pay for this flexibility: <strong>It may take more time to allocate and clean up heap storage than stack storage</strong> (if you even could create objects on the stack in Java, as you can in C++). </p>
</li>
<li><p><strong>Constant storage</strong>. Constant values are often placed directly in the program code, which is safe since they can never change. Sometimes constants are cordoned off by themselves so that they can be optionally placed in read-only memory (ROM), in embedded systems.[^2]</p>
<p>[^2]: An example of this is the string pool. All literal strings and string-valued constant expressions are interned automatically and put into special static storage.</p>
</li>
<li><p><strong>Non-RAM storage</strong>. If data lives completely outside a program, it can exist while the program is not running, outside the control of the program. The two primary examples of this are <em><u>streamed objects</u></em>, in which objects are turned into streams of bytes, generally to be sent to another machine, and <em><u>persistent objects</u></em>, in which the objects are placed on <strong>disk</strong> so they will hold their state even when the program is terminated. The trick with these types of storage is turning the objects into something that can exist on the other medium, and yet can be resurrected into a regular RAMbased object when necessary. <strong>Java provides support for lightweight persistence, and mechanisms such as <u>JDBC</u> and <u>Hibernate</u> provide more sophisticated support for storing and retrieving object information in databases.</strong></p>
<hr></li>
</ol>
<h4 id="2-2-2-Special-case"><a href="#2-2-2-Special-case" class="headerlink" title="2.2.2 Special case:"></a>2.2.2 Special case:</h4><h5 id="primitive-types"><a href="#primitive-types" class="headerlink" title="primitive types"></a>primitive types</h5><p>One group of types, which you’ll use quite often in your programming, gets special treatment. You can think of these as “<strong>primitive</strong>” types. The reason for the special treatment is that to create an object with <strong>new</strong>—especially a small, simple variable—isn’t very efficient, because <strong>new</strong> places objects on the heap. For these types Java falls back on the approach taken by C and C++. That is, <em><u>instead of creating the variable by using new, an “automatic” variable is created that is not a reference</u></em>. <strong>The variable holds the value directly, and it’s placed on the stack, so it’s much more efficient.</strong> </p>
<p>Java determines the size of each primitive type. <strong>These sizes don’t change from one machine architecture to another as they do in most languages</strong>. This size invariance is one reason Java programs are more portable than programs in most other languages.</p>
<table>
<thead>
<tr>
<th>Primitive type</th>
<th>Size</th>
<th>Minimum</th>
<th>Maximum</th>
<th>Wrapper type</th>
</tr>
</thead>
<tbody><tr>
<td><strong>boolean</strong></td>
<td>—</td>
<td>—</td>
<td>—</td>
<td><strong>Boolean</strong></td>
</tr>
<tr>
<td><strong>char</strong></td>
<td>16 bits</td>
<td>Unicode 0</td>
<td>Unicode (2^16) - 1</td>
<td><strong>Character</strong></td>
</tr>
<tr>
<td><strong>byte</strong></td>
<td>8 bits</td>
<td>-128</td>
<td>+127</td>
<td><strong>Byte</strong></td>
</tr>
<tr>
<td><strong>short</strong></td>
<td>16 bits</td>
<td>-2^15</td>
<td>+(2^15) - 1</td>
<td><strong>Short</strong></td>
</tr>
<tr>
<td><strong>int</strong></td>
<td>32 bits</td>
<td>-2^31</td>
<td>+(2^31) - 1</td>
<td><strong>Integer</strong></td>
</tr>
<tr>
<td><strong>long</strong></td>
<td>64 bits</td>
<td>-2^63</td>
<td>+(2^63) - 1</td>
<td><strong>Long</strong></td>
</tr>
<tr>
<td><strong>float</strong></td>
<td>32 bits</td>
<td>IEEE754</td>
<td>IEEE754</td>
<td><strong>Float</strong></td>
</tr>
<tr>
<td><strong>double</strong></td>
<td>64 bits</td>
<td>IEEE754</td>
<td>IEEE754</td>
<td><strong>Double</strong></td>
</tr>
<tr>
<td><strong>void</strong></td>
<td>—</td>
<td>—</td>
<td>—</td>
<td><strong>Void</strong></td>
</tr>
</tbody></table>
<p><strong><u>All numeric types are signed, so don’t look for unsigned types.</u></strong> </p>
<p>The size of the <strong>boolean</strong> type is not explicitly specified; it is only defined to be able to take the literal values <strong>true</strong> or <strong>false</strong>. </p>
<p>The “wrapper” classes for the primitive data types allow you to make a non-primitive object on the heap <strong>to represent that primitive type</strong>. For example: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> ‘x’;</span><br><span class="line"><span class="type">Character</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Character</span>(c);</span><br><span class="line"><span class="comment">// Or you could also use:</span></span><br><span class="line"><span class="type">Character</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Character</span>(‘x’);</span><br><span class="line"><span class="comment">// Java SE5 autoboxing will automatically convert from a primitive to a wrapper type:</span></span><br><span class="line"><span class="type">Character</span> <span class="variable">ch</span> <span class="operator">=</span> ‘x’; </span><br><span class="line"><span class="comment">// and back:</span></span><br><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> ch; </span><br></pre></td></tr></table></figure>

<p><strong>The reasons for wrapping primitives will be shown in a later chapter.</strong> </p>
<h5 id="High-precision-numbers"><a href="#High-precision-numbers" class="headerlink" title="High-precision numbers"></a>High-precision numbers</h5><p>Java includes two classes for performing high-precision arithmetic: <strong>BigInteger</strong> and <strong>BigDecimal</strong>. Although these approximately fit into the same category as the “wrapper” classes, <strong>neither one has a primitive analogue</strong>. </p>
<p>Both classes have methods that provide analogues for the operations that you perform on primitive types. That is, you can do anything with a <strong>BigInteger</strong> or <strong>BigDecimal</strong> that you can with an <strong>int</strong> or <strong>float</strong>, it’s just that you must use method calls instead of operators. Also, since there’s more involved, the operations will be slower. <u><strong>You’re exchanging speed for accuracy.</strong></u> </p>
<ul>
<li><p><strong>BigInteger</strong> supports arbitrary-precision integers. This means that you can accurately represent integral values of any size <strong>without losing any information during operations</strong>. </p>
</li>
<li><p><strong>BigDecimal</strong> is for arbitrary-precision fixed-point numbers; you can use these for <strong>accurate monetary calculations</strong>, for example.</p>
</li>
</ul>
<p>Consult the JDK documentation for details about the constructors and methods you can call for these two classes. </p>
<hr>

<h4 id="2-2-3-Arrays-in-Java"><a href="#2-2-3-Arrays-in-Java" class="headerlink" title="2.2.3 Arrays in Java"></a>2.2.3 Arrays in Java</h4><p>One of the primary goals of Java is safety, so many of the problems that plague programmers in C and C++ are not repeated in Java. <strong><u>A Java array is guaranteed to be initialized and cannot be accessed outside of its range.</u></strong> The range checking comes at the price of having a small amount of memory overhead on each array as well as verifying the index at run time, but the assumption is that the safety and increased productivity are worth the expense (and Java can sometimes optimize these operations). </p>
<p>When you create an array of objects, you are really <strong>creating an array of references</strong>, and <strong>each of those references is automatically initialized to a special value with its own keyword: <u><em>null</em></u></strong>. When Java sees <strong>null</strong>, it recognizes that the reference in question isn’t pointing to an object. You must assign an object to each reference before you use it, and if you try to use a reference that’s still <strong>null</strong>, the problem will be reported at run time. Thus, typical array errors are prevented in Java. </p>
<p>You can also create an array of primitives. Again, the compiler guarantees initialization because <strong>it zeroes the memory for that array.</strong> </p>
<hr>

<h3 id="2-3-You-never-need-to-destroy-an-object"><a href="#2-3-You-never-need-to-destroy-an-object" class="headerlink" title="2.3 You never need to destroy an object"></a>2.3 You never need to destroy an object</h3><p>In most programming languages, the concept of the lifetime of a variable occupies a significant portion of the programming effort. How long does the variable last? If you are supposed to destroy it, when should you? Confusion over variable lifetimes can lead to a lot of bugs, and this section shows how Java greatly simplifies the issue by doing all the cleanup work for you. </p>
<hr>

<h4 id="2-3-1-Scoping"><a href="#2-3-1-Scoping" class="headerlink" title="2.3.1 Scoping"></a>2.3.1 Scoping</h4><p>Most procedural languages have the concept of <em><u>scope</u></em>. This determines both the visibility and lifetime of the names defined within that scope. In C, C++, and Java, scope is determined by the placement of curly braces <strong>{}</strong>. So for example: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> 	<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line"> 	<span class="comment">// Only x available</span></span><br><span class="line">	&#123;</span><br><span class="line"> 		<span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> <span class="number">96</span>;</span><br><span class="line"> 		<span class="comment">// Both x &amp; q available</span></span><br><span class="line">	&#125;</span><br><span class="line"> 	<span class="comment">// Only x available</span></span><br><span class="line"> 	<span class="comment">// q is &quot;out of scope&quot;</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>A variable defined within a scope is available only to the end of that scope.</strong></p>
<p>Any text after a ‘&#x2F;&#x2F;’ to the end of a line is a <strong>comment</strong>. </p>
<p>Indentation makes Java code <strong><u>easier to read</u></strong>. Since Java is a <em>free-form</em> language, the extra spaces, tabs, and carriage returns do not affect the resulting program. </p>
<p>You <em><u>cannot</u></em> do the following, even though it is legal in C and C++:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">12</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">96</span>; <span class="comment">// Illegal</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The compiler will announce that the variable <strong>x</strong> has already been defined. Thus the C and C++ ability to “hide” a variable in a larger scope is not allowed, because the Java designers thought that it led to confusing programs. </p>
<hr>

<h4 id="2-3-2-Scope-of-objects"><a href="#2-3-2-Scope-of-objects" class="headerlink" title="2.3.2 Scope of objects"></a>2.3.2 Scope of objects</h4><p><strong>Java objects <u>do not</u> have the same lifetimes as primitives</strong>. When you create a Java object using new, <strong>it hangs around past the end of the scope</strong>. Thus if you use: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> 	<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a string&quot;</span>);</span><br><span class="line">&#125; 	<span class="comment">// End of scope </span></span><br></pre></td></tr></table></figure>

<p>the reference <strong>s</strong> vanishes at the end of the scope. However, <strong>the String object</strong> that <strong>s</strong> was pointing to is <strong>still occupying memory</strong>. In this bit of code, <strong>there is no way to access the object after the end of the scope, because the only reference to it is out of scope</strong>. In later chapters you’ll see how the reference to the object can be passed around and duplicated during the course of a program. </p>
<p>It turns out that because objects created with <strong>new</strong> stay around for <strong>as long as you want them</strong>, a whole slew of C++ programming problems simply vanish in Java. In C++ you must not only make sure that the objects stay around for as long as you need them, you must also destroy the objects when you’re done with them. </p>
<p>That brings up an interesting question. If Java leaves the objects lying around, what keeps them from filling up memory and halting your program? This is exactly the kind of problem that would occur in C++. This is where a bit of magic happens. Java has a <em><u>garbage collector</u></em>, which <strong>looks at all the objects that were created with <u>new</u></strong> and <strong>figures out which ones are not being referenced anymore</strong>. Then it <strong>releases the memory for those objects</strong>, so the memory can be used for new objects. This means that you never need to worry about reclaiming memory yourself. You simply create objects, and when you no longer need them, they will go away by themselves. This eliminates a certain class of programming problem: the so-called “<em>memory leak</em>,” in which a programmer forgets to release memory. </p>
<hr>

<h3 id="2-4-Creating-new-data-types-class"><a href="#2-4-Creating-new-data-types-class" class="headerlink" title="2.4 Creating new data types: class"></a>2.4 Creating new data types: class</h3><p>If everything is an object, what determines how a particular class of object looks and behaves? Put another way, what establishes the type of an object? You might expect there to be a keyword called “type,” and that certainly would have made sense. Historically, however, most objectoriented languages have used the keyword <strong>class</strong> to mean “I’m about to tell you what a new type of object looks like.” The <strong>class</strong> keyword (which is so common that it will not usually be boldfaced throughout this book) is followed by the name of the new type. For example: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ATypeName</span> &#123;</span><br><span class="line">    <span class="comment">/* Class body goes here */</span> </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>This introduces a new type, although the class body consists only of a comment (the stars and slashes and what is inside, which will be discussed later in this chapter), so there is not too much that you can do with it. However, you can create an object of this type using <strong>new</strong>: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ATypeName</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ATypeName</span>(); </span><br></pre></td></tr></table></figure>

<p>But you cannot tell it to do much of anything (that is, you cannot send it any interesting messages) until you define some methods for it. </p>
<hr>

<h4 id="2-4-1-Fields-and-methods"><a href="#2-4-1-Fields-and-methods" class="headerlink" title="2.4.1 Fields and methods"></a>2.4.1 Fields and methods</h4><p>When you define a class (and all you do in Java is define classes, make objects of those classes, and send messages to those objects), you can put two types of elements in your class: <em><u>fields</u></em> (sometimes called <strong>data</strong> <strong>members</strong>), and <em><u>methods</u></em> (sometimes called <strong>member</strong> <strong>functions</strong>). A <em>field</em> is an object of any type that you can talk to via its reference, or a primitive type. If it is a reference to an object, <strong>you must initialize that reference to connect it to an actual object</strong> (using <strong>new</strong>, as seen earlier). </p>
<p>Each object keeps its own storage for its fields; <strong>ordinary fields are <u>not shared</u> among objects</strong>. Here is an example of a class with some fields: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DataOnly</span> &#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"> 	<span class="type">double</span> d;</span><br><span class="line">    <span class="type">boolean</span> b;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>This class doesn’t <em>do</em> anything except hold data. But you can create an object like this: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DataOnly</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOnly</span>(); </span><br></pre></td></tr></table></figure>

<p>You can assign values to the fields, but you must first know how to refer to a member of an object. This is accomplished by <strong>stating the name of the object reference, followed by a period (dot), followed by the name of the member inside the object</strong>: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objectReference.member </span><br></pre></td></tr></table></figure>

<p>For example: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data.i = <span class="number">47</span>;</span><br><span class="line">data.d = <span class="number">1.1</span>;</span><br><span class="line">data.b = <span class="literal">false</span>; </span><br></pre></td></tr></table></figure>

<p>It is also possible that your object might contain other objects that contain data you’d like to modify. For this, you just keep “connecting the dots.” For example: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myPlane.leftTank.capacity = <span class="number">100</span>; </span><br></pre></td></tr></table></figure>

<p>The <strong>DataOnly</strong> class cannot do much of anything except hold data, because it has no methods. To understand how those work, you must first understand <em><u>arguments</u></em> and <em><u>return values</u></em>, which will be described shortly. </p>
<hr>

<h4 id="2-4-2-Default-values-for-primitive-members"><a href="#2-4-2-Default-values-for-primitive-members" class="headerlink" title="2.4.2 Default values for primitive members"></a>2.4.2 Default values for primitive members</h4><p>When a primitive data type is a member of a class, it is guaranteed to get a default value if you do not initialize it: </p>
<table>
<thead>
<tr>
<th>Primitive type</th>
<th>Default</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>false</td>
</tr>
<tr>
<td>char</td>
<td>‘\u0000’ (null)</td>
</tr>
<tr>
<td>byte</td>
<td>(byte)0</td>
</tr>
<tr>
<td>short</td>
<td>(short)0</td>
</tr>
<tr>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>0L</td>
</tr>
<tr>
<td>float</td>
<td>0.0f</td>
</tr>
<tr>
<td>double</td>
<td>0.0d</td>
</tr>
</tbody></table>
<p>The default values are only what Java guarantees when the variable is used as a <em><u>member of a class</u></em>. This ensures that member variables of primitive types will always be initialized (something C++ doesn’t do), reducing a source of bugs. However, this initial value may not be correct or even legal for the program you are writing. <strong>It’s best to always explicitly initialize your variables.</strong> </p>
<p>This guarantee doesn’t apply to *<u>local variables</u>*—those that are not fields of a class. Thus, if within a method definition you have: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br></pre></td></tr></table></figure>

<p>Then <strong>x</strong> will get some <strong>arbitrary value</strong> (as in C and C++); it will <strong>not</strong> automatically be initialized to zero. You are responsible for <strong>assigning an appropriate value before you use x</strong>. If you forget, Java definitely improves on C++: You get a compile-time error telling you the variable might not have been initialized. (Many C++ compilers will warn you about uninitialized variables, but in Java these are errors.) </p>
<hr>

<h3 id="2-5-Methods-arguments-and-return-values"><a href="#2-5-Methods-arguments-and-return-values" class="headerlink" title="2.5 Methods, arguments, and return values"></a>2.5 Methods, arguments, and return values</h3><p>Methods in Java determine the messages an object can receive. The fundamental parts of a method are the <u><em>name</em></u>, <u><em>the arguments</em></u>, <u><em>the return type</em></u>, and <u><em>the body</em></u>. Here is the basic form: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReturnType <span class="title function_">methodName</span><span class="params">( <span class="comment">/* Argument list */</span> )</span> &#123;</span><br><span class="line">	<span class="comment">/* Method body */</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>The return type describes the value that comes back from the method after you call it. The argument list gives the types and names for the information that you want to pass into the method. The <u>method name</u> and <u>argument list</u> (which is called the <em><u>signature of the method</u></em>) uniquely identify that method. </p>
<p>Methods in Java can be created only as part of a class. A method can be called only for an object[^3], and that object must be able to perform that method call. If you try to call the wrong method for an object, you’ll get an error message at compile time. You call a method for an object by <strong>naming the object followed by a period (dot), followed by the name of the method and its argument list</strong>, like this: </p>
<p>[^3]: static methods, which you’ll learn about soon, can be called for the class, without an object.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objectName.methodName(arg1, arg2, arg3); </span><br></pre></td></tr></table></figure>

<p>For example, suppose you have a method <strong>f( )</strong> that takes no arguments and returns a value of type <strong>int</strong>. Then, if you have an object called <strong>a</strong> for which <strong>f( )</strong> can be called, you can say this: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> a.f(); </span><br></pre></td></tr></table></figure>

<p><strong>The type of the return value must be compatible with the type of <u>x</u>.</strong> This act of calling a method is commonly referred to as <em><u>sending a message to an object</u></em>. In the preceding example, the message is <strong>f( )</strong> and the object is <strong>a</strong>. Object-oriented programming is often summarized as simply “sending messages to objects.” </p>
<hr>

<h4 id="2-5-1-The-argument-list"><a href="#2-5-1-The-argument-list" class="headerlink" title="2.5.1 The argument list"></a>2.5.1 The argument list</h4><p>Consider a method that takes a <strong>String</strong> as its argument. Here is the definition, which must be placed within a class definition for it to be compiled: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">storage</span><span class="params">(String s)</span> &#123;</span><br><span class="line"> 	<span class="keyword">return</span> s.length() * <span class="number">2</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>This method tells you how many bytes are required to hold the information in a particular <strong>String</strong>. (<strong>The size of each <u>char</u> in a String is <u><em>16 bits, or two bytes, to support Unicode characters</em></u></strong>) The argument is of type <strong>String</strong> and is called <strong>s</strong>. Once <strong>s</strong> is passed into the method, you can treat it just like any other object. (You can send messages to it.) Here, the <strong>length( )</strong> method is called, which is one of the methods for <strong>Strings</strong>; it returns the number of characters in a string. </p>
<p>You can also see the use of the <strong>return</strong> keyword, which does two things. First, it means “Leave the method, I’m done.” Second, if the method produces a value, that value is placed right after the <strong>return</strong> statement. In this case, the return value is produced by evaluating the expression <strong>s.length( ) * 2</strong>. </p>
<p>You can return any type you want, but <strong>if you don’t want to return anything at all</strong>, you do so by indicating that the method returns <strong>void</strong>. Here are some examples: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">flag</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">naturalLogBase</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="number">2.718</span>; &#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">nothing</span><span class="params">()</span> &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">nothing2</span><span class="params">()</span> &#123;&#125; </span><br></pre></td></tr></table></figure>

<p>When the return type is <strong>void</strong>, then the <strong>return</strong> keyword is used only to exit the method, and is therefore unnecessary when you reach the end of the method. You can return from a method at any point, but if you’ve given a <strong>non-void</strong> return type, then the compiler will force you (with error messages) to return the appropriate type of value regardless of where you return.</p>
<hr>

<h3 id="2-6-Building-a-Java-program"><a href="#2-6-Building-a-Java-program" class="headerlink" title="2.6 Building a Java program"></a>2.6 Building a Java program</h3><h4 id="2-6-1-Name-visibility"><a href="#2-6-1-Name-visibility" class="headerlink" title="2.6.1 Name visibility"></a>2.6.1 Name visibility</h4><p>To produce an unambiguous name for a library, the Java creators want you to use your Internet domain name in reverse since domain names are guaranteed to be unique. Since my domain name is <strong>MindView.net</strong>, my utility library of foibles would be named <strong>net.mindview.utility.foibles</strong>. After your reversed domain name, the dots are intended to represent subdirectories. </p>
<p>This mechanism means that all of your files automatically live in their own namespaces, and each class within a file must have a unique identifier—the language prevents name clashes for you. </p>
<hr>

<h4 id="2-6-2-Using-other-components"><a href="#2-6-2-Using-other-components" class="headerlink" title="2.6.2 Using other components"></a>2.6.2 Using other components</h4><p>This is accomplished by telling the Java compiler exactly what classes you want by using the <strong>import</strong> keyword. <strong>import</strong> tells the compiler to bring in a package, which is a library of classes. (In other languages, a library could consist of functions and data as well as classes, but remember that all code in Java must be written inside a class.) </p>
<p>Most of the time you’ll be using components from the standard Java libraries that come with your compiler. With these, you don’t need to worry about long, reversed domain names; you just say, for example: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList; </span><br></pre></td></tr></table></figure>

<p>to tell the compiler that you want to use Java’s <strong>ArrayList</strong> class. However, <strong>util</strong> contains a number of classes, and you might want to use several of them without declaring them all explicitly. This is easily accomplished by using ‘*****’ to indicate a wild card: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.utils.*;</span><br></pre></td></tr></table></figure>

<p>It is more common to import a collection of classes in this manner than to import classes individually. </p>
<hr>

<h4 id="2-6-3-The-static-keyword"><a href="#2-6-3-The-static-keyword" class="headerlink" title="2.6.3 The static keyword"></a>2.6.3 The <em><strong>static</strong></em> keyword</h4><p>There are two situations in which this approach is not sufficient. One is if you want to have only a single piece of storage for a particular field, regardless of how many objects of that class are created, or even if no objects are created. The other is if you need a method that isn’t associated with any particular object of this class. That is, you need a method that you can call even if no objects are created. </p>
<p>You can achieve both of these effects with the <strong>static</strong> keyword. When you say something is <strong>static</strong>, it means that particular field or method is not tied to any particular object instance of that class. So even if you’ve never created an object of that class you can call a <strong>static</strong> method or access a static field. With ordinary, <strong>non-static</strong> fields and methods, you must create an object and use that object to access the field or method, since <strong>non-static</strong> fields and methods must know the particular object they are working with[^4].</p>
<p>[^4]: Of course, since static methods don’t need any objects to be created before they are used, they cannot directly access non-static members or methods by simply calling those other members without referring to a named object (since nonstatic members and methods must be tied to a particular object).</p>
<p>To make a field or method <strong>static</strong>, you simply place the keyword before the definition. For example, the following produces a <strong>static</strong> field and initializes it: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StaticTest</span> &#123;</span><br><span class="line"> 	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">47</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>Now even if you make two <strong>StaticTest</strong> objects, there will still be only one piece of storage for <strong>StaticTest.i</strong>. Both objects will share the same <strong>i</strong>. Consider: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StaticTest</span> <span class="variable">st1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticTest</span>();</span><br><span class="line"><span class="type">StaticTest</span> <span class="variable">st2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticTest</span>();</span><br></pre></td></tr></table></figure>

<p>At this point, both <strong>st1.i</strong> and <strong>st2.i</strong> have the same value of 47 since they refer to the same piece of memory. </p>
<p>There are two ways to refer to a <strong>static</strong> variable. As the preceding example indicates, you can name it via an object, by saying, for example, <strong>st2.i</strong>. You can also refer to it directly through its <em><u>class name</u></em>, something you cannot do with a <strong>non-static</strong> member. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StaticTest.i++; </span><br></pre></td></tr></table></figure>

<p>The <strong>++</strong> operator adds one to the variable. At this point, both <strong>st1.i</strong> and <strong>st2.i</strong> will have the value 48.</p>
<p><strong>Using the class name is the preferred way to refer to a static variable</strong>. Not only does it emphasize that variable’s static nature, but in some cases it gives the compiler better opportunities for optimization. </p>
<p>Similar logic applies to <strong>static methods</strong>. You can refer to a <strong>static method</strong> either through an object as you can with any method, or with the special additional syntax <strong>ClassName.method( )</strong>. You define a <strong>static method</strong> in a similar way:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Incrementable</span> &#123;</span><br><span class="line"> 	<span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123; StaticTest.i++; &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>You can see that the <strong>Incrementable</strong> method <strong>increment( )</strong> increments the <strong>static data</strong> <strong>i</strong> using the <strong>++</strong> operator. You can call <strong>increment( )</strong> in the typical way, through an object: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Incrementable</span> <span class="variable">sf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Incrementable</span>();</span><br><span class="line">sf.increment(); </span><br></pre></td></tr></table></figure>

<p>Or, because <strong>increment( )</strong> is a <strong>static method</strong>, you can call it directly through its class: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Incrementable.increment(); </span><br></pre></td></tr></table></figure>

<p>Although <strong>static</strong>, when applied to a field, definitely changes the way the data is created (one for each class versus the <strong>non-static</strong> one for each object), when applied to a method it’s not so dramatic. An important use of <strong>static</strong> for methods is to allow you to call that method without creating an object. This is essential, as you will see, in defining the main( ) method that is the entry point for running an application. </p>
<hr>

<h3 id="2-7-Your-first-Java-program"><a href="#2-7-Your-first-Java-program" class="headerlink" title="2.7 Your first Java program"></a>2.7 Your first Java program</h3><p>Finally, here’s the first complete program. It starts by printing a string, and then the date, using the <strong>Date</strong> class from the Java standard library. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HelloDate.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloDate</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     	System.out.println(<span class="string">&quot;Hello, it’s: &quot;</span>);</span><br><span class="line">     	System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>The name of the class is the same as the name of the file.When you’re creating a standalone program such as this one, one of the classes in the file must have the same name as the file. (The compiler complains if you don’t do this.) That class must contain a method called <strong>main( )</strong> with this signature and return type: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br></pre></td></tr></table></figure>

<p>The <strong>public</strong> keyword means that the method is available to the outside world (described in detail in the <em>Access Control</em> chapter). The argument to <strong>main( )</strong> is an array of <strong>String</strong> objects. The <strong>args</strong> won’t be used in this program, but the Java compiler insists that they be there because they hold the arguments from the command line. </p>
<p>The line that prints the date is quite interesting: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>()); </span><br></pre></td></tr></table></figure>

<p>The argument is a <strong>Date</strong> object that is being created just to send its value (which is automatically converted to a <strong>String</strong>) to <strong>println( )</strong>. As soon as this statement is finished, that <strong>Date</strong> is unnecessary, and the garbage collector can come along and get it anytime. We don’t need to worry about cleaning it up. </p>
<p>When you look at the JDK documentation from <em><a target="_blank" rel="noopener" href="http://java.sun.com/">http://java.sun.com</a></em>, you will see that <strong>System</strong> has many other methods that allow you to produce interesting effects (one of Java’s most powerful assets is its large set of standard libraries). For example: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//: object/ShowProperties.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShowProperties</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> 	System.getProperties().list(System.out);</span><br><span class="line"> 	System.out.println(System.getProperty(<span class="string">&quot;user.name&quot;</span>));</span><br><span class="line"> 	System.out.println(</span><br><span class="line"> 		System.getProperty(<span class="string">&quot;java.library.path&quot;</span>)</span><br><span class="line">    );</span><br><span class="line"> &#125;</span><br><span class="line">&#125; <span class="comment">///:~ </span></span><br></pre></td></tr></table></figure>

<p>The first line in <strong>main( )</strong> displays all of the “properties” from the system where you are running the program, so it gives you environment information. The <strong>list( )</strong> method sends the results to its argument, <strong>System.out</strong>. You will see later in the book that you can send the results elsewhere, to a file, for example. You can also ask for a specific property—in this case, the user name and <strong>java.library.path</strong>. (The unusual comments at the beginning and end will be explained a little later.) </p>
<p>Output(part):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">-- listing properties --</span><br><span class="line">java.specification.version=17</span><br><span class="line">sun.cpu.isalist=amd64</span><br><span class="line">sun.jnu.encoding=GBK</span><br><span class="line">java.class.path=.</span><br><span class="line">java.vm.vendor=Oracle Corporation</span><br><span class="line">sun.arch.data.model=64</span><br><span class="line">java.specification.vendor=Oracle Corporation</span><br><span class="line">java.version.date=2024-01-16</span><br><span class="line">java.home=C:\Program Files\Java\jdk-17</span><br><span class="line">file.separator=\</span><br><span class="line">java.vm.compressedOopsMode=Zero based</span><br><span class="line">line.separator=</span><br><span class="line"></span><br><span class="line">sun.stdout.encoding=ms936</span><br><span class="line">java.vm.specification.vendor=Oracle Corporation</span><br><span class="line">java.specification.name=Java Platform API Specification</span><br><span class="line">user.script=</span><br><span class="line">sun.management.compiler=HotSpot 64-Bit Tiered Compilers</span><br><span class="line">java.vm.version=17.0.10+11-LTS-240</span><br><span class="line">sun.io.unicode.encoding=UnicodeLittle</span><br><span class="line">java.class.version=61.0</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<hr>

<h4 id="2-7-1-Compiling-and-running"><a href="#2-7-1-Compiling-and-running" class="headerlink" title="2.7.1 Compiling and running"></a>2.7.1 Compiling and running</h4><p>pass</p>
<hr>

<h3 id="2-8-Comments-and-embedded-documentation"><a href="#2-8-Comments-and-embedded-documentation" class="headerlink" title="2.8 Comments and embedded documentation"></a>2.8 Comments and embedded documentation</h3><p>There are two types of comments in Java. The first is the traditional C-style comment that was inherited by C++. These comments <strong>begin with a &#x2F;* and continue, possibly across many lines, until a *&#x2F;</strong>. Note that many programmers will begin each line of a continued comment with a *, so you’ll often see: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This is a comment</span></span><br><span class="line"><span class="comment"> * that continues</span></span><br><span class="line"><span class="comment"> * across lines</span></span><br><span class="line"><span class="comment"> */</span> </span><br></pre></td></tr></table></figure>

<p>Remember, however, that everything inside the <strong>&#x2F;</strong>* and ***&#x2F;** is <strong><u>ignored</u></strong>, so there’s no difference in saying: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This is a comment that</span></span><br><span class="line"><span class="comment">continues across lines */</span></span><br></pre></td></tr></table></figure>

<p>The second form of comment comes from C++. It is the <em><u>single-line comment</u></em>, which starts with a <strong>&#x2F;&#x2F;</strong> and continues until the end of the line. This type of comment is convenient and commonly used because it’s easy. You don’t need to hunt on the keyboard to find &#x2F; and then * (instead, you just press the same key twice), and you don’t need to close the comment. So you will often see: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This is a one-line comment </span></span><br></pre></td></tr></table></figure>

<hr>

<h4 id="2-8-1-Comment-documentation"><a href="#2-8-1-Comment-documentation" class="headerlink" title="2.8.1 Comment documentation"></a>2.8.1 Comment documentation</h4><p>The tool to extract the comments is called <em><u>Javadoc</u></em>, and it is part of the JDK installation. It uses some of the technology from the Java compiler to look for special comment tags that you put in your programs. It not only extracts the information marked by these tags, but it also pulls out the class name or method name that adjoins the comment. This way you can get away with the minimal amount of work to generate decent program documentation. </p>
<p>The output of Javadoc is an <strong>HTML</strong> file that you can view with your Web browser. Thus, Javadoc allows you to create and maintain a single source file and automatically generate useful documentation. Because of Javadoc, you have a straightforward standard for creating documentation, so you can expect or even demand documentation with all Java libraries. </p>
<hr>

<h4 id="2-8-2-Syntax"><a href="#2-8-2-Syntax" class="headerlink" title="2.8.2 Syntax"></a>2.8.2 Syntax</h4><p>All of the Javadoc commands occur only within <code>/**</code> comments. The comments end with <code>*/</code> as usual. There are two primary ways to use Javadoc: <em><u>Embed HTML</u></em> or use “*<u>doc tags</u>*.” Standalone doc tags are commands that start with an <code>@</code> and are placed at the beginning of a comment line. (A leading <code>*</code>, however, is ignored.) Inline doc tags can appear anywhere within a Javadoc comment and also start with an <code>@</code> <strong>but are surrounded by curly braces</strong>. </p>
<p>There are three “types” of comment documentation, which correspond to the element the comment precedes: <u>class</u>, <u>field</u>, or <u>method</u>. That is, a class comment appears right before the definition of a class, a field comment appears right in front of the definition of a field, and a method comment appears right in front of the definition of a method. As a simple example: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//: object/Documentation1.java</span></span><br><span class="line"><span class="comment">/** A class comment */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Documentation1</span> &#123;</span><br><span class="line"> <span class="comment">/** A field comment */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">int</span> i;</span><br><span class="line"> <span class="comment">/** A method comment */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125; <span class="comment">///:~ </span></span><br></pre></td></tr></table></figure>

<p>Note that Javadoc will process comment documentation for only <strong>public</strong> and <strong>protected</strong> members. Comments for <strong>private</strong> and <strong>package-access members</strong> (see the Access Control chapter) are ignored, and you’ll see no output. (<u>However, you can use the -private flag to include private members as well.</u>) This makes sense, <u>since only <strong>public</strong> and <strong>protected</strong> members are available outside the file, which is the client programmer’s perspective.</u> </p>
<p>The output for the preceding code is an HTML file that has the same standard format as all the rest of the Java documentation, so users will be comfortable with the format and can easily navigate your classes. It’s worth entering the preceding code, sending it through Javadoc, and viewing the resulting HTML file to see the results. </p>
<hr>

<h4 id="2-8-3-Embedded-HTML"><a href="#2-8-3-Embedded-HTML" class="headerlink" title="2.8.3 Embedded HTML"></a>2.8.3 Embedded HTML</h4><p>Javadoc passes HTML commands through to the generated HTML document. This allows you full use of HTML; however, the primary motive is to let you format code, such as: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//: object/Documentation2.java</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* &lt;pre&gt;</span></span><br><span class="line"><span class="comment">* System.out.println(new Date());</span></span><br><span class="line"><span class="comment">* &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">///:~ </span></span><br></pre></td></tr></table></figure>

<p>You can also use HTML just as you would in any other Web document to format the regular text in your descriptions: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//: object/Documentation3.java</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* You can &lt;em&gt;even&lt;/em&gt; insert a list:</span></span><br><span class="line"><span class="comment">* &lt;ol&gt;</span></span><br><span class="line"><span class="comment">* &lt;li&gt; Item one</span></span><br><span class="line"><span class="comment">* &lt;li&gt; Item two</span></span><br><span class="line"><span class="comment">* &lt;li&gt; Item three</span></span><br><span class="line"><span class="comment">* &lt;/ol&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">///:~ </span></span><br></pre></td></tr></table></figure>

<p>Note that within the documentation comment, asterisks at the beginning of a line are thrown away by Javadoc, along with leading spaces. Javadoc reformats everything so that it conforms to the standard documentation appearance. Don’t use headings such as </p>
<p>Note that within the documentation comment, asterisks at the beginning of a line are thrown away by Javadoc, along with leading spaces. Javadoc reformats everything so that it conforms to the standard documentation appearance. Don’t use headings such as<code>&lt;h1&gt;</code> or <code>&lt;hr&gt;</code> as embedded HTML, because Javadoc inserts its own headings and yours will interfere with them. </p>
<p>All types of comment documentation—class, field, and method—can support embedded HTML. </p>
<hr>

<h4 id="2-8-4-Some-example-tags"><a href="#2-8-4-Some-example-tags" class="headerlink" title="2.8.4 Some example tags"></a>2.8.4 Some example tags</h4><p>Here are some of the Javadoc tags available for code documentation. Before trying to do anything serious using Javadoc, you should consult the Javadoc reference in the JDK documentation to learn all the different ways that you can use Javadoc. </p>
<h5 id="1-see"><a href="#1-see" class="headerlink" title="1. @see"></a>1. @see</h5><p>This tag allows you to <strong>refer to the documentation in other classes</strong>. Javadoc will generate HTML with the <strong>@see</strong> tags hyperlinked to the other documentation. The forms are:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@see</span> classname</span><br><span class="line"><span class="meta">@see</span> fully-qualified-classname</span><br><span class="line"><span class="meta">@see</span> fully-qualified-classname#method-name </span><br></pre></td></tr></table></figure>

<p>Each one adds a hyperlinked “See Also” entry to the generated documentation. Javadoc will not check the hyperlinks you give it to make sure they are valid. </p>
<hr>

<h5 id="2-link-package-class-member-label"><a href="#2-link-package-class-member-label" class="headerlink" title="2. {@link package.class#member label}"></a>2. {@link package.class#member label}</h5><p>Very <strong>similar to @see</strong>, except that it <strong>can be used inline</strong> and uses the <strong>label</strong> as the hyperlink text rather than “See Also.” </p>
<hr>

<h5 id="3-docRoot"><a href="#3-docRoot" class="headerlink" title="3. {@docRoot}"></a>3. {@docRoot}</h5><p><strong>Produces the relative path to the documentation root directory.</strong> Useful for explicit hyperlinking to pages in the documentation tree. </p>
<hr>

<h5 id="4-inheritDoc"><a href="#4-inheritDoc" class="headerlink" title="4. {@inheritDoc}"></a>4. {@inheritDoc}</h5><p>Inherits the documentation from the nearest base class of this class into the current doc comment. </p>
<hr>

<h5 id="5-version"><a href="#5-version" class="headerlink" title="5. @version"></a>5. @version</h5><p>This is of the form: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@version</span> version-information </span><br></pre></td></tr></table></figure>

<p>in which <strong>version-information</strong> is any significant information you see fit to include. When the <strong>- version</strong> flag is placed on the Javadoc command line, the version information will be called out specially in the generated HTML documentation.</p>
<hr>

<h5 id="6-author"><a href="#6-author" class="headerlink" title="6. @author"></a>6. @author</h5><p>This is of the form:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@author</span> author-information</span><br></pre></td></tr></table></figure>

<p>in which <strong>author-information</strong> is, presumably, your name, but it could also include your email address or any other appropriate information. When the <strong>-author</strong> flag is placed on the Javadoc command line, the author information will be called out specially in the generated HTML documentation. </p>
<hr>

<h5 id="7-since"><a href="#7-since" class="headerlink" title="7. @since"></a>7. @since</h5><p>This tag allows you to <strong>indicate the version of this code that began using a particular feature</strong>. You’ll see it appearing in the HTML Java documentation to indicate what version of the JDK is used. </p>
<hr>

<h5 id="8-param"><a href="#8-param" class="headerlink" title="8. @param"></a>8. @param</h5><p>This is used for method documentation, and is of the form: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@param</span> parameter-name description</span><br></pre></td></tr></table></figure>

<p>in which <strong>parameter-name</strong> is the identifier in the method parameter list, and <strong>description</strong> is text that can continue on subsequent lines. The description is considered finished when a new documentation tag is encountered. You can have any number of these, presumably one for each parameter. </p>
<hr>

<h5 id="9-return"><a href="#9-return" class="headerlink" title="9. @return"></a>9. @return</h5><p>This is used for method documentation, and looks like this: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@return</span> description </span><br></pre></td></tr></table></figure>

<p>in which <strong>description</strong> gives you the meaning of the return value. It can continue on subsequent lines. </p>
<hr>

<h5 id="10-throws"><a href="#10-throws" class="headerlink" title="10. @throws"></a>10. @throws</h5><p>Although only one exception object can emerge when you call a method, a particular method might produce any number of different types of exceptions, all of which need descriptions. So the form for the exception tag is: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@throws</span> fully-qualified-class-name description </span><br></pre></td></tr></table></figure>

<p>in which <strong>fully-qualified-class-name</strong> gives an unambiguous name of an exception class that’s defined somewhere, and <strong>description</strong> (which can continue on subsequent lines) tells you why this particular type of exception can emerge from the method call.</p>
<hr>

<h5 id="11-deprecated"><a href="#11-deprecated" class="headerlink" title="11. @deprecated"></a>11. @deprecated</h5><p>This is used to indicate features that were superseded by an improved feature. The deprecated tag is a suggestion that you no longer use this particular feature, since sometime in the future it is likely to be removed. A method that is marked <strong>@deprecated</strong> causes the compiler to issue a warning if it is used. </p>
<p>In Java SE5, the <strong>@deprecated</strong> Javadoc tag has been superseded by the <strong>@Deprecated</strong> annotation (you’ll learn about these in the Annotations chapter). </p>
<hr>

<h4 id="2-8-5-Documentation-example"><a href="#2-8-5-Documentation-example" class="headerlink" title="2.8.5 Documentation example"></a>2.8.5 Documentation example</h4><p>Here is the first Java program again, this time with documentation comments added: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//: object/HelloDate.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/** The first Thinking in Java example program.</span></span><br><span class="line"><span class="comment"> * Displays a string and today’s date.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Bruce Eckel</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> www.MindView.net</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 4.0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloDate</span> &#123;</span><br><span class="line"> <span class="comment">/** Entry point to class &amp; application.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args array of string arguments</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> exceptions No exceptions thrown</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;Hello, it’s: &quot;</span>);</span><br><span class="line"> System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"> &#125;</span><br><span class="line">&#125; <span class="comment">/* Output: (55% match)</span></span><br><span class="line"><span class="comment">Hello, it’s:</span></span><br><span class="line"><span class="comment">Wed Oct 05 14:39:36 MDT 2005</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~ </span></span><br></pre></td></tr></table></figure>

<p>The first line of the file uses my own technique of putting a ‘&#x2F;&#x2F;:’ as <strong>a special marker for the comment line containing the source file name</strong>. That line contains the path information to the file (object indicates this chapter) followed by the file name. The last line also finishes with a comment, and this one (‘&#x2F;&#x2F;&#x2F;:~’) <strong>indicates the end of the source code listing</strong>, which allows it to be automatically updated into the text of this book after being checked with a compiler and executed. </p>
<p>The &#x2F;* Output: tag indicates <strong>the beginning of the output that will be generated by this file</strong>. In this form, it can be automatically tested to verify its accuracy. In this case, the (55% match) indicates to the testing system that <strong>the output will be fairly different from one run to the next so it should only expect a 55 percent correlation with the output shown here</strong>. Most examples in this book that produce output will contain the output in this commented form, so you can see the output and know that it is correct. </p>
<hr>

<h3 id="2-9-Coding-style"><a href="#2-9-Coding-style" class="headerlink" title="2.9 Coding style"></a>2.9 Coding style</h3><p>The style described in the <em><u>Code Conventions for the Java Programming Language</u></em>[^5] is to capitalize the first letter of a class name. If the class name consists of several words, they are run together (that is, you don’t use underscores to separate the names), and the first letter of each embedded word is capitalized, such as: </p>
<p>[^5]: <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jls/se23/html/index.html">https://docs.oracle.com/javase/specs/jls/se23/html/index.html</a> (原网站已不存在，该网站是读时添加的) To preserve space in this book and seminar presentations, not all of these guidelines could be followed, but you’ll see that the style I use here matches the Java standard as much as possible.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AllTheColorsOfTheRainbow</span> &#123; <span class="comment">// ... </span></span><br></pre></td></tr></table></figure>

<p>This is sometimes called “camel-casing.” For almost everything else—methods, fields (member variables), and object reference names—the accepted style is just as it is for classes <em>except</em> that the first letter of the identifier is lowercase. For example:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AllTheColorsOfTheRainbow</span> &#123;</span><br><span class="line"> <span class="type">int</span> anIntegerRepresentingColors;</span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">changeTheHueOfTheColor</span><span class="params">(<span class="type">int</span> newHue)</span> &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>The user must also type all these long names, so be merciful. </p>
<p>The Java code you will see in the Sun libraries also follows the placement of open-and-close curly braces that you see used in this book. </p>
<hr>

<h3 id="2-10-Summary"><a href="#2-10-Summary" class="headerlink" title="2.10 Summary"></a>2.10 Summary</h3><p>The goal of this chapter is just enough Java to understand how to write a simple program. You’ve also gotten an overview of the language and some of its basic ideas. However, the examples so far have all been of the form “Do this, then do that, then do something else.” The next two chapters will introduce the basic operators used in Java programming, and then show you how to control the flow of your program. </p>
<hr>

<h3 id="2-11-Exercises"><a href="#2-11-Exercises" class="headerlink" title="2.11 Exercises"></a>2.11 Exercises</h3><h4 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1:"></a>Exercise 1:</h4><p>Create a class containing an int and a char that are not initialized, and print their values to verify that Java performs default initialization. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">exer_1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> testInt;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> testChar;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">exer_1</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">exer_1</span>();</span><br><span class="line">        System.out.println(obj.testInt);</span><br><span class="line">        System.out.println(obj.testChar);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>output:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line"> (null)</span><br></pre></td></tr></table></figure>

<hr>

<h4 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise 2:"></a>Exercise 2:</h4><p>Following the HelloDate.java example in this chapter, create a “hello, world” program that simply displays that statement. You need only a single method in your class (the “main” one that gets executed when the program starts). Remember to make it static and to include the argument list, even though you don’t use the argument list. Compile the program with javac and run it using java. If you are using a different development environment than the JDK, learn how to compile and run programs in that environment. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">exer_2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>output:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br></pre></td></tr></table></figure>

<hr>

<h4 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3:"></a>Exercise 3:</h4><p>Find the code fragments involving ATypeName and turn them into a program that compiles and runs. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">exer_3</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">exer_3</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">exer_3</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;int i : &quot;</span> + obj.i);</span><br><span class="line">        System.out.println(<span class="string">&quot;char i : &quot;</span> + obj.c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>output:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int i : 0</span><br><span class="line">char i :  </span><br></pre></td></tr></table></figure>

<hr>

<h4 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4:"></a>Exercise 4:</h4><p>Turn the DataOnly code fragments into a program that compiles and runs. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">exer_4</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">    <span class="type">boolean</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;exer_4&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;i=&quot;</span> + i +</span><br><span class="line">                <span class="string">&quot;, d=&quot;</span> + d +</span><br><span class="line">                <span class="string">&quot;, b=&quot;</span> + b +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">exer_4</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">exer_4</span>();</span><br><span class="line"></span><br><span class="line">        obj.i = <span class="number">47</span>;</span><br><span class="line">        obj.d = <span class="number">1.1</span>;</span><br><span class="line">        obj.b = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;exer_4:&quot;</span> + obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>outputs:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exer_4:exer_4&#123;i=<span class="number">47</span>, d=<span class="number">1.1</span>, b=<span class="literal">false</span>&#125;</span><br></pre></td></tr></table></figure>

<hr>

<h4 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5:"></a>Exercise 5:</h4><p>Modify the previous exercise so that the values of the data in DataOnly are assigned to and printed in main( ). </p>
<p>同上</p>
<hr>

<h4 id="Exercise-6"><a href="#Exercise-6" class="headerlink" title="Exercise 6:"></a>Exercise 6:</h4><p>Write a program that includes and calls the storage( ) method defined as a code fragment in this chapter. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">exer_6</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">storage</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s.length() * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">exer_6</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">exer_6</span>();</span><br><span class="line"></span><br><span class="line">        System.out.println(obj.storage(<span class="string">&quot;A&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>outputs:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>

<hr>

<h4 id="Exercise-7"><a href="#Exercise-7" class="headerlink" title="Exercise 7:"></a>Exercise 7:</h4><p>Turn the Incrementable code fragments into a working program. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StaticTest</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">47</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">exer_7</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        StaticTest.i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        exer_7.increment();</span><br><span class="line">        System.out.println(StaticTest.i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>outputs:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">48</span><br></pre></td></tr></table></figure>

<hr>

<h4 id="Exercise-8"><a href="#Exercise-8" class="headerlink" title="Exercise 8:"></a>Exercise 8:</h4><p>Write a program that demonstrates that, no matter how many objects you create of a particular class, there is only one instance of a particular static field in that class. </p>
<p>pass</p>
<hr>

<h4 id="Exercise-9"><a href="#Exercise-9" class="headerlink" title="Exercise 9:"></a>Exercise 9:</h4><p>Write a program that demonstrates that autoboxing works for all the primitive types and their wrappers. </p>
<p>pass</p>
<hr>

<h4 id="Exercise-10"><a href="#Exercise-10" class="headerlink" title="Exercise 10:"></a>Exercise 10:</h4><p>Write a program that prints three arguments taken from the command line. To do this, you’ll need to index into the command-line array of Strings. </p>
<p>pass</p>
<hr>

<h4 id="Exercise-11"><a href="#Exercise-11" class="headerlink" title="Exercise 11:"></a>Exercise 11:</h4><p>Turn the AllTheColorsOfTheRainbow example into a program that compiles and runs. </p>
<p>pass</p>
<hr>

<h4 id="Exercise-12"><a href="#Exercise-12" class="headerlink" title="Exercise 12:"></a>Exercise 12:</h4><p>Find the code for the second version of HelloDate.java, which is the simple comment documentation example. Execute Javadoc on the file and view the results with your Web browser. </p>
<p>pass</p>
<hr>

<h4 id="Exercise-13"><a href="#Exercise-13" class="headerlink" title="Exercise 13:"></a>Exercise 13:</h4><p>Run Documentation1.java, Documentation2.java, and Documentation3.java through Javadoc. Verify the resulting documentation with your Web browser. </p>
<p>pass</p>
<hr>

<h4 id="Exercise-14"><a href="#Exercise-14" class="headerlink" title="Exercise 14:"></a>Exercise 14:</h4><p>Add an HTML list of items to the documentation in the previous exercise. </p>
<p>pass</p>
<hr>

<h4 id="Exercise-15"><a href="#Exercise-15" class="headerlink" title="Exercise 15:"></a>Exercise 15:</h4><p>Take the program in Exercise 2 and add comment documentation to it. Extract this comment documentation into an HTML file using Javadoc and view it with your Web browser. </p>
<p>pass</p>
<hr>

<h4 id="Exercise-16"><a href="#Exercise-16" class="headerlink" title="Exercise 16:"></a>Exercise 16:</h4><p>In the Initialization &amp; Cleanup chapter, locate the Overloading.java example and add Javadoc documentation. Extract this comment documentation into an HTML file using Javadoc and view it with your Web browser. </p>
<p>pass</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-02-09T02:54:56.000Z" title="2025/2/9 10:54:56">2025-02-09</time>发表</span><span class="level-item"><time dateTime="2025-02-12T02:38:45.211Z" title="2025/2/12 10:38:45">2025-02-12</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/Java/basics/">basics</a><span> / </span><a class="link-muted" href="/categories/Java/basics/Thinking-in-Java/">Thinking in Java</a></span><span class="level-item">32 分钟读完 (大约4855个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/02/09/Thinking-in-Java/Thinking-in-Java-pt-1/">Thinking in Java pt.1</a></p><div class="content"><h2 id="Chapter-1-Introduction-to-Objects"><a href="#Chapter-1-Introduction-to-Objects" class="headerlink" title="Chapter 1 Introduction to Objects"></a>Chapter 1 Introduction to Objects</h2><h3 id="1-1-The-progress-of-abstraction"><a href="#1-1-The-progress-of-abstraction" class="headerlink" title="1.1 The progress of abstraction"></a>1.1 The progress of abstraction</h3><p>Alan Kay summarized five basic characteristics of Smalltalk, the first successful object-oriented language and one of the languages upon which Java is based. These characteristics represent a pure approach to object-oriented programming:</p>
<ol>
<li><p><strong>Everything is an object</strong>. Think of an object as a fancy variable; it stores data, but you can “make requests” to that object, asking it to perform operations on itself. In theory, you can take any <em>conceptual(概念性的 )</em> component in the problem you’re trying to solve (dogs, buildings, services, etc.) and represent it as an object in your program.</p>
</li>
<li><p><strong>A program is a bunch of objects telling each other what to do by sending messages</strong>. To make a request of an object, you “send a message” to that object. More concretely, you can think of a message as a request to call a method that belongs to a particular object.</p>
</li>
<li><p><strong>Each object has its own memory made up of other objects</strong>. Put another way, you create a new kind of object by making a package containing existing objects. Thus, you can build complexity into a program while hiding it behind the simplicity of objects.</p>
</li>
<li><p><strong>Every object has a type</strong>. <em>Using the parlance(按照这种说法 )</em>, each object is an instance of a class, in which “class” is synonymous with “type.” The most important distinguishing characteristic of a class is “What messages can you send to it?”</p>
</li>
<li><p><strong>All objects of a particular type can receive the same messages</strong>. This is actually a loaded statement, as you will see later. Because an object of type “circle” is also an object of type “shape,” a circle is guaranteed to accept shape messages. This means you can write code that talks to shapes and automatically handle anything that fits the description of a shape. This substitutability is one of the powerful concepts in OOP.</p>
<hr/></li>
</ol>
<h3 id="1-2-An-object-has-an-interface"><a href="#1-2-An-object-has-an-interface" class="headerlink" title="1.2 An object has an interface"></a>1.2 An object has an interface</h3><p>Since a class describes a set of objects that have identical characteristics (data elements) and behaviors (functionality), a class is really a data type because a floating point number, for example, also has a set of characteristics and behaviors. The difference is that a programmer defines a class to fit a problem rather than being forced to use an existing data type that was designed to represent a unit of storage in a machine. You extend the programming language by adding new data types specific to your needs. The programming system welcomes the new classes and gives them all the care and type checking that it gives to built-in types. </p>
<p>The object-oriented approach is not limited to building simulations. Whether or not you agree that any program is a simulation of the system you’re designing, the use of OOP techniques can easily reduce a large set of problems to a simple solution. </p>
<p>Once a class is established, you can make as many objects of that class as you like, and then manipulate those objects as if they are the elements that exist in the problem you are trying to solve. Indeed, one of the challenges of object-oriented programming is to create a one-toone mapping between the elements in the problem space and objects in the solution space. </p>
<hr>

<h3 id="1-3-An-object-provides-services"><a href="#1-3-An-object-provides-services" class="headerlink" title="1.3 An object provides services"></a>1.3 An object provides services</h3><p>While you’re trying to develop or understand a program design, one of the best ways to think about objects is as “service providers.” Your program itself will provide services to the user, and it will accomplish this by using the services offered by other objects. Your goal is to produce (or even better, locate in existing code libraries) a set of objects that provide the ideal services to solve your problem. </p>
<hr>

<h3 id="1-4-The-hidden-implementation"><a href="#1-4-The-hidden-implementation" class="headerlink" title="1.4 The hidden implementation"></a>1.4 The hidden implementation</h3><p>It is helpful to break up the playing field into <em>class creators</em> (those who create new data types) and <em>client programmers</em> (the class consumers who use the data types in their applications). The goal of the client programmer is to collect a toolbox full of classes to use for rapid application development. The goal of the class creator is to build a class that exposes only what’s necessary to the client programmer and keeps everything else hidden. Why? Because if it’s hidden, the client programmer can’t access it, which means that the class creator can change the hidden portion at will without worrying about the impact on anyone else. The hidden portion usually represents the tender insides of an object that could easily be corrupted by a careless or uninformed client programmer, so hiding the implementation reduces program bugs. </p>
<p>Java uses three explicit keywords to set the boundaries in a class: <strong>public</strong>, <strong>private</strong>, and <strong>protected</strong>. These access specifiers determine who can use the definitions that follow. <strong>public</strong> means the following element is available to everyone. The <strong>private</strong> keyword, on the other hand, means that no one can access that element except you, the creator of the type, inside methods of that type. <strong>private</strong> is a brick wall between you and the client programmer. Someone who tries to access a <strong>private</strong> member will get a compile-time error. The <strong>protected</strong> keyword acts like <strong>private</strong>, with the exception that an inheriting class has access to <strong>protected</strong> members, but not <strong>private</strong> members. Inheritance will be introduced shortly. </p>
<p>Java also has a “default” access, which comes into play if you don’t use one of the aforementioned specifiers. This is usually called <em>package access</em> because classes can access the members of other classes in the same package (library component), but outside of the package those same members appear to be <strong>private</strong>. </p>
<hr>

<h3 id="1-5-Reusing-the-implementation"><a href="#1-5-Reusing-the-implementation" class="headerlink" title="1.5 Reusing the implementation"></a>1.5 Reusing the implementation</h3><p>Once a class has been created and tested, it should (ideally) represent a useful unit of code. It turns out that this reusability is not nearly so easy to achieve as many would hope; it takes experience and insight to produce a reusable object design. But once you have such a design, it begs to be reused. Code reuse is one of the greatest advantages that object-oriented programming languages provide. </p>
<p>The simplest way to reuse a class is to just use an object of that class directly, but you can also place an object of that class inside a new class. We call this “creating a member object.” Your new class can be made up of any number and type of other objects, in any combination that you need to achieve the functionality desired in your new class. Because you are composing a new class from existing classes, this concept is called composition (if the composition happens dynamically, it’s usually called aggregation). Composition is often referred to as a “has-a” relationship, as in “A car has an engine.”</p>
<p>Composition comes with a great deal of flexibility. The member objects of your new class are typically <strong>private</strong>, making them inaccessible to the client programmers who are using the class. This allows you to change those members without disturbing existing client code. You can also change the member objects at run time, to dynamically change the behavior of your program. Inheritance, which is described next, does not have this flexibility since the compiler must place compile-time restrictions on classes created with inheritance. </p>
<p>Because inheritance is so important in object-oriented programming, it is often highly emphasized, and the new programmer can get the idea that inheritance should be used everywhere. This can result in awkward and overly complicated designs. Instead, <strong><u>you should first look to composition when creating new classes</u></strong>, since it is simpler and more flexible. If you take this approach, your designs will be cleaner. Once you’ve had some experience, it will be reasonably obvious when you need inheritance. </p>
<hr>

<h3 id="1-6-Inheritance"><a href="#1-6-Inheritance" class="headerlink" title="1.6 Inheritance"></a>1.6 Inheritance</h3><p>A type does more than describe the constraints on a set of objects; it also has a relationship with other types. Two types can have characteristics and behaviors in common, but one type may contain more characteristics than another and may also handle more messages (or handle them differently). Inheritance expresses this similarity between types by using the concept of base types and derived types. A base type contains all of the characteristics and behaviors that are shared among the types derived from it. You create a base type to represent the core of your ideas about some objects in your system. From the base type, you derive other types to express the different ways that this core can be realized. </p>
<hr>

<h3 id="1-7-Interchangeable-objects-with-polymorphism"><a href="#1-7-Interchangeable-objects-with-polymorphism" class="headerlink" title="1.7 Interchangeable objects with polymorphism"></a>1.7 Interchangeable objects with polymorphism</h3><p>The compiler cannot make a function call in the traditional sense. The function call generated by a non-OOP compiler causes what is called <em><u>early binding</u></em>, a term you may not have heard before because you’ve never thought about it any other way. It means the compiler generates a call to a specific function name, and the runtime system resolves this call to the absolute address of the code to be executed. In OOP, the program cannot determine the address of the code until run time, so some other scheme is necessary when a message is sent to a generic object. </p>
<p>To solve the problem, object-oriented languages use the concept of <em><u>late binding</u></em>. When you send a message to an object, the code being called isn’t determined until run time. The compiler does ensure that the method exists and performs type checking on the arguments and return value, but it doesn’t know the exact code to execute. </p>
<hr>

<h3 id="1-8-The-singly-rooted-hierarchy"><a href="#1-8-The-singly-rooted-hierarchy" class="headerlink" title="1.8 The singly rooted hierarchy"></a>1.8 The singly rooted hierarchy</h3><p><strong><u>All objects in a singly rooted hierarchy have an interface in common, so they are all ultimately the same fundamental type.</u></strong> The alternative (provided by C++) is that you don’t know that everything is the same basic type. From a backward-compatibility standpoint this fits the model of C better and can be thought of as less restrictive, but when you want to do full-on objectoriented programming you must then build your own hierarchy to provide the same convenience that’s built into other OOP languages. And in any new class library you acquire, some other incompatible interface will be used. It requires effort (and possibly multiple inheritance) to work the new interface into your design. Is the extra “flexibility” of C++ worth it? If you need it—if you have a large investment in C—it’s quite valuable. If you’re starting from scratch, other alternatives such as Java can often be more productive. </p>
<p>All objects in a singly rooted hierarchy can be guaranteed to have certain functionality. You know you can perform certain basic operations on every object in your system. All objects can easily be created on the heap, and argument passing is greatly simplified. </p>
<p>A singly rooted hierarchy makes it much easier to implement a <em><u>garbage collector</u></em>, which is one of the fundamental improvements of Java over C++. And since information about the type of an object is guaranteed to be in all objects, you’ll never end up with an object whose type you cannot determine. This is especially important with system-level operations, such as exception handling, and to allow greater flexibility in programming. </p>
<hr>

<h3 id="1-9-Containers"><a href="#1-9-Containers" class="headerlink" title="1.9 Containers"></a>1.9 Containers</h3><p>The solution to most problems in object-oriented design seems flippant: You create another type of object. The new type of object that solves this particular problem holds references to other objects. Of course, you can do the same thing with an <em><u>array</u></em>, which is available in most languages. But this new object, generally called a container (also called a collection, but the Java library uses that term in a different sense so this book will use “container”), will expand itself whenever necessary to accommodate everything you place inside it. So you don’t need to know how many objects you’re going to hold in a container. Just create a container object and let it take care of the details. </p>
<p>Fortunately, a good OOP language comes with a set of containers as part of the package. In C++, it’s part of the Standard C++ Library and is often called the <em><u>Standard Template Library</u></em> (STL). Smalltalk has a very complete set of containers. Java also has numerous containers in its standard library. In some libraries, one or two generic containers is considered good enough for all needs, and in others (Java, for example) the library has different types of containers for different needs: several different kinds of <strong>List</strong> classes (to hold sequences), <strong>Map</strong>s (also known as associative arrays, to associate objects with other objects), <strong>Set</strong>s (to hold one of each type of object), and more components such as queues, trees, stacks, etc. </p>
<hr>

<h4 id="1-9-1-Parameterized-types-generics"><a href="#1-9-1-Parameterized-types-generics" class="headerlink" title="1.9.1 Parameterized types (generics)"></a>1.9.1 Parameterized types (generics)</h4><p>One of the big changes in Java SE5 is the addition of parameterized types, called generics in Java. You’ll recognize the use of generics by the angle brackets with types inside; for example, an <code>ArrayList</code> that holds <code>Shape</code> can be created like this: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Shape&gt; shapes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>(); </span><br></pre></td></tr></table></figure>

<p>There have also been changes to many of the standard library components in order to take advantage of generics. As you will see, generics have an impact on much of the code in this book. </p>
<hr>

<h3 id="1-10-Object-creation-lifetime"><a href="#1-10-Object-creation-lifetime" class="headerlink" title="1.10 Object creation &amp; lifetime"></a>1.10 Object creation &amp; lifetime</h3><p>The dynamic approach makes the generally logical assumption that objects tend to be complicated, so the extra overhead of finding storage and releasing that storage will not have an important impact on the creation of an object. In addition, the greater flexibility is essential to solve the general programming problem. </p>
<p>Java uses dynamic memory allocation, exclusively.7 Every time you want to create an object, you use the <strong>new</strong> operator to build a dynamic instance of that object. </p>
<p>Java provides a feature called a <em><u>garbage collector</u></em> that automatically discovers when an object is no longer in use and destroys it. A garbage collector is much more convenient because it reduces the number of issues that you must track and the code you must write. More importantly, the garbage collector provides a much higher level of insurance against the insidious problem of memory leaks, which has brought many a C++ project to its knees. </p>
<p>With Java, the garbage collector is designed to take care of the problem of releasing the memory (although this doesn’t include other aspects of cleaning up an object). The garbage collector “knows” when an object is no longer in use, and it then automatically releases the memory for that object. This, combined with the fact that all objects are inherited from the single root class <strong>Object</strong> and that you can create objects only one way—on the heap—makes the process of programming in Java much simpler than programming in C++. You have far fewer decisions to make and hurdles to overcome. </p>
<hr>

<h3 id="1-11-Exception-handling-dealing-with-errors"><a href="#1-11-Exception-handling-dealing-with-errors" class="headerlink" title="1.11 Exception handling: dealing with errors"></a>1.11 Exception handling: dealing with errors</h3><p>Exception handling wires error handling directly into the programming language and sometimes even the operating system. An exception is an object that is “thrown” from the site of the error and can be “caught” by an appropriate exception handler designed to handle that particular type of error. It’s as if exception handling is a different, parallel path of execution that can be taken when things go wrong. And because it uses a separate execution path, it doesn’t need to interfere with your normally executing code. This tends to make that code simpler to write because you aren’t constantly forced to check for errors. In addition, a thrown exception is unlike an error value that’s returned from a method or a flag that’s set by a method in order to indicate an error condition—these can be ignored. An exception cannot be ignored, so it’s guaranteed to be dealt with at some point. <em><strong>Finally, exceptions provide a way to reliably recover from a bad situation. Instead of just exiting the program, you are often able to set things right and restore execution, which produces much more robust programs.</strong></em> </p>
<p><u><strong>It’s worth noting that exception handling isn’t an object-oriented feature</strong></u>, although in objectoriented languages the exception is normally represented by an object. Exception handling existed before object-oriented languages. </p>
<hr>

<h3 id="1-12-Concurrent-programming-并发编程"><a href="#1-12-Concurrent-programming-并发编程" class="headerlink" title="1.12 Concurrent programming (并发编程)"></a>1.12 Concurrent programming (并发编程)</h3><p>Sometimes, interrupts are necessary for handling time-critical tasks, but there’s a large class of problems in which you’re simply trying to partition the problem into separately running pieces (tasks) so that the whole program can be more responsive. Within a program, these separately running pieces are called threads, and the general concept is called concurrency. A common example of concurrency is the user interface. By using tasks, a user can press a button and get a quick response rather than being forced to wait until the program finishes its current task. </p>
<p>All this makes concurrency sound pretty simple. There is a catch: <u><strong>shared resources</strong></u>. If you have more than one task running that’s expecting to access the same resource, you have a problem. For example, two processes can’t simultaneously send information to a printer. To solve the problem, resources that can be shared, such as the printer, must be locked while they are being used. So a task locks a resource, completes its task, and then releases the lock so that someone else can use the resource. </p>
<hr>

<h3 id="1-13-Java-and-the-Internet"><a href="#1-13-Java-and-the-Internet" class="headerlink" title="1.13 Java and the Internet"></a>1.13 Java and the Internet</h3><p>Although Java is very useful for solving traditional standalone programming problems, it is also important because <strong><u>it solves programming problems for the World Wide Web</u></strong>. </p>
<hr>

<h4 id="1-13-1-What-is-the-Web"><a href="#1-13-1-What-is-the-Web" class="headerlink" title="1.13.1 What is the Web?"></a>1.13.1 What is the Web?</h4><h5 id="1-Client-server-computing"><a href="#1-Client-server-computing" class="headerlink" title="1. Client&#x2F;server computing"></a>1. Client&#x2F;server computing</h5><p>The primary idea of a client&#x2F;server system is that you have a central repository of information— some kind of data, usually in a database—that you want to distribute on demand to some set of people or machines. A key to the client&#x2F;server concept is that the repository of information is centrally located so that it can be changed and so that those changes will propagate out to the information consumers. Taken together, the information repository, the software that distributes the information, and the machine(s) where the information and software reside are called “*<u>the server</u>*.” The software that resides on the consumer machine, communicates with the server, fetches the information, processes it, and then displays it on the consumer machine is called the <em><u>client</u></em>. </p>
<h5 id="2-The-Web-as-a-giant-server"><a href="#2-The-Web-as-a-giant-server" class="headerlink" title="2. The Web as a giant server"></a>2. The Web as a giant server</h5><p>The Web browser was a big step forward: the concept that <strong><u>one piece of information can be displayed on any type of computer without change</u></strong>. However, the original browsers were still rather primitive and rapidly bogged down by the demands placed on them. They weren’t particularly interactive, and tended to clog up both the server and the Internet because whenever you needed to do something that required programming you had to send information back to the server to be processed. It could take many seconds or minutes to find out you had misspelled something in your request. Since the browser was just a viewer it couldn’t perform even the simplest computing tasks. (On the other hand, it was safe, because it couldn’t execute any programs on your local machine that might contain bugs or viruses.) </p>
<p>To solve this problem, different approaches have been taken. To begin with, graphics standards have been enhanced to allow better animation and video within browsers. The remainder of the problem can be solved only by incorporating the ability to run programs on the client end, under the browser. This is called <em><u>client-side programming</u></em>. </p>
<hr>

<h4 id="1-13-2-Client-side-programming"><a href="#1-13-2-Client-side-programming" class="headerlink" title="1.13.2 Client-side programming"></a>1.13.2 Client-side programming</h4><p>Most desktop computers that run Web browsers are powerful engines capable of doing vast work, and with the original static HTML approach they are sitting there, just idly waiting for the server to dish up the next page. <strong><u>Client-side programming means that the Web browser is harnessed to do whatever work it can, and the result for the user is a much speedier and more interactive experience at your Web site</u></strong>. </p>
<p>The problem with discussions of client-side programming is that they aren’t very different from discussions of programming in general. The parameters are almost the same, but the platform is different; a Web browser is like a limited operating system. In the end, you must still program, and this accounts for the dizzying array of problems and solutions produced by client-side programming. The rest of this section provides an overview of the issues and approaches in client-side programming. </p>
<h5 id="1-Plug-ins"><a href="#1-Plug-ins" class="headerlink" title="1. Plug-ins"></a>1. Plug-ins</h5><p>One of the most significant steps forward in client-side programming is the development of the plug-in. This is a way for a programmer to add new functionality to the browser by downloading a piece of code that plugs itself into the appropriate spot in the browser.  The value of the plug-in for client-side programming is that <strong><u>it allows an expert programmer to develop extensions and add those extensions to a browser without the permission of the browser manufacturer</u></strong>. Thus, plug-ins provide a “back door” that allows the creation of new client-side programming languages (although not all languages are implemented as plug-ins). </p>
<h5 id="2-Scripting-languages"><a href="#2-Scripting-languages" class="headerlink" title="2. Scripting languages"></a>2. Scripting languages</h5><p><strong><u>Scripting languages tend to be reasonably easy to understand and, because they are simply text that is part of an HTML page, they load very quickly as part of the single server hit required to procure that page</u></strong>. The trade-off is that your code is exposed for everyone to see (and steal). Generally, however, you aren’t doing amazingly sophisticated things with scripting languages, so this is not too much of a hardship.</p>
<p>The scripting languages used inside Web browsers are really intended to solve specific types of problems, primarily the creation of richer and more interactive graphical user interfaces (GUIs). However, a scripting language might solve 80 percent of the problems encountered in client-side programming. Your problems might very well fit completely within that 80 percent, and <u><strong>since scripting languages can allow easier and faster development, you should probably consider a scripting language before looking at a more involved solution such as Java programming</strong></u>. </p>
<h5 id="3-Java"><a href="#3-Java" class="headerlink" title="3. Java"></a>3. Java</h5><p>Java is a popular solution for this. Not only is it a powerful programming language built to be secure, cross-platform, and international, but Java is being continually extended to provide language features and libraries that elegantly handle problems that are difficult in traditional programming languages, such as concurrency, database access, network programming, and distributed computing. Java allows client-side programming via the <em><u>applet</u></em> and with <em><u>Java Web Start</u></em>. </p>
<p>An applet is a mini-program that will run only under a Web browser. The applet is downloaded automatically as part of a Web page (just as, for example, a graphic is automatically downloaded). When the applet is activated, it executes a program. This is part of its beauty—<u><strong>it provides you with a way to automatically distribute the client software from the server at the time the user needs the client software</strong></u>, and no sooner. The user gets the latest version of the client software without fail and without difficult reinstallation. Because of the way Java is designed, the programmer needs to create only a single program, and that program automatically works with all computers that have browsers with built-in Java interpreters. (This safely includes the vast majority of machines.) Since Java is a full-fledged programming language, you can do as much work as possible on the client before and after making requests of the server. For example, you won’t need to send a request form across the Internet to discover that you’ve gotten a date or some other parameter wrong, and your client computer can quickly do the work of plotting data instead of waiting for the server to make a plot and ship a graphic image back to you. Not only do you get the immediate win of speed and responsiveness, but the general network traffic and load on servers can be reduced, preventing the entire Internet from slowing down. </p>
<h5 id="4-Alternatives"><a href="#4-Alternatives" class="headerlink" title="4. Alternatives"></a>4. Alternatives</h5><p>To be honest, Java applets have not particularly lived up to their initial fanfare. When Java first appeared, what everyone seemed most excited about was applets, because these would finally allow serious client-side programmability, to increase responsiveness and decrease bandwidth requirements for Internet-based applications. People envisioned vast possibilities. </p>
<p>Indeed, you can find some very clever applets on the Web. But the overwhelming move to applets never happened. The biggest problem was probably that the 10 MB download necessary to install the Java Runtime Environment (JRE) was too scary for the average user. The fact that Microsoft chose not to include the JRE with Internet Explorer may have sealed its fate. In any event, <strong><u>Java applets didn’t happen on a large scale</u></strong>. </p>
<h5 id="5-NET-and-C"><a href="#5-NET-and-C" class="headerlink" title="5. .NET and C#"></a>5. .NET and C#</h5><p>Currently, the main vulnerability and important question concerning .NET is whether Microsoft will allow it to be completely ported to other platforms. They claim there’s no problem doing this, and the Mono project (<em><a target="_blank" rel="noopener" href="http://www.go-mono.com/">www.go-mono.com</a></em>) has a partial implementation of .NET working on Linux, but until the implementation is complete and Microsoft has not decided to squash any part of it, .NET as a cross-platform solution is still a risky bet. </p>
<h5 id="6-Internet-vs-Intranet"><a href="#6-Internet-vs-Intranet" class="headerlink" title="6. Internet vs. Intranet"></a>6. Internet vs. Intranet</h5><p>When Web technology is used for an information network that is restricted to a particular company, it is referred to as an <em><u>intranet</u></em>. Intranets provide much greater security than the Internet, since you can physically control access to the servers within your company.</p>
<p>When faced with this bewildering array of solutions to the client-side programming problem, <strong><u>the best plan of attack is a cost-benefit analysis</u></strong>. Consider the constraints of your problem and what would be the shortest path to your solution. Since client-side programming is still programming, it’s always a good idea to take the fastest development approach for your particular situation. This is an aggressive stance to prepare for inevitable encounters with the problems of program development.</p>
<hr>

<h4 id="1-13-3-Server-side-programming"><a href="#1-13-3-Server-side-programming" class="headerlink" title="1.13.3 Server-side programming"></a>1.13.3 Server-side programming</h4><p>A more complicated request to a server generally involves a database transaction. A common scenario involves a request for a complex database search, which the server then formats into an HTML page and sends to you as the result. (Of course, if the client has more intelligence via Java or a scripting language, the raw data can be sent and formatted at the client end, which will be faster and less load on the server.) Or you might want to register your name in a database when you join a group or place an order, which will involve changes to that database. These database requests must be processed via some code on the server side, which is generally referred to as server-side programming. Traditionally, server-side programming has been performed using Perl, Python, C++, or some other language to create CGI programs, but more sophisticated systems have since appeared. These include Java-based Web servers that allow you to perform all your server-side programming in Java by writing what are called <em><u>servlets</u></em>. Servlets and their offspring, JSPs, are two of the most compelling reasons that companies that develop Web sites are moving to Java, especially because they eliminate the problems of dealing with differently abled browsers.</p>
<hr>

<h3 id="1-14-Summary"><a href="#1-14-Summary" class="headerlink" title="1.14 Summary"></a>1.14 Summary</h3><p>Because OOP adds many new concepts on top of what you find in a procedural language, your natural assumption may be that the resulting Java program will be far more complicated than the equivalent procedural program. Here, you’ll be pleasantly surprised: <u><strong>A well-written Java program is generally far simpler and much easier to understand than a procedural program</strong></u>. What you’ll see are <u><strong>the definitions of the objects that represent concepts in your problem space (rather than the issues of the computer representation) and messages sent to those objects to represent the activities in that space</strong></u>. One of the delights of objectoriented programming is that, with a well-designed program, it’s easy to understand the code by reading it. Usually, there’s a lot less code as well, because many of your problems will be solved by <u><strong>reusing existing library code</strong></u>. </p>
<p>OOP and Java may not be for everyone. It’s important to evaluate your own needs and decide whether Java will optimally satisfy those needs, or if you might be better off with another programming system (including the one you’re currently using). If you know that your needs will be very specialized for the foreseeable future and if you have specific constraints that may not be satisfied by Java, then you owe it to yourself to investigate the alternatives (in particular, I recommend looking at Python; see <em><a target="_blank" rel="noopener" href="http://www.python.org/">www.Python.org</a></em>). If you still choose Java as your language, <u><strong>you’ll at least understand what the options were and have a clear vision of why you took that direction.</strong></u> </p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-01-11T07:49:15.000Z" title="2025/1/11 15:49:15">2025-01-11</time>发表</span><span class="level-item"><time dateTime="2025-01-12T09:40:08.865Z" title="2025/1/12 17:40:08">2025-01-12</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/OS/">OS</a></span><span class="level-item">6 分钟读完 (大约854个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/01/11/Write%20your%20own%20Operating%20System/Operating-System-pt-2/">Operating System pt.2</a></p><div class="content"><h2 id="Install-Your-OS-in-a-Virtual-Machine"><a href="#Install-Your-OS-in-a-Virtual-Machine" class="headerlink" title="Install Your OS in a Virtual Machine"></a>Install Your OS in a Virtual Machine</h2><h3 id="1-修改Makefile制作iso文件"><a href="#1-修改Makefile制作iso文件" class="headerlink" title="1. 修改Makefile制作iso文件"></a>1. 修改Makefile制作iso文件</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">mykernel.iso: mykernel.bin</span></span><br><span class="line">	mkdir iso</span><br><span class="line">	mkdir iso/boot</span><br><span class="line">	mkdir iso/boot/grub</span><br><span class="line">	cp <span class="variable">$&lt;</span> iso/boot</span><br><span class="line">	echo &#x27;set timeout=0&#x27; &gt;&gt; iso/boot/grub/grub.cfg</span><br><span class="line">	echo &#x27;set default=0&#x27; &gt;&gt; iso/boot/grub/grub.cfg</span><br><span class="line">	echo &#x27;&#x27; &gt;&gt; iso/boot/grub/grub.cfg</span><br><span class="line">	echo &#x27;menuentry <span class="string">&quot;My Operating System&quot;</span>&#123;&#x27; &gt;&gt; iso/boot/grub/grub.cfg</span><br><span class="line">	echo &#x27;	multiboot /boot/mykernel.bin&#x27; &gt;&gt; iso/boot/grub/grub.cfg</span><br><span class="line">	echo &#x27;	boot&#x27; &gt;&gt; iso/boot/grub/grub.cfg</span><br><span class="line">	echo &#x27;&#125;&#x27; &gt;&gt; iso/boot/grub/grub.cfg</span><br><span class="line">	grub-mkrescue --output=<span class="variable">$@</span> iso</span><br><span class="line">	rm -rf iso</span><br></pre></td></tr></table></figure>

<p>这段Makefile用于生成一个名为<code>mykernel.iso</code>的可启动ISO镜像文件。它依赖于一个名为<code>mykernel.bin</code>的二进制文件，该文件通常是一个操作系统内核或引导程序。以下是逐行解释：</p>
<ol>
<li><strong><code>mykernel.iso: mykernel.bin</code></strong>:<ul>
<li>这行定义了目标文件<code>mykernel.iso</code>和它的依赖文件<code>mykernel.bin</code>。当<code>mykernel.bin</code>发生变化时，<code>mykernel.iso</code>将会被重新生成。</li>
</ul>
</li>
<li><strong><code>mkdir iso</code></strong>:<ul>
<li>创建一个名为<code>iso</code>的目录，用于临时存放构建ISO文件所需的文件。</li>
</ul>
</li>
<li><strong><code>mkdir iso/boot</code></strong>:<ul>
<li>在<code>iso</code>目录下创建一个<code>boot</code>子目录，用于存放引导相关的文件。</li>
</ul>
</li>
<li><strong><code>mkdir iso/boot/grub</code></strong>:<ul>
<li>在<code>iso/boot</code>目录下创建一个<code>grub</code>子目录，用于存放GRUB引导加载器的配置文件。</li>
</ul>
</li>
<li><strong><code>cp $&lt; iso/boot</code></strong>:<ul>
<li>将依赖文件<code>mykernel.bin</code>复制到<code>iso/boot</code>目录中。<code>$&lt;</code>是Makefile中的自动变量，表示第一个依赖文件（即<code>mykernel.bin</code>）。</li>
</ul>
</li>
<li><strong><code>echo &#39;set timeout=0&#39; &gt;&gt; iso/boot/grub/grub.cfg</code></strong>:<ul>
<li>向<code>iso/boot/grub/grub.cfg</code>文件中追加一行，设置GRUB菜单的超时时间为0秒，即不显示菜单直接启动。</li>
</ul>
</li>
<li><strong><code>echo &#39;set default=0&#39; &gt;&gt; iso/boot/grub/grub.cfg</code></strong>:<ul>
<li>向<code>grub.cfg</code>文件中追加一行，设置默认启动项为第一个菜单项。</li>
</ul>
</li>
<li><strong><code>echo &#39;&#39; &gt;&gt; iso/boot/grub/grub.cfg</code></strong>:<ul>
<li>向<code>grub.cfg</code>文件中追加一个空行。</li>
</ul>
</li>
<li><strong><code>echo &#39;menuentry &quot;My Operating System&quot;&#123;&#39; &gt;&gt; iso/boot/grub/grub.cfg</code></strong>:<ul>
<li>向<code>grub.cfg</code>文件中追加一行，定义一个名为”My Operating System”的菜单项。</li>
</ul>
</li>
<li><strong><code>echo &#39; multiboot /boot/mykernel.bin&#39; &gt;&gt; iso/boot/grub/grub.cfg</code></strong>:<ul>
<li>向<code>grub.cfg</code>文件中追加一行，指定使用<code>multiboot</code>命令加载<code>/boot/mykernel.bin</code>文件。</li>
</ul>
</li>
<li><strong><code>echo &#39; boot&#39; &gt;&gt; iso/boot/grub/grub.cfg</code></strong>:<ul>
<li>向<code>grub.cfg</code>文件中追加一行，执行<code>boot</code>命令以启动加载的内核。</li>
</ul>
</li>
<li><strong><code>echo &#39;&#125;&#39; &gt;&gt; iso/boot/grub/grub.cfg</code></strong>:<ul>
<li>向<code>grub.cfg</code>文件中追加一行，结束菜单项的定义。</li>
</ul>
</li>
<li><strong><code>grub-mkrescue --output=$@ iso</code></strong>:<ul>
<li>使用<code>grub-mkrescue</code>命令将<code>iso</code>目录中的内容打包成一个可启动的ISO镜像文件。<code>$@</code>是Makefile中的自动变量，表示目标文件（即<code>mykernel.iso</code>）。</li>
</ul>
</li>
<li><strong><code>rm -rf iso</code></strong>:<ul>
<li>删除临时创建的<code>iso</code>目录及其内容，以清理构建过程中生成的临时文件。</li>
</ul>
</li>
</ol>
<p>这段Makefile的作用是将<code>mykernel.bin</code>文件打包成一个可启动的ISO镜像文件<code>mykernel.iso</code>。它使用GRUB作为引导加载器，并配置GRUB直接启动<code>mykernel.bin</code>。构建完成后，临时目录<code>iso</code>会被删除</p>
<h3 id="2-定义types-h"><a href="#2-定义types-h" class="headerlink" title="2. 定义types.h"></a>2. 定义types.h</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __TYPES_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TYPES_H__</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">char</span> <span class="type">int8_t</span>;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="type">uint8_t</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">short</span> <span class="type">int16_t</span>;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">uint16_t</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">int</span> <span class="type">int32_t</span>;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">uint32_t</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> <span class="type">int64_t</span>;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> <span class="type">uint64_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="3-修改kernel-cpp"><a href="#3-修改kernel-cpp" class="headerlink" title="3. 修改kernel.cpp"></a>3. 修改kernel.cpp</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printf</span><span class="params">(<span class="type">char</span>* str)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint16_t</span>* VideoMemory = (<span class="type">uint16_t</span>*) <span class="number">0xB8000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; str[i] != <span class="string">&#x27;\0&#x27;</span>; ++i) &#123;</span><br><span class="line">        VideoMemory[i] = (VideoMemory[i] &amp; <span class="number">0xFF00</span>) | str[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*constructor)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> constructor start_ctors;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> constructor end_ctors;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">void</span> <span class="title">callConstructors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(constructor* i = &amp;start_ctors; i != &amp;end_ctors; i++) &#123;</span><br><span class="line">        (*i)();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">void</span> <span class="title">kernelMain</span><span class="params">(<span class="type">void</span>* multiboot_structure, <span class="type">uint32_t</span> magicnumber)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Memory-Segments-Global-Descriptor-Table"><a href="#Memory-Segments-Global-Descriptor-Table" class="headerlink" title="Memory Segments, Global Descriptor Table"></a>Memory Segments, Global Descriptor Table</h2></div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/tags/%E4%B8%AD%E6%96%87/page/0/">上一页</a></div><div class="pagination-next"><a href="/tags/%E4%B8%AD%E6%96%87/page/2/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/tags/%E4%B8%AD%E6%96%87/">1</a></li><li><a class="pagination-link" href="/tags/%E4%B8%AD%E6%96%87/page/2/">2</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.jpg" alt="Rossignol"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Rossignol</p><p class="is-size-6 is-block">NaN</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Mars</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives/"><p class="title">20</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories/"><p class="title">15</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags/"><p class="title">16</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/0xRossignol" target="_blank" rel="me noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/0xRossignol"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Golang/"><span class="level-start"><span class="level-item">Golang</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/Golang/basics/"><span class="level-start"><span class="level-item">basics</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/Java/basics/"><span class="level-start"><span class="level-item">basics</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/Java/basics/Thinking-in-Java/"><span class="level-start"><span class="level-item">Thinking in Java</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/Linux/Arch-Linux/"><span class="level-start"><span class="level-item">Arch Linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/OS/"><span class="level-start"><span class="level-item">OS</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Software-Construction/"><span class="level-start"><span class="level-item">Software Construction</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul><li><a class="level is-mobile" href="/categories/Software-Construction/MIT6-031/"><span class="level-start"><span class="level-item">MIT6.031</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/TypeScript/"><span class="level-start"><span class="level-item">TypeScript</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/test/"><span class="level-start"><span class="level-item">test</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/toy-projects/"><span class="level-start"><span class="level-item">toy projects</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%85%AB%E8%82%A1/"><span class="level-start"><span class="level-item">八股</span></span><span class="level-end"><span class="level-item tag">4</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%85%AB%E8%82%A1/JavaSE/"><span class="level-start"><span class="level-item">JavaSE</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-03-10T14:42:26.000Z">2025-03-10</time></p><p class="title"><a href="/2025/03/10/%E5%85%AB%E8%82%A1/Java%E5%9F%BA%E7%A1%80/JavaSE%20pt.1/">JavaSE pt.1</a></p><p class="categories"><a href="/categories/%E5%85%AB%E8%82%A1/">八股</a> / <a href="/categories/%E5%85%AB%E8%82%A1/JavaSE/">JavaSE</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-03-10T13:55:29.000Z">2025-03-10</time></p><p class="title"><a href="/2025/03/10/%E5%85%AB%E8%82%A1/Java%E5%9F%BA%E7%A1%80/JavaSE%20pt.3/">JavaSE pt.3</a></p><p class="categories"><a href="/categories/%E5%85%AB%E8%82%A1/">八股</a> / <a href="/categories/%E5%85%AB%E8%82%A1/JavaSE/">JavaSE</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-03-10T13:55:29.000Z">2025-03-10</time></p><p class="title"><a href="/2025/03/10/%E5%85%AB%E8%82%A1/Java%E5%9F%BA%E7%A1%80/JavaSE%20pt.2/">JavaSE pt.2</a></p><p class="categories"><a href="/categories/%E5%85%AB%E8%82%A1/">八股</a> / <a href="/categories/%E5%85%AB%E8%82%A1/JavaSE/">JavaSE</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-03-10T13:55:29.000Z">2025-03-10</time></p><p class="title"><a href="/2025/03/10/%E5%85%AB%E8%82%A1/Java%E5%9F%BA%E7%A1%80/%E5%85%B6%E4%BB%96%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/">重要知识点</a></p><p class="categories"><a href="/categories/%E5%85%AB%E8%82%A1/">八股</a> / <a href="/categories/%E5%85%AB%E8%82%A1/JavaSE/">JavaSE</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-02-24T08:24:55.000Z">2025-02-24</time></p><p class="title"><a href="/2025/02/24/Arch%20Linux/arch-install/">Arch Install</a></p><p class="categories"><a href="/categories/OS/">OS</a> / <a href="/categories/Linux/">Linux</a> / <a href="/categories/Linux/Arch-Linux/">Arch Linux</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2025/03/"><span class="level-start"><span class="level-item">三月 2025</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/02/"><span class="level-start"><span class="level-item">二月 2025</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/01/"><span class="level-start"><span class="level-item">一月 2025</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/12/"><span class="level-start"><span class="level-item">十二月 2024</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Arch-Linux/"><span class="tag">Arch Linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/English/"><span class="tag">English</span><span class="tag">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Golang/"><span class="tag">Golang</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OS/"><span class="tag">OS</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Software-Construction/"><span class="tag">Software Construction</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TypeScript/"><span class="tag">TypeScript</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/git/"><span class="tag">git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/python/"><span class="tag">python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/test/"><span class="tag">test</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/toy-projects/"><span class="tag">toy projects</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%B8%AD%E6%96%87/"><span class="tag">中文</span><span class="tag">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%85%AB%E8%82%A1/"><span class="tag">八股</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B1%87%E7%BC%96/"><span class="tag">汇编</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BF%BB%E8%AF%91/"><span class="tag">翻译</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="MyBlog" height="28"></a><p class="is-size-7"><span>&copy; 2025 Rossignol</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>