<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>标签: python - MyBlog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="MyBlog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="MyBlog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="MyBlog"><meta property="og:url" content="http://example.com/"><meta property="og:site_name" content="MyBlog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:author" content="Rossignol"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"MyBlog","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"Rossignol"},"publisher":{"@type":"Organization","name":"MyBlog","logo":{"@type":"ImageObject","url":"http://example.com/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="MyBlog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/0xRossignol"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags/">标签</a></li><li class="is-active"><a href="#" aria-current="page">python</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-02-17T02:02:45.000Z" title="2025/2/17 10:02:45">2025-02-17</time>发表</span><span class="level-item"><time dateTime="2025-02-24T07:11:37.266Z" title="2025/2/24 15:11:37">2025-02-24</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/toy-projects/">toy projects</a></span><span class="level-item">3 小时读完 (大约28070个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/02/17/Write%20yourself%20a%20Git!/Write%20yourself%20a%20Git!/">Write yourself a Git!</a></p><div class="content"><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>本文尝试从底层开始解释 <a target="_blank" rel="noopener" href="https://git-scm.com/">Git 版本控制系统</a>，也就是从底至上逐步讲解。这听起来并不容易，而且他人已经尝试多次，但效果可能都不理想（ <em>with questionable succes</em> ）。但有一种简单的方法：要理解 Git 的内部原理，只需要从零开始重新实现 Git 即可。</p>
<p>不，别跑。（No, don’t run.）</p>
<p>这不是玩笑，而且真的并不复杂：如果你从头到尾阅读这篇文章并亲自编写代码（或者直接<a target="_blank" rel="noopener" href="https://wyag.thb.lt/wyag.zip">下载 ZIP 文件</a>——但你真的应该自己写代码），最终你将得到一个名为 <strong>wyag</strong> 的程序，它将实现 Git 的所有基本功能：<code>init</code>、<code>add</code>、<code>rm</code>、<code>status</code>、<code>commit</code>、<code>log</code>…… 这些功能与 Git 本身完全兼容，兼容到（ <em>compatible enough that</em> ）在本教程中最后添加关于 <code>commit</code> 章节的提交，实际上是<a target="_blank" rel="noopener" href="https://github.com/thblt/write-yourself-a-git/commit/ed26daffb400b2be5f30e044c3237d220226d867">由 <strong>wyag</strong> 生成的，而不是 Git</a>。而且，整个实现仅用 <strong>972 行</strong> 非常简单的 Python 代码完成。</p>
<p>但是，Git 对实现来说不是太复杂了吗？（ <em>But isn’t Git too complex for that?</em> ）在我看来，认为 Git 复杂是一种误解。没错，Git 确实是一个庞大的程序，功能众多，但它的核心其实非常简单。Git 之所以显得复杂，首先是（ <em>stems first from</em> ）因为它的工作方式通常非常反直觉（而那些<a target="_blank" rel="noopener" href="https://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/">“Git 是墨西哥卷饼”的博客文章</a>可能并没有帮助）。但真正让 Git 变得令人困惑的，或许是它核心模型的极端<strong>简单性</strong>和<strong>强大性</strong>。</p>
<p>核心概念既简单又强大的组合（ <em>The combination of core simplicity and powerful applications</em> ），往往会让人难以理解，因为要从基本抽象的简单性<strong>跳跃性地</strong>推导出各种复杂应用，这种思维转换并不容易（比如单子（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Monad_(functional_programming)">monads</a>（函数式编程用语）），有人懂吗？）。</p>
<p>实现 Git 的过程将彻底揭示它的基本原理，让它的本质一览无遗。</p>
<p>我们可以期待去实现什么？本文将<strong>详细</strong>实现并解释 Git 核心命令的一个极简版本（如果有不清楚的地方，请<a target="_blank" rel="noopener" href="https://wyag.thb.lt/#feedback">反馈！</a>）。我会保持代码<strong>简洁明了</strong>，因此 <strong>wyag</strong> 远远无法与真正的 Git 命令行相比——但缺失的部分将非常明显，并且对任何想尝试实现的人来说，都很容易补充。正如他们常说的：“<strong>将 wyag 升级为完整的 Git 库和 CLI是留给读者的一个练习</strong>。”</p>
<p>更具体地说，我们将实现：</p>
<ul>
<li><code>add</code>(<a target="_blank" rel="noopener" href="https://wyag.thb.lt/#cmd-add">wyag source</a>) <a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-add">git man page</a></li>
<li><code>cat-file</code> (<a target="_blank" rel="noopener" href="https://wyag.thb.lt/#cmd-cat-file">wyag source</a>) <a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-cat-file">git man page</a></li>
<li><code>check-ignore</code> (<a target="_blank" rel="noopener" href="https://wyag.thb.lt/#cmd-check-ignore">wyag source</a>) <a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-check-ignore">git man page</a></li>
<li><code>checkout</code> (<a target="_blank" rel="noopener" href="https://wyag.thb.lt/#cmd-checkout">wyag source</a>) <a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-checkout">git man page</a></li>
<li><code>commit</code> (<a target="_blank" rel="noopener" href="https://wyag.thb.lt/#cmd-commit">wyag source</a>) <a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-commit">git man page</a></li>
<li><code>hash-object</code> (<a target="_blank" rel="noopener" href="https://wyag.thb.lt/#cmd-hash-object">wyag source</a>) <a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-hash-object">git man page</a></li>
<li><code>init</code> (<a target="_blank" rel="noopener" href="https://wyag.thb.lt/#cmd-init">wyag source</a>) <a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-init">git man page</a></li>
<li><code>log</code> (<a target="_blank" rel="noopener" href="https://wyag.thb.lt/#cmd-log">wyag source</a>) <a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-log">git man page</a></li>
<li><code>ls-files</code> (<a target="_blank" rel="noopener" href="https://wyag.thb.lt/#cmd-ls-files">wyag source</a>) <a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-ls-files">git man page</a></li>
<li><code>ls-tree</code> (<a target="_blank" rel="noopener" href="https://wyag.thb.lt/#cmd-ls-tree">wyag source</a>) <a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-ls-tree">git man page</a></li>
<li><code>rev-parse</code> (<a target="_blank" rel="noopener" href="https://wyag.thb.lt/#cmd-rev-parse">wyag source</a>) <a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-rev-parse">git man page</a></li>
<li><code>rm</code> (<a target="_blank" rel="noopener" href="https://wyag.thb.lt/#cmd-rm">wyag source</a>) <a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-rm">git man page</a></li>
<li><code>show-ref</code> (<a target="_blank" rel="noopener" href="https://wyag.thb.lt/#cmd-show-ref">wyag source</a>) <a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-show-ref">git man page</a></li>
<li><code>status</code> (<a target="_blank" rel="noopener" href="https://wyag.thb.lt/#cmd-status">wyag source</a>) <a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-status">git man page</a></li>
<li><code>tag</code> (<a target="_blank" rel="noopener" href="https://wyag.thb.lt/#cmd-tag">wyag source</a>) <a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-tag">git man page</a></li>
</ul>
<p>要跟上本文的内容，你并不需要太多前置知识：只需了解一些<strong>基本的 Git 指令</strong>（显然）、<strong>基本的 Python</strong>，以及<strong>基本的 Shell</strong> 知识即可。</p>
<ul>
<li>首先，我只假设你对 <strong>Git 的基本命令</strong> 有一定的了解——不需要是专家级别，但如果你从未使用过 <code>init</code>、<code>add</code>、<code>rm</code>、<code>commit</code> 或 <code>checkout</code>，那你可能会感到困惑。</li>
<li><strong>关于编程语言</strong>，<strong>wyag</strong> 将使用 <strong>Python</strong> 实现。同样，我不会使用任何花哨的特性，而且 Python 本身就很接近伪代码，因此会很容易理解。（讽刺的是，最复杂的部分可能是命令行参数解析逻辑，不过你其实并不需要完全理解它。）如果你有编程基础但从未接触过 Python，建议先在网上找个快速入门教程熟悉一下。</li>
<li><strong>wyag 和 Git 都是终端程序</strong>，我默认你熟悉 <strong>Unix 终端</strong> 的基本操作。你不需要是个 <strong>l33t h4x0r</strong>（精英黑客，见[补充1](#1. l33t h4x0r)），但至少应该会使用 <code>cd</code>、<code>ls</code>、<code>rm</code>、<code>tree</code> 这些常见命令。</li>
</ul>
<table>
<thead>
<tr>
<th><strong>Warning</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Windows 用户注意：<br /><strong>wyag</strong> 应该能在任何类 Unix 系统上运行，并且需要有 Python 解释器，但我完全不确定它在 Windows 上的表现。测试套件明确要求使用一个兼容 bash 的 shell，我假设 <strong>WSL</strong>（Windows Subsystem for Linux）可以提供这个功能。另外，如果你使用 WSL，确保你的 <strong>wyag</strong> 文件使用 Unix 风格的换行符（如果你用的是 VS Code，可以参考<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/48692741/how-can-i-make-all-line-endings-eols-in-all-files-in-visual-studio-code-unix">这个 StackOverflow 解决方案</a>）。欢迎 Windows 用户提供反馈！</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><strong>Note</strong></th>
</tr>
</thead>
<tbody><tr>
<td>致谢：<br />本文得到了许多人重要的贡献，我对他们表示感谢。特别感谢以下几位：<br />- GitHub 用户 <a target="_blank" rel="noopener" href="https://github.com/tammoippen"><strong>tammoippen</strong></a>，他首次草拟了我忘记写的 <code>tag_create</code> 函数（那是 <a target="_blank" rel="noopener" href="https://github.com/thblt/write-yourself-a-git/issues/9">#9</a>）。<br />- GitHub 用户 <a target="_blank" rel="noopener" href="https://github.com/hjlarry"><strong>hjlarry</strong></a>，在 <a target="_blank" rel="noopener" href="https://github.com/thblt/write-yourself-a-git/pull/22">#22</a> 中修复了多个问题。<br />- GitHub 用户 <a target="_blank" rel="noopener" href="https://github.com/cutebbb"><strong>cutebbb</strong></a>，在 <a target="_blank" rel="noopener" href="https://github.com/thblt/write-yourself-a-git/pull/32/">#32</a> 中实现了 <code>ls-files</code> 的第一个版本，凭借此功能，<strong>wyag</strong> 最终实现了“暂存区”的奇妙功能！</td>
</tr>
</tbody></table>
<h2 id="2-Getting-started"><a href="#2-Getting-started" class="headerlink" title="2. Getting started"></a>2. Getting started</h2><p>你将需要 <strong>Python 3.10</strong> 或更高版本，以及你喜欢的文本编辑器。我们不需要第三方包、虚拟环境或其他任何东西，除了常规的 Python 解释器：我们所需的一切都可以通过 Python 的标准库来实现。</p>
<p>我们会将代码分成两个文件：</p>
<ul>
<li>一个可执行文件，名为 <strong>wyag</strong>；</li>
<li>一个 Python 库文件，名为 <strong>libwyag.py</strong>。</li>
</ul>
<p>现在，每个软件项目开始时都会有一大堆模板代码，我们先把这些简单的部分搞定吧。</p>
<p>我们将从创建一个非常简短的可执行文件开始。在你的文本编辑器中创建一个新的文件，命名为 <strong>wyag</strong>，然后复制以下几行代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> libwyag</span><br><span class="line">libwyag.main()</span><br></pre></td></tr></table></figure>

<p>代码解释见[补充2](#2. code 1)</p>
<p>然后，使其变为可执行文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> +x wyag</span></span><br></pre></td></tr></table></figure>

<p>完成了！</p>
<p>接下来是库文件的创建。它必须命名为 <strong>libwyag.py</strong>，并且与 <strong>wyag</strong> 可执行文件位于同一目录下。</p>
<p>开始时，打开空的 <strong>libwyag.py</strong> 文件，准备编写代码。</p>
<p>首先，我们需要导入一系列模块（可以逐个复制每个导入语句，或者将它们合并为一行）。</p>
<ul>
<li><p>Git 是一个命令行应用程序，因此我们需要一些工具来解析命令行参数。Python 提供了一个很有用的模块叫做 <strong>argparse</strong>，它可以为我们完成 99% 的工作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br></pre></td></tr></table></figure>
</li>
<li><p>Git 使用的配置文件格式基本上是 Microsoft 的 INI 格式。Python 的 <strong>configparser</strong> 模块可以用来读取和写入这些文件。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> configparser</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们将进行一些日期&#x2F;时间操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们只需要一次，读取 Unix 上的用户&#x2F;组数据库（<code>grp</code> 用于组，<code>pwd</code> 用于用户）。这是因为 Git 保存文件的数字所有者&#x2F;组 ID，我们希望将其以文本形式友好地显示出来。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> grp, pwd</span><br></pre></td></tr></table></figure>
</li>
<li><p>为了支持 <code>.gitignore</code>，我们需要将文件名与诸如 <code>*.txt</code> 之类的模式进行匹配。文件名匹配在 <strong>fnmatch</strong> 模块中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fnmatch <span class="keyword">import</span> fnmatch</span><br></pre></td></tr></table></figure>
</li>
<li><p>Git 广泛使用 SHA-1 函数。在 Python 中，它位于 <a target="_blank" rel="noopener" href="https://docs.python.org/3/library/hashlib.html"><strong>hashlib</strong></a> 模块中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br></pre></td></tr></table></figure>
</li>
<li><p>仅需要从 <strong>math</strong> 模块中导入一个函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> ceil</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>os</strong> 和 <strong>os.path</strong> 提供了一些很好的文件系统抽象函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们只使用了一些正则表达式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们还需要 <strong>sys</strong> 来访问实际的命令行参数（在 <strong>sys.argv</strong> 中）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br></pre></td></tr></table></figure>
</li>
<li><p>Git 使用 zlib 压缩所有内容。Python 也有这个模块：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zlib</span><br></pre></td></tr></table></figure></li>
</ul>
<p>导入完成。我们将频繁处理命令行参数。Python 提供了一个简单而功能强大的解析库 <strong>argparse</strong>。它是一个很好的库，但它的接口可能不是最直观的；如果有需要，可以参考它的<a target="_blank" rel="noopener" href="https://docs.python.org/3/library/argparse.html">文档</a>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">argparser = argparse.ArgumentParser(description=<span class="string">&quot;The stupidest content tracker&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>我们需要处理子命令（如 git 中的 <code>init</code>、<code>commit</code> 等）。在 <code>argparse</code> 的术语中，这些被称为“子解析器”（subparsers）。此时，我们只需要声明我们的命令行界面（CLI）将使用一些子命令，并且所有调用实际上都需要一个子命令——你不能仅仅调用 <code>git</code>，你需要调用 <code>git COMMAND</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">argsubparsers = argparser.add_subparsers(title=<span class="string">&quot;Commands&quot;</span>, dest=<span class="string">&quot;command&quot;</span>)</span><br><span class="line">argsubparsers.required = <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p><code>dest=&quot;command&quot;</code> 参数表示所选择的子解析器的名称将作为字符串返回，并存储在一个名为 <code>command</code> 的字段中。因此，我们只需要读取这个字符串，并根据它调用正确的函数。按照惯例，我将这些函数称为“桥接函数”，并在函数名前加上 <code>cmd_</code> 前缀。桥接函数将解析后的参数作为唯一的参数，并负责在执行实际命令之前处理和验证这些参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">argv=sys.argv[<span class="number">1</span>:]</span>):</span><br><span class="line">    args = argparser.parse_args(argv)</span><br><span class="line">    <span class="keyword">match</span> args.command:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;add&quot;</span>          : cmd_add(args)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;cat-file&quot;</span>     : cmd_cat_file(args)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;check-ignore&quot;</span> : cmd_check_ignore(args)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;checkout&quot;</span>     : cmd_checkout(args)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;commit&quot;</span>       : cmd_commit(args)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;hash-object&quot;</span>  : cmd_hash_object(args)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;init&quot;</span>         : cmd_init(args)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;log&quot;</span>          : cmd_log(args)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;ls-files&quot;</span>     : cmd_ls_files(args)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;ls-tree&quot;</span>      : cmd_ls_tree(args)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;rev-parse&quot;</span>    : cmd_rev_parse(args)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;rm&quot;</span>           : cmd_rm(args)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;show-ref&quot;</span>     : cmd_show_ref(args)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;status&quot;</span>       : cmd_status(args)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;tag&quot;</span>          : cmd_tag(args)</span><br><span class="line">        <span class="keyword">case</span> _              : <span class="built_in">print</span>(<span class="string">&quot;Bad command.&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="3-Creating-repositories-init"><a href="#3-Creating-repositories-init" class="headerlink" title="3. Creating repositories: init"></a>3. Creating repositories: init</h2><p>显然，按时间顺序和逻辑顺序，第一个 Git 命令是 <code>git init</code>，因此我们将从创建 <code>wyag init</code> 开始。为了实现这一点，我们首先需要一些非常基础的仓库抽象。</p>
<h3 id="3-1-The-Repository-object"><a href="#3-1-The-Repository-object" class="headerlink" title="3.1. The Repository object"></a>3.1. The Repository object</h3><p>显然，我们需要对仓库进行一些抽象：几乎每次运行 Git 命令时，我们都是在尝试对仓库做某些操作，创建它、读取它或修改它。</p>
<p>一个 Git 仓库由两部分组成：一个“工作树”，存放着要进行版本控制的文件；一个“git 目录”，Git 用来存储自己的数据。在大多数情况下，工作树是一个普通目录，git 目录是工作树的子目录，名为 <code>.git</code>。</p>
<p>Git 支持更多的情况（裸仓库、分离的 gitdir 等），但我们不需要考虑这些情况：我们将坚持使用工作树&#x2F; <code>.git</code> 的基本结构。我们的仓库对象将只包含两个路径：工作树路径和 git 目录路径。</p>
<p>要创建一个新的 <strong>Repository</strong> 对象，我们只需要进行几个检查：</p>
<ul>
<li>必须验证目录是否存在，并且包含一个名为 <code>.git</code> 的子目录。</li>
<li>然后读取 <code>.git/config</code> 中的配置文件（它只是一个 INI 文件），并检查 <code>core.repositoryformatversion</code> 是否为 0。稍后会详细介绍这个字段。</li>
</ul>
<p>我们的构造函数接受一个可选的 <code>force</code> 参数，用于禁用所有检查。这是因为稍后我们将创建的 <code>repo_create()</code> 函数会使用 <strong>Repository</strong> 对象来创建仓库。因此，我们需要一种方法，即使在（仍然）无效的文件系统位置，也能创建这样的对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GitRepository</span> (<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;A git repository&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    worktree = <span class="literal">None</span></span><br><span class="line">    gitdir = <span class="literal">None</span></span><br><span class="line">    conf = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, path, force=<span class="literal">False</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.worktree = path</span><br><span class="line">        <span class="variable language_">self</span>.gitdir = os.path.join(path, <span class="string">&quot;.git&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (force <span class="keyword">or</span> os.path.isdir(<span class="variable language_">self</span>.gitdir)):</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">f&quot;Not a Git repository <span class="subst">&#123;path&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Read configuration file in .git/config</span></span><br><span class="line">        <span class="variable language_">self</span>.conf = configparser.ConfigParser()</span><br><span class="line">        cf = repo_file(<span class="variable language_">self</span>, <span class="string">&quot;config&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> cf <span class="keyword">and</span> os.path.exists(cf):</span><br><span class="line">            <span class="variable language_">self</span>.conf.read([cf])</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> force:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;Configuration file missing&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> force:</span><br><span class="line">            vers = <span class="built_in">int</span>(<span class="variable language_">self</span>.conf.get(<span class="string">&quot;core&quot;</span>, <span class="string">&quot;repositoryformatversion&quot;</span>))</span><br><span class="line">            <span class="keyword">if</span> vers != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">raise</span> Exception(<span class="string">&quot;Unsupported repositoryformatversion: &#123;vers&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>我们将处理仓库中的许多路径。我们不妨创建一些实用函数来计算这些路径，并在需要时创建缺失的目录结构。首先，创建一个通用的路径构建函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">repo_path</span>(<span class="params">repo, *path</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Compute path under repo&#x27;s gitdir.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> os.path.join(repo.gitdir, *path)</span><br></pre></td></tr></table></figure>

<p>（关于 Python 语法的说明：<code>*path</code> 使得这个函数变为可变参数函数，因此可以将多个路径组件作为单独的参数传入。例如，<code>repo_path(repo, &quot;objects&quot;, &quot;df&quot;, &quot;4ec9fc2ad990cb9da906a95a6eda6627d7b7b0&quot;)</code> 是一个有效的调用。函数接收到的 <code>path</code> 是一个列表。）</p>
<p>接下来的两个函数，<code>repo_file()</code> 和 <code>repo_dir()</code>，分别返回并可选择性地创建文件或目录的路径。它们之间的区别在于，文件版本(<code>repo_file()</code>)只会创建到最后一个组件的目录。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">repo_file</span>(<span class="params">repo, *path, mkdir=<span class="literal">False</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Same as repo_path, but create dirname(*path) if absent.  For</span></span><br><span class="line"><span class="string">example, repo_file(r, \&quot;refs\&quot;, \&quot;remotes\&quot;, \&quot;origin\&quot;, \&quot;HEAD\&quot;) will create</span></span><br><span class="line"><span class="string">.git/refs/remotes/origin.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> repo_dir(repo, *path[:-<span class="number">1</span>], mkdir=mkdir):</span><br><span class="line">        <span class="keyword">return</span> repo_path(repo, *path)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">repo_dir</span>(<span class="params">repo, *path, mkdir=<span class="literal">False</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Same as repo_path, but mkdir *path if absent if mkdir.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    path = repo_path(repo, *path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(path):</span><br><span class="line">        <span class="keyword">if</span> (os.path.isdir(path)):</span><br><span class="line">            <span class="keyword">return</span> path</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">f&quot;Not a directory <span class="subst">&#123;path&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> mkdir:</span><br><span class="line">        os.makedirs(path)</span><br><span class="line">        <span class="keyword">return</span> path</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>（关于语法的第二个也是最后一个说明：由于 <code>*path</code> 使得函数成为可变参数函数，因此 <code>mkdir</code> 参数必须通过名称显式传递。例如，<code>repo_file(repo, &quot;objects&quot;, mkdir=True)</code>。）</p>
<p>要创建一个新的仓库，我们首先从一个目录开始（如果该目录不存在，我们会创建它），然后在其中创建 git 目录（该目录必须不存在或为空）。这个目录叫做 <code>.git</code>（前导的点使其在 Unix 系统中成为“隐藏”目录），并包含：</p>
<ul>
<li><code>.git/objects/</code>：对象存储，我们将在下一节介绍。</li>
<li><code>.git/refs/</code>：引用存储，稍后会讨论。它包含两个子目录，<code>heads</code> 和 <code>tags</code>。</li>
<li><code>.git/HEAD</code>：当前 HEAD 的引用（稍后会详细讲解！）。</li>
<li><code>.git/config</code>：仓库的配置文件。</li>
<li><code>.git/description</code>：包含一个自由格式的仓库描述，供人类使用，且很少使用。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">repo_create</span>(<span class="params">path</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Create a new repository at path.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    repo = GitRepository(path, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># First, we make sure the path either doesn&#x27;t exist or is an</span></span><br><span class="line">    <span class="comment"># empty dir.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(repo.worktree):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(repo.worktree):</span><br><span class="line">            <span class="keyword">raise</span> Exception (<span class="string">f&quot;<span class="subst">&#123;path&#125;</span> is not a directory!&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> os.path.exists(repo.gitdir) <span class="keyword">and</span> os.listdir(repo.gitdir):</span><br><span class="line">            <span class="keyword">raise</span> Exception (<span class="string">f&quot;<span class="subst">&#123;path&#125;</span> is not empty!&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        os.makedirs(repo.worktree)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> repo_dir(repo, <span class="string">&quot;branches&quot;</span>, mkdir=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">assert</span> repo_dir(repo, <span class="string">&quot;objects&quot;</span>, mkdir=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">assert</span> repo_dir(repo, <span class="string">&quot;refs&quot;</span>, <span class="string">&quot;tags&quot;</span>, mkdir=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">assert</span> repo_dir(repo, <span class="string">&quot;refs&quot;</span>, <span class="string">&quot;heads&quot;</span>, mkdir=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># .git/description</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(repo_file(repo, <span class="string">&quot;description&quot;</span>), <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(<span class="string">&quot;Unnamed repository; edit this file &#x27;description&#x27; to name the repository.\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># .git/HEAD</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(repo_file(repo, <span class="string">&quot;HEAD&quot;</span>), <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(<span class="string">&quot;ref: refs/heads/master\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(repo_file(repo, <span class="string">&quot;config&quot;</span>), <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        config = repo_default_config()</span><br><span class="line">        config.write(f)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> repo</span><br></pre></td></tr></table></figure>

<p>配置文件非常简单，它是一个类似 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/INI_file">INI</a> 的文件，包含一个部分（<code>[core]</code>）和三个字段：</p>
<ul>
<li><code>repositoryformatversion = 0</code>：gitdir 格式的版本。0 表示初始格式，1 表示带扩展的相同格式。如果大于 1，Git 会 panic；wyag 只接受 0。</li>
<li><code>filemode = false</code>：禁用在工作树中跟踪文件模式（权限）更改。</li>
<li><code>bare = false</code>：指示该仓库有一个工作树。Git 支持一个可选的 <code>worktree</code> 键，用于指示工作树的位置（如果不是 <code>..</code>）；wyag 不支持此功能。</li>
</ul>
<p>我们使用 Python 的 <code>configparser</code> 库来创建这个文件：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">repo_default_config</span>():</span><br><span class="line">    ret = configparser.ConfigParser()</span><br><span class="line"></span><br><span class="line">    ret.add_section(<span class="string">&quot;core&quot;</span>)</span><br><span class="line">    ret.<span class="built_in">set</span>(<span class="string">&quot;core&quot;</span>, <span class="string">&quot;repositoryformatversion&quot;</span>, <span class="string">&quot;0&quot;</span>)</span><br><span class="line">    ret.<span class="built_in">set</span>(<span class="string">&quot;core&quot;</span>, <span class="string">&quot;filemode&quot;</span>, <span class="string">&quot;false&quot;</span>)</span><br><span class="line">    ret.<span class="built_in">set</span>(<span class="string">&quot;core&quot;</span>, <span class="string">&quot;bare&quot;</span>, <span class="string">&quot;false&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<h3 id="3-2-The-init-command"><a href="#3-2-The-init-command" class="headerlink" title="3.2. The init command"></a>3.2. The init command</h3><p>现在我们有了用于读取和创建仓库的代码，让我们通过创建 <code>wyag init</code> 命令来使这些代码可以从命令行使用。<code>wyag init</code> 的行为与 <code>git init</code> 完全相同——当然，自定义性要少得多。<code>wyag init</code> 的语法将是：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wyag init [path]</span><br></pre></td></tr></table></figure>

<p>我们已经有了完整的仓库创建逻辑。为了创建这个命令，我们只需要再添加两件事：</p>
<ol>
<li><p>我们需要创建一个 <code>argparse</code> 子解析器来处理我们命令的参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">argsp = argsubparsers.add_parser(<span class="string">&quot;init&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;Initialize a new, empty repository.&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>对于 <code>init</code> 命令，有一个单一的可选位置参数：初始化仓库的路径。默认为当前目录 :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">argsp.add_argument(<span class="string">&quot;path&quot;</span>,</span><br><span class="line">                   metavar=<span class="string">&quot;directory&quot;</span>,</span><br><span class="line">                   nargs=<span class="string">&quot;?&quot;</span>,</span><br><span class="line">                   default=<span class="string">&quot;.&quot;</span>,</span><br><span class="line">                   <span class="built_in">help</span>=<span class="string">&quot;Where to create the repository.&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>我们还需要一个“桥接”函数，它将从 <code>argparse</code> 返回的对象中读取参数值，并使用正确的值调用实际的函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cmd_init</span>(<span class="params">args</span>):</span><br><span class="line">    repo_create(args.path)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>完成了！如果你按照这些步骤操作，你现在应该能够在任何地方使用 <code>wyag init</code> 创建一个 Git 仓库了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wyag init <span class="built_in">test</span></span></span><br></pre></td></tr></table></figure>

<p>（<code>wyag</code> 可执行文件通常不在你的 <code>$PATH</code> 中：你需要通过它的完整路径来调用它，例如 <code>~/projects/wyag/wyag init .</code>。）</p>
<h3 id="3-3-The-repo-find-function"><a href="#3-3-The-repo-find-function" class="headerlink" title="3.3. The repo_find() function"></a>3.3. The repo_find() function</h3><p>在我们实现仓库功能时，我们需要一个函数来找到当前仓库的根目录。我们将频繁使用这个函数，因为几乎所有 Git 功能都需要在现有仓库上工作（当然，<code>init</code> 除外！）。有时根目录就是当前目录，但也可能是父目录：比如你的仓库根目录可能在 <code>~/Documents/MyProject</code>，但你当前可能在 <code>~/Documents/MyProject/src/tui/frames/mainview/</code> 工作。我们现在将创建的 <code>repo_find()</code> 函数将从当前目录开始查找仓库根目录，并递归向上查找，直到根目录 <code>/</code>。要识别一个路径是否为仓库，它将检查该路径是否存在 <code>.git</code> 目录。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">repo_find</span>(<span class="params">path=<span class="string">&quot;.&quot;</span>, required=<span class="literal">True</span></span>):</span><br><span class="line">    path = os.path.realpath(path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> os.path.isdir(os.path.join(path, <span class="string">&quot;.git&quot;</span>)):</span><br><span class="line">        <span class="keyword">return</span> GitRepository(path)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># If we haven&#x27;t returned, recurse in parent, if w</span></span><br><span class="line">    parent = os.path.realpath(os.path.join(path, <span class="string">&quot;..&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> parent == path:</span><br><span class="line">        <span class="comment"># Bottom case</span></span><br><span class="line">        <span class="comment"># os.path.join(&quot;/&quot;, &quot;..&quot;) == &quot;/&quot;:</span></span><br><span class="line">        <span class="comment"># If parent==path, then path is root.</span></span><br><span class="line">        <span class="keyword">if</span> required:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;No git directory.&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Recursive case</span></span><br><span class="line">    <span class="keyword">return</span> repo_find(parent, required)</span><br></pre></td></tr></table></figure>

<p>仓库部分完成了！</p>
<h2 id="4-Reading-and-writing-objects-hash-object-and-cat-file"><a href="#4-Reading-and-writing-objects-hash-object-and-cat-file" class="headerlink" title="4. Reading and writing objects: hash-object and cat-file"></a>4. Reading and writing objects: hash-object and cat-file</h2><h3 id="4-1-What-are-objects"><a href="#4-1-What-are-objects" class="headerlink" title="4.1. What are objects?"></a>4.1. What are objects?</h3><p>既然我们已经有了仓库，接下来就是往其中放东西。与此同时，仓库本身也很单调，编写 Git 实现不应该仅仅是写一堆 <code>mkdir</code>。让我们来谈谈对象，并实现 <code>git hash-object</code> 和 <code>git cat-file</code>。</p>
<p>也许你不太了解这两个命令——它们并不是 Git 日常工具箱的一部分，而且实际上是非常底层的命令（在 Git 术语中叫做“管道命令”）。它们的功能其实非常简单：<code>hash-object</code> 将一个现有的文件转换成一个 Git 对象，而 <code>cat-file</code> 将一个现有的 Git 对象打印到标准输出。</p>
<p>那么，什么是 Git 对象呢？从本质上来说，Git 是一个“内容寻址文件系统”。这意味着，与普通的文件系统不同，文件名是任意的，与文件内容无关，而 Git 存储的文件名是通过文件内容的数学计算得出的。这有一个非常重要的含义：如果一个文件的内容（例如文本文件）发生了一点变化，它的内部名称也会发生变化。简单来说，你在 Git 中不是修改文件，而是创建一个新文件并将其存储在一个不同的位置。Git 对象就是这样：在 Git 仓库中的文件，它们的路径由文件内容决定。</p>
<table>
<thead>
<tr>
<th><strong>Warning</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Git 并不是真正的键值存储<br />一些文档，包括优秀的 <a target="_blank" rel="noopener" href="https://git-scm.com/book/id/v2/Git-Internals-Git-Objects">Pro Git</a> ，将 Git 称为“键值存储”。这并不完全错误，但可能会引起误解。普通的文件系统实际上比 Git 更接近键值存储。因为 Git 是根据数据计算键，所以更准确的说法是，Git 应该被称为“值-值存储”。</td>
</tr>
</tbody></table>
<p>Git 使用对象来存储许多内容：首先是它保持版本控制的实际文件——例如源代码。提交也是对象，标签也是。除了少数几个例外（稍后我们会看到！），在 Git 中，几乎所有的内容都是以对象的形式存储的。</p>
<p>Git 存储给定对象的路径是通过计算其内容的 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/SHA-1">SHA-1</a> <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Cryptographic_hash_function">哈希</a>来确定的。更精确地说，Git 将哈希值转换为小写十六进制字符串，并将其拆分为两部分：前两位字符和其余部分。它使用前两位作为目录名，其余部分作为文件名（这是因为大多数文件系统不喜欢在单个目录中存储太多文件，否则会导致系统变慢。Git 的方法创建了 256 个可能的中间目录，从而将每个目录中的平均文件数量减少了 256 倍）。</p>
<table>
<thead>
<tr>
<th><strong>Note</strong></th>
</tr>
</thead>
<tbody><tr>
<td>哈希函数是什么？<br />SHA-1 就是我们所说的“哈希函数”。简单来说，哈希函数是一种单向数学函数：计算一个值的哈希值很容易，但无法反推出哪个值产生了该哈希值。<br />一个非常简单的哈希函数例子是经典的 <code>len</code>（或 <code>strlen</code>）函数，它返回字符串的长度。计算一个字符串的长度非常容易，并且给定一个字符串，它的长度永远不会改变（当然，除非字符串本身改变！），但是仅凭长度是无法恢复原始字符串的。加密哈希函数是同样原理的更复杂版本，且具有额外的特性：计算一个输入值来产生给定哈希值的难度足够大，以至于实际上几乎不可能做到。（比如，要产生一个长度为 12 的字符串 <code>i</code>，你只需要随便输入 12 个字符。但对于像 SHA-1 这样的算法，需要的时间要长得多——足够长，以至于在实际中几乎不可能做到。[^1]</td>
</tr>
</tbody></table>
<p>[^1]: You may know that <a target="_blank" rel="noopener" href="https://shattered.io/">collisions have been discovered in SHA-1</a>. Git actually doesn’t use SHA-1 anymore: it uses a <a target="_blank" rel="noopener" href="https://github.com/git/git/blob/26e47e261e969491ad4e3b6c298450c061749c9e/Documentation/technical/hash-function-transition.txt#L34-L36">hardened variant</a> which is not SHA, but which applies the same hash to every known input but the two PDF files known to collide.</p>
<p>在我们开始实现对象存储系统之前，必须了解它们的确切存储格式。一个对象以一个头部开始，该头部指定其类型：<code>blob</code>、<code>commit</code>、<code>tag </code>或 <code>tree</code>（稍后会详细讲解）。这个头部后面跟着一个 ASCII 空格（0x20），然后是对象大小的 ASCII 数字，接着是一个空字符（0x00），最后是对象的内容。在 Wyag 的仓库中，一个 commit 对象的前 48 个字节看起来像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00000000  63 6f 6d 6d 69 74 20 31  30 38 36 00 74 72 65 65  |commit 1086.tree|</span><br><span class="line">00000010  20 32 39 66 66 31 36 63  39 63 31 34 65 32 36 35  | 29ff16c9c14e265|</span><br><span class="line">00000020  32 62 32 32 66 38 62 37  38 62 62 30 38 61 35 61  |2b22f8b78bb08a5a|</span><br></pre></td></tr></table></figure>

<p>在第一行中，我们可以看到类型头部，一个空格（<code>0x20</code>），大小的 ASCII 表示（1086）和 null 分隔符 <code>0x00</code>。第一行的最后四个字节是该对象内容的开头，单词“tree”——我们稍后会在讨论 commit 时进一步讲解。</p>
<p>这些对象（包括头部和内容）都是使用 <code>zlib</code> 压缩存储的。</p>
<h3 id="4-2-A-generic-object-object"><a href="#4-2-A-generic-object-object" class="headerlink" title="4.2. A generic object object"></a>4.2. A generic object object</h3><p>对象可以有多种类型，但它们都共享相同的存储&#x2F;检索机制以及相同的通用头部格式。在深入了解各种类型的对象之前，我们需要对这些共同特性进行抽象。最简单的方法是创建一个通用的 <code>GitObject</code> 类，具有两个未实现的方法：<code>serialize()</code> 和 <code>deserialize()</code>，并提供一个默认的 <code>init()</code> 方法，用于在需要时创建一个新的空对象（抱歉，Python 用户，这不是非常好的设计，但它可能比使用超级构造器更容易理解）。我们的 <code>__init__</code> 方法要么从提供的数据中加载对象，要么调用子类提供的 <code>init()</code> 方法来创建一个新的空对象。</p>
<p>稍后，我们将对子类化这个通用类，为每种对象格式实际实现这些函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GitObject</span> (<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> data != <span class="literal">None</span>:</span><br><span class="line">            <span class="variable language_">self</span>.deserialize(data)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="variable language_">self</span>.init()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">serialize</span>(<span class="params">self, repo</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;This function MUST be implemented by subclasses.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">It must read the object&#x27;s contents from self.data, a byte string, and</span></span><br><span class="line"><span class="string">do whatever it takes to convert it into a meaningful representation.</span></span><br><span class="line"><span class="string">What exactly that means depend on each subclass.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&quot;Unimplemented!&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deserialize</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&quot;Unimplemented!&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">init</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span> <span class="comment"># Just do nothing. This is a reasonable default!</span></span><br></pre></td></tr></table></figure>

<h3 id="4-3-Reading-objects"><a href="#4-3-Reading-objects" class="headerlink" title="4.3. Reading objects"></a>4.3. Reading objects</h3><p>为了读取一个对象，我们需要知道它的 SHA-1 哈希值。然后，我们根据这个哈希值计算其路径（按照之前解释的公式：前两个字符，然后是目录分隔符“&#x2F;”，然后是剩余部分），并在 gitdir 的“objects”目录中查找它。也就是说，<code>e673d1b7eaa0aa01b5bc2442d570a765bdaae751 </code>的路径是 <code>.git/objects/e6/73d1b7eaa0aa01b5bc2442d570a765bdaae751</code>。</p>
<p>接着，我们将该文件作为二进制文件读取，并使用 <code>zlib </code>解压它。</p>
<p>从解压后的数据中，我们提取两个头部组件：对象类型和大小。通过类型，我们确定实际使用的类。我们将大小转换为 Python 整数，并进行匹配检查。</p>
<p>完成所有步骤后，我们只需调用该对象格式的正确构造函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">object_read</span>(<span class="params">repo, sha</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Read object sha from Git repository repo.  Return a</span></span><br><span class="line"><span class="string">    GitObject whose exact type depends on the object.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    path = repo_file(repo, <span class="string">&quot;objects&quot;</span>, sha[<span class="number">0</span>:<span class="number">2</span>], sha[<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.isfile(path):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span> (path, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        raw = zlib.decompress(f.read())</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Read object type</span></span><br><span class="line">        x = raw.find(<span class="string">b&#x27; &#x27;</span>)</span><br><span class="line">        fmt = raw[<span class="number">0</span>:x]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Read and validate object size</span></span><br><span class="line">        y = raw.find(<span class="string">b&#x27;\x00&#x27;</span>, x)</span><br><span class="line">        size = <span class="built_in">int</span>(raw[x:y].decode(<span class="string">&quot;ascii&quot;</span>))</span><br><span class="line">        <span class="keyword">if</span> size != <span class="built_in">len</span>(raw)-y-<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">f&quot;Malformed object <span class="subst">&#123;sha&#125;</span>: bad length&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Pick constructor</span></span><br><span class="line">        <span class="keyword">match</span> fmt:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">b&#x27;commit&#x27;</span> : c=GitCommit</span><br><span class="line">            <span class="keyword">case</span> <span class="string">b&#x27;tree&#x27;</span>   : c=GitTree</span><br><span class="line">            <span class="keyword">case</span> <span class="string">b&#x27;tag&#x27;</span>    : c=GitTag</span><br><span class="line">            <span class="keyword">case</span> <span class="string">b&#x27;blob&#x27;</span>   : c=GitBlob</span><br><span class="line">            <span class="keyword">case</span> _:</span><br><span class="line">                <span class="keyword">raise</span> Exception(<span class="string">f&quot;Unknown type <span class="subst">&#123;fmt.decode(<span class="string">&quot;ascii&quot;</span>)&#125;</span> for object <span class="subst">&#123;sha&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Call constructor and return object</span></span><br><span class="line">        <span class="keyword">return</span> c(raw[y+<span class="number">1</span>:])</span><br></pre></td></tr></table></figure>

<h3 id="4-4-Writing-objects"><a href="#4-4-Writing-objects" class="headerlink" title="4.4. Writing objects"></a>4.4. Writing objects</h3><p>写入对象的过程实际上是读取过程的逆操作：我们先计算哈希值，接着添加头部，然后使用 zlib 压缩所有数据，并将结果写入正确的位置。这里不需要太多解释，值得注意的是哈希值是在添加头部后计算的（因此它是对象本身的哈希值，包括未压缩的头部，而不仅仅是内容的哈希）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">object_write</span>(<span class="params">obj, repo=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="comment"># Serialize object data</span></span><br><span class="line">    data = obj.serialize()</span><br><span class="line">    <span class="comment"># Add header</span></span><br><span class="line">    result = obj.fmt + <span class="string">b&#x27; &#x27;</span> + <span class="built_in">str</span>(<span class="built_in">len</span>(data)).encode() + <span class="string">b&#x27;\x00&#x27;</span> + data</span><br><span class="line">    <span class="comment"># Compute hash</span></span><br><span class="line">    sha = hashlib.sha1(result).hexdigest()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> repo:</span><br><span class="line">        <span class="comment"># Compute path</span></span><br><span class="line">        path=repo_file(repo, <span class="string">&quot;objects&quot;</span>, sha[<span class="number">0</span>:<span class="number">2</span>], sha[<span class="number">2</span>:], mkdir=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path):</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(path, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                <span class="comment"># Compress and write</span></span><br><span class="line">                f.write(zlib.compress(result))</span><br><span class="line">    <span class="keyword">return</span> sha</span><br></pre></td></tr></table></figure>

<h3 id="4-5-Working-with-blobs"><a href="#4-5-Working-with-blobs" class="headerlink" title="4.5. Working with blobs"></a>4.5. Working with blobs</h3><p>正如之前所说，类型头可以是四种之一：<code>blob</code>、<code>commit</code>、<code>tag</code> 和 <code>tree </code>— 因此 Git 有四种对象类型。</p>
<p>Blobs 是这四种类型中最简单的，因为它们没有实际的格式。Blobs 是用户数据：你放入 Git 中的每个文件（如 main.c、logo.png、README.md）的内容都作为一个 Blob 存储。这使得它们易于操作，因为除了基本的对象存储机制外，它们没有实际的语法或约束：它们只是未指定的数据。因此，创建一个 GitBlob 类是微不足道的，<code>serialize </code>和 <code>deserialize </code>函数只需存储和返回它们的输入，不做任何修改。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GitBlob</span>(<span class="title class_ inherited__">GitObject</span>):</span><br><span class="line">    fmt=<span class="string">b&#x27;blob&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">serialize</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.blobdata</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deserialize</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="variable language_">self</span>.blobdata = data</span><br></pre></td></tr></table></figure>

<h3 id="4-6-The-cat-file-command"><a href="#4-6-The-cat-file-command" class="headerlink" title="4.6. The cat-file command"></a>4.6. The cat-file command</h3><p>我们现在可以创建 <code>wyag cat-file</code> 了。<code>git cat-file</code> 只是将对象的原始内容打印到标准输出，解压缩并去除 Git 头部信息。在 <a target="_blank" rel="noopener" href="https://github.com/thblt/write-yourself-a-git">Wyag 的源代码仓库</a>中，运行：<code>git cat-file blob e0695f14a412c29e252c998c81de1dde59658e4a</code>将会显示某个 README 文件的版本内容。</p>
<p>我们的简化版本只需要两个位置参数：一个类型和一个对象标识符。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wyag cat-file TYPE OBJECT</span><br></pre></td></tr></table></figure>

<p>子解析器非常简单：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">argsp = argsubparsers.add_parser(<span class="string">&quot;cat-file&quot;</span>,</span><br><span class="line">                                 <span class="built_in">help</span>=<span class="string">&quot;Provide content of repository objects&quot;</span>)</span><br><span class="line"></span><br><span class="line">argsp.add_argument(<span class="string">&quot;type&quot;</span>,</span><br><span class="line">                   metavar=<span class="string">&quot;type&quot;</span>,</span><br><span class="line">                   choices=[<span class="string">&quot;blob&quot;</span>, <span class="string">&quot;commit&quot;</span>, <span class="string">&quot;tag&quot;</span>, <span class="string">&quot;tree&quot;</span>],</span><br><span class="line">                   <span class="built_in">help</span>=<span class="string">&quot;Specify the type&quot;</span>)</span><br><span class="line"></span><br><span class="line">argsp.add_argument(<span class="string">&quot;object&quot;</span>,</span><br><span class="line">                   metavar=<span class="string">&quot;object&quot;</span>,</span><br><span class="line">                   <span class="built_in">help</span>=<span class="string">&quot;The object to display&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>我们可以实现这些函数，它们只是调用我们之前编写的现有代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cmd_cat_file</span>(<span class="params">args</span>):</span><br><span class="line">    repo = repo_find()</span><br><span class="line">    cat_file(repo, args.<span class="built_in">object</span>, fmt=args.<span class="built_in">type</span>.encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cat_file</span>(<span class="params">repo, obj, fmt=<span class="literal">None</span></span>):</span><br><span class="line">    obj = object_read(repo, object_find(repo, obj, fmt=fmt))</span><br><span class="line">    sys.stdout.buffer.write(obj.serialize())</span><br></pre></td></tr></table></figure>

<p>这个函数调用了一个尚未介绍的 <code>object_find</code> 函数。目前，它只是返回其中一个参数，像这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">object_find</span>(<span class="params">repo, name, fmt=<span class="literal">None</span>, follow=<span class="literal">True</span></span>):</span><br><span class="line">    <span class="keyword">return</span> name</span><br></pre></td></tr></table></figure>

<p>之所以需要这个奇怪的小函数，是因为 Git 有许多方式来引用对象：完整哈希、短哈希、标签……<code>object_find()</code> 将作为我们的名称解析函数。我们稍后才会实现它，因此这里只是一个临时占位符。这意味着在实现真正的 <code>object_find()</code> 之前，我们只能通过完整哈希来引用对象。</p>
<h3 id="4-7-The-hash-object-command"><a href="#4-7-The-hash-object-command" class="headerlink" title="4.7. The hash-object command"></a>4.7. The hash-object command</h3><p>我们希望能够将自己的数据存入仓库中。<code>hash-object</code> 基本上是 <code>cat-file</code> 的反向操作：它读取一个文件，将其计算为对象的哈希值，并在仓库中存储该对象（如果传递了 <code>-w</code> 标志），或者只是打印其哈希值。</p>
<p><code>wyag hash-object</code> 的语法是 <code>git hash-object</code> 的简化版本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wyag hash-object [-w] [-t TYPE] FILE</span><br></pre></td></tr></table></figure>

<p>这转换为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">argsp = argsubparsers.add_parser(</span><br><span class="line">    <span class="string">&quot;hash-object&quot;</span>,</span><br><span class="line">    <span class="built_in">help</span>=<span class="string">&quot;Compute object ID and optionally creates a blob from a file&quot;</span>)</span><br><span class="line"></span><br><span class="line">argsp.add_argument(<span class="string">&quot;-t&quot;</span>,</span><br><span class="line">                   metavar=<span class="string">&quot;type&quot;</span>,</span><br><span class="line">                   dest=<span class="string">&quot;type&quot;</span>,</span><br><span class="line">                   choices=[<span class="string">&quot;blob&quot;</span>, <span class="string">&quot;commit&quot;</span>, <span class="string">&quot;tag&quot;</span>, <span class="string">&quot;tree&quot;</span>],</span><br><span class="line">                   default=<span class="string">&quot;blob&quot;</span>,</span><br><span class="line">                   <span class="built_in">help</span>=<span class="string">&quot;Specify the type&quot;</span>)</span><br><span class="line"></span><br><span class="line">argsp.add_argument(<span class="string">&quot;-w&quot;</span>,</span><br><span class="line">                   dest=<span class="string">&quot;write&quot;</span>,</span><br><span class="line">                   action=<span class="string">&quot;store_true&quot;</span>,</span><br><span class="line">                   <span class="built_in">help</span>=<span class="string">&quot;Actually write the object into the database&quot;</span>)</span><br><span class="line"></span><br><span class="line">argsp.add_argument(<span class="string">&quot;path&quot;</span>,</span><br><span class="line">                   <span class="built_in">help</span>=<span class="string">&quot;Read object from &lt;file&gt;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>实际实现非常简单。像往常一样，我们创建一个小的桥接函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cmd_hash_object</span>(<span class="params">args</span>):</span><br><span class="line">    <span class="keyword">if</span> args.write:</span><br><span class="line">        repo = repo_find()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        repo = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(args.path, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> fd:</span><br><span class="line">        sha = object_hash(fd, args.<span class="built_in">type</span>.encode(), repo)</span><br><span class="line">        <span class="built_in">print</span>(sha)</span><br></pre></td></tr></table></figure>

<p>实际实现也很简单。<code>repo</code> 参数是可选的，如果它是 <code>None</code>，对象就不会被写入（这一点在上面的 <code>object_write()</code> 中处理）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">object_hash</span>(<span class="params">fd, fmt, repo=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; Hash object, writing it to repo if provided.&quot;&quot;&quot;</span></span><br><span class="line">    data = fd.read()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Choose constructor according to fmt argument</span></span><br><span class="line">    <span class="keyword">match</span> fmt:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">b&#x27;commit&#x27;</span> : obj=GitCommit(data)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">b&#x27;tree&#x27;</span>   : obj=GitTree(data)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">b&#x27;tag&#x27;</span>    : obj=GitTag(data)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">b&#x27;blob&#x27;</span>   : obj=GitBlob(data)</span><br><span class="line">        <span class="keyword">case</span> _: <span class="keyword">raise</span> Exception(<span class="string">f&quot;Unknown type <span class="subst">&#123;fmt&#125;</span>!&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> object_write(obj, repo)</span><br></pre></td></tr></table></figure>

<h3 id="4-8-Aside-what-about-packfiles"><a href="#4-8-Aside-what-about-packfiles" class="headerlink" title="4.8. Aside: what about packfiles?"></a>4.8. Aside: what about packfiles?</h3><p>我们刚刚实现的被称为“松散对象”（loose objects）。Git 还有另一种对象存储机制，称为 packfiles。Packfiles 比松散对象更高效，但也更复杂。简单来说，packfile 是松散对象的一个集合（类似于 tar 文件），但其中一些对象以增量（delta）的形式存储，即作为另一个对象的变体。Packfiles 过于复杂，wyag 无法支持它们。</p>
<p>Packfile 存储在 <code>.git/objects/pack/</code> 目录下，扩展名为 <code>.pack</code>，并附带一个同名的索引文件，扩展名为 <code>.idx</code>。如果你想将 packfile 转换为松散对象格式（例如，在现有的仓库上使用 wyag），可以使用以下方法：</p>
<p>首先，将 packfile 移出 gitdir（仅仅复制是无效的）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv .git/objects/pack/pack-d9ef004d4ca729287f12aaaacf36fee39baa7c9d.pack .</span><br></pre></td></tr></table></figure>

<p>你可以忽略 <code>.idx</code> 文件。然后，在工作区中，只需使用 <code>cat</code> 命令输出 packfile 并通过管道传递给 <code>git unpack-objects</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat pack-d9ef004d4ca729287f12aaaacf36fee39baa7c9d.pack | git unpack-objects</span><br></pre></td></tr></table></figure>

<h2 id="5-Reading-commit-history-log"><a href="#5-Reading-commit-history-log" class="headerlink" title="5. Reading commit history: log"></a>5. Reading commit history: log</h2><h3 id="5-1-Parsing-commits"><a href="#5-1-Parsing-commits" class="headerlink" title="5.1. Parsing commits"></a>5.1. Parsing commits</h3><p>现在我们已经可以读取和写入对象，我们应该考虑提交对象。一个提交对象（未压缩且不含头部）看起来像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">tree 29ff16c9c14e2652b22f8b78bb08a5a07930c147</span><br><span class="line">parent 206941306e8a8af65b66eaaaea388a7ae24d49a0</span><br><span class="line">author Thibault Polge &lt;thibault@thb.lt&gt; 1527025023 +0200</span><br><span class="line">committer Thibault Polge &lt;thibault@thb.lt&gt; 1527025044 +0200</span><br><span class="line">gpgsig -----BEGIN PGP SIGNATURE-----</span><br><span class="line"></span><br><span class="line"> iQIzBAABCAAdFiEExwXquOM8bWb4Q2zVGxM2FxoLkGQFAlsEjZQACgkQGxM2FxoL</span><br><span class="line"> kGQdcBAAqPP+ln4nGDd2gETXjvOpOxLzIMEw4A9gU6CzWzm+oB8mEIKyaH0UFIPh</span><br><span class="line"> rNUZ1j7/ZGFNeBDtT55LPdPIQw4KKlcf6kC8MPWP3qSu3xHqx12C5zyai2duFZUU</span><br><span class="line"> wqOt9iCFCscFQYqKs3xsHI+ncQb+PGjVZA8+jPw7nrPIkeSXQV2aZb1E68wa2YIL</span><br><span class="line"> 3eYgTUKz34cB6tAq9YwHnZpyPx8UJCZGkshpJmgtZ3mCbtQaO17LoihnqPn4UOMr</span><br><span class="line"> V75R/7FjSuPLS8NaZF4wfi52btXMSxO/u7GuoJkzJscP3p4qtwe6Rl9dc1XC8P7k</span><br><span class="line"> NIbGZ5Yg5cEPcfmhgXFOhQZkD0yxcJqBUcoFpnp2vu5XJl2E5I/quIyVxUXi6O6c</span><br><span class="line"> /obspcvace4wy8uO0bdVhc4nJ+Rla4InVSJaUaBeiHTW8kReSFYyMmDCzLjGIu1q</span><br><span class="line"> doU61OM3Zv1ptsLu3gUE6GU27iWYj2RWN3e3HE4Sbd89IFwLXNdSuM0ifDLZk7AQ</span><br><span class="line"> WBhRhipCCgZhkj9g2NEk7jRVslti1NdN5zoQLaJNqSwO1MtxTmJ15Ksk3QP6kfLB</span><br><span class="line"> Q52UWybBzpaP9HEd4XnR+HuQ4k2K0ns2KgNImsNvIyFwbpMUyUWLMPimaV1DWUXo</span><br><span class="line"> 5SBjDB/V/W2JBFR+XKHFJeFwYhj7DD/ocsGr4ZMx/lgc8rjIBkI=</span><br><span class="line"> =lgTX</span><br><span class="line"> -----END PGP SIGNATURE-----</span><br><span class="line"></span><br><span class="line">Create first draft</span><br></pre></td></tr></table></figure>

<p>该格式是 RFC 2822 规定的邮件消息的简化版本。它以一系列键值对开头，使用空格作为键和值的分隔符，并以提交消息结束，提交消息可能会跨多行。值可能会延续到多行，后续行以空格开头，解析器必须忽略这些空格（例如上面的 <code>gpgsig</code> 字段，它跨越了 16 行）。</p>
<p>让我们来看一下这些字段的含义：</p>
<ul>
<li><p><strong>tree</strong>：指向一个树（tree）对象，我们将在接下来介绍它。树对象将 blob ID 映射到文件系统位置，并描述工作区的状态。简单来说，它代表了提交的实际内容：文件内容以及它们的位置。</p>
</li>
<li><p><strong>parent</strong>：指向该提交的父提交。该字段可以重复，例如合并提交（merge commit）通常有多个父提交。但它也可能不存在，例如一个仓库中的第一个提交显然没有父提交。</p>
</li>
<li><p><strong>author</strong> 和 <strong>committer</strong>：它们是分开的，因为提交的作者不一定是最终提交的人（对于 GitHub 用户来说，这可能并不明显，但许多项目是通过电子邮件进行 Git 操作的）。</p>
</li>
<li><p><strong>gpgsig</strong>：该对象的 PGP 签名。</p>
</li>
</ul>
<p>我们将从编写一个简单的解析器开始，代码很直观。我们即将创建的函数名 <strong><code>kvlm_parse()</code></strong> 可能会让人困惑：它不叫 <strong><code>commit_parse()</code><strong>，因为 <strong>tag</strong> 对象使用的是完全相同的格式，因此我们会将它用于这两种对象类型。我使用 <strong>KVLM</strong> 来表示“</strong>Key-Value List with Message</strong>”（键值列表加消息）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">kvlm_parse</span>(<span class="params">raw, start=<span class="number">0</span>, dct=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> dct:</span><br><span class="line">        dct = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="comment"># You CANNOT declare the argument as dct=dict() or all call to</span></span><br><span class="line">        <span class="comment"># the functions will endlessly grow the same dict.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># This function is recursive: it reads a key/value pair, then call</span></span><br><span class="line">    <span class="comment"># itself back with the new position.  So we first need to know</span></span><br><span class="line">    <span class="comment"># where we are: at a keyword, or already in the messageQ</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># We search for the next space and the next newline.</span></span><br><span class="line">    spc = raw.find(<span class="string">b&#x27; &#x27;</span>, start)</span><br><span class="line">    nl = raw.find(<span class="string">b&#x27;\n&#x27;</span>, start)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># If space appears before newline, we have a keyword.  Otherwise,</span></span><br><span class="line">    <span class="comment"># it&#x27;s the final message, which we just read to the end of the file.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Base case</span></span><br><span class="line">    <span class="comment"># =========</span></span><br><span class="line">    <span class="comment"># If newline appears first (or there&#x27;s no space at all, in which</span></span><br><span class="line">    <span class="comment"># case find returns -1), we assume a blank line.  A blank line</span></span><br><span class="line">    <span class="comment"># means the remainder of the data is the message.  We store it in</span></span><br><span class="line">    <span class="comment"># the dictionary, with None as the key, and return.</span></span><br><span class="line">    <span class="keyword">if</span> (spc &lt; <span class="number">0</span>) <span class="keyword">or</span> (nl &lt; spc):</span><br><span class="line">        <span class="keyword">assert</span> nl == start</span><br><span class="line">        dct[<span class="literal">None</span>] = raw[start+<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">return</span> dct</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Recursive case</span></span><br><span class="line">    <span class="comment"># ==============</span></span><br><span class="line">    <span class="comment"># we read a key-value pair and recurse for the next.</span></span><br><span class="line">    key = raw[start:spc]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Find the end of the value.  Continuation lines begin with a</span></span><br><span class="line">    <span class="comment"># space, so we loop until we find a &quot;\n&quot; not followed by a space.</span></span><br><span class="line">    end = start</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        end = raw.find(<span class="string">b&#x27;\n&#x27;</span>, end+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> raw[end+<span class="number">1</span>] != <span class="built_in">ord</span>(<span class="string">&#x27; &#x27;</span>): <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Grab the value</span></span><br><span class="line">    <span class="comment"># Also, drop the leading space on continuation lines</span></span><br><span class="line">    value = raw[spc+<span class="number">1</span>:end].replace(<span class="string">b&#x27;\n &#x27;</span>, <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Don&#x27;t overwrite existing data contents</span></span><br><span class="line">    <span class="keyword">if</span> key <span class="keyword">in</span> dct:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(dct[key]) == <span class="built_in">list</span>:</span><br><span class="line">            dct[key].append(value)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dct[key] = [ dct[key], value ]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        dct[key]=value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> kvlm_parse(raw, start=end+<span class="number">1</span>, dct=dct)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>Note</strong></th>
</tr>
</thead>
<tbody><tr>
<td>对象标识规则<br />我们使用 <strong>字典（HashMap）</strong> 来存储键&#x2F;值关联，但我们依赖于 <strong>Python 字典的一个特性</strong>：它会保留插入顺序。这意味着当我们将对象写回时，我们会按字典中字段的添加顺序进行迭代，并以完全相同的顺序输出字段。这一点很重要，因为 Git 对对象标识有两个严格的规则：<br />1. <strong>相同的名称始终引用相同的对象</strong><br/>我们之前已经看到过这个规则，它是 Git 计算对象名称的方法的直接结果 —— <strong>对象的名称是其内容的哈希值</strong>。<br />2. <strong>相同的对象始终具有相同的名称</strong><br/>这条规则稍微复杂一些：它意味着 <strong>不应该存在两个等效但名称不同的对象</strong>。<br/>例如，在 Git 中，如果我们更改提交对象中字段的顺序（比如将 <code>tree</code> 字段放在 <code>parent</code> 之后），那么提交对象的 <strong>SHA-1 哈希值</strong> 也会改变，从而创建出两个 <strong>等效但哈希不同</strong> 的提交对象。<br />例如，在比较 <strong>tree 对象</strong> 时，Git 会假设 <strong>哈希不同的两个 tree 是不同的</strong>，这就是为什么在存储 tree 对象时，我们必须确保 <strong>其中的元素按正确顺序排序</strong>，以防止生成 <strong>等效但哈希不同的 tree</strong>。</td>
</tr>
</tbody></table>
<p>我们还需要写类似的对象，因此让我们向工具包中添加一个 <code>kvlm_serialize()</code> 函数。这非常简单：我们先写所有的字段，然后是一个换行符，接着是消息内容，最后再是一个换行符。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">kvlm_serialize</span>(<span class="params">kvlm</span>):</span><br><span class="line">    ret = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Output fields</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> kvlm.keys():</span><br><span class="line">        <span class="comment"># Skip the message itself</span></span><br><span class="line">        <span class="keyword">if</span> k == <span class="literal">None</span>: <span class="keyword">continue</span></span><br><span class="line">        val = kvlm[k]</span><br><span class="line">        <span class="comment"># Normalize to a list</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(val) != <span class="built_in">list</span>:</span><br><span class="line">            val = [ val ]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> val:</span><br><span class="line">            ret += k + <span class="string">b&#x27; &#x27;</span> + (v.replace(<span class="string">b&#x27;\n&#x27;</span>, <span class="string">b&#x27;\n &#x27;</span>)) + <span class="string">b&#x27;\n&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Append message</span></span><br><span class="line">    ret += <span class="string">b&#x27;\n&#x27;</span> + kvlm[<span class="literal">None</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<h3 id="5-2-The-Commit-object"><a href="#5-2-The-Commit-object" class="headerlink" title="5.2. The Commit object"></a>5.2. The Commit object</h3><p>现在我们有了解析器，我们可以创建 <code>GitCommit</code> 类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GitCommit</span>(<span class="title class_ inherited__">GitObject</span>):</span><br><span class="line">    fmt=<span class="string">b&#x27;commit&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deserialize</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="variable language_">self</span>.kvlm = kvlm_parse(data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">serialize</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> kvlm_serialize(<span class="variable language_">self</span>.kvlm)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">init</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.kvlm = <span class="built_in">dict</span>()</span><br></pre></td></tr></table></figure>

<h3 id="5-3-The-log-command"><a href="#5-3-The-log-command" class="headerlink" title="5.3. The log command"></a>5.3. The log command</h3><p>我们将实现一个比 Git 提供的版本简单得多的日志功能。最重要的是，我们不会处理日志的表示。相反，我们将输出 Graphviz 数据，让用户使用 dot 来渲染实际的日志。（如果你不知道如何使用 Graphviz，只需将原始输出粘贴到<a target="_blank" rel="noopener" href="https://dreampuf.github.io/GraphvizOnline/">这个网站</a>中。如果该链接无法访问，可以在你喜欢的搜索引擎中搜索“graphviz online”）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">argsp = argsubparsers.add_parser(<span class="string">&quot;log&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;Display history of a given commit.&quot;</span>)</span><br><span class="line">argsp.add_argument(<span class="string">&quot;commit&quot;</span>,</span><br><span class="line">                   default=<span class="string">&quot;HEAD&quot;</span>,</span><br><span class="line">                   nargs=<span class="string">&quot;?&quot;</span>,</span><br><span class="line">                   <span class="built_in">help</span>=<span class="string">&quot;Commit to start at.&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cmd_log</span>(<span class="params">args</span>):</span><br><span class="line">    repo = repo_find()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;digraph wyaglog&#123;&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;  node[shape=rect]&quot;</span>)</span><br><span class="line">    log_graphviz(repo, object_find(repo, args.commit), <span class="built_in">set</span>())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log_graphviz</span>(<span class="params">repo, sha, seen</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> sha <span class="keyword">in</span> seen:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    seen.add(sha)</span><br><span class="line"></span><br><span class="line">    commit = object_read(repo, sha)</span><br><span class="line">    message = commit.kvlm[<span class="literal">None</span>].decode(<span class="string">&quot;utf8&quot;</span>).strip()</span><br><span class="line">    message = message.replace(<span class="string">&quot;\\&quot;</span>, <span class="string">&quot;\\\\&quot;</span>)</span><br><span class="line">    message = message.replace(<span class="string">&quot;\&quot;&quot;</span>, <span class="string">&quot;\\\&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;\n&quot;</span> <span class="keyword">in</span> message: <span class="comment"># Keep only the first line</span></span><br><span class="line">        message = message[:message.index(<span class="string">&quot;\n&quot;</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;  c_<span class="subst">&#123;sha&#125;</span> [label=\&quot;<span class="subst">&#123;sha[<span class="number">0</span>:<span class="number">7</span>]&#125;</span>: <span class="subst">&#123;message&#125;</span>\&quot;]&quot;</span>)</span><br><span class="line">    <span class="keyword">assert</span> commit.fmt==<span class="string">b&#x27;commit&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="string">b&#x27;parent&#x27;</span> <span class="keyword">in</span> commit.kvlm.keys():</span><br><span class="line">        <span class="comment"># Base case: the initial commit.</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    parents = commit.kvlm[<span class="string">b&#x27;parent&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(parents) != <span class="built_in">list</span>:</span><br><span class="line">        parents = [ parents ]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> parents:</span><br><span class="line">        p = p.decode(<span class="string">&quot;ascii&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">f&quot;  c_<span class="subst">&#123;sha&#125;</span> -&gt; c_<span class="subst">&#123;p&#125;</span>;&quot;</span>)</span><br><span class="line">        log_graphviz(repo, p, seen)</span><br></pre></td></tr></table></figure>

<p>你现在可以像这样使用我们的 log 命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wyag log e03158242ecab460f31b0d6ae1642880577ccbe8 &gt; log.dot</span><br><span class="line">dot -O -Tpdf log.dot</span><br></pre></td></tr></table></figure>

<h3 id="5-4-Anatomy-of-a-commit"><a href="#5-4-Anatomy-of-a-commit" class="headerlink" title="5.4. Anatomy of a commit"></a>5.4. Anatomy of a commit</h3><p>你现在可能注意到了一些事情。</p>
<p>首先也是最重要的一点，我们一直在处理提交，浏览和遍历提交对象，构建提交历史的图形，而从未触及工作树中的任何文件或 Blob。我们做了很多关于提交的事情，但没有考虑它们的内容。这一点很重要：工作树的内容只是提交的一部分。但一个提交由它所包含的一切组成：它的内容、它的作者，还有它的父提交。如果你记得提交的 ID（SHA-1 哈希）是从整个提交对象计算出来的，你就会明白为什么提交是不可变的：如果你更改了作者、父提交或单个文件，你实际上创建了一个新的、不同的对象。每一个提交都与其所在的位置及其与整个仓库的关系绑定，直到第一个提交。换句话说，一个给定的提交 ID 不仅标识了一些文件内容，它还将提交与其完整的历史和整个仓库绑定在一起。</p>
<p>还值得注意的是，从提交的角度来看，时间似乎是倒流的：我们通常是从项目的谦逊起步开始考虑历史，最初可能是作为一种消磨时间的活动，开始时只有几行代码，一些初步的提交，随后逐渐发展到现在的状态（成千上万行代码，几十个贡献者等等）。但是每个提交完全不知未来的情况，它只与过去相连接。提交有“记忆”，但没有预感。</p>
<p>那么，是什么构成了一个提交呢？总结一下：</p>
<ul>
<li>一个树对象，即工作树的内容，文件和目录；</li>
<li>零个、一个或多个父提交；</li>
<li>一个作者身份（姓名和电子邮件），以及一个时间戳；</li>
<li>一个提交者身份（姓名和电子邮件），以及一个时间戳；</li>
<li>一个可选的 PGP 签名；</li>
<li>一条消息；</li>
<li>所有这些内容哈希在一起，生成一个唯一的 SHA-1 标识符。</li>
</ul>
<table>
<thead>
<tr>
<th><strong>Note</strong></th>
</tr>
</thead>
<tbody><tr>
<td>等一下，这是否意味着 Git 是区块链？<br />因为加密货币的原因，区块链现在非常火。确实，在某种程度上，Git 可以被视为一个区块链：它是一系列由加密手段连接在一起的区块（提交），以确保每一个元素都与整个历史关联起来。不过，不必太认真地对比这两者：我们不需要 GitCoin，真的。</td>
</tr>
</tbody></table>
<h2 id="6-Reading-commit-data-checkout"><a href="#6-Reading-commit-data-checkout" class="headerlink" title="6. Reading commit data: checkout"></a>6. Reading commit data: checkout</h2><p>虽然提交包含了比文件和目录更丰富的信息，但这并不意味着它们就很有用。现在可能是时候开始实现树对象了，这样我们才能将提交检出到工作树中。</p>
<h3 id="6-1-What’s-in-a-tree"><a href="#6-1-What’s-in-a-tree" class="headerlink" title="6.1. What’s in a tree?"></a>6.1. What’s in a tree?</h3><p>非正式地说，树描述了工作树的内容，也就是说，它将 blobs 与路径关联起来。它是由三元组组成的数组，每个三元组包含一个文件模式、一个路径（相对于工作树）和一个 SHA-1。一个典型的树内容可能如下所示：</p>
<table>
<thead>
<tr>
<th><strong>Mode</strong></th>
<th>SHA-1</th>
<th><strong>Path</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>100644</code></td>
<td><code>894a44cc066a027465cd26d634948d56d13af9af</code></td>
<td><code>.gitignore</code></td>
</tr>
<tr>
<td><code>100644</code></td>
<td><code>94a9ed024d3859793618152ea559a168bbcbb5e2</code></td>
<td><code>LICENSE</code></td>
</tr>
<tr>
<td><code>100644</code></td>
<td><code>bab489c4f4600a38ce6dbfd652b90383a4aa3e45</code></td>
<td><code>README.md</code></td>
</tr>
<tr>
<td><code>100644</code></td>
<td><code>6d208e47659a2a10f5f8640e0155d9276a2130a9</code></td>
<td><code>src</code></td>
</tr>
<tr>
<td><code>040000</code></td>
<td><code>e7445b03aea61ec801b20d6ab62f076208b7d097</code></td>
<td><code>tests</code></td>
</tr>
<tr>
<td><code>040000</code></td>
<td><code>d5ec863f17f3a2e92aa8f6b66ac18f7b09fd1b38</code></td>
<td><code>main.c</code></td>
</tr>
</tbody></table>
<p>模式只是文件的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/File-system_permissions">模式</a>，路径是其位置。SHA-1 引用的是 blob 或另一个树对象。如果是 blob，路径是文件；如果是树，它是目录。为了在文件系统中实例化这棵树，我们将从加载与第一个路径（.gitignore）相关的对象开始，并检查它的类型。由于它是一个 blob，我们将创建一个名为 .gitignore 的文件，并填充该 blob 的内容；LICENSE 和 README.md 也按同样的方法处理。但是与 src 相关联的对象不是一个 blob，而是另一棵树：我们将创建目录 src，并在该目录中对新的树重复相同的操作。</p>
<table>
<thead>
<tr>
<th><strong>Warning</strong></th>
</tr>
</thead>
<tbody><tr>
<td>路径是一个单一的文件系统条目<br />路径准确地标识一个文件或目录。不是两个，也不是三个。如果你有五级嵌套的目录，即使其中四个除了下一个目录外都是空的，你也需要五个树对象，递归地相互引用。你不能通过将一个完整的路径放在单个树条目中来走捷径，比如 dir1&#x2F;dir2&#x2F;dir3&#x2F;dir4&#x2F;dir5。</td>
</tr>
</tbody></table>
<h3 id="6-2-Parsing-trees"><a href="#6-2-Parsing-trees" class="headerlink" title="6.2. Parsing trees"></a>6.2. Parsing trees</h3><p>与标签和提交不同，树对象是二进制对象，但它们的格式实际上非常简单。一个树是由以下格式的记录连接而成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[mode] space [path] 0x00 [sha-1]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>[mode] 是最多六个字节，是文件模式的八进制表示，以 ASCII 存储。例如，100644 使用字节值 49（ASCII “1”），48（ASCII “0”），48，54，52，54 来编码。前两位数字编码文件类型（文件、目录、符号链接或子模块），最后四位是权限。</p>
</li>
<li><p>它后面跟着 0x20，一个 ASCII 空格；</p>
</li>
<li><p>接下来是以 null 终止的（0x00）路径；</p>
</li>
<li><p>然后是对象的 SHA-1，以二进制编码，长度为 20 字节。</p>
</li>
</ul>
<p>解析器将非常简单。首先，为单个记录（叶子，单个路径）创建一个小的对象封装器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GitTreeLeaf</span> (<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, mode, path, sha</span>):</span><br><span class="line">        <span class="variable language_">self</span>.mode = mode</span><br><span class="line">        <span class="variable language_">self</span>.path = path</span><br><span class="line">        <span class="variable language_">self</span>.sha = sha</span><br></pre></td></tr></table></figure>

<p>因为树对象只是相同基本数据结构的重复，我们将解析器写成两个函数。首先，编写一个解析单个记录的函数，返回解析的数据和它在输入数据中到达的位置：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tree_parse_one</span>(<span class="params">raw, start=<span class="number">0</span></span>):</span><br><span class="line">    <span class="comment"># Find the space terminator of the mode</span></span><br><span class="line">    x = raw.find(<span class="string">b&#x27; &#x27;</span>, start)</span><br><span class="line">    <span class="keyword">assert</span> x-start == <span class="number">5</span> <span class="keyword">or</span> x-start==<span class="number">6</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Read the mode</span></span><br><span class="line">    mode = raw[start:x]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(mode) == <span class="number">5</span>:</span><br><span class="line">        <span class="comment"># Normalize to six bytes.</span></span><br><span class="line">        mode = <span class="string">b&quot;0&quot;</span> + mode</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Find the NULL terminator of the path</span></span><br><span class="line">    y = raw.find(<span class="string">b&#x27;\x00&#x27;</span>, x)</span><br><span class="line">    <span class="comment"># and read the path</span></span><br><span class="line">    path = raw[x+<span class="number">1</span>:y]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Read the SHA…</span></span><br><span class="line">    raw_sha = <span class="built_in">int</span>.from_bytes(raw[y+<span class="number">1</span>:y+<span class="number">21</span>], <span class="string">&quot;big&quot;</span>)</span><br><span class="line">    <span class="comment"># and convert it into an hex string, padded to 40 chars</span></span><br><span class="line">    <span class="comment"># with zeros if needed.</span></span><br><span class="line">    sha = <span class="built_in">format</span>(raw_sha, <span class="string">&quot;040x&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> y+<span class="number">21</span>, GitTreeLeaf(mode, path.decode(<span class="string">&quot;utf8&quot;</span>), sha)</span><br></pre></td></tr></table></figure>

<p>然后是“真正的”解析器，它只是循环调用前一个解析器，直到输入数据耗尽。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tree_parse</span>(<span class="params">raw</span>):</span><br><span class="line">    pos = <span class="number">0</span></span><br><span class="line">    <span class="built_in">max</span> = <span class="built_in">len</span>(raw)</span><br><span class="line">    ret = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">while</span> pos &lt; <span class="built_in">max</span>:</span><br><span class="line">        pos, data = tree_parse_one(raw, pos)</span><br><span class="line">        ret.append(data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<p>最终，我们需要一个序列化器来将树对象写回去。由于我们可能已经添加或修改了条目，因此需要对它们重新排序。保持一致的排序很重要，因为我们需要遵守 Git 的<a target="_blank" rel="noopener" href="https://wyag.thb.lt/#org2616760">身份规则</a>，该规则规定不能有两个等效的对象具有不同的哈希值——但是如果相同内容的树对象排序不同，它们仍然是等效的（描述相同的目录结构），但在数值上是不同的（不同的 SHA-1 标识符）。不正确排序的树对象是无效的，但 Git 并不会强制执行这一点。我在编写 wyag 时意外创建了一些无效的树对象，结果导致 Git 状态显示奇怪的错误（具体来说，<code>git status</code> 会报告一个实际上是干净的工作区被完全修改）。我们不希望发生这种情况。</p>
<p>排序函数非常简单，但有一个意想不到的细节。条目是按名称按字母顺序排序的，但目录（即树对象的条目）会在末尾添加一个 <code>/</code> 进行排序。这一点很重要，因为这意味着如果 <code>whatever</code> 是一个普通文件，它将在 <code>whatever.c</code> 之前排序，但如果 <code>whatever</code> 是一个目录，它将作为 <code>whatever/</code> 排序在后。（我不确定 Git 为什么这样做。如果你感兴趣，可以查看 Git 源码中 <code>tree.c</code> 文件里的 <code>base_name_compare</code> 函数。）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Notice this isn&#x27;t a comparison function, but a conversion function.</span></span><br><span class="line"><span class="comment"># Python&#x27;s default sort doesn&#x27;t accept a custom comparison function,</span></span><br><span class="line"><span class="comment"># like in most languages, but a `key` arguments that returns a new</span></span><br><span class="line"><span class="comment"># value, which is compared using the default rules.  So we just return</span></span><br><span class="line"><span class="comment"># the leaf name, with an extra / if it&#x27;s a directory.</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tree_leaf_sort_key</span>(<span class="params">leaf</span>):</span><br><span class="line">    <span class="keyword">if</span> leaf.mode.startswith(<span class="string">b&quot;10&quot;</span>):</span><br><span class="line">        <span class="keyword">return</span> leaf.path</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> leaf.path + <span class="string">&quot;/&quot;</span></span><br></pre></td></tr></table></figure>

<p>然后是序列化器本身。这部分非常简单：我们使用新创建的转换函数对项进行排序，然后按顺序写入。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tree_serialize</span>(<span class="params">obj</span>):</span><br><span class="line">    obj.items.sort(key=tree_leaf_sort_key)</span><br><span class="line">    ret = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> obj.items:</span><br><span class="line">        ret += i.mode</span><br><span class="line">        ret += <span class="string">b&#x27; &#x27;</span></span><br><span class="line">        ret += i.path.encode(<span class="string">&quot;utf8&quot;</span>)</span><br><span class="line">        ret += <span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line">        sha = <span class="built_in">int</span>(i.sha, <span class="number">16</span>)</span><br><span class="line">        ret += sha.to_bytes(<span class="number">20</span>, byteorder=<span class="string">&quot;big&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<p>现在，我们只需要将所有内容组合到一个类中即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GitTree</span>(<span class="title class_ inherited__">GitObject</span>):</span><br><span class="line">    fmt=<span class="string">b&#x27;tree&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deserialize</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="variable language_">self</span>.items = tree_parse(data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">serialize</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> tree_serialize(<span class="variable language_">self</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">init</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.items = <span class="built_in">list</span>()</span><br></pre></td></tr></table></figure>

<h3 id="6-3-Showing-trees-ls-tree"><a href="#6-3-Showing-trees-ls-tree" class="headerlink" title="6.3. Showing trees: ls-tree"></a>6.3. Showing trees: ls-tree</h3><p>既然如此，我们顺便给 wyag 添加 <code>ls-tree</code> 命令吧。这么简单的功能，没有理由不加。<code>git ls-tree [-r] TREE</code> 只是打印树的内容，带 <code>-r</code> 标志时会递归打印。在递归模式下，它不会显示子树，而是仅显示最终对象及其完整路径。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">argsp = argsubparsers.add_parser(<span class="string">&quot;ls-tree&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;Pretty-print a tree object.&quot;</span>)</span><br><span class="line">argsp.add_argument(<span class="string">&quot;-r&quot;</span>,</span><br><span class="line">                   dest=<span class="string">&quot;recursive&quot;</span>,</span><br><span class="line">                   action=<span class="string">&quot;store_true&quot;</span>,</span><br><span class="line">                   <span class="built_in">help</span>=<span class="string">&quot;Recurse into sub-trees&quot;</span>)</span><br><span class="line"></span><br><span class="line">argsp.add_argument(<span class="string">&quot;tree&quot;</span>,</span><br><span class="line">                   <span class="built_in">help</span>=<span class="string">&quot;A tree-ish object.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd_ls_tree</span>(<span class="params">args</span>):</span><br><span class="line">    repo = repo_find()</span><br><span class="line">    ls_tree(repo, args.tree, args.recursive)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ls_tree</span>(<span class="params">repo, ref, recursive=<span class="literal">None</span>, prefix=<span class="string">&quot;&quot;</span></span>):</span><br><span class="line">    sha = object_find(repo, ref, fmt=<span class="string">b&quot;tree&quot;</span>)</span><br><span class="line">    obj = object_read(repo, sha)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> obj.items:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(item.mode) == <span class="number">5</span>:</span><br><span class="line">            <span class="built_in">type</span> = item.mode[<span class="number">0</span>:<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">type</span> = item.mode[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">match</span> <span class="built_in">type</span>: <span class="comment"># Determine the type.</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">b&#x27;04&#x27;</span>: <span class="built_in">type</span> = <span class="string">&quot;tree&quot;</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">b&#x27;10&#x27;</span>: <span class="built_in">type</span> = <span class="string">&quot;blob&quot;</span> <span class="comment"># A regular file.</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">b&#x27;12&#x27;</span>: <span class="built_in">type</span> = <span class="string">&quot;blob&quot;</span> <span class="comment"># A symlink. Blob contents is link target.</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">b&#x27;16&#x27;</span>: <span class="built_in">type</span> = <span class="string">&quot;commit&quot;</span> <span class="comment"># A submodule</span></span><br><span class="line">            <span class="keyword">case</span> _: <span class="keyword">raise</span> Exception(<span class="string">f&quot;Weird tree leaf mode <span class="subst">&#123;item.mode&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (recursive <span class="keyword">and</span> <span class="built_in">type</span>==<span class="string">&#x27;tree&#x27;</span>): <span class="comment"># This is a leaf</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;<span class="string">&#x27;0&#x27;</span> * (<span class="number">6</span> - <span class="built_in">len</span>(item.mode)) + item.mode.decode(<span class="string">&quot;ascii&quot;</span>)&#125;</span> <span class="subst">&#123;<span class="built_in">type</span>&#125;</span> <span class="subst">&#123;item.sha&#125;</span>\t<span class="subst">&#123;os.path.join(prefix, item.path)&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># This is a branch, recurse</span></span><br><span class="line">            ls_tree(repo, item.sha, recursive, os.path.join(prefix, item.path))</span><br></pre></td></tr></table></figure>

<h3 id="6-4-The-checkout-command"><a href="#6-4-The-checkout-command" class="headerlink" title="6.4. The checkout command"></a>6.4. The checkout command</h3><p><code>git checkout</code> 只是将某个提交实例化到工作区。为了让我们的实现清晰易懂，我们将对实际的 <code>git checkout</code> 命令进行简化，同时添加一些安全措施。我们的 <code>checkout</code> 版本将按以下方式工作：</p>
<ul>
<li>它需要两个参数：一个提交（commit）和一个目录（directory）。Git 的 <code>checkout</code> 命令只需要一个提交。</li>
<li>它会在指定目录中实例化该提交的树，但<strong>仅当该目录为空</strong>时才进行操作。Git 具有许多安全机制来防止数据丢失，而在 wyag 中尝试完全复现这些机制既复杂又不安全。由于 wyag 的目的是演示 Git，而不是提供完整的实现，这一限制是可以接受的。</li>
</ul>
<p>让我们开始实现。如往常一样，我们需要一个子解析器（subparser）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">argsp = argsubparsers.add_parser(<span class="string">&quot;checkout&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;Checkout a commit inside of a directory.&quot;</span>)</span><br><span class="line"></span><br><span class="line">argsp.add_argument(<span class="string">&quot;commit&quot;</span>,</span><br><span class="line">                   <span class="built_in">help</span>=<span class="string">&quot;The commit or tree to checkout.&quot;</span>)</span><br><span class="line"></span><br><span class="line">argsp.add_argument(<span class="string">&quot;path&quot;</span>,</span><br><span class="line">                   <span class="built_in">help</span>=<span class="string">&quot;The EMPTY directory to checkout on.&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>一个包装函数（wrapper function）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cmd_checkout</span>(<span class="params">args</span>):</span><br><span class="line">    repo = repo_find()</span><br><span class="line"></span><br><span class="line">    obj = object_read(repo, object_find(repo, args.commit))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># If the object is a commit, we grab its tree</span></span><br><span class="line">    <span class="keyword">if</span> obj.fmt == <span class="string">b&#x27;commit&#x27;</span>:</span><br><span class="line">        obj = object_read(repo, obj.kvlm[<span class="string">b&#x27;tree&#x27;</span>].decode(<span class="string">&quot;ascii&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Verify that path is an empty directory</span></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(args.path):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(args.path):</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">f&quot;Not a directory <span class="subst">&#123;args.path&#125;</span>!&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> os.listdir(args.path):</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">f&quot;Not empty <span class="subst">&#123;args.path&#125;</span>!&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        os.makedirs(args.path)</span><br><span class="line"></span><br><span class="line">    tree_checkout(repo, obj, os.path.realpath(args.path))</span><br></pre></td></tr></table></figure>

<p>以及一个执行实际工作的函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tree_checkout</span>(<span class="params">repo, tree, path</span>):</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> tree.items:</span><br><span class="line">        obj = object_read(repo, item.sha)</span><br><span class="line">        dest = os.path.join(path, item.path)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> obj.fmt == <span class="string">b&#x27;tree&#x27;</span>:</span><br><span class="line">            os.mkdir(dest)</span><br><span class="line">            tree_checkout(repo, obj, dest)</span><br><span class="line">        <span class="keyword">elif</span> obj.fmt == <span class="string">b&#x27;blob&#x27;</span>:</span><br><span class="line">            <span class="comment"># @TODO Support symlinks (identified by mode 12****)</span></span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(dest, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(obj.blobdata)</span><br></pre></td></tr></table></figure>

<h2 id="7-Refs-tags-and-branches"><a href="#7-Refs-tags-and-branches" class="headerlink" title="7. Refs, tags and branches"></a>7. Refs, tags and branches</h2><h3 id="7-1-What-a-ref-is-and-the-show-ref-command"><a href="#7-1-What-a-ref-is-and-the-show-ref-command" class="headerlink" title="7.1. What a ref is, and the show-ref command"></a>7.1. What a ref is, and the show-ref command</h3><p>到目前为止，我们唯一可以引用对象的方式是使用完整的十六进制标识符。然而，在 git 中，我们实际上很少看到这些标识符，除了在讨论特定提交时。通常，我们会使用 HEAD，或者某个名为 main 或 feature&#x2F;more-bombs 的分支名称等。这是通过一个简单的机制——引用（references）来处理的。</p>
<p>Git 引用（refs）可能是 git 存储的最简单的内容。它们位于 <code>.git/refs</code> 的子目录中，并且是包含对象哈希值的文本文件，使用 ASCII 编码。它们实际上就是这样简单：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6071c08bcb4757d8c89a30d9755d2466cef8c1de</span><br></pre></td></tr></table></figure>

<p>引用（Refs）也可以间接地引用对象，即引用另一个引用，在这种情况下，它们看起来像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ref: refs/remotes/origin/master</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>Note</strong></th>
</tr>
</thead>
<tbody><tr>
<td>直接和间接引用<br />从现在开始，我将把形式为 <code>ref: path/to/other/ref</code> 的引用称为间接引用，而把包含 SHA-1 对象 ID 的引用称为直接引用。</td>
</tr>
</tbody></table>
<p>这一部分将描述引用（refs）的用途。目前，最重要的是：</p>
<ul>
<li>它们是文本文件，位于 <code>.git/refs</code> 目录结构中；</li>
<li>它们保存一个对象的 SHA-1 标识符，或者引用另一个引用，最终指向一个 SHA-1（没有循环！）</li>
</ul>
<p>为了操作引用，我们首先需要一个简单的递归解析器，它将接受一个引用名称，跟踪可能存在的递归引用（即以 <code>ref:</code> 开头的引用，如上所示），并返回最终的 SHA-1 标识符：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">ref_resolve</span>(<span class="params">repo, ref</span>):</span><br><span class="line">    path = repo_file(repo, ref)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Sometimes, an indirect reference may be broken.  This is normal</span></span><br><span class="line">    <span class="comment"># in one specific case: we&#x27;re looking for HEAD on a new repository</span></span><br><span class="line">    <span class="comment"># with no commits.  In that case, .git/HEAD points to &quot;ref:</span></span><br><span class="line">    <span class="comment"># refs/heads/main&quot;, but .git/refs/heads/main doesn&#x27;t exist yet</span></span><br><span class="line">    <span class="comment"># (since there&#x27;s no commit for it to refer to).</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.isfile(path):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        data = fp.read()[:-<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># Drop final \n ^^^^^</span></span><br><span class="line">    <span class="keyword">if</span> data.startswith(<span class="string">&quot;ref: &quot;</span>):</span><br><span class="line">        <span class="keyword">return</span> ref_resolve(repo, data[<span class="number">5</span>:])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>

<p>让我们创建两个小函数，并实现 <code>show-refs</code> 命令——它仅列出仓库中的所有引用。首先，创建一个简单的递归函数来收集引用，并将它们作为字典返回：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">ref_list</span>(<span class="params">repo, path=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> path:</span><br><span class="line">        path = repo_dir(repo, <span class="string">&quot;refs&quot;</span>)</span><br><span class="line">    ret = <span class="built_in">dict</span>()</span><br><span class="line">    <span class="comment"># Git shows refs sorted.  To do the same, we sort the output of</span></span><br><span class="line">    <span class="comment"># listdir</span></span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> <span class="built_in">sorted</span>(os.listdir(path)):</span><br><span class="line">        can = os.path.join(path, f)</span><br><span class="line">        <span class="keyword">if</span> os.path.isdir(can):</span><br><span class="line">            ret[f] = ref_list(repo, can)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ret[f] = ref_resolve(repo, can)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<p>以及，像往常一样，一个子解析器，一个桥接函数和一个（递归）工作函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">argsp = argsubparsers.add_parser(<span class="string">&quot;show-ref&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;List references.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd_show_ref</span>(<span class="params">args</span>):</span><br><span class="line">    repo = repo_find()</span><br><span class="line">    refs = ref_list(repo)</span><br><span class="line">    show_ref(repo, refs, prefix=<span class="string">&quot;refs&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_ref</span>(<span class="params">repo, refs, with_hash=<span class="literal">True</span>, prefix=<span class="string">&quot;&quot;</span></span>):</span><br><span class="line">    <span class="keyword">if</span> prefix:</span><br><span class="line">        prefix = prefix + <span class="string">&#x27;/&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> refs.items():</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(v) == <span class="built_in">str</span> <span class="keyword">and</span> with_hash:</span><br><span class="line">            <span class="built_in">print</span> (<span class="string">f&quot;<span class="subst">&#123;v&#125;</span> <span class="subst">&#123;prefix&#125;</span><span class="subst">&#123;k&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">type</span>(v) == <span class="built_in">str</span>:</span><br><span class="line">            <span class="built_in">print</span> (<span class="string">f&quot;<span class="subst">&#123;prefix&#125;</span><span class="subst">&#123;k&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            show_ref(repo, v, with_hash=with_hash, prefix=<span class="string">f&quot;<span class="subst">&#123;prefix&#125;</span><span class="subst">&#123;k&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="7-2-Tags-as-references"><a href="#7-2-Tags-as-references" class="headerlink" title="7.2. Tags as references"></a>7.2. Tags as references</h3><p>refs的最简单用途是标签。标签只是一个用户定义的对象名称，通常是一个提交。标签的一个非常常见的用途是标识软件版本：例如，您刚刚合并了程序的版本12.78.52的最后一个提交，所以您最近的提交（我们称之为<code>6071c08</code>）就是您的版本12.78.52。为了使这种关联显式化，您只需要这样做：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag v12.78.52 6071c08</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">the object <span class="built_in">hash</span> ^here^^ is optional and defaults to HEAD.</span></span><br></pre></td></tr></table></figure>

<p>这会创建一个新的标签，叫做 <code>v12.78.52</code>，指向 <code>6071c08</code>。标签就像别名：标签为现有对象引入了一种新的引用方式。标签创建之后，<code>v12.78.52</code> 这个名称就指向了 <code>6071c08</code>。例如，下面这两个命令现在是完全等价的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout v12.78.52</span><br><span class="line">git checkout 6071c08</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>Note</strong></th>
</tr>
</thead>
<tbody><tr>
<td>版本是标签的一个常见用途，但像 Git 中几乎所有东西一样，标签没有预定义的语义：它们的意义由你决定，并且可以指向你想指向的任何对象，甚至可以为 blobs 打标签！</td>
</tr>
</tbody></table>
<h3 id="7-3-Lightweight-tags-and-tag-objects-and-parsing-the-latter"><a href="#7-3-Lightweight-tags-and-tag-objects-and-parsing-the-latter" class="headerlink" title="7.3. Lightweight tags and tag objects, and parsing the latter"></a>7.3. Lightweight tags and tag objects, and parsing the latter</h3><p>你可能已经猜到了，标签实际上就是 refs。它们位于 <code>.git/refs/tags/</code> 层级。唯一需要注意的地方是，它们有两种类型：轻量标签和标签对象。</p>
<p>“轻量级”标签只是指向提交、树或 Blob 的常规 refs。 标签对象是指向类型为 tag 的对象的常规 refs。与轻量标签不同，标签对象具有作者、日期、可选的 PGP 签名和可选的注释。它们的格式与提交对象相同。</p>
<p>我们甚至不需要实现标签对象，可以重用 <code>GitCommit</code> 类，只需更改 <code>fmt</code> 字段即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GitTag</span>(<span class="title class_ inherited__">GitCommit</span>):</span><br><span class="line">    fmt = <span class="string">b&#x27;tag&#x27;</span></span><br></pre></td></tr></table></figure>

<p>现在我们支持标签了。</p>
<h3 id="7-4-The-tag-command"><a href="#7-4-The-tag-command" class="headerlink" title="7.4. The tag command"></a>7.4. The tag command</h3><p>让我们添加 <code>tag</code> 命令。在 Git 中，它做两件事：创建一个新的标签或列出现有标签（默认情况下）。所以你可以用以下方式调用它：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git tag                  # List all tags</span><br><span class="line">git tag NAME [OBJECT]    # create a new *lightweight* tag NAME, pointing</span><br><span class="line">                         # at HEAD (default) or OBJECT</span><br><span class="line">git tag -a NAME [OBJECT] # create a new tag *object* NAME, pointing at</span><br><span class="line">                         # HEAD (default) or OBJECT</span><br></pre></td></tr></table></figure>

<p>这在 argparse 中的实现如下。请注意，我们忽略了 <code>--list</code> 和 <code>[-a] name [object]</code> 之间的互斥关系，因为对于 argparse 来说，这看起来太复杂了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">argsp = argsubparsers.add_parser(</span><br><span class="line">    <span class="string">&quot;tag&quot;</span>,</span><br><span class="line">    <span class="built_in">help</span>=<span class="string">&quot;List and create tags&quot;</span>)</span><br><span class="line"></span><br><span class="line">argsp.add_argument(<span class="string">&quot;-a&quot;</span>,</span><br><span class="line">                   action=<span class="string">&quot;store_true&quot;</span>,</span><br><span class="line">                   dest=<span class="string">&quot;create_tag_object&quot;</span>,</span><br><span class="line">                   <span class="built_in">help</span>=<span class="string">&quot;Whether to create a tag object&quot;</span>)</span><br><span class="line"></span><br><span class="line">argsp.add_argument(<span class="string">&quot;name&quot;</span>,</span><br><span class="line">                   nargs=<span class="string">&quot;?&quot;</span>,</span><br><span class="line">                   <span class="built_in">help</span>=<span class="string">&quot;The new tag&#x27;s name&quot;</span>)</span><br><span class="line"></span><br><span class="line">argsp.add_argument(<span class="string">&quot;object&quot;</span>,</span><br><span class="line">                   default=<span class="string">&quot;HEAD&quot;</span>,</span><br><span class="line">                   nargs=<span class="string">&quot;?&quot;</span>,</span><br><span class="line">                   <span class="built_in">help</span>=<span class="string">&quot;The object the new tag will point to&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><code>cmd_tag</code> 函数将根据是否提供了 <code>name</code> 来分派行为（列出或创建）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cmd_tag</span>(<span class="params">args</span>):</span><br><span class="line">    repo = repo_find()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> args.name:</span><br><span class="line">        tag_create(repo,</span><br><span class="line">                   args.name,</span><br><span class="line">                   args.<span class="built_in">object</span>,</span><br><span class="line">                   create_tag_object = args.create_tag_object)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        refs = ref_list(repo)</span><br><span class="line">        show_ref(repo, refs[<span class="string">&quot;tags&quot;</span>], with_hash=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>我们只需要一个函数来实际创建标签：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tag_create</span>(<span class="params">repo, name, ref, create_tag_object=<span class="literal">False</span></span>):</span><br><span class="line">    <span class="comment"># get the GitObject from the object reference</span></span><br><span class="line">    sha = object_find(repo, ref)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> create_tag_object:</span><br><span class="line">        <span class="comment"># create tag object (commit)</span></span><br><span class="line">        tag = GitTag()</span><br><span class="line">        tag.kvlm = <span class="built_in">dict</span>()</span><br><span class="line">        tag.kvlm[<span class="string">b&#x27;object&#x27;</span>] = sha.encode()</span><br><span class="line">        tag.kvlm[<span class="string">b&#x27;type&#x27;</span>] = <span class="string">b&#x27;commit&#x27;</span></span><br><span class="line">        tag.kvlm[<span class="string">b&#x27;tag&#x27;</span>] = name.encode()</span><br><span class="line">        <span class="comment"># Feel free to let the user give their name!</span></span><br><span class="line">        <span class="comment"># Notice you can fix this after commit, read on!</span></span><br><span class="line">        tag.kvlm[<span class="string">b&#x27;tagger&#x27;</span>] = <span class="string">b&#x27;Wyag &lt;wyag@example.com&gt;&#x27;</span></span><br><span class="line">        <span class="comment"># …and a tag message!</span></span><br><span class="line">        tag.kvlm[<span class="literal">None</span>] = <span class="string">b&quot;A tag generated by wyag, which won&#x27;t let you customize the message!\n&quot;</span></span><br><span class="line">        tag_sha = object_write(tag, repo)</span><br><span class="line">        <span class="comment"># create reference</span></span><br><span class="line">        ref_create(repo, <span class="string">&quot;tags/&quot;</span> + name, tag_sha)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># create lightweight tag (ref)</span></span><br><span class="line">        ref_create(repo, <span class="string">&quot;tags/&quot;</span> + name, sha)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ref_create</span>(<span class="params">repo, ref_name, sha</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(repo_file(repo, <span class="string">&quot;refs/&quot;</span> + ref_name), <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        fp.write(sha + <span class="string">&quot;\n&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="7-5-What’s-a-branch"><a href="#7-5-What’s-a-branch" class="headerlink" title="7.5. What’s a branch?"></a>7.5. What’s a branch?</h3><p>标签已完成，现在是另一个大块内容：分支。</p>
<p>是时候处理问题了：像大多数 Git 用户一样，wyag 仍然没有任何关于分支的概念。它目前将一个仓库视为一堆杂乱无章的对象，其中一些是提交对象，而完全没有表示提交是如何在分支中组织的，也没有表示在任何时候都有一个提交是 HEAD，即活跃分支的头部提交（或“尖端”）。</p>
<p>那么，什么是分支呢？答案其实出奇地简单，但也可能让人惊讶：分支就是对某个提交的引用。你甚至可以说分支是对某个提交的别名。在这方面，分支和标签完全一样。标签是引用，存在于 <code>.git/refs/tags</code> 中，而分支是引用，存在于 <code>.git/refs/heads</code> 中。</p>
<p>当然，分支和标签之间是有区别的：</p>
<ul>
<li>分支是对一个提交的引用，标签可以引用任何对象；</li>
<li>最重要的是，分支引用在每次提交时会被更新。这意味着每当你提交时，Git 实际上会执行以下操作：<ul>
<li>创建一个新的提交对象，当前分支的提交 ID 作为其父提交；</li>
<li>提交对象被哈希并存储；</li>
<li>分支引用被更新，指向新提交的哈希值。</li>
</ul>
</li>
</ul>
<p>仅此而已。</p>
<p>但当前分支又是什么呢？实际上，它更简单。它是一个位于 <code>refs</code> 层级外的引用文件，存在于 <code>.git/HEAD</code> 中，它是一个间接引用（即它是类似 <code>ref: path/to/other/ref</code> 的形式，而不是简单的哈希值）。</p>
<table>
<thead>
<tr>
<th><strong>Note</strong></th>
</tr>
</thead>
<tbody><tr>
<td>分离的 HEAD<br />当你仅仅检出一个随机的提交时，Git 会警告你它处于“分离的 HEAD 状态”。这意味着你不再处于任何分支上。在这种情况下，<code>.git/HEAD</code> 是一个直接引用：它包含一个 SHA-1 值。</td>
</tr>
</tbody></table>
<h3 id="7-6-Referring-to-objects-the-object-find-function"><a href="#7-6-Referring-to-objects-the-object-find-function" class="headerlink" title="7.6. Referring to objects: the object_find function"></a>7.6. Referring to objects: the <code>object_find</code> function</h3><h4 id="7-6-1-Resolving-names"><a href="#7-6-1-Resolving-names" class="headerlink" title="7.6.1. Resolving names"></a>7.6.1. Resolving names</h4><p>记得我们创建的 [愚蠢的 <code>object_find</code> 函数](#4.6. The cat-file command) 吗？它接受四个参数，返回第二个参数不变，并忽略其他三个参数。现在是时候用一个更有用的函数来替换它了。我们将实现 Git 名称解析算法的一个小而实用的子集。新的 <code>object_find()</code> 将分为两步：首先，给定一个名称，它将返回一个完整的 sha-1 哈希。例如，对于 <code>HEAD</code>，它将返回当前分支的头部提交的哈希，等等。更精确地说，这个名称解析函数将按以下方式工作：</p>
<ol>
<li>如果名称是 HEAD，它将解析为 .git&#x2F;HEAD；</li>
<li>如果名称是完整的哈希，则直接返回该哈希；</li>
<li>如果名称看起来像是短哈希，它将收集所有完整哈希以该短哈希为前缀的对象；</li>
<li>最后，它将解析与名称匹配的标签和分支。</li>
</ol>
<p>请注意，最后两步是收集值：前两步是绝对引用，因此我们可以安全地返回结果。但短哈希或分支名称可能是模糊的，我们希望列举出所有可能的含义，并在找到多个结果时抛出错误。</p>
<h5 id="短哈希"><a href="#短哈希" class="headerlink" title="短哈希"></a>短哈希</h5><p>为了方便，Git 允许通过哈希值的前缀来引用哈希。例如，<code>5bd254aa973646fa16f66d702a5826ea14a3eb45</code> 可以简称为 <code>5bd254</code>。这被称为“短哈希”。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">object_resolve</span>(<span class="params">repo, name</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Resolve name to an object hash in repo.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">This function is aware of:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> - the HEAD literal</span></span><br><span class="line"><span class="string">    - short and long hashes</span></span><br><span class="line"><span class="string">    - tags</span></span><br><span class="line"><span class="string">    - branches</span></span><br><span class="line"><span class="string">    - remote branches&quot;&quot;&quot;</span></span><br><span class="line">    candidates = <span class="built_in">list</span>()</span><br><span class="line">    hashRE = re.<span class="built_in">compile</span>(<span class="string">r&quot;^[0-9A-Fa-f]&#123;4,40&#125;$&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Empty string?  Abort.</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> name.strip():</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Head is nonambiguous</span></span><br><span class="line">    <span class="keyword">if</span> name == <span class="string">&quot;HEAD&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> [ ref_resolve(repo, <span class="string">&quot;HEAD&quot;</span>) ]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># If it&#x27;s a hex string, try for a hash.</span></span><br><span class="line">    <span class="keyword">if</span> hashRE.<span class="keyword">match</span>(name):</span><br><span class="line">        <span class="comment"># This may be a hash, either small or full.  4 seems to be the</span></span><br><span class="line">        <span class="comment"># minimal length for git to consider something a short hash.</span></span><br><span class="line">        <span class="comment"># This limit is documented in man git-rev-parse</span></span><br><span class="line">        name = name.lower()</span><br><span class="line">        prefix = name[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">        path = repo_dir(repo, <span class="string">&quot;objects&quot;</span>, prefix, mkdir=<span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">if</span> path:</span><br><span class="line">            rem = name[<span class="number">2</span>:]</span><br><span class="line">            <span class="keyword">for</span> f <span class="keyword">in</span> os.listdir(path):</span><br><span class="line">                <span class="keyword">if</span> f.startswith(rem):</span><br><span class="line">                    <span class="comment"># Notice a string startswith() itself, so this</span></span><br><span class="line">                    <span class="comment"># works for full hashes.</span></span><br><span class="line">                    candidates.append(prefix + f)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Try for references.</span></span><br><span class="line">    as_tag = ref_resolve(repo, <span class="string">&quot;refs/tags/&quot;</span> + name)</span><br><span class="line">    <span class="keyword">if</span> as_tag: <span class="comment"># Did we find a tag?</span></span><br><span class="line">        candidates.append(as_tag)</span><br><span class="line"></span><br><span class="line">    as_branch = ref_resolve(repo, <span class="string">&quot;refs/heads/&quot;</span> + name)</span><br><span class="line">    <span class="keyword">if</span> as_branch: <span class="comment"># Did we find a branch?</span></span><br><span class="line">        candidates.append(as_branch)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> candidates</span><br></pre></td></tr></table></figure>

<p>第二步是，如果提供了类型参数，我们将找到的对象跟踪到所需类型的对象。这是一个非常简单的迭代过程，因为我们只需要处理简单的情况：</p>
<ol>
<li>如果我们有一个标签，并且 <code>fmt</code> 不是我们期望的类型（例如 commit 或其他），则我们跟踪该标签。</li>
<li>如果我们有一个 commit 并且 <code>fmt</code> 是 <code>tree</code>，则返回该 commit 的树对象。</li>
<li>在所有其他情况下，我们中止操作：因为没有其他合理的情况需要处理。</li>
</ol>
<p>这个过程是迭代的，因为它可能需要不确定的步骤，原因在于标签本身也可以被标记。这意味着如果一个标签指向另一个标签，我们需要继续解析，直到最终找到一个直接指向某个对象（如 commit 或 tree）的标签。这个递归过程确保我们能够跟踪所有引用，直到找到所需类型的对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">object_find</span>(<span class="params">repo, name, fmt=<span class="literal">None</span>, follow=<span class="literal">True</span></span>):</span><br><span class="line">    sha = object_resolve(repo, name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> sha:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">f&quot;No such reference <span class="subst">&#123;name&#125;</span>.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sha) &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&quot;Ambiguous reference &#123;name&#125;: Candidates are:\n - &#123;&#x27;\n - &#x27;.join(sha)&#125;.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    sha = sha[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> fmt:</span><br><span class="line">        <span class="keyword">return</span> sha</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        obj = object_read(repo, sha)</span><br><span class="line">        <span class="comment">#     ^^^^^^^^^^^ &lt; this is a bit agressive: we&#x27;re reading</span></span><br><span class="line">        <span class="comment"># the full object just to get its type.  And we&#x27;re doing</span></span><br><span class="line">        <span class="comment"># that in a loop, albeit normally short.  Don&#x27;t expect</span></span><br><span class="line">        <span class="comment"># high performance here.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> obj.fmt == fmt:</span><br><span class="line">            <span class="keyword">return</span> sha</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> follow:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Follow tags</span></span><br><span class="line">        <span class="keyword">if</span> obj.fmt == <span class="string">b&#x27;tag&#x27;</span>:</span><br><span class="line">            sha = obj.kvlm[<span class="string">b&#x27;object&#x27;</span>].decode(<span class="string">&quot;ascii&quot;</span>)</span><br><span class="line">        <span class="keyword">elif</span> obj.fmt == <span class="string">b&#x27;commit&#x27;</span> <span class="keyword">and</span> fmt == <span class="string">b&#x27;tree&#x27;</span>:</span><br><span class="line">            sha = obj.kvlm[<span class="string">b&#x27;tree&#x27;</span>].decode(<span class="string">&quot;ascii&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>通过新的 <code>object_find()</code> 函数，CLI <code>wyag</code> 变得更加易用。你现在可以执行以下操作：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wyag checkout v3.11 <span class="comment"># A tag</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wyag checkout feature/explosions <span class="comment"># A branch</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wyag ls-tree -r HEAD <span class="comment"># The active branch or commit.  There&#x27;s also a</span></span></span><br><span class="line">                       # follow here: HEAD is actually a commit.</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wyag cat-file blob e0695f <span class="comment"># A short hash</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wyag cat-file tree master <span class="comment"># A branch, as a tree (another &quot;follow&quot;)</span></span></span><br></pre></td></tr></table></figure>

<h4 id="7-6-2-The-rev-parse-command"><a href="#7-6-2-The-rev-parse-command" class="headerlink" title="7.6.2. The rev-parse command"></a>7.6.2. The rev-parse command</h4><p>让我们实现 <code>wyag rev-parse</code>。<code>git rev-parse</code> 命令的功能很多，但我们要克隆的用例之一是解析引用。为了进一步测试 <code>object_find</code> 的“跟随”功能，我们将在其接口中添加一个可选的 <code>wyag-type</code> 参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">argsp = argsubparsers.add_parser(</span><br><span class="line">    <span class="string">&quot;rev-parse&quot;</span>,</span><br><span class="line">    <span class="built_in">help</span>=<span class="string">&quot;Parse revision (or other objects) identifiers&quot;</span>)</span><br><span class="line"></span><br><span class="line">argsp.add_argument(<span class="string">&quot;--wyag-type&quot;</span>,</span><br><span class="line">                   metavar=<span class="string">&quot;type&quot;</span>,</span><br><span class="line">                   dest=<span class="string">&quot;type&quot;</span>,</span><br><span class="line">                   choices=[<span class="string">&quot;blob&quot;</span>, <span class="string">&quot;commit&quot;</span>, <span class="string">&quot;tag&quot;</span>, <span class="string">&quot;tree&quot;</span>],</span><br><span class="line">                   default=<span class="literal">None</span>,</span><br><span class="line">                   <span class="built_in">help</span>=<span class="string">&quot;Specify the expected type&quot;</span>)</span><br><span class="line"></span><br><span class="line">argsp.add_argument(<span class="string">&quot;name&quot;</span>,</span><br><span class="line">                   <span class="built_in">help</span>=<span class="string">&quot;The name to parse&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>桥接函数完成所有工作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cmd_rev_parse</span>(<span class="params">args</span>):</span><br><span class="line">    <span class="keyword">if</span> args.<span class="built_in">type</span>:</span><br><span class="line">        fmt = args.<span class="built_in">type</span>.encode()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        fmt = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    repo = repo_find()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> (object_find(repo, args.name, fmt, follow=<span class="literal">True</span>))</span><br></pre></td></tr></table></figure>

<p>并且它可以正常运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wyag rev-parse --wyag-type commit HEAD</span></span><br><span class="line">6c22393f5e3830d15395fd8d2f8b0cf8eb40dd58</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wyag rev-parse --wyag-type tree HEAD</span></span><br><span class="line">11d33fad71dbac72840aff1447e0d080c7484361</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wyag rev-parse --wyag-type tag HEAD</span></span><br><span class="line">None</span><br></pre></td></tr></table></figure>

<h2 id="8-Working-with-the-staging-area-and-the-index-file"><a href="#8-Working-with-the-staging-area-and-the-index-file" class="headerlink" title="8. Working with the staging area and the index file"></a>8. Working with the staging area and the index file</h2><h3 id="8-1-What’s-the-index-file"><a href="#8-1-What’s-the-index-file" class="headerlink" title="8.1. What’s the index file?"></a>8.1. What’s the index file?</h3><p>这最后一步将带我们进入提交的过程（尽管实际创建提交的部分将在下一节进行！）。</p>
<p>你可能知道，在 Git 中进行提交之前，首先需要使用 <code>git add</code> 和 <code>git rm</code> 来“暂存”一些更改，然后才能执行提交。这种介于上一次提交和下一次提交之间的中间状态被称为 <strong>暂存区（staging area）</strong>。</p>
<p>看起来用提交对象（commit object）或树对象（tree object）来表示暂存区似乎是合乎逻辑的，但 Git 实际上使用了一种完全不同的机制，即所谓的 <strong>索引文件（index file）</strong>。</p>
<p>在一次提交之后，索引文件可以看作是该提交的一种副本：它存储了与对应树相同的“路径-Blob”关联信息。但除此之外，它还保存了工作区文件的额外信息，比如文件的创建&#x2F;修改时间，因此 <code>git status</code> 通常不需要实际对比文件内容，而是仅检查文件的修改时间是否与索引文件中存储的时间相同，只有当两者不匹配时，它才会进行真正的内容比较。</p>
<p>因此，你可以将索引文件视为一个 <strong>三方关联表（three-way association list）</strong>：不仅包含路径与 Blob 的映射关系，还包含路径与实际文件系统条目的映射关系。</p>
<p>索引文件的另一个重要特点是：<strong>它可以表示不一致的状态</strong>，比如合并冲突，而树对象总是完整且明确的表示一个文件系统状态。</p>
<p>当你执行提交（commit）时，Git 实际上会将索引文件转换为一个新的 <strong>树对象（tree object）</strong>。总结如下：</p>
<ul>
<li><p>当仓库处于“干净”状态（即没有未提交的更改）时，索引文件的内容与 <code>HEAD</code> 指向的提交完全相同，同时还包含关于对应文件系统条目的元数据。例如，它可能包含如下信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">There’s a file called src/disp.c whose contents are blob 797441c76e59e28794458b39b0f1eff4c85f4fa0. The real src/disp.c file, in the worktree, was created on 2023-07-15 15:28:29.168572151, and last modified 2023-07-15 15:28:29.1689427709. It is stored on device 65026, inode 8922881.</span><br></pre></td></tr></table></figure>
</li>
<li><p>当你执行 <code>git add</code> 或 <code>git rm</code> 时，索引文件会相应地被修改。在上面的示例中，如果你修改了 <code>src/disp.c</code> 并添加你的更改，索引文件将使用新的 blob ID 进行更新（当然，blob 本身也会在此过程中被创建），并且各种文件元数据也会被更新，以便 <code>git status</code> 知道何时不需要比较文件内容。</p>
</li>
<li><p>当你 <code>git commit</code> 这些更改时，一个新的树对象将从索引文件中生成，一个新的提交对象将使用该树创建，分支将被更新，然后操作完成。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th><strong>Note</strong></th>
</tr>
</thead>
<tbody><tr>
<td>关于术语的说明<br />暂存区（staging area）和索引（index）实际上是同一回事，但“暂存区”更侧重于 Git 面向用户的功能名称（这一功能本可以通过其他方式实现），可以理解为一种抽象概念；而“索引文件”（index file）则特指 Git 实际实现该抽象功能的方式。</td>
</tr>
</tbody></table>
<h3 id="8-2-Parsing-the-index"><a href="#8-2-Parsing-the-index" class="headerlink" title="8.2. Parsing the index"></a>8.2. Parsing the index</h3><p>索引文件是 Git 仓库中最复杂的数据结构。其完整文档可以在 Git 源代码树的 <code>Documentation/gitformat-index.txt</code> 中找到，你也可以在 <a target="_blank" rel="noopener" href="https://github.com/git/git/tree/master/Documentation">GitHub 镜像</a>上浏览。索引文件由三部分组成：</p>
<ul>
<li><p>一个包含格式版本号和索引中条目数量的头部；</p>
</li>
<li><p>一系列按排序存储的条目，每个条目代表一个文件，并填充至 8 字节的倍数；</p>
</li>
<li><p>一系列可选扩展，我们将在此忽略。</p>
</li>
</ul>
<p>我们需要表示的第一个部分是一个条目。它实际上包含了很多信息，我会在注释中留下详细说明。值得注意的是，一个条目存储了与其关联的 blob 的 SHA-1 值，以及关于实际文件在实际文件系统上的大量元数据。再次强调，这是因为 <code>git/wyag status</code> 需要确定索引中哪些文件已经被修改：最有效的做法是先检查最后修改的时间戳，并将其与已知值进行比较，而不是直接比较文件内容。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GitIndexEntry</span> (<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, ctime=<span class="literal">None</span>, mtime=<span class="literal">None</span>, dev=<span class="literal">None</span>, ino=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">                 mode_type=<span class="literal">None</span>, mode_perms=<span class="literal">None</span>, uid=<span class="literal">None</span>, gid=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">                 fsize=<span class="literal">None</span>, sha=<span class="literal">None</span>, flag_assume_valid=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">                 flag_stage=<span class="literal">None</span>, name=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="comment"># The last time a file&#x27;s metadata changed.  This is a pair</span></span><br><span class="line">        <span class="comment"># (timestamp in seconds, nanoseconds)</span></span><br><span class="line">        <span class="variable language_">self</span>.ctime = ctime</span><br><span class="line">        <span class="comment"># The last time a file&#x27;s data changed.  This is a pair</span></span><br><span class="line">        <span class="comment"># (timestamp in seconds, nanoseconds)</span></span><br><span class="line">        <span class="variable language_">self</span>.mtime = mtime</span><br><span class="line">        <span class="comment"># The ID of device containing this file</span></span><br><span class="line">        <span class="variable language_">self</span>.dev = dev</span><br><span class="line">        <span class="comment"># The file&#x27;s inode number</span></span><br><span class="line">        <span class="variable language_">self</span>.ino = ino</span><br><span class="line">        <span class="comment"># The object type, either b1000 (regular), b1010 (symlink),</span></span><br><span class="line">        <span class="comment"># b1110 (gitlink).</span></span><br><span class="line">        <span class="variable language_">self</span>.mode_type = mode_type</span><br><span class="line">        <span class="comment"># The object permissions, an integer.</span></span><br><span class="line">        <span class="variable language_">self</span>.mode_perms = mode_perms</span><br><span class="line">        <span class="comment"># User ID of owner</span></span><br><span class="line">        <span class="variable language_">self</span>.uid = uid</span><br><span class="line">        <span class="comment"># Group ID of ownner</span></span><br><span class="line">        <span class="variable language_">self</span>.gid = gid</span><br><span class="line">        <span class="comment"># Size of this object, in bytes</span></span><br><span class="line">        <span class="variable language_">self</span>.fsize = fsize</span><br><span class="line">        <span class="comment"># The object&#x27;s SHA</span></span><br><span class="line">        <span class="variable language_">self</span>.sha = sha</span><br><span class="line">        <span class="variable language_">self</span>.flag_assume_valid = flag_assume_valid</span><br><span class="line">        <span class="variable language_">self</span>.flag_stage = flag_stage</span><br><span class="line">        <span class="comment"># Name of the object (full path this time!)</span></span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br></pre></td></tr></table></figure>

<p>索引文件是一个二进制文件，可能是出于性能原因。不过格式相对简单。它以一个包含 DIRC 魔术字节、版本号和索引文件中条目总数的头部开始。我们创建 <code>GitIndex</code> 类来存储这些内容：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GitIndex</span> (<span class="title class_ inherited__">object</span>):</span><br><span class="line">    version = <span class="literal">None</span></span><br><span class="line">    entries = []</span><br><span class="line">    <span class="comment"># ext = None</span></span><br><span class="line">    <span class="comment"># sha = None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, version=<span class="number">2</span>, entries=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> entries:</span><br><span class="line">            entries = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.version = version</span><br><span class="line">        <span class="variable language_">self</span>.entries = entries</span><br></pre></td></tr></table></figure>

<p>并且我们需要一个解析器，将索引文件读入这些对象。在读取完 12 字节的头部后，我们按照出现顺序解析条目。每个条目以一组固定长度的数据开头，后面跟着一个可变长度的文件名。</p>
<p>这段代码相当直接，但由于它在读取二进制格式，它比我们之前的代码稍显杂乱。我们频繁使用 <code>int.from_bytes(bytes, endianness)</code> 来将原始字节转换成整数，并且进行少量的位运算来分离共享同一字节的数据。</p>
<p>（这种格式可能是为了让索引文件能够直接映射到内存（<code>mmapp()</code>），并像 C 结构体一样直接读取，通常在大多数情况下构建索引的时间复杂度为 O(n)。这种方法在 C 中往往能产生比 Python 更优雅的代码……）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">index_read</span>(<span class="params">repo</span>):</span><br><span class="line">    index_file = repo_file(repo, <span class="string">&quot;index&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># New repositories have no index!</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(index_file):</span><br><span class="line">        <span class="keyword">return</span> GitIndex()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(index_file, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        raw = f.read()</span><br><span class="line"></span><br><span class="line">    header = raw[:<span class="number">12</span>]</span><br><span class="line">    signature = header[:<span class="number">4</span>]</span><br><span class="line">    <span class="keyword">assert</span> signature == <span class="string">b&quot;DIRC&quot;</span> <span class="comment"># Stands for &quot;DirCache&quot;</span></span><br><span class="line">    version = <span class="built_in">int</span>.from_bytes(header[<span class="number">4</span>:<span class="number">8</span>], <span class="string">&quot;big&quot;</span>)</span><br><span class="line">    <span class="keyword">assert</span> version == <span class="number">2</span>, <span class="string">&quot;wyag only supports index file version 2&quot;</span></span><br><span class="line">    count = <span class="built_in">int</span>.from_bytes(header[<span class="number">8</span>:<span class="number">12</span>], <span class="string">&quot;big&quot;</span>)</span><br><span class="line"></span><br><span class="line">    entries = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line">    content = raw[<span class="number">12</span>:]</span><br><span class="line">    idx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, count):</span><br><span class="line">        <span class="comment"># Read creation time, as a unix timestamp (seconds since</span></span><br><span class="line">        <span class="comment"># 1970-01-01 00:00:00, the &quot;epoch&quot;)</span></span><br><span class="line">        ctime_s =  <span class="built_in">int</span>.from_bytes(content[idx: idx+<span class="number">4</span>], <span class="string">&quot;big&quot;</span>)</span><br><span class="line">        <span class="comment"># Read creation time, as nanoseconds after that timestamps,</span></span><br><span class="line">        <span class="comment"># for extra precision.</span></span><br><span class="line">        ctime_ns = <span class="built_in">int</span>.from_bytes(content[idx+<span class="number">4</span>: idx+<span class="number">8</span>], <span class="string">&quot;big&quot;</span>)</span><br><span class="line">        <span class="comment"># Same for modification time: first seconds from epoch.</span></span><br><span class="line">        mtime_s = <span class="built_in">int</span>.from_bytes(content[idx+<span class="number">8</span>: idx+<span class="number">12</span>], <span class="string">&quot;big&quot;</span>)</span><br><span class="line">        <span class="comment"># Then extra nanoseconds</span></span><br><span class="line">        mtime_ns = <span class="built_in">int</span>.from_bytes(content[idx+<span class="number">12</span>: idx+<span class="number">16</span>], <span class="string">&quot;big&quot;</span>)</span><br><span class="line">        <span class="comment"># Device ID</span></span><br><span class="line">        dev = <span class="built_in">int</span>.from_bytes(content[idx+<span class="number">16</span>: idx+<span class="number">20</span>], <span class="string">&quot;big&quot;</span>)</span><br><span class="line">        <span class="comment"># Inode</span></span><br><span class="line">        ino = <span class="built_in">int</span>.from_bytes(content[idx+<span class="number">20</span>: idx+<span class="number">24</span>], <span class="string">&quot;big&quot;</span>)</span><br><span class="line">        <span class="comment"># Ignored.</span></span><br><span class="line">        unused = <span class="built_in">int</span>.from_bytes(content[idx+<span class="number">24</span>: idx+<span class="number">26</span>], <span class="string">&quot;big&quot;</span>)</span><br><span class="line">        <span class="keyword">assert</span> <span class="number">0</span> == unused</span><br><span class="line">        mode = <span class="built_in">int</span>.from_bytes(content[idx+<span class="number">26</span>: idx+<span class="number">28</span>], <span class="string">&quot;big&quot;</span>)</span><br><span class="line">        mode_type = mode &gt;&gt; <span class="number">12</span></span><br><span class="line">        <span class="keyword">assert</span> mode_type <span class="keyword">in</span> [<span class="number">0b1000</span>, <span class="number">0b1010</span>, <span class="number">0b1110</span>]</span><br><span class="line">        mode_perms = mode &amp; <span class="number">0b0000000111111111</span></span><br><span class="line">        <span class="comment"># User ID</span></span><br><span class="line">        uid = <span class="built_in">int</span>.from_bytes(content[idx+<span class="number">28</span>: idx+<span class="number">32</span>], <span class="string">&quot;big&quot;</span>)</span><br><span class="line">        <span class="comment"># Group ID</span></span><br><span class="line">        gid = <span class="built_in">int</span>.from_bytes(content[idx+<span class="number">32</span>: idx+<span class="number">36</span>], <span class="string">&quot;big&quot;</span>)</span><br><span class="line">        <span class="comment"># Size</span></span><br><span class="line">        fsize = <span class="built_in">int</span>.from_bytes(content[idx+<span class="number">36</span>: idx+<span class="number">40</span>], <span class="string">&quot;big&quot;</span>)</span><br><span class="line">        <span class="comment"># SHA (object ID).  We&#x27;ll store it as a lowercase hex string</span></span><br><span class="line">        <span class="comment"># for consistency.</span></span><br><span class="line">        sha = <span class="built_in">format</span>(<span class="built_in">int</span>.from_bytes(content[idx+<span class="number">40</span>: idx+<span class="number">60</span>], <span class="string">&quot;big&quot;</span>), <span class="string">&quot;040x&quot;</span>)</span><br><span class="line">        <span class="comment"># Flags we&#x27;re going to ignore</span></span><br><span class="line">        flags = <span class="built_in">int</span>.from_bytes(content[idx+<span class="number">60</span>: idx+<span class="number">62</span>], <span class="string">&quot;big&quot;</span>)</span><br><span class="line">        <span class="comment"># Parse flags</span></span><br><span class="line">        flag_assume_valid = (flags &amp; <span class="number">0b1000000000000000</span>) != <span class="number">0</span></span><br><span class="line">        flag_extended = (flags &amp; <span class="number">0b0100000000000000</span>) != <span class="number">0</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="keyword">not</span> flag_extended</span><br><span class="line">        flag_stage =  flags &amp; <span class="number">0b0011000000000000</span></span><br><span class="line">        <span class="comment"># Length of the name.  This is stored on 12 bits, some max</span></span><br><span class="line">        <span class="comment"># value is 0xFFF, 4095.  Since names can occasionally go</span></span><br><span class="line">        <span class="comment"># beyond that length, git treats 0xFFF as meaning at least</span></span><br><span class="line">        <span class="comment"># 0xFFF, and looks for the final 0x00 to find the end of the</span></span><br><span class="line">        <span class="comment"># name --- at a small, and probably very rare, performance</span></span><br><span class="line">        <span class="comment"># cost.</span></span><br><span class="line">        name_length = flags &amp; <span class="number">0b0000111111111111</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># We&#x27;ve read 62 bytes so far.</span></span><br><span class="line">        idx += <span class="number">62</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> name_length &lt; <span class="number">0xFFF</span>:</span><br><span class="line">            <span class="keyword">assert</span> content[idx + name_length] == <span class="number">0x00</span></span><br><span class="line">            raw_name = content[idx:idx+name_length]</span><br><span class="line">            idx += name_length + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Notice: Name is 0x<span class="subst">&#123;name_length:X&#125;</span> bytes long.&quot;</span>)</span><br><span class="line">            <span class="comment"># This probably wasn&#x27;t tested enough.  It works with a</span></span><br><span class="line">            <span class="comment"># path of exactly 0xFFF bytes.  Any extra bytes broke</span></span><br><span class="line">            <span class="comment"># something between git, my shell and my filesystem.</span></span><br><span class="line">            null_idx = content.find(<span class="string">b&#x27;\x00&#x27;</span>, idx + <span class="number">0xFFF</span>)</span><br><span class="line">            raw_name = content[idx: null_idx]</span><br><span class="line">            idx = null_idx + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Just parse the name as utf8.</span></span><br><span class="line">        name = raw_name.decode(<span class="string">&quot;utf8&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Data is padded on multiples of eight bytes for pointer</span></span><br><span class="line">        <span class="comment"># alignment, so we skip as many bytes as we need for the next</span></span><br><span class="line">        <span class="comment"># read to start at the right position.</span></span><br><span class="line"></span><br><span class="line">        idx = <span class="number">8</span> * ceil(idx / <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># And we add this entry to our list.</span></span><br><span class="line">        entries.append(GitIndexEntry(ctime=(ctime_s, ctime_ns),</span><br><span class="line">                                     mtime=(mtime_s,  mtime_ns),</span><br><span class="line">                                     dev=dev,</span><br><span class="line">                                     ino=ino,</span><br><span class="line">                                     mode_type=mode_type,</span><br><span class="line">                                     mode_perms=mode_perms,</span><br><span class="line">                                     uid=uid,</span><br><span class="line">                                     gid=gid,</span><br><span class="line">                                     fsize=fsize,</span><br><span class="line">                                     sha=sha,</span><br><span class="line">                                     flag_assume_valid=flag_assume_valid,</span><br><span class="line">                                     flag_stage=flag_stage,</span><br><span class="line">                                     name=name))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> GitIndex(version=version, entries=entries)</span><br></pre></td></tr></table></figure>

<h3 id="8-3-The-ls-files-command"><a href="#8-3-The-ls-files-command" class="headerlink" title="8.3. The ls-files command"></a>8.3. The ls-files command</h3><p><code>git ls-files</code> 显示暂存区中文件的名称，并且通常会有许多选项。我们的 <code>ls-files</code> 会简单得多，但我们会添加一个 <code>--verbose</code> 选项，虽然在 git 中并没有这个选项，但为了能够显示索引文件中的每一项信息，我们会加上它。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">argsp = argsubparsers.add_parser(<span class="string">&quot;ls-files&quot;</span>, <span class="built_in">help</span> = <span class="string">&quot;List all the stage files&quot;</span>)</span><br><span class="line">argsp.add_argument(<span class="string">&quot;--verbose&quot;</span>, action=<span class="string">&quot;store_true&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;Show everything.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd_ls_files</span>(<span class="params">args</span>):</span><br><span class="line">    repo = repo_find()</span><br><span class="line">    index = index_read(repo)</span><br><span class="line">    <span class="keyword">if</span> args.verbose:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Index file format v<span class="subst">&#123;index.version&#125;</span>, containing <span class="subst">&#123;<span class="built_in">len</span>(index.entries)&#125;</span> entries.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> index.entries:</span><br><span class="line">        <span class="built_in">print</span>(e.name)</span><br><span class="line">        <span class="keyword">if</span> args.verbose:</span><br><span class="line">            entry_type = &#123; <span class="number">0b1000</span>: <span class="string">&quot;regular file&quot;</span>,</span><br><span class="line">                           <span class="number">0b1010</span>: <span class="string">&quot;symlink&quot;</span>,</span><br><span class="line">                           <span class="number">0b1110</span>: <span class="string">&quot;git link&quot;</span> &#125;[e.mode_type]</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;  <span class="subst">&#123;entry_type&#125;</span> with perms: <span class="subst">&#123;e.mode_perms:o&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;  on blob: <span class="subst">&#123;e.sha&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;  created: <span class="subst">&#123;datetime.fromtimestamp(e.ctime[<span class="number">0</span>])&#125;</span>.<span class="subst">&#123;e.ctime[<span class="number">1</span>]&#125;</span>, modified: <span class="subst">&#123;datetime.fromtimestamp(e.mtime[<span class="number">0</span>])&#125;</span>.<span class="subst">&#123;e.mtime[<span class="number">1</span>]&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;  device: <span class="subst">&#123;e.dev&#125;</span>, inode: <span class="subst">&#123;e.ino&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;  user: <span class="subst">&#123;pwd.getpwuid(e.uid).pw_name&#125;</span> (<span class="subst">&#123;e.uid&#125;</span>)  group: <span class="subst">&#123;grp.getgrgid(e.gid).gr_name&#125;</span> (<span class="subst">&#123;e.gid&#125;</span>)&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;  flags: stage=<span class="subst">&#123;e.flag_stage&#125;</span> assume_valid=<span class="subst">&#123;e.flag_assume_valid&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>如果运行 <code>ls-files</code>，你会注意到在一个“干净”的工作区（一个未修改的 HEAD 检出）中，它列出了 HEAD 上的所有文件。同样，索引文件并不是从 HEAD 提交的增量（即差异集），而是以不同的格式作为 HEAD 的副本开始的。</p>
<h3 id="8-4-A-detour-the-check-ignore-command"><a href="#8-4-A-detour-the-check-ignore-command" class="headerlink" title="8.4. A detour: the check-ignore command"></a>8.4. A detour: the check-ignore command</h3><p>我们想要实现 <code>status</code> 命令，但 <code>status</code> 需要了解忽略规则，这些规则存储在各种 <code>.gitignore</code> 文件中。因此，我们首先需要在 wyag 中添加一些基本的对忽略文件的支持。我们将通过 <code>check-ignore</code> 命令来暴露这一支持，该命令接受一组路径并返回那些应该被忽略的路径。</p>
<p>同样，命令解析器是非常简单的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">argsp = argsubparsers.add_parser(<span class="string">&quot;check-ignore&quot;</span>, <span class="built_in">help</span> = <span class="string">&quot;Check path(s) against ignore rules.&quot;</span>)</span><br><span class="line">argsp.add_argument(<span class="string">&quot;path&quot;</span>, nargs=<span class="string">&quot;+&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;Paths to check&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>而这个函数也同样简单：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cmd_check_ignore</span>(<span class="params">args</span>):</span><br><span class="line">    repo = repo_find()</span><br><span class="line">    rules = gitignore_read(repo)</span><br><span class="line">    <span class="keyword">for</span> path <span class="keyword">in</span> args.path:</span><br><span class="line">        <span class="keyword">if</span> check_ignore(rules, path):</span><br><span class="line">            <span class="built_in">print</span>(path)</span><br></pre></td></tr></table></figure>

<p>当然，许多我们调用的函数在 wyag 中还不存在。我们将首先编写一个用于读取忽略文件规则的函数 <code>gitignore_read()</code>。这些规则的语法相当简单：忽略文件中的每一行都是一个排除模式，匹配此模式的文件会被 status、add -A 等操作忽略。然而，有三种特殊情况：</p>
<ul>
<li>以感叹号 <code>!</code> 开头的行会否定该模式（即使之前的模式已经忽略了文件，这些文件也会被包括在内）。</li>
<li>以井号 <code>#</code> 开头的行是注释，会被跳过。</li>
<li>行首的反斜杠 <code>\</code> 会将 <code>!</code> 和 <code>#</code> 视为普通字符。</li>
</ul>
<p>首先，我们需要编写一个解析单个模式的函数。这个解析器返回一个元组：模式本身，以及一个布尔值，用于指示匹配该模式的文件是应该被排除（<code>True</code>）还是包括（<code>False</code>）。换句话说，如果模式是以 <code>!</code> 开头的，返回 <code>False</code>，否则返回 <code>True</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gitignore_parse1</span>(<span class="params">raw</span>):</span><br><span class="line">    raw = raw.strip() <span class="comment"># Remove leading/trailing spaces</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> raw <span class="keyword">or</span> raw[<span class="number">0</span>] == <span class="string">&quot;#&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">elif</span> raw[<span class="number">0</span>] == <span class="string">&quot;!&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> (raw[<span class="number">1</span>:], <span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">elif</span> raw[<span class="number">0</span>] == <span class="string">&quot;\\&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> (raw[<span class="number">1</span>:], <span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> (raw, <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>解析文件就是收集文件中的所有规则。注意，这个函数并不直接解析文件，而是解析行的列表：这是因为我们不仅需要从常规文件中读取规则，还需要从 Git 的 blob 中读取规则。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gitignore_parse</span>(<span class="params">lines</span>):</span><br><span class="line">    ret = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        parsed = gitignore_parse1(line)</span><br><span class="line">        <span class="keyword">if</span> parsed:</span><br><span class="line">            ret.append(parsed)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<p>最后我们需要做的是收集各种忽略文件。它们有两种类型：</p>
<ol>
<li>一些文件存在于索引中：它们是各种 gitignore 文件。强调一下复数形式；虽然通常只有一个这样的文件，位于根目录，但每个目录下都可以有一个，这个文件适用于该目录及其子目录。我将这些称为“作用域”，因为它们仅适用于其所在目录及其子目录。</li>
<li>另一些文件存在于索引之外。它们是全局忽略文件（通常位于 <code>~/.config/git/ignore</code>）和存储在 <code>.git/info/exclude</code> 中的仓库特定忽略文件。我将这些称为“绝对”，因为它们适用于整个仓库，但优先级较低。</li>
</ol>
<p>再次创建一个类来持有这些文件的信息：包括一个绝对规则的列表和一个相对规则的字典。这个字典的键是相对于工作区根目录的目录路径。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GitIgnore</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    absolute = <span class="literal">None</span></span><br><span class="line">    scoped = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, absolute, scoped</span>):</span><br><span class="line">        <span class="variable language_">self</span>.absolute = absolute</span><br><span class="line">        <span class="variable language_">self</span>.scoped = scoped</span><br></pre></td></tr></table></figure>

<p>最后，我们编写一个函数来收集仓库中所有的 gitignore 规则，并返回一个 <code>GitIgnore</code> 对象。需要注意的是，它从索引中读取作用域文件，而不是从工作区读取：只有已暂存的 <code>.gitignore</code> 文件才有意义（还要记住：<code>HEAD</code> 已经被暂存——暂存区是一个副本，而不是增量）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gitignore_read</span>(<span class="params">repo</span>):</span><br><span class="line">    ret = GitIgnore(absolute=<span class="built_in">list</span>(), scoped=<span class="built_in">dict</span>())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Read local configuration in .git/info/exclude</span></span><br><span class="line">    repo_file = os.path.join(repo.gitdir, <span class="string">&quot;info/exclude&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> os.path.exists(repo_file):</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(repo_file, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            ret.absolute.append(gitignore_parse(f.readlines()))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Global configuration</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;XDG_CONFIG_HOME&quot;</span> <span class="keyword">in</span> os.environ:</span><br><span class="line">        config_home = os.environ[<span class="string">&quot;XDG_CONFIG_HOME&quot;</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        config_home = os.path.expanduser(<span class="string">&quot;~/.config&quot;</span>)</span><br><span class="line">    global_file = os.path.join(config_home, <span class="string">&quot;git/ignore&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(global_file):</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(global_file, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            ret.absolute.append(gitignore_parse(f.readlines()))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># .gitignore files in the index</span></span><br><span class="line">    index = index_read(repo)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> entry <span class="keyword">in</span> index.entries:</span><br><span class="line">        <span class="keyword">if</span> entry.name == <span class="string">&quot;.gitignore&quot;</span> <span class="keyword">or</span> entry.name.endswith(<span class="string">&quot;/.gitignore&quot;</span>):</span><br><span class="line">            dir_name = os.path.dirname(entry.name)</span><br><span class="line">            contents = object_read(repo, entry.sha)</span><br><span class="line">            lines = contents.blobdata.decode(<span class="string">&quot;utf8&quot;</span>).splitlines()</span><br><span class="line">            ret.scoped[dir_name] = gitignore_parse(lines)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<p>我们快完成了。为了将所有内容结合在一起，我们需要一个 <code>check_ignore</code> 函数，它将路径与一组规则进行匹配，这些路径是相对于工作树的根目录的。这个函数的工作方式如下：</p>
<ol>
<li><strong>作用域规则匹配</strong>：它首先尝试将路径与作用域规则进行匹配。匹配的顺序是从路径的最深父级开始，逐级向上查找。例如，如果路径是 <code>src/support/w32/legacy/sound.c~</code>，它会先查找 <code>src/support/w32/legacy/.gitignore</code> 中的规则，然后是 <code>src/support/w32/.gitignore</code>，再是 <code>src/support/.gitignore</code>，直到根目录下的 <code>.gitignore</code>。</li>
<li><strong>绝对规则匹配</strong>：如果作用域规则没有匹配，它将继续使用绝对规则进行匹配。</li>
</ol>
<p>我们将编写三个小的支持函数。第一个是用来将路径与规则集进行匹配的，并返回最后一个匹配规则的结果。注意，这不是一个真正的布尔函数，因为它有三个可能的返回值：<code>True</code>、<code>False</code> 和 <code>None</code>。如果没有匹配，它将返回 <code>None</code>，这样调用者就知道应该继续尝试更一般的忽略文件（例如，向上移动一个目录级别）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">check_ignore1</span>(<span class="params">rules, path</span>):</span><br><span class="line">    result = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> (pattern, value) <span class="keyword">in</span> rules:</span><br><span class="line">        <span class="keyword">if</span> fnmatch(path, pattern):</span><br><span class="line">            result = value</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p>这是一个用于匹配作用域规则字典（即各种 <code>.gitignore</code> 文件）的函数。它从路径所在的目录开始，逐级向上递归查找父目录，直到测试到根目录。请注意，这个函数（以及接下来的两个函数）在处理每个 <code>.gitignore</code> 文件时不会提前停止。即使某个规则匹配，它们会继续扫描整个文件，因为该文件中的其他规则可能会反转之前的效果（规则是按顺序处理的，因此如果你想排除 <code>*.c</code> 但不排除 <code>generator.c</code>，通用规则必须放在特定规则之前）。但是，一旦在某个文件中至少匹配到一个规则，我们就停止继续检查该文件的剩余规则，因为更一般的文件永远不会取消更具体规则的效果（这就是为什么 <code>check_ignore1</code> 是三值而不是布尔的原因）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">check_ignore_scoped</span>(<span class="params">rules, path</span>):</span><br><span class="line">    parent = os.path.dirname(path)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> parent <span class="keyword">in</span> rules:</span><br><span class="line">            result = check_ignore1(rules[parent], path)</span><br><span class="line">            <span class="keyword">if</span> result != <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">if</span> parent == <span class="string">&quot;&quot;</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        parent = os.path.dirname(parent)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>这是一个用于匹配绝对规则列表的简单函数。请注意，我们将这些规则推送到列表的顺序很重要（因为我们确实先读取了仓库规则，再读取了全局规则！）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">check_ignore_absolute</span>(<span class="params">rules, path</span>):</span><br><span class="line">    parent = os.path.dirname(path)</span><br><span class="line">    <span class="keyword">for</span> ruleset <span class="keyword">in</span> rules:</span><br><span class="line">        result = check_ignore1(ruleset, path)</span><br><span class="line">        <span class="keyword">if</span> result != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span> <span class="comment"># This is a reasonable default at this point.</span></span><br></pre></td></tr></table></figure>

<p>最后，我们需要一个函数将它们全部绑定在一起。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">check_ignore</span>(<span class="params">rules, path</span>):</span><br><span class="line">    <span class="keyword">if</span> os.path.isabs(path):</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&quot;This function requires path to be relative to the repository&#x27;s root&quot;</span>)</span><br><span class="line"></span><br><span class="line">    result = check_ignore_scoped(rules.scoped, path)</span><br><span class="line">    <span class="keyword">if</span> result != <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> check_ignore_absolute(rules.absolute, path)</span><br></pre></td></tr></table></figure>

<p>现在，您可以在其源代码树上调用 <code>wyag check-ignore</code>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wyag check-ignore hello.el hello.elc hello.html wyag.zip wyag.tar</span></span><br><span class="line">hello.elc</span><br><span class="line">hello.html</span><br><span class="line">wyag.zip</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>Warning</strong></th>
</tr>
</thead>
<tbody><tr>
<td>这只是一个近似实现<br />这并不是一个完美的重新实现。特别是，通过仅使用目录名称（例如 <code>__pycache__</code>）的规则排除整个目录将不起作用，因为 <code>fnmatch</code> 需要的模式是 <code>__pycache__/**</code>。如果你真的想深入了解忽略规则，这可能是一个很好的起点。</td>
</tr>
</tbody></table>
<h3 id="8-5-The-status-command"><a href="#8-5-The-status-command" class="headerlink" title="8.5. The status command"></a>8.5. The status command</h3><p><code>status</code> 比 <code>ls-files</code> 更复杂，因为它需要同时比较索引（index）与 <code>HEAD</code> 以及实际的文件系统（worktree）。当你运行 <code>git status</code> 时，它会告诉你哪些文件自上次提交以来被添加、删除或修改，以及这些更改中哪些已经被暂存，并将出现在下一次提交中。因此，<code>status</code> 实际上是在比较 <code>HEAD</code> 与暂存区（staging area），以及暂存区与工作区（worktree）。它的输出格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)</span><br><span class="line">	modified:   write-yourself-a-git.org</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">	modified:   write-yourself-a-git.org</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">	org-html-themes/</span><br><span class="line">	wl-copy</span><br></pre></td></tr></table></figure>

<p>我们将实现 status 的三个部分：首先是活动分支或“分离的 HEAD”，然后是索引和工作区之间的差异（“未暂存的更改”），最后是 HEAD 和索引之间的差异（“已暂存的更改”和“未跟踪的文件”）。</p>
<p>公共接口非常简单，我们的 status 将不接受任何参数:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">argsp = argsubparsers.add_parser(<span class="string">&quot;status&quot;</span>, <span class="built_in">help</span> = <span class="string">&quot;Show the working tree status.&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>桥接函数只是按顺序调用这三个组件函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cmd_status</span>(<span class="params">_</span>):</span><br><span class="line">    repo = repo_find()</span><br><span class="line">    index = index_read(repo)</span><br><span class="line"></span><br><span class="line">    cmd_status_branch(repo)</span><br><span class="line">    cmd_status_head_index(repo, index)</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">    cmd_status_index_worktree(repo, index) </span><br></pre></td></tr></table></figure>

<h4 id="8-5-1-Finding-the-active-branch"><a href="#8-5-1-Finding-the-active-branch" class="headerlink" title="8.5.1. Finding the active branch"></a>8.5.1. Finding the active branch</h4><p>首先，我们需要知道当前是否位于某个分支上，如果是的话，确定是哪一个分支。我们可以通过检查 <code>.git/HEAD</code> 来实现这一点。该文件应该包含一个十六进制 ID（在分离的 HEAD 状态下指向某个提交），或者是一个间接引用，指向 <code>refs/heads/</code> 目录中的某个分支。如果是分支，我们返回其名称；如果不是，则返回 <code>False</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">branch_get_active</span>(<span class="params">repo</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(repo_file(repo, <span class="string">&quot;HEAD&quot;</span>), <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        head = f.read()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> head.startswith(<span class="string">&quot;ref: refs/heads/&quot;</span>):</span><br><span class="line">        <span class="keyword">return</span>(head[<span class="number">16</span>:-<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>基于此，我们可以编写 <code>cmd_status_*</code> 函数中的第一个，该函数由桥接函数调用。它的作用是打印当前活动分支的名称，或者在处于分离的 HEAD 状态时，打印其哈希值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cmd_status_branch</span>(<span class="params">repo</span>):</span><br><span class="line">    branch = branch_get_active(repo)</span><br><span class="line">    <span class="keyword">if</span> branch:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;On branch <span class="subst">&#123;branch&#125;</span>.&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;HEAD detached at <span class="subst">&#123;object_find(repo, <span class="string">&#x27;HEAD&#x27;</span>)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="8-5-2-Finding-changes-between-HEAD-and-index"><a href="#8-5-2-Finding-changes-between-HEAD-and-index" class="headerlink" title="8.5.2. Finding changes between HEAD and index"></a>8.5.2. Finding changes between HEAD and index</h4><p>状态输出的第二块是“待提交的更改”，即暂存区与 HEAD 的差异。为此，我们将首先读取 HEAD 的树，并将其展平为一个单一的字典（哈希映射），键为完整路径，这样它就更接近于将路径与 blob 关联的（扁平化的）索引。然后，我们只需对比它们并输出差异。</p>
<p>首先，编写一个函数，将树（递归的，记得哦）转换为一个（扁平化的）字典。由于树是递归的，所以该函数本身也是递归的——抱歉，理解这一点需要点耐心 :)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tree_to_dict</span>(<span class="params">repo, ref, prefix=<span class="string">&quot;&quot;</span></span>):</span><br><span class="line">    ret = <span class="built_in">dict</span>()</span><br><span class="line">    tree_sha = object_find(repo, ref, fmt=<span class="string">b&quot;tree&quot;</span>)</span><br><span class="line">    tree = object_read(repo, tree_sha)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> leaf <span class="keyword">in</span> tree.items:</span><br><span class="line">        full_path = os.path.join(prefix, leaf.path)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># We read the object to extract its type (this is uselessly</span></span><br><span class="line">        <span class="comment"># expensive: we could just open it as a file and read the</span></span><br><span class="line">        <span class="comment"># first few bytes)</span></span><br><span class="line">        is_subtree = leaf.mode.startswith(<span class="string">b&#x27;04&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Depending on the type, we either store the path (if it&#x27;s a</span></span><br><span class="line">        <span class="comment"># blob, so a regular file), or recurse (if it&#x27;s another tree,</span></span><br><span class="line">        <span class="comment"># so a subdir)</span></span><br><span class="line">        <span class="keyword">if</span> is_subtree:</span><br><span class="line">            ret.update(tree_to_dict(repo, leaf.sha, full_path))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ret[full_path] = leaf.sha</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<p>以及命令本身：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cmd_status_head_index</span>(<span class="params">repo, index</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Changes to be committed:&quot;</span>)</span><br><span class="line"></span><br><span class="line">    head = tree_to_dict(repo, <span class="string">&quot;HEAD&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> entry <span class="keyword">in</span> index.entries:</span><br><span class="line">        <span class="keyword">if</span> entry.name <span class="keyword">in</span> head:</span><br><span class="line">            <span class="keyword">if</span> head[entry.name] != entry.sha:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;  modified:&quot;</span>, entry.name)</span><br><span class="line">            <span class="keyword">del</span> head[entry.name] <span class="comment"># Delete the key</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;  added:   &quot;</span>, entry.name)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Keys still in HEAD are files that we haven&#x27;t met in the index,</span></span><br><span class="line">    <span class="comment"># and thus have been deleted.</span></span><br><span class="line">    <span class="keyword">for</span> entry <span class="keyword">in</span> head.keys():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;  deleted: &quot;</span>, entry)</span><br></pre></td></tr></table></figure>

<h4 id="8-5-3-Finding-changes-between-index-and-worktree"><a href="#8-5-3-Finding-changes-between-index-and-worktree" class="headerlink" title="8.5.3. Finding changes between index and worktree"></a>8.5.3. Finding changes between index and worktree</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cmd_status_index_worktree</span>(<span class="params">repo, index</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Changes not staged for commit:&quot;</span>)</span><br><span class="line"></span><br><span class="line">    ignore = gitignore_read(repo)</span><br><span class="line"></span><br><span class="line">    gitdir_prefix = repo.gitdir + os.path.sep</span><br><span class="line"></span><br><span class="line">    all_files = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># We begin by walking the filesystem</span></span><br><span class="line">    <span class="keyword">for</span> (root, _, files) <span class="keyword">in</span> os.walk(repo.worktree, <span class="literal">True</span>):</span><br><span class="line">        <span class="keyword">if</span> root==repo.gitdir <span class="keyword">or</span> root.startswith(gitdir_prefix):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">for</span> f <span class="keyword">in</span> files:</span><br><span class="line">            full_path = os.path.join(root, f)</span><br><span class="line">            rel_path = os.path.relpath(full_path, repo.worktree)</span><br><span class="line">            all_files.append(rel_path)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># We now traverse the index, and compare real files with the cached</span></span><br><span class="line">    <span class="comment"># versions.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> entry <span class="keyword">in</span> index.entries:</span><br><span class="line">        full_path = os.path.join(repo.worktree, entry.name)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># That file *name* is in the index</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(full_path):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;  deleted: &quot;</span>, entry.name)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            stat = os.stat(full_path)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Compare metadata</span></span><br><span class="line">            ctime_ns = entry.ctime[<span class="number">0</span>] * <span class="number">10</span>**<span class="number">9</span> + entry.ctime[<span class="number">1</span>]</span><br><span class="line">            mtime_ns = entry.mtime[<span class="number">0</span>] * <span class="number">10</span>**<span class="number">9</span> + entry.mtime[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> (stat.st_ctime_ns != ctime_ns) <span class="keyword">or</span> (stat.st_mtime_ns != mtime_ns):</span><br><span class="line">                <span class="comment"># If different, deep compare.</span></span><br><span class="line">                <span class="comment"># @FIXME This *will* crash on symlinks to dir.</span></span><br><span class="line">                <span class="keyword">with</span> <span class="built_in">open</span>(full_path, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> fd:</span><br><span class="line">                    new_sha = object_hash(fd, <span class="string">b&quot;blob&quot;</span>, <span class="literal">None</span>)</span><br><span class="line">                    <span class="comment"># If the hashes are the same, the files are actually the same.</span></span><br><span class="line">                    same = entry.sha == new_sha</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> same:</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">&quot;  modified:&quot;</span>, entry.name)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> entry.name <span class="keyword">in</span> all_files:</span><br><span class="line">            all_files.remove(entry.name)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Untracked files:&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> all_files:</span><br><span class="line">        <span class="comment"># @TODO If a full directory is untracked, we should display</span></span><br><span class="line">        <span class="comment"># its name without its contents.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> check_ignore(ignore, f):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot; &quot;</span>, f)</span><br></pre></td></tr></table></figure>

<p>我们的 <code>status</code> 函数完成了。它应该输出类似于：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wyag status</span></span><br><span class="line">On branch main.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  added:    src/main.c</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  modified: build.py</span><br><span class="line">  deleted:  README.org</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  src/cli.c</span><br></pre></td></tr></table></figure>

<p>真正的 <code>status</code> 更智能：例如，它可以检测重命名，而我们的实现无法做到这一点。另一个值得提到的重要区别是，<code>git status</code> 实际上会在文件的元数据被修改但内容未改变时将索引文件写回。如果用我们特别的 <code>ls-files</code> 来查看，你可以看到这一点：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wyag ls-files --verbose</span></span><br><span class="line">Index file format v2, containing 1 entries.</span><br><span class="line">file</span><br><span class="line">  regular file with perms: 644</span><br><span class="line">  on blob: f2f279981ce01b095c42ee7162aadf60185c8f67</span><br><span class="line">  created: 2023-07-18 18:26:15.771460869, modified: 2023-07-18 18:26:15.771460869</span><br><span class="line">  ...</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">touch</span> file</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status &gt; /dev/null</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wyag ls-files --verbose</span></span><br><span class="line">Index file format v2, containing 1 entries.</span><br><span class="line">file</span><br><span class="line">  regular file with perms: 644</span><br><span class="line">  on blob: f2f279981ce01b095c42ee7162aadf60185c8f67</span><br><span class="line">  created: 2023-07-18 18:26:41.421743098, modified: 2023-07-18 18:26:41.421743098</span><br></pre></td></tr></table></figure>

<p>请注意，<code>git status</code> 如何更新了索引文件中的两个时间戳，以反映实际文件元数据的变化。</p>
<h2 id="9-Staging-area-and-index-part-2-staging-and-committing"><a href="#9-Staging-area-and-index-part-2-staging-and-committing" class="headerlink" title="9. Staging area and index, part 2: staging and committing"></a>9. Staging area and index, part 2: staging and committing</h2><p>好的，让我们创建提交。</p>
<p>我们几乎已经准备好了，但还差最后三样东西：</p>
<ul>
<li>需要修改索引的命令，以便我们的提交不是仅仅复制其父提交。这些命令是 <code>add</code> 和 <code>rm</code>。</li>
<li>这些命令需要将修改后的索引写回，因为提交是基于索引进行的。</li>
<li>当然，我们还需要 <code>commit</code> 函数及其对应的 <code>wyag commit</code> 命令。</li>
</ul>
<h3 id="9-1-Writing-the-index"><a href="#9-1-Writing-the-index" class="headerlink" title="9.1. Writing the index"></a>9.1. Writing the index</h3><p>我们将从写入索引开始。本质上，我们只是将所有内容序列化回二进制格式。这虽然有些繁琐，但代码应该很直观。我会在注释中详细说明具体细节，但实际上，这只是 <code>index_read</code> 的反向操作——如果需要，可以参考它以及 <code>GitIndexEntry</code> 类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">index_write</span>(<span class="params">repo, index</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(repo_file(repo, <span class="string">&quot;index&quot;</span>), <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># HEADER</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Write the magic bytes.</span></span><br><span class="line">        f.write(<span class="string">b&quot;DIRC&quot;</span>)</span><br><span class="line">        <span class="comment"># Write version number.</span></span><br><span class="line">        f.write(index.version.to_bytes(<span class="number">4</span>, <span class="string">&quot;big&quot;</span>))</span><br><span class="line">        <span class="comment"># Write the number of entries.</span></span><br><span class="line">        f.write(<span class="built_in">len</span>(index.entries).to_bytes(<span class="number">4</span>, <span class="string">&quot;big&quot;</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># ENTRIES</span></span><br><span class="line"></span><br><span class="line">        idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> index.entries:</span><br><span class="line">            f.write(e.ctime[<span class="number">0</span>].to_bytes(<span class="number">4</span>, <span class="string">&quot;big&quot;</span>))</span><br><span class="line">            f.write(e.ctime[<span class="number">1</span>].to_bytes(<span class="number">4</span>, <span class="string">&quot;big&quot;</span>))</span><br><span class="line">            f.write(e.mtime[<span class="number">0</span>].to_bytes(<span class="number">4</span>, <span class="string">&quot;big&quot;</span>))</span><br><span class="line">            f.write(e.mtime[<span class="number">1</span>].to_bytes(<span class="number">4</span>, <span class="string">&quot;big&quot;</span>))</span><br><span class="line">            f.write(e.dev.to_bytes(<span class="number">4</span>, <span class="string">&quot;big&quot;</span>))</span><br><span class="line">            f.write(e.ino.to_bytes(<span class="number">4</span>, <span class="string">&quot;big&quot;</span>))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Mode</span></span><br><span class="line">            mode = (e.mode_type &lt;&lt; <span class="number">12</span>) | e.mode_perms</span><br><span class="line">            f.write(mode.to_bytes(<span class="number">4</span>, <span class="string">&quot;big&quot;</span>))</span><br><span class="line"></span><br><span class="line">            f.write(e.uid.to_bytes(<span class="number">4</span>, <span class="string">&quot;big&quot;</span>))</span><br><span class="line">            f.write(e.gid.to_bytes(<span class="number">4</span>, <span class="string">&quot;big&quot;</span>))</span><br><span class="line"></span><br><span class="line">            f.write(e.fsize.to_bytes(<span class="number">4</span>, <span class="string">&quot;big&quot;</span>))</span><br><span class="line">            <span class="comment"># @FIXME Convert back to int.</span></span><br><span class="line">            f.write(<span class="built_in">int</span>(e.sha, <span class="number">16</span>).to_bytes(<span class="number">20</span>, <span class="string">&quot;big&quot;</span>))</span><br><span class="line"></span><br><span class="line">            flag_assume_valid = <span class="number">0x1</span> &lt;&lt; <span class="number">15</span> <span class="keyword">if</span> e.flag_assume_valid <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            name_bytes = e.name.encode(<span class="string">&quot;utf8&quot;</span>)</span><br><span class="line">            bytes_len = <span class="built_in">len</span>(name_bytes)</span><br><span class="line">            <span class="keyword">if</span> bytes_len &gt;= <span class="number">0xFFF</span>:</span><br><span class="line">                name_length = <span class="number">0xFFF</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                name_length = bytes_len</span><br><span class="line"></span><br><span class="line">            <span class="comment"># We merge back three pieces of data (two flags and the</span></span><br><span class="line">            <span class="comment"># length of the name) on the same two bytes.</span></span><br><span class="line">            f.write((flag_assume_valid | e.flag_stage | name_length).to_bytes(<span class="number">2</span>, <span class="string">&quot;big&quot;</span>))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Write back the name, and a final 0x00.</span></span><br><span class="line">            f.write(name_bytes)</span><br><span class="line">            f.write((<span class="number">0</span>).to_bytes(<span class="number">1</span>, <span class="string">&quot;big&quot;</span>))</span><br><span class="line"></span><br><span class="line">            idx += <span class="number">62</span> + <span class="built_in">len</span>(name_bytes) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Add padding if necessary.</span></span><br><span class="line">            <span class="keyword">if</span> idx % <span class="number">8</span> != <span class="number">0</span>:</span><br><span class="line">                pad = <span class="number">8</span> - (idx % <span class="number">8</span>)</span><br><span class="line">                f.write((<span class="number">0</span>).to_bytes(pad, <span class="string">&quot;big&quot;</span>))</span><br><span class="line">                idx += pad</span><br></pre></td></tr></table></figure>

<h3 id="9-2-The-rm-command"><a href="#9-2-The-rm-command" class="headerlink" title="9.2. The rm command"></a>9.2. The rm command</h3><p>对索引进行的最简单的更改就是从中删除一个条目，这意味着下一个提交将不会包含该文件。这正是 <code>git rm</code> 命令的作用。</p>
<table>
<thead>
<tr>
<th><strong>Danger</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>git rm</code> 是一个破坏性操作，<code>wyag rm</code> 也是如此。该命令不仅修改索引，还会从工作区中删除文件。与 <code>git</code> 不同，<code>wyag rm</code> 不会在删除文件前检查其是否已保存。因此，请谨慎操作。</td>
</tr>
</tbody></table>
<p><code>rm</code> 接受一个参数，即要删除的路径列表：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">argsp = argsubparsers.add_parser(<span class="string">&quot;rm&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;Remove files from the working tree and the index.&quot;</span>)</span><br><span class="line">argsp.add_argument(<span class="string">&quot;path&quot;</span>, nargs=<span class="string">&quot;+&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;Files to remove&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd_rm</span>(<span class="params">args</span>):</span><br><span class="line">    repo = repo_find()</span><br><span class="line">    rm(repo, args.path)</span><br></pre></td></tr></table></figure>

<p><code>rm</code> 函数虽然有点长，但它非常简单。它接受一个仓库和一个路径列表，读取该仓库的索引，并从索引中删除与该列表匹配的条目。可选参数控制函数是否实际删除文件，以及如果某些路径在索引中不存在是否应中止（这两个参数供 <code>add</code> 使用，并不会在 <code>wyag rm</code> 命令中暴露）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rm</span>(<span class="params">repo, paths, delete=<span class="literal">True</span>, skip_missing=<span class="literal">False</span></span>):</span><br><span class="line">    <span class="comment"># Find and read the index</span></span><br><span class="line">    index = index_read(repo)</span><br><span class="line"></span><br><span class="line">    worktree = repo.worktree + os.sep</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Make paths absolute</span></span><br><span class="line">    abspaths = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">for</span> path <span class="keyword">in</span> paths:</span><br><span class="line">        abspath = os.path.abspath(path)</span><br><span class="line">        <span class="keyword">if</span> abspath.startswith(worktree):</span><br><span class="line">            abspaths.add(abspath)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">f&quot;Cannot remove paths outside of worktree: <span class="subst">&#123;paths&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># The list of entries to *keep*, which we will write back to the</span></span><br><span class="line">    <span class="comment"># index.</span></span><br><span class="line">    kept_entries = <span class="built_in">list</span>()</span><br><span class="line">    <span class="comment"># The list of removed paths, which we&#x27;ll use after index update</span></span><br><span class="line">    <span class="comment"># to physically remove the actual paths from the filesystem.</span></span><br><span class="line">    remove = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Now iterate over the list of entries, and remove those whose</span></span><br><span class="line">    <span class="comment"># paths we find in abspaths.  Preserve the others in kept_entries.</span></span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> index.entries:</span><br><span class="line">        full_path = os.path.join(repo.worktree, e.name)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> full_path <span class="keyword">in</span> abspaths:</span><br><span class="line">            remove.append(full_path)</span><br><span class="line">            abspaths.remove(full_path)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            kept_entries.append(e) <span class="comment"># Preserve entry</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># If abspaths is empty, it means some paths weren&#x27;t in the index.</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(abspaths) &gt; <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> skip_missing:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">f&quot;Cannot remove paths not in the index: <span class="subst">&#123;abspaths&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Physically delete paths from filesystem.</span></span><br><span class="line">    <span class="keyword">if</span> delete:</span><br><span class="line">        <span class="keyword">for</span> path <span class="keyword">in</span> remove:</span><br><span class="line">            os.unlink(path)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Update the list of entries in the index, and write it back.</span></span><br><span class="line">    index.entries = kept_entries</span><br><span class="line">    index_write(repo, index)</span><br></pre></td></tr></table></figure>

<p>现在，我们可以使用 <code>wyag rm</code> 来删除文件了。</p>
<h3 id="9-3-The-add-command"><a href="#9-3-The-add-command" class="headerlink" title="9.3. The add command"></a>9.3. The add command</h3><p>添加文件比删除稍微复杂一些，但我们已经掌握了所需的知识。将文件暂存（stage）到索引是一个三步操作：</p>
<ol>
<li>先从索引中删除已有的条目（如果存在），但不删除文件本身（这也是我们在 <code>rm</code> 函数中添加可选参数的原因）。</li>
<li>计算文件的哈希值，将其存储为 blob 对象。</li>
<li>创建相应的索引条目，并将修改后的索引写回。</li>
</ol>
<p>首先，我们来看命令的接口。没有什么特别之处，<code>wyag add PATH ...</code>，其中 <code>PATH</code> 是要暂存的一个或多个文件。这个桥接函数（bridge function）和之前的一样简单无趣。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">argsp = argsubparsers.add_parser(<span class="string">&quot;add&quot;</span>, <span class="built_in">help</span> = <span class="string">&quot;Add files contents to the index.&quot;</span>)</span><br><span class="line">argsp.add_argument(<span class="string">&quot;path&quot;</span>, nargs=<span class="string">&quot;+&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;Files to add&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd_add</span>(<span class="params">args</span>):</span><br><span class="line">    repo = repo_find()</span><br><span class="line">    add(repo, args.path)</span><br></pre></td></tr></table></figure>

<p><code>add</code> 与 <code>rm</code> 的主要区别在于，<code>add</code> 需要创建一个索引条目（index entry）。这并不难：我们只需对文件调用 <code>stat()</code>，然后将文件的元数据复制到索引的相应字段中（<code>stat()</code> 返回的元数据包括创建&#x2F;修改时间等，这些信息会存储在索引中）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">repo, paths, delete=<span class="literal">True</span>, skip_missing=<span class="literal">False</span></span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># First remove all paths from the index, if they exist.</span></span><br><span class="line">    rm (repo, paths, delete=<span class="literal">False</span>, skip_missing=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    worktree = repo.worktree + os.sep</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Convert the paths to pairs: (absolute, relative_to_worktree).</span></span><br><span class="line">    <span class="comment"># Also delete them from the index if they&#x27;re present.</span></span><br><span class="line">    clean_paths = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">for</span> path <span class="keyword">in</span> paths:</span><br><span class="line">        abspath = os.path.abspath(path)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (abspath.startswith(worktree) <span class="keyword">and</span> os.path.isfile(abspath)):</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">f&quot;Not a file, or outside the worktree: <span class="subst">&#123;paths&#125;</span>&quot;</span>)</span><br><span class="line">        relpath = os.path.relpath(abspath, repo.worktree)</span><br><span class="line">        clean_paths.add((abspath,  relpath))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Find and read the index.  It was modified by rm.  (This isn&#x27;t</span></span><br><span class="line">    <span class="comment"># optimal, good enough for wyag!)</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># @FIXME, though: we could just move the index through</span></span><br><span class="line">    <span class="comment"># commands instead of reading and writing it over again.</span></span><br><span class="line">    index = index_read(repo)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (abspath, relpath) <span class="keyword">in</span> clean_paths:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(abspath, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> fd:</span><br><span class="line">            sha = object_hash(fd, <span class="string">b&quot;blob&quot;</span>, repo)</span><br><span class="line"></span><br><span class="line">            stat = os.stat(abspath)</span><br><span class="line"></span><br><span class="line">            ctime_s = <span class="built_in">int</span>(stat.st_ctime)</span><br><span class="line">            ctime_ns = stat.st_ctime_ns % <span class="number">10</span>**<span class="number">9</span></span><br><span class="line">            mtime_s = <span class="built_in">int</span>(stat.st_mtime)</span><br><span class="line">            mtime_ns = stat.st_mtime_ns % <span class="number">10</span>**<span class="number">9</span></span><br><span class="line"></span><br><span class="line">            entry = GitIndexEntry(ctime=(ctime_s, ctime_ns), mtime=(mtime_s, mtime_ns), dev=stat.st_dev, ino=stat.st_ino,</span><br><span class="line">                                  mode_type=<span class="number">0b1000</span>, mode_perms=<span class="number">0o644</span>, uid=stat.st_uid, gid=stat.st_gid,</span><br><span class="line">                                  fsize=stat.st_size, sha=sha, flag_assume_valid=<span class="literal">False</span>,</span><br><span class="line">                                  flag_stage=<span class="literal">False</span>, name=relpath)</span><br><span class="line">            index.entries.append(entry)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Write the index back</span></span><br><span class="line">    index_write(repo, index)</span><br></pre></td></tr></table></figure>

<h3 id="9-4-The-commit-command"><a href="#9-4-The-commit-command" class="headerlink" title="9.4. The commit command"></a>9.4. The commit command</h3><p>现在，我们已经修改了索引并实际暂存了更改，接下来只需要将这些更改转换为一个提交（commit）。这正是 <code>commit</code> 命令的作用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">argsp = argsubparsers.add_parser(<span class="string">&quot;commit&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;Record changes to the repository.&quot;</span>)</span><br><span class="line"></span><br><span class="line">argsp.add_argument(<span class="string">&quot;-m&quot;</span>,</span><br><span class="line">                   metavar=<span class="string">&quot;message&quot;</span>,</span><br><span class="line">                   dest=<span class="string">&quot;message&quot;</span>,</span><br><span class="line">                   <span class="built_in">help</span>=<span class="string">&quot;Message to associate with this commit.&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>为了做到这一点，我们首先需要将索引转换为一个树对象，生成并存储相应的提交对象，并将 HEAD 分支更新为新的提交（记住：分支仅仅是对提交的引用）。</p>
<p>在进入有趣的细节之前，我们需要读取 Git 的配置，以获取用户的姓名，并将其用作作者和提交者的名字。我们将使用与读取仓库配置时相同的 <code>configparser</code> 库。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gitconfig_read</span>():</span><br><span class="line">    xdg_config_home = os.environ[<span class="string">&quot;XDG_CONFIG_HOME&quot;</span>] <span class="keyword">if</span> <span class="string">&quot;XDG_CONFIG_HOME&quot;</span> <span class="keyword">in</span> os.environ <span class="keyword">else</span> <span class="string">&quot;~/.config&quot;</span></span><br><span class="line">    configfiles = [</span><br><span class="line">        os.path.expanduser(os.path.join(xdg_config_home, <span class="string">&quot;git/config&quot;</span>)),</span><br><span class="line">        os.path.expanduser(<span class="string">&quot;~/.gitconfig&quot;</span>)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    config = configparser.ConfigParser()</span><br><span class="line">    config.read(configfiles)</span><br><span class="line">    <span class="keyword">return</span> config</span><br></pre></td></tr></table></figure>

<p>以及一个简单的函数来获取并格式化用户身份：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gitconfig_user_get</span>(<span class="params">config</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;user&quot;</span> <span class="keyword">in</span> config:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;name&quot;</span> <span class="keyword">in</span> config[<span class="string">&quot;user&quot;</span>] <span class="keyword">and</span> <span class="string">&quot;email&quot;</span> <span class="keyword">in</span> config[<span class="string">&quot;user&quot;</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;config[<span class="string">&#x27;user&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]&#125;</span> &lt;<span class="subst">&#123;config[<span class="string">&#x27;user&#x27;</span>][<span class="string">&#x27;email&#x27;</span>]&#125;</span>&gt;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>现在是有趣的部分。我们首先需要根据索引构建一个树对象。这并不难，但需要注意的是，虽然索引是扁平的（它存储了工作区中所有文件的完整路径），而树是递归结构：它列出了文件或其他树。为了将索引“解扁平”成树，我们将按照以下步骤进行：</p>
<ol>
<li><strong>构建目录字典（哈希映射）</strong>：键是从工作区根目录开始的完整路径（例如 <code>assets/sprites/monsters/</code>），值是包含在该目录中的 <code>GitIndexEntry</code> 对象的列表。此时，字典仅包含文件：目录仅作为其键存在。</li>
<li><strong>遍历目录列表，按照从最深的目录到根目录的顺序进行</strong>：即从最深的目录开始，逐步向上遍历。这意味着我们将按完整路径的长度对目录进行排序，从最长的路径到最短的路径（父目录的路径显然总是比子目录短）。举个例子，假设我们从 <code>assets/sprites/monsters/</code> 开始：<ul>
<li>对于 <code>assets/sprites/monsters/</code>，我们创建一个树对象，包含 <code>cacodemon.png</code>、<code>imp.png</code> 和 <code>baron-of-hell.png</code>。</li>
<li>我们将新创建的树写入仓库，并将该树添加到父目录中。也就是说，此时 <code>assets/sprites/</code> 中将包含该树对象的 SHA-1 ID，树的名称为 <code>monsters</code>。</li>
</ul>
</li>
<li><strong>继续迭代下一个目录</strong>：比如我们到 <code>assets/sprites/keys</code>，在其中找到 <code>red.png</code>、<code>blue.png</code> 和 <code>yellow.png</code>，创建树、存储树、将树的 SHA-1 添加到 <code>assets/sprites/</code> 中，依此类推。</li>
</ol>
<p>最终，通过这个过程，我们将索引中的文件和目录重新组织成一个树结构，并能够将其保存为一个 Git 树对象。</p>
<p>因为树是递归的，所以我们最后构建的树，必定是根目录的树（因为它的键的长度为 0），它最终会引用所有其他的树，因此它将是我们需要的唯一一棵树。我们只需返回它的 SHA-1，就可以完成。</p>
<p>由于这个过程可能看起来有点复杂，让我们通过一个完整的示例来详细演示——如果你愿意，随时可以跳过。最初，我们从索引中构建的字典看起来是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">contents[&quot;assets/sprites/monsters&quot;] =</span><br><span class="line">  [ cacodemon.png : GitIndexEntry</span><br><span class="line">  , imp.png : GitIndexEntry</span><br><span class="line">  , baron-of-hell.png : GitIndexEntry ]</span><br><span class="line">contents[&quot;assets/sprites/keys&quot;] =</span><br><span class="line">  [ red.png : GitIndexEntry</span><br><span class="line">  , blue.png : GitIndexEntry</span><br><span class="line">  , yellow.png : GitIndexEntry ]</span><br><span class="line">contents[&quot;assets/sprites/&quot;] =</span><br><span class="line">  [ hero.png : GitIndexEntry ]</span><br><span class="line">contents[&quot;assets/&quot;] = [] # No files in here</span><br><span class="line">contents[&quot;&quot;] = # Root!</span><br><span class="line">  [ README: GitIndexEntry ]</span><br></pre></td></tr></table></figure>

<p>我们按键长度降序遍历它。我们遇到的第一个键是最长的，也就是 <code>assets/sprites/monsters</code>。我们从它的内容构建一个新的树对象，将三个文件名（<code>cacodemon.png</code>、<code>imp.png</code>、<code>baron-of-hell.png</code>）与它们相应的 blob 关联起来（树叶存储的数据比索引少——只是路径、模式和 blob。因此，将条目转换成这种方式很容易）。</p>
<p>请注意，我们不需要关心存储这些文件的内容：<code>wyag add </code>会在需要时创建相应的 blobs。我们需要将我们创建的树存储到对象库中，但可以假设 blobs 已经存在了。</p>
<p>假设我们新创建的树的哈希值，从直接位于 <code>assets/sprites/monsters</code> 中的索引条目生成，哈希值是 <code>426f894781bc3c38f1d26f8fd2c7f38ab8d21763</code>。我们修改字典，将这个新的树对象添加到该目录的父级，就像这样，现在剩下需要遍历的部分看起来是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">contents[&quot;assets/sprites/keys&quot;] = # &lt;- unmodified.</span><br><span class="line">  [ red.png : GitIndexEntry</span><br><span class="line">  , blue.png : GitIndexEntry</span><br><span class="line">  , yellow.png : GitIndexEntry ]</span><br><span class="line">contents[&quot;assets/sprites/&quot;] =</span><br><span class="line">  [ hero.png : GitIndexEntry</span><br><span class="line">  , monsters : Tree 426f894781bc3c38f1d26f8fd2c7f38ab8d21763 ] &lt;- look here</span><br><span class="line">contents[&quot;assets/&quot;] = [] # empty</span><br><span class="line">contents[&quot;&quot;] = # Root!</span><br><span class="line">  [ README: GitIndexEntry ]</span><br></pre></td></tr></table></figure>

<p>我们对下一个最长的键 <code>assets/sprites/keys</code> 做同样的操作，生成一个哈希值为 <code>b42788e087b1e94a0e69dcb7a4a243eaab802bb2 </code>的树，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">contents[&quot;assets/sprites/&quot;] =</span><br><span class="line">  [ hero.png : GitIndexEntry</span><br><span class="line">  ,  monsters : Tree 426f894781bc3c38f1d26f8fd2c7f38ab8d21763</span><br><span class="line">  , keys : Tree b42788e087b1e94a0e69dcb7a4a243eaab802bb2 ]</span><br><span class="line">contents[&quot;assets/&quot;] = [] # empty</span><br><span class="line">contents[&quot;&quot;] = # Root!</span><br><span class="line">  [ README: GitIndexEntry ]</span><br></pre></td></tr></table></figure>

<p>然后，我们从 <code>assets/sprites </code> 生成哈希值为 <code>6364113557ed681d775ccbd3c90895ed276956a2</code> 的树，该树现在包含我们的两个子树和 hero.png 文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">contents[&quot;assets/&quot;] = [</span><br><span class="line">  sprites: Tree 6364113557ed681d775ccbd3c90895ed276956a2 ]</span><br><span class="line">contents[&quot;&quot;] = # Root!</span><br><span class="line">  [ README: GitIndexEntry ]</span><br></pre></td></tr></table></figure>

<p>接着，<code>assets</code> 变成了哈希值为 <code>4d35513cb6d2a816bc00505be926624440ebbddd </code>的树，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contents[&quot;&quot;] = # Root!</span><br><span class="line">  [ README: GitIndexEntry,</span><br><span class="line">    assets: 4d35513cb6d2a816bc00505be926624440ebbddd]</span><br></pre></td></tr></table></figure>

<p>我们从最后一个键（包含 README blob 和 <code>assets</code> 子树）创建一个树，哈希值为 <code>9352e52ff58fa9bf5a750f090af64c09fa6a3d93</code>。这就是我们的返回值：包含与索引内容相同的树。</p>
<p>这是实际的函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tree_from_index</span>(<span class="params">repo, index</span>):</span><br><span class="line">    contents = <span class="built_in">dict</span>()</span><br><span class="line">    contents[<span class="string">&quot;&quot;</span>] = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Enumerate entries, and turn them into a dictionary where keys</span></span><br><span class="line">    <span class="comment"># are directories, and values are lists of directory contents.</span></span><br><span class="line">    <span class="keyword">for</span> entry <span class="keyword">in</span> index.entries:</span><br><span class="line">        dirname = os.path.dirname(entry.name)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># We create all dictonary entries up to root (&quot;&quot;).  We need</span></span><br><span class="line">        <span class="comment"># them *all*, because even if a directory holds no files it</span></span><br><span class="line">        <span class="comment"># will contain at least a tree.</span></span><br><span class="line">        key = dirname</span><br><span class="line">        <span class="keyword">while</span> key != <span class="string">&quot;&quot;</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> key <span class="keyword">in</span> contents:</span><br><span class="line">                contents[key] = <span class="built_in">list</span>()</span><br><span class="line">            key = os.path.dirname(key)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># For now, simply store the entry in the list.</span></span><br><span class="line">        contents[dirname].append(entry)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Get keys (= directories) and sort them by length, descending.</span></span><br><span class="line">    <span class="comment"># This means that we&#x27;ll always encounter a given path before its</span></span><br><span class="line">    <span class="comment"># parent, which is all we need, since for each directory D we&#x27;ll</span></span><br><span class="line">    <span class="comment"># need to modify its parent P to add D&#x27;s tree.</span></span><br><span class="line">    sorted_paths = <span class="built_in">sorted</span>(contents.keys(), key=<span class="built_in">len</span>, reverse=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># This variable will store the current tree&#x27;s SHA-1.  After we&#x27;re</span></span><br><span class="line">    <span class="comment"># done iterating over our dict, it will contain the hash for the</span></span><br><span class="line">    <span class="comment"># root tree.</span></span><br><span class="line">    sha = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># We ge through the sorted list of paths (dict keys)</span></span><br><span class="line">    <span class="keyword">for</span> path <span class="keyword">in</span> sorted_paths:</span><br><span class="line">        <span class="comment"># Prepare a new, empty tree object</span></span><br><span class="line">        tree = GitTree()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Add each entry to our new tree, in turn</span></span><br><span class="line">        <span class="keyword">for</span> entry <span class="keyword">in</span> contents[path]:</span><br><span class="line">            <span class="comment"># An entry can be a normal GitIndexEntry read from the</span></span><br><span class="line">            <span class="comment"># index, or a tree we&#x27;ve created.</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(entry, GitIndexEntry): <span class="comment"># Regular entry (a file)</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># We transcode the mode: the entry stores it as integers,</span></span><br><span class="line">                <span class="comment"># we need an octal ASCII representation for the tree.</span></span><br><span class="line">                leaf_mode = <span class="string">f&quot;<span class="subst">&#123;entry.mode_type:02o&#125;</span><span class="subst">&#123;entry.mode_perms:04o&#125;</span>&quot;</span>.encode(<span class="string">&quot;ascii&quot;</span>)</span><br><span class="line">                leaf = GitTreeLeaf(mode = leaf_mode, path=os.path.basename(entry.name), sha=entry.sha)</span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># Tree.  We&#x27;ve stored it as a pair: (basename, SHA)</span></span><br><span class="line">                leaf = GitTreeLeaf(mode = <span class="string">b&quot;040000&quot;</span>, path=entry[<span class="number">0</span>], sha=entry[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">            tree.items.append(leaf)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Write the new tree object to the store.</span></span><br><span class="line">        sha = object_write(tree, repo)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Add the new tree hash to the current dictionary&#x27;s parent, as</span></span><br><span class="line">        <span class="comment"># a pair (basename, SHA)</span></span><br><span class="line">        parent = os.path.dirname(path)</span><br><span class="line">        base = os.path.basename(path) <span class="comment"># The name without the path, eg main.go for src/main.go</span></span><br><span class="line">        contents[parent].append((base, sha))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sha</span><br></pre></td></tr></table></figure>

<p>这部分是最难的；希望讲解足够清楚。从这里开始，创建提交对象并更新 HEAD 就会简单得多。请记住，这个函数的作用是构建并存储尽可能多的树对象，以表示索引的状态，并返回根树的 SHA-1 哈希值。</p>
<p>创建提交对象的函数非常简单，它只需要几个参数：树的哈希值、父提交的哈希值、作者身份（字符串）、时间戳和时区偏移量，以及提交消息：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">commit_create</span>(<span class="params">repo, tree, parent, author, timestamp, message</span>):</span><br><span class="line">    commit = GitCommit() <span class="comment"># Create the new commit object.</span></span><br><span class="line">    commit.kvlm[<span class="string">b&quot;tree&quot;</span>] = tree.encode(<span class="string">&quot;ascii&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> parent:</span><br><span class="line">        commit.kvlm[<span class="string">b&quot;parent&quot;</span>] = parent.encode(<span class="string">&quot;ascii&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Trim message and add a trailing \n</span></span><br><span class="line">    message = message.strip() + <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="comment"># Format timezone</span></span><br><span class="line">    offset = <span class="built_in">int</span>(timestamp.astimezone().utcoffset().total_seconds())</span><br><span class="line">    hours = offset // <span class="number">3600</span></span><br><span class="line">    minutes = (offset % <span class="number">3600</span>) // <span class="number">60</span></span><br><span class="line">    tz = <span class="string">&quot;&#123;&#125;&#123;:02&#125;&#123;:02&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;+&quot;</span> <span class="keyword">if</span> offset &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="string">&quot;-&quot;</span>, hours, minutes)</span><br><span class="line"></span><br><span class="line">    author = author + timestamp.strftime(<span class="string">&quot; %s &quot;</span>) + tz</span><br><span class="line"></span><br><span class="line">    commit.kvlm[<span class="string">b&quot;author&quot;</span>] = author.encode(<span class="string">&quot;utf8&quot;</span>)</span><br><span class="line">    commit.kvlm[<span class="string">b&quot;committer&quot;</span>] = author.encode(<span class="string">&quot;utf8&quot;</span>)</span><br><span class="line">    commit.kvlm[<span class="literal">None</span>] = message.encode(<span class="string">&quot;utf8&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> object_write(commit, repo)</span><br></pre></td></tr></table></figure>

<p>剩下要编写的就是 <code>cmd_commit</code>，它是 <code>wyag commit</code> 命令的桥接函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cmd_commit</span>(<span class="params">args</span>):</span><br><span class="line">    repo = repo_find()</span><br><span class="line">    index = index_read(repo)</span><br><span class="line">    <span class="comment"># Create trees, grab back SHA for the root tree.</span></span><br><span class="line">    tree = tree_from_index(repo, index)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Create the commit object itself</span></span><br><span class="line">    commit = commit_create(repo,</span><br><span class="line">                           tree,</span><br><span class="line">                           object_find(repo, <span class="string">&quot;HEAD&quot;</span>),</span><br><span class="line">                           gitconfig_user_get(gitconfig_read()),</span><br><span class="line">                           datetime.now(),</span><br><span class="line">                           args.message)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Update HEAD so our commit is now the tip of the active branch.</span></span><br><span class="line">    active_branch = branch_get_active(repo)</span><br><span class="line">    <span class="keyword">if</span> active_branch: <span class="comment"># If we&#x27;re on a branch, we update refs/heads/BRANCH</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(repo_file(repo, os.path.join(<span class="string">&quot;refs/heads&quot;</span>, active_branch)), <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> fd:</span><br><span class="line">            fd.write(commit + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>: <span class="comment"># Otherwise, we update HEAD itself.</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(repo_file(repo, <span class="string">&quot;HEAD&quot;</span>), <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> fd:</span><br><span class="line">            fd.write(<span class="string">&quot;\n&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>And we’re done!</p>
<h2 id="10-Final-words"><a href="#10-Final-words" class="headerlink" title="10. Final words"></a>10. Final words</h2><h3 id="10-1-Comments-feedback-and-issues"><a href="#10-1-Comments-feedback-and-issues" class="headerlink" title="10.1. Comments, feedback and issues"></a>10.1. Comments, feedback and issues</h3><p>此页面没有评论系统 :) 您可以通过电子邮件联系我：<a href="thibault@thb.lt">thibault@thb.lt</a>。我也可以在 Mastodon 上找到，用户名是 <a target="_blank" rel="noopener" href="https://toad.social/@thblt">@thblt@toad.social</a>，或者在 Twitter 上 <a target="_blank" rel="noopener" href="https://x.com/ThbPlg">@ThbPlg</a>，有时也会出现在 Libera 的 IRC 频道，昵称是 <code>thblt</code>。</p>
<p>本文的源码托管在 <a target="_blank" rel="noopener" href="https://github.com/thblt/write-yourself-a-git">GitHub</a> 上。欢迎通过 GitHub 直接提交问题报告和拉取请求，或者如果您愿意，也可以通过电子邮件与我联系。</p>
<h3 id="10-2-License"><a href="#10-2-License" class="headerlink" title="10.2. License"></a>10.2. License</h3><p>本文在创作共用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">BY-NC-SA 4.0 许可协议</a> 下发布。程序本身也根据 GNU 通用公共许可证 3.0 版，或根据您的选择，任何该许可证的后续版本进行许可。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="1-l33t-h4x0r"><a href="#1-l33t-h4x0r" class="headerlink" title="1. l33t h4x0r"></a>1. l33t h4x0r</h3><p><strong>“l33t h4x0r”</strong> 是一种 <strong>黑客文化（hacker culture）</strong> 里的 <strong>Leetspeak（精英语）</strong> 表达方式，它的原意是 **”leet hacker”**，即 <strong>elite hacker（精英黑客）</strong>。</p>
<p>在 Leetspeak 里：</p>
<ul>
<li><strong>l33t</strong> &#x3D; <strong>leet</strong>（elite 的变形，意为“精英”）</li>
<li><strong>h4x0r</strong> &#x3D; <strong>hacker</strong>（haxor 是 hacker 的变体，”4” 代替 “a”，”0” 代替 “o”）</li>
</ul>
<p>这个词通常用来形容那些技术高超的黑客（有时也带有一点戏谑或自嘲的意味），或者用来调侃那些<strong>自认为是黑客</strong>但实际上技术并不高的人。</p>
<h3 id="2-code-1"><a href="#2-code-1" class="headerlink" title="2. code 1"></a>2. code 1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> libwyag</span><br><span class="line">libwyag.main()</span><br></pre></td></tr></table></figure>

<p>这段代码是 <strong>wyag</strong> 可执行文件的内容。我们可以逐行解释：</p>
<ol>
<li><p><code>#!/usr/bin/env python3</code><br>这一行是 <strong>shebang</strong>（或称作 hashbang），它告诉操作系统应该使用哪个解释器来运行这个文件。在这里，它指定了 <strong>python3</strong> 作为解释器，并使用 <code>env</code> 命令来确保使用系统中可用的 Python 3 版本。</p>
</li>
<li><p><code>import libwyag</code><br>这行代码导入了我们之前提到的 <strong>libwyag.py</strong> 库文件，这个文件包含了实际的逻辑和功能。导入后，<strong>wyag</strong> 可以调用库中的函数和类。</p>
</li>
<li><p><code>libwyag.main()</code><br>这一行调用了 <strong>libwyag.py</strong> 中的 <code>main()</code> 函数。通常，<code>main()</code> 函数是程序的入口点，它会处理主要的任务和逻辑。在这里，它可能会启动执行 Git 核心命令的相关功能。</p>
</li>
</ol>
</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.jpg" alt="Rossignol"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Rossignol</p><p class="is-size-6 is-block">NaN</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Mars</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives/"><p class="title">24</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories/"><p class="title">15</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags/"><p class="title">16</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/0xRossignol" target="_blank" rel="me noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/0xRossignol"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Golang/"><span class="level-start"><span class="level-item">Golang</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/Golang/basics/"><span class="level-start"><span class="level-item">basics</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/Java/basics/"><span class="level-start"><span class="level-item">basics</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/Java/basics/Thinking-in-Java/"><span class="level-start"><span class="level-item">Thinking in Java</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/Linux/Arch-Linux/"><span class="level-start"><span class="level-item">Arch Linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/OS/"><span class="level-start"><span class="level-item">OS</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Software-Construction/"><span class="level-start"><span class="level-item">Software Construction</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul><li><a class="level is-mobile" href="/categories/Software-Construction/MIT6-031/"><span class="level-start"><span class="level-item">MIT6.031</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/TypeScript/"><span class="level-start"><span class="level-item">TypeScript</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/test/"><span class="level-start"><span class="level-item">test</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/toy-projects/"><span class="level-start"><span class="level-item">toy projects</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%85%AB%E8%82%A1/"><span class="level-start"><span class="level-item">八股</span></span><span class="level-end"><span class="level-item tag">4</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%85%AB%E8%82%A1/JavaSE/"><span class="level-start"><span class="level-item">JavaSE</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-04-06T14:45:19.961Z">2025-04-06</time></p><p class="title"><a href="/2025/04/06/%E5%85%AB%E8%82%A1/Java/IO/IO%20%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-04-06T14:45:19.961Z">2025-04-06</time></p><p class="title"><a href="/2025/04/06/%E5%85%AB%E8%82%A1/Java/IO/IO%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-04-06T14:45:19.961Z">2025-04-06</time></p><p class="title"><a href="/2025/04/06/%E5%85%AB%E8%82%A1/Java/IO/NIO%20%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-04-06T14:45:06.006Z">2025-04-06</time></p><p class="title"><a href="/2025/04/06/%E5%85%AB%E8%82%A1/Java/IO/IO%20%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-04-06T13:55:29.000Z">2025-04-06</time></p><p class="title"><a href="/2025/04/06/%E5%85%AB%E8%82%A1/Java/Java%E5%9F%BA%E7%A1%80/JavaSE%20pt.3/">JavaSE pt.3</a></p><p class="categories"><a href="/categories/%E5%85%AB%E8%82%A1/">八股</a> / <a href="/categories/%E5%85%AB%E8%82%A1/JavaSE/">JavaSE</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2025/04/"><span class="level-start"><span class="level-item">四月 2025</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/03/"><span class="level-start"><span class="level-item">三月 2025</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/02/"><span class="level-start"><span class="level-item">二月 2025</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/01/"><span class="level-start"><span class="level-item">一月 2025</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/12/"><span class="level-start"><span class="level-item">十二月 2024</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Arch-Linux/"><span class="tag">Arch Linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/English/"><span class="tag">English</span><span class="tag">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Golang/"><span class="tag">Golang</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OS/"><span class="tag">OS</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Software-Construction/"><span class="tag">Software Construction</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TypeScript/"><span class="tag">TypeScript</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/git/"><span class="tag">git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/python/"><span class="tag">python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/test/"><span class="tag">test</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/toy-projects/"><span class="tag">toy projects</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%B8%AD%E6%96%87/"><span class="tag">中文</span><span class="tag">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%85%AB%E8%82%A1/"><span class="tag">八股</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B1%87%E7%BC%96/"><span class="tag">汇编</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BF%BB%E8%AF%91/"><span class="tag">翻译</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="MyBlog" height="28"></a><p class="is-size-7"><span>&copy; 2025 Rossignol</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>