<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>标签: Rust - MyBlog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="MyBlog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="MyBlog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="MyBlog"><meta property="og:url" content="http://example.com/"><meta property="og:site_name" content="MyBlog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:author" content="Rossignol"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"MyBlog","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"Rossignol"},"publisher":{"@type":"Organization","name":"MyBlog","logo":{"@type":"ImageObject","url":"http://example.com/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="MyBlog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/0xRossignol"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags/">标签</a></li><li class="is-active"><a href="#" aria-current="page">Rust</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-06-01T12:30:26.000Z" title="2025/6/1 20:30:26">2025-06-01</time>发表</span><span class="level-item"><time dateTime="2025-06-01T12:54:53.628Z" title="2025/6/1 20:54:53">2025-06-01</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Rust/">Rust</a><span> / </span><a class="link-muted" href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></span><span class="level-item">16 分钟读完 (大约2449个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/06/01/Rust/The%20Rust%20Programming%20Language/12.5%20%E5%A4%84%E7%90%86%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/">12.5 处理环境变量</a></p><div class="content"><h2 id="处理环境变量"><a href="#处理环境变量" class="headerlink" title="处理环境变量"></a>处理环境变量</h2><p>我们将增加一个额外的功能来改进 <code>minigrep</code>：用户可以通过设置环境变量来设置搜索是否是大小写敏感的选项。当然，我们也可以将其设计为一个命令行参数并要求用户每次需要时都加上它，不过在这里我们将使用环境变量。这允许用户设置环境变量一次之后在整个终端会话中所有的搜索都将是大小写不敏感的。</p>
<h3 id="编写一个大小写不敏感-search-函数的失败测试"><a href="#编写一个大小写不敏感-search-函数的失败测试" class="headerlink" title="编写一个大小写不敏感 search 函数的失败测试"></a>编写一个大小写不敏感 <code>search</code> 函数的失败测试</h3><p>首先我们希望增加一个新函数 <code>search_case_insensitive</code>，并将会在环境变量有值时调用它。这里将继续遵循 TDD 过程，其第一步是再次编写一个失败测试。我们将为新的大小写不敏感搜索函数新增一个测试函数，并将老的测试函数从 <code>one_result</code> 改名为 <code>case_sensitive</code> 来更清楚的表明这两个测试的区别，如示例 12-20 所示：</p>
<p>文件名：src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">case_sensitive</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">query</span> = <span class="string">&quot;duct&quot;</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">contents</span> = <span class="string">&quot;\</span></span><br><span class="line"><span class="string">Rust:</span></span><br><span class="line"><span class="string">safe, fast, productive.</span></span><br><span class="line"><span class="string">Pick three.</span></span><br><span class="line"><span class="string">Duct tape.&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="built_in">vec!</span>[<span class="string">&quot;safe, fast, productive.&quot;</span>], <span class="title function_ invoke__">search</span>(query, contents));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">case_insensitive</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">query</span> = <span class="string">&quot;rUsT&quot;</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">contents</span> = <span class="string">&quot;\</span></span><br><span class="line"><span class="string">Rust:</span></span><br><span class="line"><span class="string">safe, fast, productive.</span></span><br><span class="line"><span class="string">Pick three.</span></span><br><span class="line"><span class="string">Trust me.&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert_eq!</span>(</span><br><span class="line">            <span class="built_in">vec!</span>[<span class="string">&quot;Rust:&quot;</span>, <span class="string">&quot;Trust me.&quot;</span>],</span><br><span class="line">            <span class="title function_ invoke__">search_case_insensitive</span>(query, contents)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 12-20：为准备添加的大小写不敏感函数新增失败测试</p>
<p>注意我们也改变了老测试中 <code>contents</code> 的值。还新增了一个含有文本 <code>&quot;Duct tape.&quot;</code> 的行，它有一个大写的 D，这在大小写敏感搜索时不应该匹配 <code>&quot;duct&quot;</code>。我们修改这个测试以确保不会意外破坏已经实现的大小写敏感搜索功能；这个测试现在应该能通过并在处理大小写不敏感搜索时应该能一直通过。</p>
<p>大小写<strong>不敏感</strong>搜索的新测试使用 <code>&quot;rUsT&quot;</code> 作为其查询字符串。在我们将要增加的 <code>search_case_insensitive</code> 函数中，<code>&quot;rUsT&quot;</code> 查询应该包含带有一个大写 R 的 <code>&quot;Rust:&quot;</code> 还有 <code>&quot;Trust me.&quot;</code> 这两行，即便它们与查询的大小写都不同。这个测试现在不能编译，因为还没有定义 <code>search_case_insensitive</code> 函数。请随意增加一个总是返回空 vector 的骨架实现，正如示例 12-16 中 <code>search</code> 函数为了使测试通过编译并失败时所做的那样。</p>
<h3 id="实现-search-case-insensitive-函数"><a href="#实现-search-case-insensitive-函数" class="headerlink" title="实现 search_case_insensitive 函数"></a>实现 <code>search_case_insensitive</code> 函数</h3><p><code>search_case_insensitive</code> 函数，如示例 12-21 所示，将与 <code>search</code> 函数基本相同。唯一的区别是它会将 <code>query</code> 变量和每一 <code>line</code> 都变为小写，这样不管输入参数是大写还是小写，在检查该行是否包含查询字符串时都会是小写。</p>
<p>文件名：src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">search_case_insensitive</span>&lt;<span class="string">&#x27;a&gt;(</span></span><br><span class="line"><span class="string">    query: &amp;str,</span></span><br><span class="line"><span class="string">    contents: &amp;&#x27;</span>a <span class="type">str</span>,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="string">&#x27;a str&gt; &#123;</span></span><br><span class="line"><span class="string">    let query = query.to_lowercase();</span></span><br><span class="line"><span class="string">    let mut results = Vec::new();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    for line in contents.lines() &#123;</span></span><br><span class="line"><span class="string">        if line.to_lowercase().contains(&amp;query) &#123;</span></span><br><span class="line"><span class="string">            results.push(line);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    results</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>示例 12-21：定义 <code>search_case_insensitive</code> 函数，它在比较查询和每一行之前将它们都转换为小写</p>
<p>首先我们将 <code>query</code> 字符串转换为小写，并将其覆盖到同名的变量中，遮蔽原来的 <code>query</code>。对查询字符串调用 <code>to_lowercase</code> 是必需的，这样不管用户的查询是 <code>&quot;rust&quot;</code>、<code>&quot;RUST&quot;</code>、<code>&quot;Rust&quot;</code> 或者 <code>&quot;rUsT&quot;</code>，我们都将其当作 <code>&quot;rust&quot;</code> 处理并对大小写不敏感。虽然 <code>to_lowercase</code> 可以处理基本的 Unicode，但它不是 100% 准确。如果编写真实的程序的话，我们还需多做一些工作，不过这一部分是关于环境变量而不是 Unicode 的，所以这样就够了。</p>
<p>注意 <code>query</code> 现在是一个 <code>String</code> 而不是字符串 slice，因为调用 <code>to_lowercase</code> 是在创建新数据，而不是引用现有数据。如果查询字符串是 <code>&quot;rUsT&quot;</code>，这个字符串 slice 并不包含可供我们使用的小写的 <code>u</code> 或 <code>t</code>，所以必需分配一个包含 <code>&quot;rust&quot;</code> 的新 <code>String</code>。现在当我们将 <code>query</code> 作为一个参数传递给 <code>contains</code> 方法时，需要增加一个 &amp; 因为 <code>contains</code> 的签名被定义为获取一个字符串 slice。</p>
<p>接下来我们对每一 <code>line</code> 都调用 <code>to_lowercase</code> 将其转为小写。现在我们将 <code>line</code> 和 <code>query</code> 都转换成了小写，这样就可以不管查询的大小写进行匹配了。</p>
<p>让我们看看这个实现能否通过测试：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo <span class="built_in">test</span></span></span><br><span class="line">   Compiling minigrep v0.1.0 (file:///projects/minigrep)</span><br><span class="line">    Finished `test` profile [unoptimized + debuginfo] target(s) in 1.33s</span><br><span class="line">     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)</span><br><span class="line"></span><br><span class="line">running 2 tests</span><br><span class="line">test tests::case_insensitive ... ok</span><br><span class="line">test tests::case_sensitive ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br><span class="line"></span><br><span class="line">     Running unittests src/main.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)</span><br><span class="line"></span><br><span class="line">running 0 tests</span><br><span class="line"></span><br><span class="line">test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br><span class="line"></span><br><span class="line">   Doc-tests minigrep</span><br><span class="line"></span><br><span class="line">running 0 tests</span><br><span class="line"></span><br><span class="line">test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br></pre></td></tr></table></figure>

<p>太好了！测试都通过了。现在，让我们在 <code>run</code> 函数中实际调用新 <code>search_case_insensitive</code> 函数。首先，我们将在 <code>Config</code> 结构体中增加一个配置项来切换大小写敏感和大小写不敏感搜索。增加这些字段会导致编译错误，因为我们还没有在任何地方初始化这些字段：</p>
<p>文件名：src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> query: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> file_path: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> ignore_case: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里增加了 <code>ignore_case</code> 字段来存放一个布尔值。接着我们需要 <code>run</code> 函数检查 <code>case_sensitive</code> 字段的值并使用它来决定是否调用 <code>search</code> 函数或 <code>search_case_insensitive</code> 函数，如示例 12-22 所示。注意这还不能编译：</p>
<p>文件名：src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run</span>(config: Config) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">contents</span> = fs::<span class="title function_ invoke__">read_to_string</span>(config.file_path)?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">results</span> = <span class="keyword">if</span> config.ignore_case &#123;</span><br><span class="line">        <span class="title function_ invoke__">search_case_insensitive</span>(&amp;config.query, &amp;contents)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">search</span>(&amp;config.query, &amp;contents)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">line</span> <span class="keyword">in</span> results &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;line&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 12-22：根据 <code>config.ignore_case</code> 的值调用 <code>search</code> 或 <code>search_case_insensitive</code></p>
<p>最后需要实际检查环境变量。处理环境变量的函数位于标准库的 <code>env</code> 模块中，所以我们需要在 <em>src&#x2F;lib.rs</em> 的开头将这个模块引入作用域中。接着使用 <code>env</code> 模块的 <code>var</code> 方法来检查一个叫做 <code>IGNORE_CASE</code> 的环境变量，如示例 12-23 所示：</p>
<p>文件名：src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"><span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">build</span>(args: &amp;[<span class="type">String</span>]) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Config, &amp;<span class="string">&#x27;static str&gt; &#123;</span></span><br><span class="line"><span class="string">        if args.len() &lt; 3 &#123;</span></span><br><span class="line"><span class="string">            return Err(&quot;not enough arguments&quot;);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        let query = args[1].clone();</span></span><br><span class="line"><span class="string">        let file_path = args[2].clone();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        let ignore_case = env::var(&quot;IGNORE_CASE&quot;).is_ok();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Ok(Config &#123;</span></span><br><span class="line"><span class="string">            query,</span></span><br><span class="line"><span class="string">            file_path,</span></span><br><span class="line"><span class="string">            ignore_case,</span></span><br><span class="line"><span class="string">        &#125;)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>示例 12-23：检查叫做 <code>IGNORE_CASE</code> 的环境变量</p>
<p>这里创建了一个新变量 <code>ignore_case</code>。为了设置它的值，需要调用 <code>env::var</code> 函数并传递我们需要寻找的环境变量名称，<code>IGNORE_CASE</code>。<code>env::var</code> 返回一个 <code>Result</code>，它在环境变量被设置时返回包含其值的 <code>Ok</code> 变体，并在环境变量未被设置时返回 <code>Err</code> 变体。</p>
<p>我们使用 <code>Result</code> 的 <code>is_ok</code> 方法来检查环境变量是否被设置，这也就意味着程序应该进行一个大小写不敏感的搜索。如果 <code>IGNORE_CASE</code> 环境变量没有被设置为任何值，<code>is_ok</code> 会返回 <code>false</code> 并将进行大小写敏感的搜索。我们并不关心环境变量所设置的<strong>值</strong>，只关心它是否被设置了，所以检查 <code>is_ok</code> 而不是 <code>unwrap</code>、<code>expect</code> 或任何我们已经见过的 <code>Result</code> 的方法。</p>
<p>我们将变量 <code>ignore_case</code> 的值传递给 <code>Config</code> 实例，这样 <code>run</code> 函数可以读取其值并决定是否调用示例 12-22 中实现的 <code>search_case_insensitive</code> 或者 <code>search</code>。</p>
<p>让我们试一试吧！首先不设置环境变量并使用查询 <code>to</code> 运行程序，这应该会匹配任何全小写的单词 “to” 的行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run -- to poem.txt</span></span><br><span class="line">   Compiling minigrep v0.1.0 (file:///projects/minigrep)</span><br><span class="line">    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s</span><br><span class="line">     Running `target/debug/minigrep to poem.txt`</span><br><span class="line">Are you nobody, too?</span><br><span class="line">How dreary to be somebody!</span><br></pre></td></tr></table></figure>

<p>看起来程序仍然能够工作！现在将 <code>IGNORE_CASE</code> 设置为 <code>1</code> 并仍使用相同的查询 <em>to</em> 来运行程序：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">IGNORE_CASE=1 cargo run -- to poem.txt</span></span><br></pre></td></tr></table></figure>

<p>如果你使用 PowerShell，则需要用两个命令来分别设置环境变量并运行程序：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">PS&gt; </span><span class="language-bash"><span class="variable">$Env</span>:IGNORE_CASE=1; cargo run -- to poem.txt</span></span><br></pre></td></tr></table></figure>

<p>而这会让 <code>IGNORE_CASE</code> 的效果在当前 shell 会话中持续生效。可以通过 <code>Remove-Item</code> cmdlet 来取消设置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">PS&gt; </span><span class="language-bash">Remove-Item Env:IGNORE_CASE</span></span><br></pre></td></tr></table></figure>

<p>这回应该得到包含可能有大写字母的 <em>to</em> 的行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Are you nobody, too?</span><br><span class="line">How dreary to be somebody!</span><br><span class="line">To tell your name the livelong day</span><br><span class="line">To an admiring bog!</span><br></pre></td></tr></table></figure>

<p>好极了，我们也得到了包含 <em>to</em> 的行！现在 <code>minigrep</code> 程序可以通过环境变量控制进行大小写不敏感搜索了。现在你知道了如何管理由命令行参数或环境变量设置的选项了！</p>
<p>一些程序允许对相同配置同时使用参数<strong>和</strong>环境变量。在这种情况下，程序来决定参数和环境变量的优先级。作为一个留给你的测试，尝试通过一个命令行参数或一个环境变量来控制大小写敏感搜索。并在运行程序时遇到矛盾值时决定命令行参数和环境变量的优先级。</p>
<p><code>std::env</code> 模块还包含了更多处理环境变量的实用功能；请查看其文档来了解其可用的功能。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-06-01T11:50:26.000Z" title="2025/6/1 19:50:26">2025-06-01</time>发表</span><span class="level-item"><time dateTime="2025-06-01T12:31:42.195Z" title="2025/6/1 20:31:42">2025-06-01</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Rust/">Rust</a><span> / </span><a class="link-muted" href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></span><span class="level-item">19 分钟读完 (大约2900个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/06/01/Rust/The%20Rust%20Programming%20Language/12.4%20%E9%87%87%E7%94%A8%E6%B5%8B%E8%AF%95%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%AE%8C%E5%96%84%E5%BA%93%E7%9A%84%E5%8A%9F%E8%83%BD/">12.4 采用测试驱动开发完善库的功能</a></p><div class="content"><h2 id="采用测试驱动开发完善库的功能"><a href="#采用测试驱动开发完善库的功能" class="headerlink" title="采用测试驱动开发完善库的功能"></a>采用测试驱动开发完善库的功能</h2><p>现在我们将逻辑提取到了 <em>src&#x2F;lib.rs</em> 并将所有的参数解析和错误处理留在了 <em>src&#x2F;main.rs</em> 中，为代码的核心功能编写测试将更加容易。我们可以直接使用多种参数调用函数并检查返回值而无需从命令行运行二进制文件了。</p>
<p>在这一部分，我们将遵循测试驱动开发（Test Driven Development, TDD）的模式来逐步增加 <code>minigrep</code> 的搜索逻辑。它遵循如下步骤：</p>
<ol>
<li>编写一个失败的测试，并运行它以确保它失败的原因是你所期望的。</li>
<li>编写或修改足够的代码来使新的测试通过。</li>
<li>重构刚刚增加或修改的代码，并确保测试仍然能通过。</li>
<li>从步骤 1 开始重复！</li>
</ol>
<p>虽然这只是众多编写软件的方法之一，不过 TDD 有助于驱动代码的设计。在编写能使测试通过的代码之前编写测试有助于在开发过程中保持高测试覆盖率。</p>
<p>我们将测试驱动实现实际在文件内容中搜索查询字符串并返回匹配的行示例的功能。我们将在一个叫做 <code>search</code> 的函数中增加这些功能。</p>
<h3 id="编写失败测试"><a href="#编写失败测试" class="headerlink" title="编写失败测试"></a>编写失败测试</h3><p>去掉 <em>src&#x2F;lib.rs</em> 和 <em>src&#x2F;main.rs</em> 中用于检查程序行为的 <code>println!</code> 语句，因为不再真正需要它们了。接着我们会像[第十一章](.&#x2F;11.1 如何编写测试)那样增加一个 <code>test</code> 模块和一个测试函数。测试函数指定了 <code>search</code> 函数期望拥有的行为：它会获取一个需要查询的字符串和用来查询的文本，并只会返回包含请求的文本行。示例 12-15 展示了这个测试，它还不能编译：</p>
<p>文件名：src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">one_result</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">query</span> = <span class="string">&quot;duct&quot;</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">contents</span> = <span class="string">&quot;\</span></span><br><span class="line"><span class="string">Rust:</span></span><br><span class="line"><span class="string">safe, fast, productive.</span></span><br><span class="line"><span class="string">Pick three.&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="built_in">vec!</span>[<span class="string">&quot;safe, fast, productive.&quot;</span>], <span class="title function_ invoke__">search</span>(query, contents));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 12-15：创建一个我们期望的 <code>search</code> 函数的失败测试</p>
<p>这里选择使用 <code>&quot;duct&quot;</code> 作为这个测试中需要搜索的字符串。用来搜索的文本有三行，其中只有一行包含 <code>&quot;duct&quot;</code>。（注意双引号之后的反斜杠，这告诉 Rust 不要在字符串字面值内容的开头加入换行符）我们断言 <code>search</code> 函数的返回值只包含期望的那一行。</p>
<p>我们还不能运行这个测试并看到它失败，因为它甚至都还不能编译：<code>search</code> 函数还不存在呢！根据 TDD 的原则，我们将增加足够的代码来使其能够编译：一个总是会返回空 vector 的 <code>search</code> 函数定义，如示例 12-16 所示。然后这个测试应该能够编译并因为空 vector 并不匹配一个包含一行 <code>&quot;safe, fast, productive.&quot;</code> 的 vector 而失败。</p>
<p>文件名：src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">search</span>&lt;<span class="string">&#x27;a&gt;(query: &amp;str, contents: &amp;&#x27;</span>a <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="string">&#x27;a str&gt; &#123;</span></span><br><span class="line"><span class="string">    vec![]</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>示例 12-16：刚好足够使测试通过编译的 <code>search</code> 函数定义</p>
<p>注意需要在 <code>search</code> 的签名中定义一个显式生命周期 <code>&#39;a</code> 并用于 <code>contents</code> 参数和返回值。回忆一下[第十章](.&#x2F;10.3 生命周期确保引用有效)中讲到生命周期参数指定哪个参数的生命周期与返回值的生命周期相关联。在这个例子中，我们表明返回的 vector 中应该包含引用参数 <code>contents</code>（而不是参数<code>query</code>）slice 的字符串 slice。</p>
<p>换句话说，我们告诉 Rust 函数 <code>search</code> 返回的数据将与 <code>search</code> 函数中的参数 <code>contents</code> 的数据存在的一样久。这是非常重要的！为了使这个引用有效那么<strong>被</strong> slice 引用的数据也需要保持有效；如果编译器认为我们是在创建 <code>query</code> 而不是 <code>contents</code> 的字符串 slice，那么安全检查将是不正确的。</p>
<p>如果我们忘记添加生命周期注解而尝试编译此函数，就会得到如下错误：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo build</span></span><br><span class="line">   Compiling minigrep v0.1.0 (file:///projects/minigrep)</span><br><span class="line">error[E0106]: missing lifetime specifier</span><br><span class="line"><span class="meta prompt_">  --&gt; </span><span class="language-bash">src/lib.rs:28:51</span></span><br><span class="line">   |</span><br><span class="line">28 | pub fn search(query: &amp;str, contents: &amp;str) -&gt; Vec&lt;&amp;str&gt; &#123;</span><br><span class="line">   |                      ----            ----         ^ expected named lifetime parameter</span><br><span class="line">   |</span><br><span class="line">   = help: this function&#x27;s return type contains a borrowed value, but the signature does not say whether it is borrowed from `query` or `contents`</span><br><span class="line">help: consider introducing a named lifetime parameter</span><br><span class="line">   |</span><br><span class="line">28 | pub fn search&lt;&#x27;a&gt;(query: &amp;&#x27;a str, contents: &amp;&#x27;a str) -&gt; Vec&lt;&amp;&#x27;a str&gt; &#123;</span><br><span class="line">   |              ++++         ++                 ++              ++</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0106`.</span><br><span class="line">error: could not compile `minigrep` (lib) due to 1 previous error</span><br></pre></td></tr></table></figure>

<p>Rust 不可能知道我们需要的是哪一个参数，所以需要显式地告诉它。因为参数 <code>contents</code> 包含了所有的文本而且我们希望返回匹配的那部分文本，所以我们知道 <code>contents</code> 是应该要使用生命周期语法来与返回值相关联的参数。</p>
<p>其他语言中并不需要你在函数签名中将参数与返回值相关联。所以这么做可能仍然感觉有些陌生，随着时间的推移这将会变得越来越容易。你可能想要将这个例子与第十章中[“生命周期确保引用有效”](.&#x2F;10.3 生命周期确保引用有效)部分做对比。</p>
<p>现在运行测试：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo <span class="built_in">test</span></span></span><br><span class="line">   Compiling minigrep v0.1.0 (file:///projects/minigrep)</span><br><span class="line">    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.97s</span><br><span class="line">     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)</span><br><span class="line"></span><br><span class="line">running 1 test</span><br><span class="line">test tests::one_result ... FAILED</span><br><span class="line"></span><br><span class="line">failures:</span><br><span class="line"></span><br><span class="line">---- tests::one_result stdout ----</span><br><span class="line"></span><br><span class="line">thread &#x27;tests::one_result&#x27; panicked at src/lib.rs:44:9:</span><br><span class="line">assertion `left == right` failed</span><br><span class="line">  left: [&quot;safe, fast, productive.&quot;]</span><br><span class="line"> right: []</span><br><span class="line">note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">failures:</span><br><span class="line">    tests::one_result</span><br><span class="line"></span><br><span class="line">test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br><span class="line"></span><br><span class="line">error: test failed, to rerun pass `--lib`</span><br></pre></td></tr></table></figure>

<p>很好，测试失败了，这正是我们所期望的。修改代码来让测试通过吧！</p>
<h3 id="编写使测试通过的代码"><a href="#编写使测试通过的代码" class="headerlink" title="编写使测试通过的代码"></a>编写使测试通过的代码</h3><p>目前测试之所以会失败是因为我们总是返回一个空的 vector。为了修复并实现 <code>search</code>，我们的程序需要遵循如下步骤：</p>
<ol>
<li>遍历内容的每一行文本。</li>
<li>查看这一行是否包含要搜索的字符串。</li>
<li>如果有，将这一行加入列表返回值中。</li>
<li>如果没有，什么也不做。</li>
<li>返回匹配到的结果列表。</li>
</ol>
<p>让我们一步一步的来，从遍历每行开始。</p>
<h4 id="使用-lines-方法逐行遍历"><a href="#使用-lines-方法逐行遍历" class="headerlink" title="使用 lines 方法逐行遍历"></a>使用 <code>lines</code> 方法逐行遍历</h4><p>Rust 有一个有助于一行一行遍历字符串的方法，出于方便它被命名为 <code>lines</code>，它如示例 12-17 这样工作。注意这还不能编译：</p>
<p>文件名：src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">search</span>&lt;<span class="string">&#x27;a&gt;(query: &amp;str, contents: &amp;&#x27;</span>a <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="string">&#x27;a str&gt; &#123;</span></span><br><span class="line"><span class="string">    for line in contents.lines() &#123;</span></span><br><span class="line"><span class="string">        // do something with line</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>示例 12-17：遍历 <code>contents</code> 的每一行</p>
<p><code>lines</code> 方法返回一个迭代器。[第十三章](.&#x2F;13.2 使用迭代器处理元素序列)会深入了解迭代器，不过我们已经在[示例 3-5](.&#x2F;03.5 控制流) 中见过使用迭代器的方法了，在那里使用了一个 <code>for</code> 循环和迭代器在一个集合的每一项上运行了一些代码。</p>
<h4 id="用查询字符串搜索每一行"><a href="#用查询字符串搜索每一行" class="headerlink" title="用查询字符串搜索每一行"></a>用查询字符串搜索每一行</h4><p>接下来将会增加检查当前行是否包含查询字符串的功能。幸运的是，字符串类型为此也有一个叫做 <code>contains</code> 的实用方法！如示例 12-18 所示在 <code>search</code> 函数中加入 <code>contains</code> 方法调用。注意这仍然不能编译：</p>
<p>文件名：src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">search</span>&lt;<span class="string">&#x27;a&gt;(query: &amp;str, contents: &amp;&#x27;</span>a <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="string">&#x27;a str&gt; &#123;</span></span><br><span class="line"><span class="string">    for line in contents.lines() &#123;</span></span><br><span class="line"><span class="string">        if line.contains(query) &#123;</span></span><br><span class="line"><span class="string">            // 对文本行进行操作</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>示例 12-18：增加检查文本行是否包含 <code>query</code> 中字符串的功能</p>
<p>目前，我们正在构建功能。为了让代码能够编译，需要从函数体返回一个我们在函数签名中所声明的值。</p>
<h4 id="存储匹配的行"><a href="#存储匹配的行" class="headerlink" title="存储匹配的行"></a>存储匹配的行</h4><p>为了完成这个函数，我们需要一种方法来存储要返回的匹配行。为此可以在 <code>for</code> 循环之前创建一个可变的 vector 并调用 <code>push</code> 方法在 vector 中存放一个 <code>line</code>。在 <code>for</code> 循环之后，返回这个 vector，如示例 12-19 所示：</p>
<p>文件名：src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">search</span>&lt;<span class="string">&#x27;a&gt;(query: &amp;str, contents: &amp;&#x27;</span>a <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="string">&#x27;a str&gt; &#123;</span></span><br><span class="line"><span class="string">    let mut results = Vec::new();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    for line in contents.lines() &#123;</span></span><br><span class="line"><span class="string">        if line.contains(query) &#123;</span></span><br><span class="line"><span class="string">            results.push(line);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    results</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>示例 12-19：储存匹配的行以便可以返回它们</p>
<p>现在 <code>search</code> 函数应该返回只包含 <code>query</code> 的那些行，而测试应该会通过。让我们运行测试：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo <span class="built_in">test</span></span></span><br><span class="line">   Compiling minigrep v0.1.0 (file:///projects/minigrep)</span><br><span class="line">    Finished `test` profile [unoptimized + debuginfo] target(s) in 1.22s</span><br><span class="line">     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)</span><br><span class="line"></span><br><span class="line">running 1 test</span><br><span class="line">test tests::one_result ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br><span class="line"></span><br><span class="line">     Running unittests src/main.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)</span><br><span class="line"></span><br><span class="line">running 0 tests</span><br><span class="line"></span><br><span class="line">test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br><span class="line"></span><br><span class="line">   Doc-tests minigrep</span><br><span class="line"></span><br><span class="line">running 0 tests</span><br><span class="line"></span><br><span class="line">test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br></pre></td></tr></table></figure>

<p>测试通过了，我们知道它可以工作了！</p>
<p>现在正是可以考虑重构的时机，在保证测试通过，保持功能不变的前提下重构 <code>search</code> 函数。<code>search</code> 函数中的代码并不坏，不过并没有利用迭代器的一些实用功能。第十三章将回到这个例子并深入探索迭代器并看看如何改进代码。</p>
<h4 id="在-run-函数中使用-search-函数"><a href="#在-run-函数中使用-search-函数" class="headerlink" title="在 run 函数中使用 search 函数"></a>在 <code>run</code> 函数中使用 <code>search</code> 函数</h4><p>现在 <code>search</code> 函数是可以工作并测试通过了的，我们需要实际在 <code>run</code> 函数中调用 <code>search</code>。需要将 <code>config.query</code> 值和 <code>run</code> 从文件中读取的 <code>contents</code> 传递给 <code>search</code> 函数。接着 <code>run</code> 会打印出 <code>search</code> 返回的每一行：</p>
<p>文件名：src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run</span>(config: Config) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">contents</span> = fs::<span class="title function_ invoke__">read_to_string</span>(config.file_path)?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">line</span> <span class="keyword">in</span> <span class="title function_ invoke__">search</span>(&amp;config.query, &amp;contents) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;line&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里仍然使用了 <code>for</code> 循环获取了 <code>search</code> 返回的每一行并打印出来。</p>
<p>现在整个程序应该可以工作了！让我们试一试，首先使用一个只会在艾米莉·狄金森的诗中返回一行的单词 “frog”：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run -- frog poem.txt</span></span><br><span class="line">   Compiling minigrep v0.1.0 (file:///projects/minigrep)</span><br><span class="line">    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.38s</span><br><span class="line">     Running `target/debug/minigrep frog poem.txt`</span><br><span class="line">How public, like a frog</span><br></pre></td></tr></table></figure>

<p>不错！现在试试一个会匹配多行的单词，比如 “body”：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run -- body poem.txt</span></span><br><span class="line">   Compiling minigrep v0.1.0 (file:///projects/minigrep)</span><br><span class="line">    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s</span><br><span class="line">     Running `target/debug/minigrep body poem.txt`</span><br><span class="line">I&#x27;m nobody! Who are you?</span><br><span class="line">Are you nobody, too?</span><br><span class="line">How dreary to be somebody!</span><br></pre></td></tr></table></figure>

<p>最后，让我们确保搜索一个在诗中哪里都没有的单词时不会得到任何行，比如 <em>monomorphization</em>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run -- monomorphization poem.txt</span></span><br><span class="line">   Compiling minigrep v0.1.0 (file:///projects/minigrep)</span><br><span class="line">    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s</span><br><span class="line">     Running `target/debug/minigrep monomorphization poem.txt`</span><br></pre></td></tr></table></figure>

<p>非常好！我们创建了一个属于自己的迷你版经典工具，并学习了很多如何组织程序的知识。我们还学习了一些文件输入输出、生命周期、测试和命令行解析的内容。</p>
<p>为了使这个项目更丰满，我们将简要的展示如何处理环境变量和打印到标准错误，这两者在编写命令行程序时都很有用。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-06-01T11:35:26.000Z" title="2025/6/1 19:35:26">2025-06-01</time>发表</span><span class="level-item"><time dateTime="2025-06-01T12:14:56.534Z" title="2025/6/1 20:14:56">2025-06-01</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Rust/">Rust</a><span> / </span><a class="link-muted" href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></span><span class="level-item">42 分钟读完 (大约6232个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/06/01/Rust/The%20Rust%20Programming%20Language/12.3%20%E9%87%8D%E6%9E%84%E6%94%B9%E8%BF%9B%E6%A8%A1%E5%9D%97%E6%80%A7%E5%92%8C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/">12.3 重构改进模块性和错误处理</a></p><div class="content"><h2 id="重构改进模块性和错误处理"><a href="#重构改进模块性和错误处理" class="headerlink" title="重构改进模块性和错误处理"></a>重构改进模块性和错误处理</h2><p>为了改善我们的程序这里有四个问题需要修复，而且它们都与程序的组织方式和如何处理潜在错误有关。第一，<code>main</code> 现在进行了两个任务：它解析了参数并打开了文件。然而随着 <code>main</code> 中的功能持续增加，<code>main</code> 函数处理的独立任务也会增加。当函数承担了更多责任，它就更难以推导，更难以测试，并且更难以在不破坏其他部分的情况下做出修改。最好能分离出功能以便每个函数各司其职。</p>
<p>这同时也关系到第二个问题：<code>query</code> 和 <code>file_path</code> 是程序中的配置变量，而像 <code>contents</code> 则用来执行程序逻辑。随着 <code>main</code> 函数的增长，就需要引入更多的变量到作用域中，而当作用域中有更多的变量时，将更难以追踪每个变量的目的。最好能将配置变量组织进一个结构，这样就能使它们的目的更明确了。</p>
<p>第三个问题是如果打开文件失败时我们使用 <code>expect</code> 来打印出错误信息，不过这个错误信息只是说 <code>Should have been able to read the file</code>。读取文件失败的原因有多种：例如文件可能不存在，或者没有打开此文件的权限。目前，无论哪种情况，都会显示相同的错误信息，无法为用户提供任何有用的线索！</p>
<p>第四，我们也使用 <code>expect</code> 来处理参数错误，如果用户没有指定足够的参数来运行程序，他们会从 Rust 得到 <code>index out of bounds</code> 错误，而这并不能明确地解释问题。如果所有的错误处理都位于一处，这样将来的维护者在需要修改错误处理逻辑时就只需要考虑这一处代码。将所有的错误处理都放在一处也有助于确保我们打印的错误信息对终端用户来说是有意义的。</p>
<p>让我们通过重构项目来解决这四个问题。</p>
<h3 id="二进制项目的关注分离"><a href="#二进制项目的关注分离" class="headerlink" title="二进制项目的关注分离"></a>二进制项目的关注分离</h3><p><code>main</code> 函数负责多个任务的组织问题在许多二进制项目中很常见。所以 Rust 社区开发出一类在 <code>main</code> 函数开始变得庞大时进行二进制程序的关注分离的指南。这些过程包括如下步骤：</p>
<ul>
<li><p>将程序拆分成 <em>main.rs</em> 和 <em>lib.rs</em> 并将程序的逻辑放入 <em>lib.rs</em> 中。</p>
</li>
<li><p>当命令行解析逻辑比较小时，可以保留在 <em>main.rs</em> 中。</p>
</li>
<li><p>当命令行解析开始变得复杂时，也同样将其从 <em>main.rs</em> 提取到 <em>lib.rs</em> 中。</p>
</li>
</ul>
<p>经过这些过程之后保留在 <code>main</code> 函数中的责任应该被限制为：</p>
<ul>
<li>使用参数值调用命令行解析逻辑</li>
<li>设置任何其他的配置</li>
<li>调用 <em>lib.rs</em> 中的 <code>run</code> 函数</li>
<li>如果 <code>run</code> 返回错误，则进行错误处理</li>
</ul>
<p>这个模式的一切就是为了关注分离：<em>main.rs</em> 处理程序运行，而 <em>lib.rs</em> 处理所有的真正的任务逻辑。因为不能直接测试 <code>main</code> 函数，这个结构通过将所有的程序逻辑移动到 <em>lib.rs</em> 的函数中使得我们可以测试它们。仅仅保留在 <em>main.rs</em> 中的代码将足够小以便阅读就可以验证其正确性。让我们遵循这些步骤来重构程序。</p>
<h4 id="提取参数解析器"><a href="#提取参数解析器" class="headerlink" title="提取参数解析器"></a>提取参数解析器</h4><p>首先，我们将解析参数的功能提取到一个 <code>main</code> 将会调用的函数中，为将命令行解析逻辑移动到 <em>src&#x2F;lib.rs</em> 中做准备。示例 12-5 中展示了新 <code>main</code> 函数的开头，它调用了新函数 <code>parse_config</code>。目前它仍将定义在 <em>src&#x2F;main.rs</em> 中：</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (query, file_path) = <span class="title function_ invoke__">parse_config</span>(&amp;args);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">parse_config</span>(args: &amp;[<span class="type">String</span>]) <span class="punctuation">-&gt;</span> (&amp;<span class="type">str</span>, &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">query</span> = &amp;args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">file_path</span> = &amp;args[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    (query, file_path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 12-5：从 <code>main</code> 中提取出 <code>parse_config</code> 函数</p>
<p>我们仍然将命令行参数收集进一个 vector，不过不同于在 <code>main</code> 函数中将索引 1 的参数值赋值给变量 <code>query</code> 和将索引 2 的值赋值给变量 <code>file_path</code>，我们将整个 vector 传递给 <code>parse_config</code> 函数。接着 <code>parse_config</code> 函数将包含决定哪个参数该放入哪个变量的逻辑，并将这些值返回到 <code>main</code>。我们仍然在 <code>main</code> 中创建变量 <code>query</code> 和 <code>file_path</code>，不过 <code>main</code> 不再负责处理命令行参数与变量如何对应。</p>
<p>这对重构我们这小程序可能有点大材小用，不过我们将采用小的、增量的步骤进行重构。在做出这些改变之后，再次运行程序并验证参数解析是否仍然正常。经常验证你的进展是一个好习惯，这样在遇到问题时能帮助你定位问题的成因。</p>
<h3 id="组合配置值"><a href="#组合配置值" class="headerlink" title="组合配置值"></a>组合配置值</h3><p>我们可以采取另一个小的步骤来进一步改善 <code>parse_config</code> 函数。现在函数返回一个元组，不过立刻又将元组拆成了独立的部分。这是一个我们可能没有进行正确抽象的信号。</p>
<p>另一个表明还有改进空间的迹象是 <code>parse_config</code> 名称的 <code>config</code> 部分，它暗示了我们返回的两个值是相关的并都是一个配置值的一部分。目前除了将这两个值组合进元组之外并没有表达这个数据结构的意义；相反我们可以将这两个值放入一个结构体并给每个字段一个有意义的名字。这会让未来的维护者更容易理解不同的值如何相互关联以及它们的目的。</p>
<p>示例 12-6 展示了 <code>parse_config</code> 函数的改进。</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span> = <span class="title function_ invoke__">parse_config</span>(&amp;args);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Searching for &#123;&#125;&quot;</span>, config.query);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;In file &#123;&#125;&quot;</span>, config.file_path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">contents</span> = fs::<span class="title function_ invoke__">read_to_string</span>(config.file_path)</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Should have been able to read the file&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    query: <span class="type">String</span>,</span><br><span class="line">    file_path: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">parse_config</span>(args: &amp;[<span class="type">String</span>]) <span class="punctuation">-&gt;</span> Config &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">query</span> = args[<span class="number">1</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">file_path</span> = args[<span class="number">2</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line"></span><br><span class="line">    Config &#123; query, file_path &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 12-6：重构 <code>parse_config</code> 返回一个 <code>Config</code> 结构体实例</p>
<p>我们添加了一个名为 <code>Config</code> 的结构体，其中包含 <code>query</code> 和 <code>file_path</code> 字段。<code>parse_config</code> 的签名表明它现在返回一个 <code>Config</code> 值。在之前的 <code>parse_config</code> 函数体中，我们返回了引用 <code>args</code> 中 <code>String</code> 值的字符串 slice，现在我们定义 <code>Config</code> 来包含拥有所有权的 <code>String</code> 值。<code>main</code> 中的 <code>args</code> 变量是参数值的所有者并只允许 <code>parse_config</code> 函数借用它们，这意味着如果 <code>Config</code> 尝试获取 <code>args</code> 中值的所有权将违反 Rust 的借用规则。</p>
<p>还有许多不同的方式可以处理 <code>String</code> 的数据，而最简单但有些不太高效的方式是调用这些值的 <code>clone</code> 方法。这会生成 <code>Config</code> 实例可以拥有的数据的完整拷贝，不过会比储存字符串数据的引用消耗更多的时间和内存。不过拷贝数据使得代码显得更加直白因为无需管理引用的生命周期，所以在这种情况下牺牲一小部分性能来换取简洁性的取舍是值得的。</p>
<blockquote>
<h4 id="使用-clone-的权衡取舍"><a href="#使用-clone-的权衡取舍" class="headerlink" title="使用 clone 的权衡取舍"></a>使用 <code>clone</code> 的权衡取舍</h4><p>由于其运行时消耗，许多 Rustacean 之间有一个趋势是倾向于避免使用 <code>clone</code> 来解决所有权问题。在关于迭代器的第十三章中，我们将会学习如何更有效率的处理这种情况，不过现在，复制一些字符串来取得进展是没有问题的，因为只会进行一次这样的拷贝，而且文件路径和要搜索的字符串都比较短。在第一轮编写时拥有一个可以工作但有点低效的程序要比尝试过度优化代码更好一些。随着你对 Rust 更加熟练，将能更轻松的直奔合适的方法，不过现在调用 <code>clone</code> 是完全可以接受的。</p>
</blockquote>
<p>我们更新 <code>main</code> 将 <code>parse_config</code> 返回的 <code>Config</code> 实例放入变量 <code>config</code> 中，并将之前分别使用 <code>query</code> 和 <code>file_path</code> 变量的代码更新为现在的使用 <code>Config</code> 结构体的字段的代码。</p>
<p>现在代码更明确的表现了我们的意图，<code>query</code> 和 <code>file_path</code> 是相关联的并且它们的目的是配置程序如何工作。任何使用这些值的代码就知道在 <code>config</code> 实例中对应目的的字段名中寻找它们。</p>
<h3 id="创建-Config-的构造函数"><a href="#创建-Config-的构造函数" class="headerlink" title="创建 Config 的构造函数"></a>创建 <code>Config</code> 的构造函数</h3><p>目前为止，我们将负责解析命令行参数的逻辑从 <code>main</code> 提取到了 <code>parse_config</code> 函数中，这有助于我们看清值 <code>query</code> 和 <code>file_path</code> 是相互关联的并应该在代码中表现这种关系。接着我们增加了 <code>Config</code> 结构体来描述 <code>query</code> 和 <code>file_path</code> 的相关性，并能够从 <code>parse_config</code> 函数中将这些值的名称作为结构体字段名称返回。</p>
<p>所以现在 <code>parse_config</code> 函数的目的是创建一个 <code>Config</code> 实例，我们可以将 <code>parse_config</code> 从一个普通函数变为一个叫做 <code>new</code> 的与结构体关联的函数。做出这个改变使得代码更符合习惯：可以像标准库中的 <code>String</code> 调用 <code>String::new</code> 来创建一个该类型的实例那样，将 <code>parse_config</code> 变为一个与 <code>Config</code> 关联的 <code>new</code> 函数。示例 12-7 展示了需要做出的修改：</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span> = Config::<span class="title function_ invoke__">new</span>(&amp;args);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(args: &amp;[<span class="type">String</span>]) <span class="punctuation">-&gt;</span> Config &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">query</span> = args[<span class="number">1</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">file_path</span> = args[<span class="number">2</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line"></span><br><span class="line">        Config &#123; query, file_path &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 12-7：将 <code>parse_config</code> 变为 <code>Config::new</code></p>
<p>这里将 <code>main</code> 中调用 <code>parse_config</code> 的地方更新为调用 <code>Config::new</code>。我们将 <code>parse_config</code> 的名字改为 <code>new</code> 并将其移动到 <code>impl</code> 块中，这使得 <code>new</code> 函数与 <code>Config</code> 相关联。再次尝试编译并确保它可以工作。</p>
<h3 id="修复错误处理"><a href="#修复错误处理" class="headerlink" title="修复错误处理"></a>修复错误处理</h3><p>现在我们开始修复错误处理。回忆一下之前提到过如果 <code>args</code> vector 包含少于 3 个项并尝试访问 vector 中索引 <code>1</code> 或索引 <code>2</code> 的值会造成程序 panic。尝试不带任何参数运行程序；这将看起来像这样：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">   Compiling minigrep v0.1.0 (file:///projects/minigrep)</span><br><span class="line">    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s</span><br><span class="line">     Running `target/debug/minigrep`</span><br><span class="line"></span><br><span class="line">thread &#x27;main&#x27; panicked at src/main.rs:27:21:</span><br><span class="line">index out of bounds: the len is 1 but the index is 1</span><br><span class="line">note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace</span><br></pre></td></tr></table></figure>

<p><code>index out of bounds: the len is 1 but the index is 1</code> 是一个面向程序员的错误信息，然而这并不能真正帮助终端用户理解发生了什么和他们应该做什么。现在就让我们修复它吧。</p>
<h4 id="改善错误信息"><a href="#改善错误信息" class="headerlink" title="改善错误信息"></a>改善错误信息</h4><p>在示例 12-8 中，在 <code>new</code> 函数中增加了一个检查在访问索引 <code>1</code> 和 <code>2</code> 之前检查 slice 是否足够长。如果 slice 不够长，程序会打印一个更好的错误信息并 panic：</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --snip--</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">new</span>(args: &amp;[<span class="type">String</span>]) <span class="punctuation">-&gt;</span> Config &#123;</span><br><span class="line">    <span class="keyword">if</span> args.<span class="title function_ invoke__">len</span>() &lt; <span class="number">3</span> &#123;</span><br><span class="line">        <span class="built_in">panic!</span>(<span class="string">&quot;not enough arguments&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br></pre></td></tr></table></figure>

<p>示例 12-8：增加一个参数数量检查</p>
<p>这类似于[示例 9-13 中的 <code>Guess::new</code> 函数](.&#x2F;09.3 要不要 panic!)，那里如果 <code>value</code> 参数超出了有效值的范围就调用 <code>panic!</code>。不同于检查值的范围，这里检查 <code>args</code> 的长度至少是 <code>3</code>，而函数的剩余部分则可以在假设这个条件成立的基础上运行。如果 <code>args</code> 少于 3 个项，则这个条件将为真，并调用 <code>panic!</code> 立即终止程序。</p>
<p>有了 <code>new</code> 中这几行额外的代码，再次不带任何参数运行程序并看看现在错误看起来像什么：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">   Compiling minigrep v0.1.0 (file:///projects/minigrep)</span><br><span class="line">    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s</span><br><span class="line">     Running `target/debug/minigrep`</span><br><span class="line"></span><br><span class="line">thread &#x27;main&#x27; panicked at src/main.rs:26:13:</span><br><span class="line">not enough arguments</span><br><span class="line">note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace</span><br></pre></td></tr></table></figure>

<p>这个输出就更好了：现在有了一个合理的错误信息。然而，还是有一堆额外的信息我们不希望提供给用户。所以在这里使用示例 9-13 中的技术可能不是最好的；正如[第九章](.&#x2F;09.3 要不要 panic!)所讲到的一样，<code>panic!</code> 的调用更趋向于程序上的问题而不是使用上的问题。相反我们可以使用第九章学习的另一个技术 —— 返回一个可以表明成功或错误的 [<code>Result</code>](.&#x2F;09.2 用 Result 处理可恢复的错误)。</p>
<h4 id="返回-Result-而不是调用-panic"><a href="#返回-Result-而不是调用-panic" class="headerlink" title="返回 Result 而不是调用 panic!"></a>返回 <code>Result</code> 而不是调用 <code>panic!</code></h4><p>我们可以选择返回一个 <code>Result</code> 值，它在成功时会包含一个 <code>Config</code> 的实例，而在错误时会描述问题。我们还将把函数名从 <code>new</code> 改为 <code>build</code>，因为许多程序员希望 <code>new</code> 函数永远不会失败。当 <code>Config::new</code> 与 <code>main</code> 交流时，可以使用 <code>Result</code> 类型来表明这里存在问题。接着修改 <code>main</code> 将 <code>Err</code> 成员转换为对用户更友好的错误，而不是 <code>panic!</code> 调用产生的关于 <code>thread &#39;main&#39;</code> 和 <code>RUST_BACKTRACE</code> 的文本。</p>
<p>示例 12-9 展示了为了返回 <code>Result</code> 在 <code>Config::new</code> 的返回值和函数体中所需的改变。注意这还不能编译，直到下一个示例更新了 <code>main</code> 之后。</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">build</span>(args: &amp;[<span class="type">String</span>]) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Config, &amp;<span class="string">&#x27;static str&gt; &#123;</span></span><br><span class="line"><span class="string">        if args.len() &lt; 3 &#123;</span></span><br><span class="line"><span class="string">            return Err(&quot;not enough arguments&quot;);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        let query = args[1].clone();</span></span><br><span class="line"><span class="string">        let file_path = args[2].clone();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Ok(Config &#123; query, file_path &#125;)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>示例 12-9：从 <code>Config::build</code> 中返回 <code>Result</code></p>
<p>现在 <code>build</code> 函数返回一个 <code>Result</code>，在成功时带有一个 <code>Config</code> 实例而在出现错误时总是一个有着 <code>&#39;static</code> 生命周期的字符串字面值。</p>
<p><code>build</code> 函数体中有两处修改：当没有足够参数时不再调用 <code>panic!</code>，而是返回 <code>Err</code> 值。同时我们将 <code>Config</code> 返回值包装进 <code>Ok</code> 成员中。这些修改使得函数符合其新的类型签名。</p>
<p>通过让 <code>Config::build</code> 返回一个 <code>Err</code> 值，这就允许 <code>main</code> 函数处理 <code>build</code> 函数返回的 <code>Result</code> 值并在出现错误的情况更明确的结束进程。</p>
<h4 id="调用-Config-build-并处理错误"><a href="#调用-Config-build-并处理错误" class="headerlink" title="调用 Config::build 并处理错误"></a>调用 <code>Config::build</code> 并处理错误</h4><p>为了处理错误情况并打印一个对用户友好的信息，我们需要像示例 12-10 那样更新 <code>main</code> 函数来处理现在 <code>Config::build</code> 返回的 <code>Result</code>。另外还需要手动实现原先由 <code>panic!</code> 负责的工作，即以非零错误码退出命令行工具的工作。非零的退出状态是一个惯例信号，用来告诉调用程序的进程：该程序以错误状态退出了。</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::process;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span> = Config::<span class="title function_ invoke__">build</span>(&amp;args).<span class="title function_ invoke__">unwrap_or_else</span>(|err| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Problem parsing arguments: &#123;err&#125;&quot;</span>);</span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br></pre></td></tr></table></figure>

<p>示例 12-10：如果新建 <code>Config</code> 失败则使用错误码退出</p>
<p>在上面的示例中，使用了一个之前没有详细说明的方法：<code>unwrap_or_else</code>，它定义于标准库的 <code>Result&lt;T, E&gt;</code> 上。使用 <code>unwrap_or_else</code> 可以进行一些自定义的非 <code>panic!</code> 的错误处理。当 <code>Result</code> 是 <code>Ok</code> 时，这个方法的行为类似于 <code>unwrap</code>：它返回 <code>Ok</code> 内部封装的值。然而，当其值是 <code>Err</code> 时，该方法会调用一个<strong>闭包</strong>（<em>closure</em>），也就是一个我们定义的作为参数传递给 <code>unwrap_or_else</code> 的匿名函数。第十三章会更详细地介绍闭包。现在你需要理解的是 <code>unwrap_or_else</code> 会将 <code>Err</code> 的内部值，也就是示例 12-9 中增加的 <code>not enough arguments</code> 静态字符串的情况，传递给闭包中位于两道竖线间的参数 <code>err</code>。闭包中的代码在其运行时可以使用这个 <code>err</code> 值。</p>
<p>我们新增了一个 <code>use</code> 行来从标准库中导入 <code>process</code>。在错误的情况闭包中将被运行的代码只有两行：我们打印出了 <code>err</code> 值，接着调用了 <code>std::process::exit</code>。<code>process::exit</code> 会立即停止程序并将传递给它的数字作为退出状态码。这类似于示例 12-8 中使用的基于 <code>panic!</code> 的错误处理，除了不会再得到所有的额外输出了。让我们试试：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">   Compiling minigrep v0.1.0 (file:///projects/minigrep)</span><br><span class="line">    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s</span><br><span class="line">     Running `target/debug/minigrep`</span><br><span class="line">Problem parsing arguments: not enough arguments</span><br></pre></td></tr></table></figure>

<p>非常好！现在输出对于用户来说就友好多了。</p>
<h3 id="从-main-提取逻辑"><a href="#从-main-提取逻辑" class="headerlink" title="从 main 提取逻辑"></a>从 <code>main</code> 提取逻辑</h3><p>现在我们完成了配置解析的重构，让我们转向程序的逻辑。正如<a href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%85%B3%E6%B3%A8%E5%88%86%E7%A6%BB">“二进制项目的关注分离”</a>部分所展开的讨论，我们将提取一个叫做 <code>run</code> 的函数来存放目前 <code>main</code> 函数中不属于设置配置或处理错误的所有逻辑。一旦完成这些，<code>main</code> 函数将简明得足以通过观察来验证，而我们将能够为所有其他逻辑编写测试。</p>
<p>示例 12-11 展示了提取出来的 <code>run</code> 函数。目前我们只进行小的增量式的提取函数的改进。我们仍将在 <em>src&#x2F;main.rs</em> 中定义这个函数：</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Searching for &#123;&#125;&quot;</span>, config.query);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;In file &#123;&#125;&quot;</span>, config.file_path);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">run</span>(config);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">run</span>(config: Config) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">contents</span> = fs::<span class="title function_ invoke__">read_to_string</span>(config.file_path)</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Should have been able to read the file&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;With text:\n&#123;contents&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --snip--</span></span><br></pre></td></tr></table></figure>

<p>示例 12-11：提取 <code>run</code> 函数来包含剩余的程序逻辑</p>
<p>现在 <code>run</code> 函数包含了 <code>main</code> 中从读取文件开始的剩余的所有逻辑。<code>run</code> 函数获取一个 <code>Config</code> 实例作为参数。</p>
<h4 id="从-run-函数返回错误"><a href="#从-run-函数返回错误" class="headerlink" title="从 run 函数返回错误"></a>从 <code>run</code> 函数返回错误</h4><p>通过将剩余的逻辑分离进 <code>run</code> 函数中，就可以像示例 12-9 中的 <code>Config::build</code> 那样改进错误处理。不再通过 <code>expect</code> 允许程序 panic，<code>run</code> 函数将会在出错时返回一个 <code>Result&lt;T, E&gt;</code>。这让我们进一步以一种对用户友好的方式将处理错误的逻辑统一到 <code>main</code> 中。示例 12-12 展示了 <code>run</code> 签名和函数体中的改变：</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">run</span>(config: Config) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">contents</span> = fs::<span class="title function_ invoke__">read_to_string</span>(config.file_path)?;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;With text:\n&#123;contents&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 12-12：修改 <code>run</code> 函数返回 <code>Result</code></p>
<p>这里我们做出了三个明显的修改。首先，将 <code>run</code> 函数的返回类型变为 <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code>。之前这个函数返回 unit 类型 <code>()</code>，现在它仍然保持作为 <code>Ok</code> 时的返回值。</p>
<p>对于错误类型，使用 <strong>trait 对象</strong> <code>Box&lt;dyn Error&gt;</code>（在开头使用了 <code>use</code> 语句将 <code>std::error::Error</code> 引入作用域）。第十八章会涉及 trait 对象。目前只需知道 <code>Box&lt;dyn Error&gt;</code> 意味着函数会返回实现了 <code>Error</code> trait 的类型，不过无需指定具体将会返回的值的类型。这提供了在不同的错误场景可能有不同类型的错误返回值的灵活性。这也就是 <code>dyn</code>，它是“动态的”（“dynamic”）的缩写。</p>
<p>第二个改变是去掉了 <code>expect</code> 调用并替换为[第九章](.&#x2F;09.2 用 Result 处理可恢复的错误)讲到的 <code>?</code> 运算符。不同于遇到错误就 <code>panic!</code>，<code>?</code> 会从函数中返回错误值并让调用者来处理它。</p>
<p>第三个修改是现在成功时这个函数会返回一个 <code>Ok</code> 值。因为 <code>run</code> 函数签名中声明成功类型返回值是 <code>()</code>，这意味着需要将 unit 类型值包装进 <code>Ok</code> 值中。<code>Ok(())</code> 一开始看起来有点奇怪，不过这样使用 <code>()</code> 是惯用的做法，表明调用 <code>run</code> 函数只是为了它的副作用；函数并没有返回什么有意义的值。</p>
<p>运行上述代码时，它能够编译通过，但会显示一条警告：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run -- the poem.txt</span></span><br><span class="line">   Compiling minigrep v0.1.0 (file:///projects/minigrep)</span><br><span class="line">warning: unused `Result` that must be used</span><br><span class="line"><span class="meta prompt_">  --&gt; </span><span class="language-bash">src/main.rs:19:5</span></span><br><span class="line">   |</span><br><span class="line">19 |     run(config);</span><br><span class="line">   |     ^^^^^^^^^^^</span><br><span class="line">   |</span><br><span class="line">   = note: this `Result` may be an `Err` variant, which should be handled</span><br><span class="line">   = note: `#[warn(unused_must_use)]` on by default</span><br><span class="line">help: use `let _ = ...` to ignore the resulting value</span><br><span class="line">   |</span><br><span class="line">19 |     let _ = run(config);</span><br><span class="line">   |     +++++++</span><br><span class="line"></span><br><span class="line">warning: `minigrep` (bin &quot;minigrep&quot;) generated 1 warning</span><br><span class="line">    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.71s</span><br><span class="line">     Running `target/debug/minigrep the poem.txt`</span><br><span class="line">Searching for the</span><br><span class="line">In file poem.txt</span><br><span class="line">With text:</span><br><span class="line">I&#x27;m nobody! Who are you?</span><br><span class="line">Are you nobody, too?</span><br><span class="line">Then there&#x27;s a pair of us - don&#x27;t tell!</span><br><span class="line">They&#x27;d banish us, you know.</span><br><span class="line"></span><br><span class="line">How dreary to be somebody!</span><br><span class="line">How public, like a frog</span><br><span class="line">To tell your name the livelong day</span><br><span class="line">To an admiring bog!</span><br></pre></td></tr></table></figure>

<p>Rust 提示我们的代码忽略了 <code>Result</code> 值，它可能表明这里存在一个错误。但我们却没有检查这里是否有一个错误，而编译器提醒我们这里应该有一些错误处理代码！现在就让我们修正这个问题。</p>
<h4 id="在-main-中处理-run-返回的错误"><a href="#在-main-中处理-run-返回的错误" class="headerlink" title="在 main 中处理 run 返回的错误"></a>在 <code>main</code> 中处理 <code>run</code> 返回的错误</h4><p>我们将检查错误并使用类似示例 12-10 中 <code>Config::build</code> 处理错误的技术来处理它们，不过有一些细微的不同：</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Searching for &#123;&#125;&quot;</span>, config.query);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;In file &#123;&#125;&quot;</span>, config.file_path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = <span class="title function_ invoke__">run</span>(config) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Application error: &#123;e&#125;&quot;</span>);</span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用 <code>if let</code> 来检查 <code>run</code> 是否返回一个 <code>Err</code> 值，不同于 <code>unwrap_or_else</code>，并在出错时调用 <code>process::exit(1)</code>。<code>run</code> 并不返回像 <code>Config::build</code> 返回的 <code>Config</code> 实例那样需要 <code>unwrap</code> 的值。因为 <code>run</code> 在成功时返回 <code>()</code>，而我们只关心检测错误，所以并不需要 <code>unwrap_or_else</code> 来返回未封装的值，因为它只会是 <code>()</code>。</p>
<p>不过两个例子中 <code>if let</code> 和 <code>unwrap_or_else</code> 的函数体都一样：打印出错误并退出。</p>
<h3 id="将代码拆分到库-crate"><a href="#将代码拆分到库-crate" class="headerlink" title="将代码拆分到库 crate"></a>将代码拆分到库 crate</h3><p>现在我们的 <code>minigrep</code> 项目看起来好多了！现在我们将要拆分 <em>src&#x2F;main.rs</em> 并将一些代码放入 <em>src&#x2F;lib.rs</em>，这样就能测试它们并拥有一个含有更少功能的 <code>main</code> 函数。</p>
<p>让我们将所有不是 <code>main</code> 函数的代码从 <em>src&#x2F;main.rs</em> 移动到新文件 <em>src&#x2F;lib.rs</em> 中：</p>
<ul>
<li><code>run</code> 函数定义</li>
<li>相关的 <code>use</code> 语句</li>
<li><code>Config</code> 的定义</li>
<li><code>Config::build</code> 函数定义</li>
</ul>
<p>现在 <em>src&#x2F;lib.rs</em> 的内容应该看起来像示例 12-13（为了简洁省略了函数体）。注意直到下一个示例修改完 <em>src&#x2F;main.rs</em> 之后，代码还不能编译。</p>
<p>文件名：src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> query: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> file_path: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">build</span>(args: &amp;[<span class="type">String</span>]) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Config, &amp;<span class="string">&#x27;static str&gt; &#123;</span></span><br><span class="line"><span class="string">        // --snip--</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; &#123;</span></span><br><span class="line"><span class="string">    // --snip--</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>示例 12-13：将 <code>Config</code> 和 <code>run</code> 移动到 <em>src&#x2F;lib.rs</em></p>
<p>这里大量使用了 <code>pub</code> 关键字：在 <code>Config</code>、其字段和其 <code>build</code> 方法，以及 <code>run</code> 函数上。现在我们有了一个拥有可以测试的公有 API 的库 crate 了。</p>
<p>现在需要在 <em>src&#x2F;main.rs</em> 中将移动到 <em>src&#x2F;lib.rs</em> 的代码引入二进制 crate 的作用域中，如示例 12-14 所示：</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"><span class="keyword">use</span> std::process;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> minigrep::Config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = minigrep::<span class="title function_ invoke__">run</span>(config) &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 12-14：将 <code>minigrep</code> crate 引入 <em>src&#x2F;main.rs</em> 的作用域中</p>
<p>我们添加了一行 <code>use minigrep::Config</code>，它将 <code>Config</code> 类型引入作用域，并使用 crate 名称作为 <code>run</code> 函数的前缀。通过这些重构，所有功能应该能够联系在一起并运行了。运行 <code>cargo run</code> 来确保一切都正确的衔接在一起。</p>
<p>呼！我们做了大量的工作，不过我们为将来的成功打下了基础。现在处理错误将更容易，同时代码也更加模块化。从现在开始几乎所有的工作都将在 <em>src&#x2F;lib.rs</em> 中进行。</p>
<p>让我们利用这些新创建的模块的优势来进行一些在旧代码中难以展开的工作，这些工作在新代码中非常容易实现：那就是编写测试！</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-06-01T11:30:26.000Z" title="2025/6/1 19:30:26">2025-06-01</time>发表</span><span class="level-item"><time dateTime="2025-06-01T11:33:33.434Z" title="2025/6/1 19:33:33">2025-06-01</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Rust/">Rust</a><span> / </span><a class="link-muted" href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></span><span class="level-item">5 分钟读完 (大约749个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/06/01/Rust/The%20Rust%20Programming%20Language/12.2%20%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6/">12.2 读取文件</a></p><div class="content"><h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><p>现在我们要增加读取由 <code>file_path</code> 命令行参数指定的文件的功能。首先，需要一个用来测试的示例文件：我们会用一个拥有多行少量文本且有一些重复单词的文件。示例 12-3 是一首艾米莉·狄金森（Emily Dickinson）的诗，它正适合这个工作！在项目根目录创建一个文件 <em>poem.txt</em>，并输入诗 “I’m nobody! Who are you?”：</p>
<p>文件名：poem.txt</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">I&#x27;m nobody! Who are you?</span><br><span class="line">Are you nobody, too?</span><br><span class="line">Then there&#x27;s a pair of us - don&#x27;t tell!</span><br><span class="line">They&#x27;d banish us, you know.</span><br><span class="line"></span><br><span class="line">How dreary to be somebody!</span><br><span class="line">How public, like a frog</span><br><span class="line">To tell your name the livelong day</span><br><span class="line">To an admiring bog!</span><br></pre></td></tr></table></figure>

<p>示例 12-3：艾米莉·狄金森的诗 “I’m nobody! Who are you?”，一个好的测试用例</p>
<p>有了文本后，修改 <em>src&#x2F;main.rs</em> 并增加如示例 12-4 所示的打开文件的代码：</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;In file &#123;file_path&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">contents</span> = fs::<span class="title function_ invoke__">read_to_string</span>(file_path)</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Should have been able to read the file&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;With text:\n&#123;contents&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 12-4：读取第二个参数所指定的文件内容</p>
<p>首先，我们增加了一个 <code>use</code> 语句来引入标准库中的相关部分：我们需要 <code>std::fs</code> 来处理文件。</p>
<p>在 <code>main</code> 中新增了一行语句：<code>fs::read_to_string</code> 接受 <code>file_path</code>，打开文件，接着返回包含其内容的 <code>std::io::Result&lt;String&gt;</code>。</p>
<p>在这些代码之后，我们再次增加了临时的 <code>println!</code> 打印出读取文件之后 <code>contents</code> 的值，这样就可以检查目前为止的程序能否工作。</p>
<p>尝试运行这些代码，随意指定一个字符串作为第一个命令行参数（因为还未实现搜索功能的部分）而将 <em>poem.txt</em> 文件将作为第二个参数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run -- the poem.txt</span></span><br><span class="line">   Compiling minigrep v0.1.0 (file:///projects/minigrep)</span><br><span class="line">    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s</span><br><span class="line">     Running `target/debug/minigrep the poem.txt`</span><br><span class="line">Searching for the</span><br><span class="line">In file poem.txt</span><br><span class="line">With text:</span><br><span class="line">I&#x27;m nobody! Who are you?</span><br><span class="line">Are you nobody, too?</span><br><span class="line">Then there&#x27;s a pair of us - don&#x27;t tell!</span><br><span class="line">They&#x27;d banish us, you know.</span><br><span class="line"></span><br><span class="line">How dreary to be somebody!</span><br><span class="line">How public, like a frog</span><br><span class="line">To tell your name the livelong day</span><br><span class="line">To an admiring bog!</span><br></pre></td></tr></table></figure>

<p>好的！代码读取并打印出了文件的内容。虽然它还有一些瑕疵：此时 <code>main</code> 函数有着多个职能，通常函数只负责一个功能的话会更简洁并易于维护。另一个问题是没有尽可能的处理错误。虽然我们的程序还很小，这些瑕疵并不是什么大问题，不过随着程序功能的丰富，要干净地修复它们就会越来越困难。在开发程序时，及早开始重构是一个良好实践，因为重构少量代码时要容易的多。接下来我们就来进行重构。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-06-01T06:30:26.000Z" title="2025/6/1 14:30:26">2025-06-01</time>发表</span><span class="level-item"><time dateTime="2025-06-01T11:28:13.671Z" title="2025/6/1 19:28:13">2025-06-01</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Rust/">Rust</a><span> / </span><a class="link-muted" href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></span><span class="level-item">10 分钟读完 (大约1550个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/06/01/Rust/The%20Rust%20Programming%20Language/12.1%20%E6%8E%A5%E5%8F%97%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0/">12.1 接受命令行参数</a></p><div class="content"><h2 id="接受命令行参数"><a href="#接受命令行参数" class="headerlink" title="接受命令行参数"></a>接受命令行参数</h2><p>一如既往使用 <code>cargo new</code> 新建一个项目，我们称之为 <code>minigrep</code> 以便与可能已经安装在系统上的 <code>grep</code> 工具相区分。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo new minigrep</span></span><br><span class="line">     Created binary (application) `minigrep` project</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> minigrep</span></span><br></pre></td></tr></table></figure>

<p>第一个任务是让 <code>minigrep</code> 能够接受两个命令行参数：文件路径和要搜索的字符串。也就是说我们希望能够使用 <code>cargo run</code>，两个连字符来表明后面的参数是要传递给程序而不是 <code>cargo</code>，要搜索的字符串和被搜索的文件的路径来运行程序，像这样：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run -- searchstring example-filename.txt</span></span><br></pre></td></tr></table></figure>

<p>现在 <code>cargo new</code> 生成的程序无法处理传递给它的参数。<a target="_blank" rel="noopener" href="https://crates.io/">Crates.io</a> 上有一些现成的库可以帮助我们接受命令行参数，不过我们正在学习这一概念，就让我们自己实现这个功能。</p>
<h3 id="读取参数值"><a href="#读取参数值" class="headerlink" title="读取参数值"></a>读取参数值</h3><p>为了确保 <code>minigrep</code> 能够获取传递给它的命令行参数的值，我们需要一个 Rust 标准库提供的 <code>std::env::args</code> 函数。这个函数返回一个传递给程序的命令行参数的<strong>迭代器</strong>（<em>iterator</em>）。我们会在第十三章全面介绍迭代器。但是现在只需理解迭代器的两个细节：迭代器生成一系列的值，可以在迭代器上调用 <code>collect</code> 方法将其转换为一个集合，比如包含所有迭代器产生元素的 vector。</p>
<p>示例 12-1 中的代码允许 <code>minigrep</code> 程序读取任何传递给它的命令行参数并将其收集到一个 vector 中。</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    dbg!(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 12-1：将命令行参数收集到一个 vector 中并打印出来</p>
<p>首先使用 <code>use</code> 语句来将 <code>std::env</code> 模块引入作用域以便可以使用它的 <code>args</code> 函数。注意 <code>std::env::args</code> 函数被嵌套进了两层模块中。正如[第七章](.&#x2F;07.4 使用 use 关键字将路径引入作用域)讲到的，当所需函数嵌套了多于一层模块时，通常将父模块引入作用域而不是其自身。这便于我们利用 <code>std::env</code> 中的其他函数。这比增加了 <code>use std::env::args;</code> 后仅仅使用 <code>args</code> 调用函数要更明确一些，因为 <code>args</code> 容易被错认成一个定义于当前模块的函数。</p>
<blockquote>
<h3 id="args-函数和无效的-Unicode"><a href="#args-函数和无效的-Unicode" class="headerlink" title="args 函数和无效的 Unicode"></a><code>args</code> 函数和无效的 Unicode</h3><p>注意 <code>std::env::args</code> 在其任何参数包含无效 Unicode 字符时会 panic。如果你需要接受包含无效 Unicode 字符的参数，使用 <code>std::env::args_os</code> 代替。这个函数返回 <code>OsString</code> 值而不是 <code>String</code> 值。这里出于简单考虑使用了 <code>std::env::args</code>，因为 <code>OsString</code> 值每个平台都不一样而且比 <code>String</code> 值处理起来更为复杂。</p>
</blockquote>
<p>在 <code>main</code> 函数的第一行，我们调用了 <code>env::args</code>，并立即使用 <code>collect</code> 来创建了一个包含迭代器所有值的 vector。<code>collect</code> 可以被用来创建很多类型的集合，所以这里显式注明 <code>args</code> 的类型来指定我们需要一个字符串 vector。虽然在 Rust 中我们很少会需要注明类型，然而 <code>collect</code> 是一个经常需要注明类型的函数，因为 Rust 不能推断出你想要什么类型的集合。</p>
<p>最后，我们使用调试宏打印出 vector。让我们先在不传递任何参数的情况下运行一次代码，然后再传入两个参数运行一次：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">   Compiling minigrep v0.1.0 (file:///projects/minigrep)</span><br><span class="line">    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.61s</span><br><span class="line">     Running `target/debug/minigrep`</span><br><span class="line">[src/main.rs:5:5] args = [</span><br><span class="line">    &quot;target/debug/minigrep&quot;,</span><br><span class="line">]</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run -- needle haystack</span></span><br><span class="line">   Compiling minigrep v0.1.0 (file:///projects/minigrep)</span><br><span class="line">    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.57s</span><br><span class="line">     Running `target/debug/minigrep needle haystack`</span><br><span class="line">[src/main.rs:5:5] args = [</span><br><span class="line">    &quot;target/debug/minigrep&quot;,</span><br><span class="line">    &quot;needle&quot;,</span><br><span class="line">    &quot;haystack&quot;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>注意 vector 的第一个值是 <code>&quot;target/debug/minigrep&quot;</code>，它是我们二进制文件的名称。这与 C 中的参数列表的行为相匹配，让程序使用在执行时调用它们的名称。如果要在消息中打印它或者根据用于调用程序的命令行别名更改程序的行为，通常可以方便地访问程序名称，不过考虑到本章的目的，我们将忽略它并只保存所需的两个参数。</p>
<h3 id="将参数值保存进变量"><a href="#将参数值保存进变量" class="headerlink" title="将参数值保存进变量"></a>将参数值保存进变量</h3><p>目前程序可以访问指定为命令行参数的值。现在需要将这两个参数的值保存进变量这样就可以在程序的余下部分使用这些值了。让我们如示例 12-2 这样做：</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">query</span> = &amp;args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">file_path</span> = &amp;args[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Searching for &#123;query&#125;&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;In file &#123;file_path&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 12-2：创建变量来存放查询参数和文件路径参数</p>
<p>正如之前打印出 vector 时所看到的，程序的名称占据了 vector 的第一个值 <code>args[0]</code>，所以我们从索引为 <code>1</code> 的参数开始。<code>minigrep</code> 获取的第一个参数是需要搜索的字符串，所以将第一个参数的引用存放在变量 <code>query</code> 中。第二个参数将是文件路径，所以将第二个参数的引用放入变量 <code>file_path</code> 中。</p>
<p>我们将临时打印出这些变量的值来证明代码如我们期望的那样工作。使用参数 <code>test</code> 和 <code>sample.txt</code> 再次运行这个程序：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run -- <span class="built_in">test</span> sample.txt</span></span><br><span class="line">   Compiling minigrep v0.1.0 (file:///projects/minigrep)</span><br><span class="line">    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s</span><br><span class="line">     Running `target/debug/minigrep test sample.txt`</span><br><span class="line">Searching for test</span><br><span class="line">In file sample.txt</span><br></pre></td></tr></table></figure>

<p>太好了，程序正常工作！我们将所需的参数值保存进了对应的变量中。之后会增加一些错误处理来应对类似用户没有提供参数的情况。不过现在我们将忽略它们并开始增加读取文件功能。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-05-31T07:10:26.000Z" title="2025/5/31 15:10:26">2025-05-31</time>发表</span><span class="level-item"><time dateTime="2025-05-31T09:16:34.159Z" title="2025/5/31 17:16:34">2025-05-31</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Rust/">Rust</a><span> / </span><a class="link-muted" href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></span><span class="level-item">24 分钟读完 (大约3534个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/05/31/Rust/The%20Rust%20Programming%20Language/11.3%20%E6%B5%8B%E8%AF%95%E7%9A%84%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84/">11.3 测试的组织结构</a></p><div class="content"><h2 id="测试的组织结构"><a href="#测试的组织结构" class="headerlink" title="测试的组织结构"></a>测试的组织结构</h2><p>本章一开始就提到，测试是一个复杂的概念，而且不同的开发者也采用不同的术语和组织。Rust 社区倾向于根据测试的两个主要分类来考虑问题：<strong>单元测试</strong>（<em>unit tests</em>）与<strong>集成测试</strong>（<em>integration tests</em>）。单元测试倾向于更小而更集中，在隔离的环境中一次测试一个模块，并且可以测试私有接口。而<strong>集成测试</strong>对于你的库来说则完全是外部的。它们与其他外部代码一样，通过相同的方式使用你的代码，只测试公有接口而且每个测试都有可能会测试多个模块。</p>
<p>为了保证你的库能够按照你的预期运行，从独立和整体的角度编写这两类测试都是非常重要的。</p>
<h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>单元测试的目的是在与其他部分隔离的环境中测试每一个单元的代码，以便于快速而准确地验证某个单元的代码功能是否符合预期。单元测试与它们要测试的代码共同存放在位于 <em>src</em> 目录下相同的文件中。规范是在每个文件中创建包含测试函数的 <code>tests</code> 模块，并使用 <code>cfg(test)</code> 标注模块。</p>
<h4 id="测试模块和-cfg-test"><a href="#测试模块和-cfg-test" class="headerlink" title="测试模块和 #[cfg(test)\]"></a>测试模块和 <code>#[cfg(test)\]</code></h4><p>测试模块的 <code>#[cfg(test)]</code> 注解告诉 Rust 只在执行 <code>cargo test</code> 时才编译和运行测试代码，而在运行 <code>cargo build</code> 时不这么做。这在只希望构建库的时候可以节省编译时间，并且因为它们并没有包含测试，所以能减少编译产生的文件的大小。与之对应的集成测试因为位于另一个文件夹，所以它们并不需要 <code>#[cfg(test)]</code> 注解。然而单元测试位于与源码相同的文件中，所以你需要使用 <code>#[cfg(test)]</code> 来指定它们不应该被包含进编译结果中。</p>
<p>回忆本章第一部分新建的 <code>adder</code> 项目，Cargo 为我们生成了如下代码：</p>
<p>文件名：src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add</span>(left: <span class="type">u64</span>, right: <span class="type">u64</span>) <span class="punctuation">-&gt;</span> <span class="type">u64</span> &#123;</span><br><span class="line">    left + right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">it_works</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">add</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">assert_eq!</span>(result, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码就是自动生成的测试模块。<code>cfg</code> 属性代表<strong>配置</strong>（<em>configuration</em>），它告诉 Rust 接下来的项只有在给定特定配置选项时，才会被包含。在这种情况下，配置选项是 <code>test</code>，即 Rust 所提供的用于编译和运行测试的配置选项。通过使用 <code>cfg</code> 属性，Cargo 只会在我们主动使用 <code>cargo test</code> 运行测试时才编译测试代码。这包括测试模块中可能存在的辅助函数，以及标注为 <code>#[test]</code> 的函数。</p>
<h4 id="测试私有函数"><a href="#测试私有函数" class="headerlink" title="测试私有函数"></a>测试私有函数</h4><p>测试社区中一直存在关于是否应该对私有函数直接进行测试的论战，而在其他语言中想要测试私有函数是一件困难的，甚至是不可能的事。不过无论你坚持哪种测试意识形态，Rust 的私有性规则确实允许你测试私有函数。考虑示例 11-12 中带有私有函数 <code>internal_adder</code> 的代码。</p>
<p>文件名：src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_two</span>(a: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">internal_adder</span>(a, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">internal_adder</span>(left: <span class="type">usize</span>, right: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    left + right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">internal</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">internal_adder</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">assert_eq!</span>(result, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 11-12：测试私有函数</p>
<p>注意 <code>internal_adder</code> 函数并没有标记为 <code>pub</code>。测试也不过是 Rust 代码，同时 <code>tests</code> 也仅仅是另一个模块。正如[“路径用于引用模块树中的项”](.&#x2F;07.3 引用模块项目的路径) 部分所说，子模块的项可以使用其上级模块的项。在测试中，我们通过 <code>use super::*</code> 将 <code>tests</code> 模块的父模块的所有项引入了作用域，接着测试调用了 <code>internal_adder</code>。如果你并不认为应该测试私有函数，Rust 也不会强迫你这么做。</p>
<h3 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h3><p>在 Rust 中，集成测试对于你需要测试的库来说完全是外部的。同其他使用库的代码一样使用库文件，也就是说它们只能调用一部分库中的公有 API。集成测试的目的是测试库的多个部分能否一起正常工作。一些单独能正确运行的代码单元集成在一起也可能会出现问题，所以集成测试的覆盖率也是很重要的。为了创建集成测试，你需要先创建一个 <em>tests</em> 目录。</p>
<h4 id="tests-目录"><a href="#tests-目录" class="headerlink" title="tests 目录"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch11-03-test-organization.html#tests-%E7%9B%AE%E5%BD%95"><em>tests</em> 目录</a></h4><p>为了编写集成测试，需要在项目根目录创建一个 <em>tests</em> 目录，与 <em>src</em> 同级。Cargo 知道如何去寻找这个目录中的集成测试文件。接着可以随意在这个目录中创建任意多的测试文件，Cargo 会将每一个文件当作单独的 crate 来编译。</p>
<p>让我们来创建一个集成测试。保留示例 11-12 中 <em>src&#x2F;lib.rs</em> 的代码。创建一个 <em>tests</em> 目录，新建一个文件 <em>tests&#x2F;integration_test.rs</em>。目录结构应该看起来像这样：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">adder</span><br><span class="line">├── Cargo.lock</span><br><span class="line">├── Cargo.toml</span><br><span class="line">├── src</span><br><span class="line">│   └── lib.rs</span><br><span class="line">└── tests</span><br><span class="line">    └── integration_test.rs</span><br></pre></td></tr></table></figure>

<p>将示例 11-13 中的代码输入到 <em>tests&#x2F;integration_test.rs</em> 文件中。</p>
<p>文件名：tests&#x2F;integration_test.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> adder::add_two;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">it_adds_two</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">add_two</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(result, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 11-13：一个 <code>adder</code> crate 中函数的集成测试</p>
<p>因为每一个 <em>tests</em> 目录中的测试文件都是完全独立的 crate，所以需要将库引入到每个测试 crate 的作用域中。为此与单元测试不同，我们需要在文件顶部添加 <code>use adder::add_two;</code>，这在单元测试中是不需要的。</p>
<p>并不需要将 <em>tests&#x2F;integration_test.rs</em> 中的任何代码标注为 <code>#[cfg(test)]</code>。 <code>tests</code> 文件夹在 Cargo 中是一个特殊的文件夹，Cargo 只会在运行 <code>cargo test</code> 时编译这个目录中的文件。现在就运行 <code>cargo test</code> 试试：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo <span class="built_in">test</span></span></span><br><span class="line">   Compiling adder v0.1.0 (file:///projects/adder)</span><br><span class="line">    Finished `test` profile [unoptimized + debuginfo] target(s) in 1.31s</span><br><span class="line">     Running unittests src/lib.rs (target/debug/deps/adder-1082c4b063a8fbe6)</span><br><span class="line"></span><br><span class="line">running 1 test</span><br><span class="line">test tests::internal ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br><span class="line"></span><br><span class="line">     Running tests/integration_test.rs (target/debug/deps/integration_test-1082c4b063a8fbe6)</span><br><span class="line"></span><br><span class="line">running 1 test</span><br><span class="line">test it_adds_two ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br><span class="line"></span><br><span class="line">   Doc-tests adder</span><br><span class="line"></span><br><span class="line">running 0 tests</span><br><span class="line"></span><br><span class="line">test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br></pre></td></tr></table></figure>

<p>现在有了三个部分的输出：单元测试、集成测试和文档测试。注意如果一个部分的任何测试失败，之后的部分都不会运行。例如如果一个单元测试失败，则不会有任何集成测试和文档测试的输出，因为这些测试只会在所有单元测试都通过后才会执行。</p>
<p>第一部分单元测试与我们之前见过的一样：每个单元测试一行（示例 11-12 中有一个叫做 <code>internal</code> 的测试），接着是一个单元测试的摘要行。</p>
<p>集成测试部分以行 <code>Running tests/integration_test.rs</code>开头。接下来每一行是一个集成测试中的测试函数，以及一个位于 <code>Doc-tests adder</code> 部分之前的集成测试的摘要行。</p>
<p>每一个集成测试文件有对应的测试结果部分，所以如果在 <em>tests</em> 目录中增加更多文件，测试结果中就会有更多集成测试结果部分。</p>
<p>我们仍然可以通过指定测试函数的名称作为 <code>cargo test</code> 的参数来运行特定集成测试。也可以使用 <code>cargo test</code> 的 <code>--test</code> 后跟文件的名称来运行某个特定集成测试文件中的所有测试：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo <span class="built_in">test</span> --<span class="built_in">test</span> integration_test</span></span><br><span class="line">   Compiling adder v0.1.0 (file:///projects/adder)</span><br><span class="line">    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.64s</span><br><span class="line">     Running tests/integration_test.rs (target/debug/deps/integration_test-82e7799c1bc62298)</span><br><span class="line"></span><br><span class="line">running 1 test</span><br><span class="line">test it_adds_two ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br></pre></td></tr></table></figure>

<p>这个命令只运行 <em>tests&#x2F;integration_test.rs</em> 文件中的测试。</p>
<h4 id="集成测试中的子模块"><a href="#集成测试中的子模块" class="headerlink" title="集成测试中的子模块"></a>集成测试中的子模块</h4><p>随着集成测试的增加，你可能希望在 <code>tests</code> 目录创建更多文件以便更好地组织它们；例如根据测试的功能来将测试分组。如前所述，<em>tests</em> 目录中的每一个文件都被编译成一个单独的 crate，这有助于创建独立的作用域，以便更接近于最终用户使用你的 crate 的方式。但这意味着，<em>tests</em> 目录中的文件的行为，和你在第七章中学习如何将代码分为模块和文件时，学到的 <em>src</em> 中的文件的行为不一样。</p>
<p>当你有一些在多个集成测试文件都会用到的帮助函数，而你尝试按照第七章[“将模块移动到其他文件”](.&#x2F;07.5 将模块拆分成多个文件)部分的步骤将它们提取到一个通用的模块中时，<em>tests</em> 目录中文件行为的不同就会凸显出来。例如，如果我们在 <em>tests&#x2F;common.rs</em> 中创建一个名为 <code>setup</code> 的函数，并希望在多个测试文件的测试函数中调用它，就可以在 <code>setup</code> 中添加想要复用的代码：</p>
<p>文件名：tests&#x2F;common.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">setup</span>() &#123;</span><br><span class="line">    <span class="comment">// setup code specific to your library&#x27;s tests would go here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果再次运行测试，将会在测试结果中看到一个新的对应 <em>common.rs</em> 文件的测试结果部分，即便这个文件并没有包含任何测试函数，也没有任何地方调用了 <code>setup</code> 函数：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo <span class="built_in">test</span></span></span><br><span class="line">   Compiling adder v0.1.0 (file:///projects/adder)</span><br><span class="line">    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.89s</span><br><span class="line">     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)</span><br><span class="line"></span><br><span class="line">running 1 test</span><br><span class="line">test tests::internal ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br><span class="line"></span><br><span class="line">     Running tests/common.rs (target/debug/deps/common-92948b65e88960b4)</span><br><span class="line"></span><br><span class="line">running 0 tests</span><br><span class="line"></span><br><span class="line">test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br><span class="line"></span><br><span class="line">     Running tests/integration_test.rs (target/debug/deps/integration_test-92948b65e88960b4)</span><br><span class="line"></span><br><span class="line">running 1 test</span><br><span class="line">test it_adds_two ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br><span class="line"></span><br><span class="line">   Doc-tests adder</span><br><span class="line"></span><br><span class="line">running 0 tests</span><br><span class="line"></span><br><span class="line">test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br></pre></td></tr></table></figure>

<p>我们并不想要 <code>common</code> 出现在测试结果中显示 <code>running 0 tests</code>。我们只是想与其他集成测试文件共享一些代码而已。为了不让 <code>common</code> 出现在测试输出中，我们将创建 <em>tests&#x2F;common&#x2F;mod.rs</em>，而不是创建 <em>tests&#x2F;common.rs</em> 。现在项目目录结构看起来像这样：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">├── Cargo.lock</span><br><span class="line">├── Cargo.toml</span><br><span class="line">├── src</span><br><span class="line">│   └── lib.rs</span><br><span class="line">└── tests</span><br><span class="line">    ├── common</span><br><span class="line">    │   └── mod.rs</span><br><span class="line">    └── integration_test.rs</span><br></pre></td></tr></table></figure>

<p>这是一种老的命名规范，正如第七章[“另一种文件路径”](.&#x2F;07.5 将模块拆分成多个文件)中提到的 Rust 仍然理解它们。这样命名告诉 Rust 不要将 <code>common</code> 看作一个集成测试文件。将 <code>setup</code> 函数代码移动到 <em>tests&#x2F;common&#x2F;mod.rs</em> 并删除 <em>tests&#x2F;common.rs</em> 文件之后，测试输出中将不会出现这一部分。<em>tests</em> 目录中的子目录不会被作为单独的 crate 编译或作为一个测试结果部分出现在测试输出中。</p>
<p>一旦创建了 <em>tests&#x2F;common&#x2F;mod.rs</em>，就可以将其作为模块以便在任何集成测试文件中使用。这里是一个 <em>tests&#x2F;integration_test.rs</em> 中调用 <code>setup</code> 函数的 <code>it_adds_two</code> 测试的示例：</p>
<p>文件名：tests&#x2F;integration_test.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> adder::add_two;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> common;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">it_adds_two</span>() &#123;</span><br><span class="line">    common::<span class="title function_ invoke__">setup</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">add_two</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(result, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意 <code>mod common;</code> 声明与示例 7-21 中展示的模块声明相同。接着在测试函数中就可以调用 <code>common::setup()</code> 了。</p>
<h4 id="二进制-crate-的集成测试"><a href="#二进制-crate-的集成测试" class="headerlink" title="二进制 crate 的集成测试"></a>二进制 crate 的集成测试</h4><p>如果项目是二进制 crate 并且只包含 <em>src&#x2F;main.rs</em> 而没有 <em>src&#x2F;lib.rs</em>，这样就不可能在 <em>tests</em> 目录创建集成测试并也无法通过 <code>use</code> 语句将 <em>src&#x2F;main.rs</em> 中定义的函数引入作用域。只有库 crate 才会向其他 crate 暴露了可供调用和使用的函数；二进制 crate 只意在单独运行。</p>
<p>这就是许多 Rust 二进制项目使用一个简单的 <em>src&#x2F;main.rs</em> 调用 <em>src&#x2F;lib.rs</em> 中的逻辑的原因之一。因为通过这种结构，集成测试<strong>就可以</strong>通过 <code>use</code> 来测试库 crate 中的重要功能了。而如果这些重要的功能没有问题的话，<em>src&#x2F;main.rs</em> 中的少量代码也就会正常工作且不需要测试。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Rust 的测试功能提供了一个确保即使你改变了函数的实现方式，也能继续以期望的方式运行的途径。单元测试独立地验证库的不同部分，也能够测试私有函数实现细节。集成测试则检查多个部分是否能结合起来正确地工作，并像其他外部代码那样测试库的公有 API。即使 Rust 的类型系统和所有权规则可以帮助避免某些类型的 bug，不过测试对于减少代码中不符合期望行为的逻辑 bug 仍然是很重要的。</p>
<p>让我们将本章和其前面各章所学的知识组合起来，在下一章一起编写一个项目！</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-05-31T06:50:26.000Z" title="2025/5/31 14:50:26">2025-05-31</time>发表</span><span class="level-item"><time dateTime="2025-05-31T08:40:48.098Z" title="2025/5/31 16:40:48">2025-05-31</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Rust/">Rust</a><span> / </span><a class="link-muted" href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></span><span class="level-item">17 分钟读完 (大约2585个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/05/31/Rust/The%20Rust%20Programming%20Language/11.2%20%E6%8E%A7%E5%88%B6%E6%B5%8B%E8%AF%95%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C/">11.2 控制测试如何运行</a></p><div class="content"><h2 id="控制测试如何运行"><a href="#控制测试如何运行" class="headerlink" title="控制测试如何运行"></a>控制测试如何运行</h2><p>就像 <code>cargo run</code> 会编译代码并运行生成的二进制文件一样，<code>cargo test</code> 在测试模式下编译代码并运行生成的测试二进制文件。<code>cargo test</code> 产生的二进制文件的默认行为是并发运行所有的测试，并截获测试运行过程中产生的输出，阻止它们被显示出来，使得阅读测试结果相关的内容变得更容易。不过可以指定命令行参数来改变 <code>cargo test</code> 的默认行为。</p>
<p>可以将一部分命令行参数传递给 <code>cargo test</code>，而将另外一部分传递给生成的测试二进制文件。为了分隔这两种参数，需要先列出传递给 <code>cargo test</code> 的参数，接着是分隔符 <code>--</code>，再之后是传递给测试二进制文件的参数。运行 <code>cargo test --help</code> 会提示 <code>cargo test</code> 的有关参数，而运行 <code>cargo test -- --help</code> 可以提示在分隔符之后使用的有关参数。有关这些选项的说明，请参阅 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/rustc/index.html">the rustc book</a> 的 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/rustc/tests/index.html">“Tests” 一节</a>。</p>
<h3 id="并行或顺序运行测试"><a href="#并行或顺序运行测试" class="headerlink" title="并行或顺序运行测试"></a>并行或顺序运行测试</h3><p>当运行多个测试时，Rust 默认使用多线程来并行运行。这意味着测试会更快地运行完毕，所以你可以更快的得到代码能否工作的反馈。因为测试是在同时运行的，你应该确保测试不能相互依赖，或依赖任何共享的状态，包括依赖共享的环境，比如当前工作目录或者环境变量。</p>
<p>举个例子，每一个测试都运行一些代码，假设这些代码都在硬盘上创建一个 <em>test-output.txt</em> 文件并写入一些数据。接着每一个测试都读取文件中的数据并断言这个文件包含特定的值，而这个值在每个测试中都是不同的。因为所有测试都是同时运行的，一个测试可能会在另一个测试读写文件过程中修改了文件。那么第二个测试就会失败，并不是因为代码不正确，而是因为测试并行运行时相互干扰。一个解决方案是使每一个测试读写不同的文件；另一个解决方案是一次运行一个测试。</p>
<p>如果你不希望测试并行运行，或者想要更加精确的控制线程的数量，可以传递 <code>--test-threads</code> 参数和希望使用线程的数量给测试二进制文件。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo <span class="built_in">test</span> -- --test-threads=1</span></span><br></pre></td></tr></table></figure>

<p>这里将测试线程设置为 <code>1</code>，告诉程序不要使用任何并行机制。这也会比并行运行花费更多时间，不过在有共享的状态时，测试就不会潜在的相互干扰了。</p>
<h3 id="显示函数输出"><a href="#显示函数输出" class="headerlink" title="显示函数输出"></a>显示函数输出</h3><p>默认情况下，当测试通过时，Rust 的测试库会捕获打印到标准输出的所有内容。比如在测试中调用了 <code>println!</code> 而测试通过了，我们将不会在终端看到 <code>println!</code> 的输出：只会看到说明测试通过的提示行。如果测试失败了，则会看到所有标准输出和其他错误信息。</p>
<p>例如，示例 11-10 有一个无意义的函数，它打印出其参数的值并接着返回 10。接着还有一个会通过的测试和一个会失败的测试：</p>
<p>文件名：src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">prints_and_returns_10</span>(a: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;I got the value &#123;a&#125;&quot;</span>);</span><br><span class="line">    <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">this_test_will_pass</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">value</span> = <span class="title function_ invoke__">prints_and_returns_10</span>(<span class="number">4</span>);</span><br><span class="line">        <span class="built_in">assert_eq!</span>(value, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">this_test_will_fail</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">value</span> = <span class="title function_ invoke__">prints_and_returns_10</span>(<span class="number">8</span>);</span><br><span class="line">        <span class="built_in">assert_eq!</span>(value, <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 11-10：一个调用了 <code>println!</code> 的函数的测试</p>
<p>运行 <code>cargo test</code> 将会看到这些测试的输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo <span class="built_in">test</span></span></span><br><span class="line">   Compiling silly-function v0.1.0 (file:///projects/silly-function)</span><br><span class="line">    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.58s</span><br><span class="line">     Running unittests src/lib.rs (target/debug/deps/silly_function-160869f38cff9166)</span><br><span class="line"></span><br><span class="line">running 2 tests</span><br><span class="line">test tests::this_test_will_fail ... FAILED</span><br><span class="line">test tests::this_test_will_pass ... ok</span><br><span class="line"></span><br><span class="line">failures:</span><br><span class="line"></span><br><span class="line">---- tests::this_test_will_fail stdout ----</span><br><span class="line">I got the value 8</span><br><span class="line"></span><br><span class="line">thread &#x27;tests::this_test_will_fail&#x27; panicked at src/lib.rs:19:9:</span><br><span class="line">assertion `left == right` failed</span><br><span class="line">  left: 10</span><br><span class="line"> right: 5</span><br><span class="line">note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">failures:</span><br><span class="line">    tests::this_test_will_fail</span><br><span class="line"></span><br><span class="line">test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br><span class="line"></span><br><span class="line">error: test failed, to rerun pass `--lib`</span><br></pre></td></tr></table></figure>

<p>注意输出中不会出现测试通过时打印的内容，即 <code>I got the value 4</code>。因为当测试通过时，这些输出会被截获。失败测试的输出 <code>I got the value 8</code> ，则出现在输出的测试摘要部分，同时也显示了测试失败的原因。</p>
<p>如果你希望也能看到通过的测试中打印的值，也可以在结尾加上 <code>--show-output</code> 告诉 Rust 显示成功测试的输出。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo <span class="built_in">test</span> -- --show-output</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>--show-output</code> 参数再次运行示例 11-10 中的测试会显示如下输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo <span class="built_in">test</span> -- --show-output</span></span><br><span class="line">   Compiling silly-function v0.1.0 (file:///projects/silly-function)</span><br><span class="line">    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.60s</span><br><span class="line">     Running unittests src/lib.rs (target/debug/deps/silly_function-160869f38cff9166)</span><br><span class="line"></span><br><span class="line">running 2 tests</span><br><span class="line">test tests::this_test_will_fail ... FAILED</span><br><span class="line">test tests::this_test_will_pass ... ok</span><br><span class="line"></span><br><span class="line">successes:</span><br><span class="line"></span><br><span class="line">---- tests::this_test_will_pass stdout ----</span><br><span class="line">I got the value 4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">successes:</span><br><span class="line">    tests::this_test_will_pass</span><br><span class="line"></span><br><span class="line">failures:</span><br><span class="line"></span><br><span class="line">---- tests::this_test_will_fail stdout ----</span><br><span class="line">I got the value 8</span><br><span class="line"></span><br><span class="line">thread &#x27;tests::this_test_will_fail&#x27; panicked at src/lib.rs:19:9:</span><br><span class="line">assertion `left == right` failed</span><br><span class="line">  left: 10</span><br><span class="line"> right: 5</span><br><span class="line">note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">failures:</span><br><span class="line">    tests::this_test_will_fail</span><br><span class="line"></span><br><span class="line">test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br><span class="line"></span><br><span class="line">error: test failed, to rerun pass `--lib`</span><br></pre></td></tr></table></figure>

<h3 id="通过名称运行部分测试"><a href="#通过名称运行部分测试" class="headerlink" title="通过名称运行部分测试"></a>通过名称运行部分测试</h3><p>有时运行整个测试集会耗费很长时间。如果你负责特定位置的代码，你可能会希望只运行与这些代码相关的测试。你可以向 <code>cargo test</code> 传递所希望运行的测试名称的参数来选择运行哪些测试。</p>
<p>为了展示如何运行部分测试，示例 11-11 为 <code>add_two</code> 函数创建了三个测试，我们可以选择具体运行哪一个：</p>
<p>文件名：src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_two</span>(a: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    a + <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add_two_and_two</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">add_two</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">assert_eq!</span>(result, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add_three_and_two</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">add_two</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">assert_eq!</span>(result, <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">one_hundred</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">add_two</span>(<span class="number">100</span>);</span><br><span class="line">        <span class="built_in">assert_eq!</span>(result, <span class="number">102</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 11-11：不同名称的三个测试</p>
<p>如果没有传递任何参数就运行测试，如你所见，所有测试都会并行运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo <span class="built_in">test</span></span></span><br><span class="line">   Compiling adder v0.1.0 (file:///projects/adder)</span><br><span class="line">    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.62s</span><br><span class="line">     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)</span><br><span class="line"></span><br><span class="line">running 3 tests</span><br><span class="line">test tests::add_three_and_two ... ok</span><br><span class="line">test tests::add_two_and_two ... ok</span><br><span class="line">test tests::one_hundred ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br><span class="line"></span><br><span class="line">   Doc-tests adder</span><br><span class="line"></span><br><span class="line">running 0 tests</span><br><span class="line"></span><br><span class="line">test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br></pre></td></tr></table></figure>

<h4 id="运行单个测试"><a href="#运行单个测试" class="headerlink" title="运行单个测试"></a>运行单个测试</h4><p>可以向 <code>cargo test</code> 传递任意测试的名称来只运行这个测试：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo <span class="built_in">test</span> one_hundred</span></span><br><span class="line">   Compiling adder v0.1.0 (file:///projects/adder)</span><br><span class="line">    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.69s</span><br><span class="line">     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)</span><br><span class="line"></span><br><span class="line">running 1 test</span><br><span class="line">test tests::one_hundred ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out; finished in 0.00s</span><br></pre></td></tr></table></figure>

<p>只有名称为 <code>one_hundred</code> 的测试被运行了；因为其余两个测试并不匹配这个名称。测试输出在末尾显示了 <code>2 filtered out</code>，表明还有 2 个测试被过滤，未被运行。</p>
<p>不能像这样指定多个测试名称；只有传递给 <code>cargo test</code> 的第一个值才会被使用。不过有个运行多个测试的方法。</p>
<h4 id="过滤运行多个测试"><a href="#过滤运行多个测试" class="headerlink" title="过滤运行多个测试"></a>过滤运行多个测试</h4><p>我们可以指定部分测试的名称，任何名称匹配这个名称的测试会被运行。例如，因为头两个测试的名称包含 <code>add</code>，可以通过 <code>cargo test add</code> 来运行这两个测试：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo <span class="built_in">test</span> add</span></span><br><span class="line">   Compiling adder v0.1.0 (file:///projects/adder)</span><br><span class="line">    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.61s</span><br><span class="line">     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)</span><br><span class="line"></span><br><span class="line">running 2 tests</span><br><span class="line">test tests::add_three_and_two ... ok</span><br><span class="line">test tests::add_two_and_two ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s</span><br></pre></td></tr></table></figure>

<p>这运行了所有名字中带有 <code>add</code> 的测试，也过滤掉了名为 <code>one_hundred</code> 的测试。同时注意测试所在的模块也是测试名称的一部分，所以可以通过过滤模块名来运行一个模块中的所有测试。</p>
<h3 id="除非特别指定否则忽略某些测试"><a href="#除非特别指定否则忽略某些测试" class="headerlink" title="除非特别指定否则忽略某些测试"></a>除非特别指定否则忽略某些测试</h3><p>有时一些特定的测试执行起来是非常耗费时间的，所以在大多数运行 <code>cargo test</code> 的时候希望能排除它们。虽然可以通过参数列举出所有希望运行的测试来做到，也可以使用 <code>ignore</code> 属性来标记耗时的测试并排除它们，如下所示：</p>
<p>文件名：src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">it_works</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">add</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">assert_eq!</span>(result, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="meta">#[ignore]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">expensive_test</span>() &#123;</span><br><span class="line">        <span class="comment">// code that takes an hour to run</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于想要排除的测试，我们在 <code>#[test]</code> 之后增加了 <code>#[ignore]</code> 行。现在如果运行测试，就会发现 <code>it_works</code> 运行了，而 <code>expensive_test</code> 没有运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo <span class="built_in">test</span></span></span><br><span class="line">   Compiling adder v0.1.0 (file:///projects/adder)</span><br><span class="line">    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.60s</span><br><span class="line">     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)</span><br><span class="line"></span><br><span class="line">running 2 tests</span><br><span class="line">test tests::expensive_test ... ignored</span><br><span class="line">test tests::it_works ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. 1 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br><span class="line"></span><br><span class="line">   Doc-tests adder</span><br><span class="line"></span><br><span class="line">running 0 tests</span><br><span class="line"></span><br><span class="line">test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br></pre></td></tr></table></figure>

<p><code>expensive_test</code> 被列为 <code>ignored</code>，如果我们只希望运行被忽略的测试，可以使用 <code>cargo test -- --ignored</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo <span class="built_in">test</span> -- --ignored</span></span><br><span class="line">   Compiling adder v0.1.0 (file:///projects/adder)</span><br><span class="line">    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.61s</span><br><span class="line">     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)</span><br><span class="line"></span><br><span class="line">running 1 test</span><br><span class="line">test expensive_test ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s</span><br><span class="line"></span><br><span class="line">   Doc-tests adder</span><br><span class="line"></span><br><span class="line">running 0 tests</span><br><span class="line"></span><br><span class="line">test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br></pre></td></tr></table></figure>

<p>通过控制运行哪些测试，你可以确保 <code>cargo test</code> 的结果能够快速返回。当你需要运行 <code>ignored</code> 的测试时，可以执行 <code>cargo test -- --ignored</code>。如果你希望不管是否忽略都要运行全部测试，可以运行 <code>cargo test -- --include-ignored</code>。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-05-31T06:30:26.000Z" title="2025/5/31 14:30:26">2025-05-31</time>发表</span><span class="level-item"><time dateTime="2025-05-31T08:31:21.055Z" title="2025/5/31 16:31:21">2025-05-31</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Rust/">Rust</a><span> / </span><a class="link-muted" href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></span><span class="level-item">1 小时读完 (大约6750个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/05/31/Rust/The%20Rust%20Programming%20Language/11.1%20%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95/">11.1 如何编写测试</a></p><div class="content"><h2 id="如何编写测试"><a href="#如何编写测试" class="headerlink" title="如何编写测试"></a>如何编写测试</h2><p>Rust 中的测试函数是用来验证非测试代码是否是按照期望的方式运行的。测试函数体通常执行如下三种操作：</p>
<ul>
<li>设置任何所需的数据或状态</li>
<li>运行需要测试的代码</li>
<li>断言其结果是我们所期望的</li>
</ul>
<p>让我们看看 Rust 提供的专门用来编写测试的功能：<code>test</code> 属性、一些宏和 <code>should_panic</code> 属性。</p>
<h3 id="测试函数剖析"><a href="#测试函数剖析" class="headerlink" title="测试函数剖析"></a>测试函数剖析</h3><p>作为最简单例子，Rust 中的测试就是一个带有 <code>test</code> 属性注解的函数。属性（attribute）是关于 Rust 代码片段的元数据；第五章中结构体中用到的 <code>derive</code> 属性就是一个例子。为了将一个函数变成测试函数，需要在 <code>fn</code> 行之前加上 <code>#[test]</code>。当使用 <code>cargo test</code> 命令运行测试时，Rust 会构建一个测试执行程序用来调用被标注的函数，并报告每一个测试是通过还是失败。</p>
<p>每次使用 Cargo 新建一个库项目时，它会自动为我们生成一个测试模块和一个测试函数。这个模块提供了一个编写测试的模板，为此每次开始新项目时不必去查找测试函数的具体结构和语法了。当然你也可以额外增加任意多的测试函数以及测试模块！</p>
<p>在实际编写测试代码之前，让我们先通过尝试那些自动生成的测试模版来探索测试是如何工作的。接着，我们会写一些真正的测试，调用我们编写的代码并断言它们的行为的正确性。</p>
<p>让我们创建一个新的库项目 <code>adder</code>，它会将两个数字相加：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo new adder --lib</span></span><br><span class="line">     Created library `adder` project</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> adder</span></span><br></pre></td></tr></table></figure>

<p><code>adder</code> 库中 <em>src&#x2F;lib.rs</em> 的内容应该看起来如示例 11-1 所示：</p>
<p>文件名：src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add</span>(left: <span class="type">u64</span>, right: <span class="type">u64</span>) <span class="punctuation">-&gt;</span> <span class="type">u64</span> &#123;</span><br><span class="line">    left + right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">it_works</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">add</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">assert_eq!</span>(result, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 11-1：由 <code>cargo new</code> 自动生成的测试模块和函数</p>
<p>文件以一个示例 <code>add</code> 函数开头，这样我们就有东西可以测试。</p>
<p>现在让我们只关注 <code>it_works</code> 函数本身。注意 <code>fn</code> 行之前的 <code>#[test]</code>：这个属性表明这是一个测试函数，这样测试执行者就知道将其作为测试处理。<code>tests</code> 模块中也可以有非测试的函数来帮助我们建立通用场景或进行常见操作，必须每次都标明哪些函数是测试。</p>
<p>示例函数体通过使用 <code>assert_eq!</code> 宏来断言 <code>result</code>（其中包含 2 加 2 的结果）等于 4。这个断言示例展示了典型测试的格式。接下来运行就可以看到测试通过。</p>
<p><code>cargo test</code> 命令会运行项目中所有的测试，如示例 11-2 所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo <span class="built_in">test</span></span></span><br><span class="line">   Compiling adder v0.1.0 (file:///projects/adder)</span><br><span class="line">    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.57s</span><br><span class="line">     Running unittests src/lib.rs (target/debug/deps/adder-01ad14159ff659ab)</span><br><span class="line"></span><br><span class="line">running 1 test</span><br><span class="line">test tests::it_works ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br><span class="line"></span><br><span class="line">   Doc-tests adder</span><br><span class="line"></span><br><span class="line">running 0 tests</span><br><span class="line"></span><br><span class="line">test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br></pre></td></tr></table></figure>

<p>示例 11-2：运行自动生成测试的输出</p>
<p>Cargo 编译并运行了测试。可以看到 <code>running 1 test</code> 这一行。下一行显示了生成的测试函数的名称，<code>tests::it_works</code>，以及测试的运行结果，<code>ok</code>。接着可以看到全体测试运行结果的摘要：<code>test result: ok.</code> 意味着所有测试都通过了。<code>1 passed; 0 failed</code> 表示通过或失败的测试数量。</p>
<p>可以将一个测试标记为忽略以便在特定情况下它就不会运行；本章之后的[“除非特别指定否则忽略某些测试”](.&#x2F;11.2 控制测试如何运行)部分会介绍它。因为之前我们并没有将任何测试标记为忽略，所以摘要中会显示 <code>0 ignored</code>。</p>
<p><code>0 measured</code> 统计是针对性能测试的。性能测试（benchmark tests）在编写本书时，仍只能用于 Rust 开发版（nightly Rust）。请查看 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/unstable-book/library-features/test.html">性能测试的文档</a> 了解更多。</p>
<p>我们可以将参数传递给 <code>cargo test</code> 命令，以便只运行名称与字符串匹配的测试；这就是所谓的<strong>过滤</strong>（<em>filtering</em>），我们会在 [“通过名称运行部分测试”](.&#x2F;11.2 控制测试如何运行) 讨论这一点。这里我们没有过滤需要运行的测试，所以摘要中会显示<code>0 filtered out</code>。</p>
<p>测试输出中的以 <code>Doc-tests adder</code> 开头的这一部分是所有文档测试的结果。我们现在并没有任何文档测试，不过 Rust 会编译任何在 API 文档中的代码示例。这个功能帮助我们使文档和代码保持同步！在第十四章的 [“文档注释作为测试”](.&#x2F;14.2 将 crate 发布到 Crates.io) 部分会讲到如何编写文档测试。现在我们将忽略 <code>Doc-tests</code> 部分的输出。</p>
<p>让我们开始自定义测试来满足我们的需求。首先给 <code>it_works</code> 函数起个不同的名字，比如 <code>exploration</code>，像这样：</p>
<p>文件名：src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add</span>(left: <span class="type">u64</span>, right: <span class="type">u64</span>) <span class="punctuation">-&gt;</span> <span class="type">u64</span> &#123;</span><br><span class="line">    left + right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">exploration</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">add</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">assert_eq!</span>(result, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并再次运行 <code>cargo test</code>。现在输出中将出现 <code>exploration</code> 而不是 <code>it_works</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo <span class="built_in">test</span></span></span><br><span class="line">   Compiling adder v0.1.0 (file:///projects/adder)</span><br><span class="line">    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.59s</span><br><span class="line">     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)</span><br><span class="line"></span><br><span class="line">running 1 test</span><br><span class="line">test tests::exploration ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br><span class="line"></span><br><span class="line">   Doc-tests adder</span><br><span class="line"></span><br><span class="line">running 0 tests</span><br><span class="line"></span><br><span class="line">test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br></pre></td></tr></table></figure>

<p>现在让我们增加另一个测试，不过这一次是一个会失败的测试！当测试函数中出现 panic 时测试就失败了。每一个测试都在一个新线程中运行，当主线程发现测试线程异常了，就将对应测试标记为失败。第九章讲到了最简单的造成 panic 的方法：调用 <code>panic!</code> 宏。写入新测试 <code>another</code> 后，<em>src&#x2F;lib.rs</em> 现在看起来如示例 11-3 所示：</p>
<p>文件名：src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add</span>(left: <span class="type">u64</span>, right: <span class="type">u64</span>) <span class="punctuation">-&gt;</span> <span class="type">u64</span> &#123;</span><br><span class="line">    left + right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">exploration</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">add</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">assert_eq!</span>(result, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">another</span>() &#123;</span><br><span class="line">        <span class="built_in">panic!</span>(<span class="string">&quot;Make this test fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 11-3：增加第二个因调用了 <code>panic!</code> 而失败的测试</p>
<p>再次 <code>cargo test</code> 运行测试。输出应该看起来像示例 11-4，它表明 <code>exploration</code> 测试通过了而 <code>another</code> 失败了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo <span class="built_in">test</span></span></span><br><span class="line">   Compiling adder v0.1.0 (file:///projects/adder)</span><br><span class="line">    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.72s</span><br><span class="line">     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)</span><br><span class="line"></span><br><span class="line">running 2 tests</span><br><span class="line">test tests::another ... FAILED</span><br><span class="line">test tests::exploration ... ok</span><br><span class="line"></span><br><span class="line">failures:</span><br><span class="line"></span><br><span class="line">---- tests::another stdout ----</span><br><span class="line"></span><br><span class="line">thread &#x27;tests::another&#x27; panicked at src/lib.rs:17:9:</span><br><span class="line">Make this test fail</span><br><span class="line">note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">failures:</span><br><span class="line">    tests::another</span><br><span class="line"></span><br><span class="line">test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br><span class="line"></span><br><span class="line">error: test failed, to rerun pass `--lib`</span><br></pre></td></tr></table></figure>

<p>示例 11-4：一个测试通过和一个测试失败的测试结果</p>
<p><code>test tests::another</code> 这一行是 <code>FAILED</code> 而不是 <code>ok</code> 了。在单独测试结果和摘要之间多了两个新的部分：第一个部分显示了测试失败的详细原因。在这个例子中，我们看到 <code>another</code> 因为在 <em>src&#x2F;lib.rs</em> 的第 10 行 <code>panicked at &#39;Make this test fail&#39;</code> 而失败的详细信息。下一部分列出了所有失败的测试，这在有很多测试和很多失败测试的详细输出时很有帮助。我们可以通过使用失败测试的名称来只运行这个测试，以便调试；下一部分 [“控制测试如何运行”](.&#x2F;11.2 控制测试如何运行) 会讲到更多运行测试的方法。</p>
<p>最后是摘要行：总体上讲，测试结果是 <code>FAILED</code>。有一个测试通过和一个测试失败。</p>
<p>现在我们见过不同场景中测试结果是什么样子的了，再来看看除 <code>panic!</code> 之外的一些在测试中有帮助的宏吧。</p>
<h3 id="使用-assert-宏来检查结果"><a href="#使用-assert-宏来检查结果" class="headerlink" title="使用 assert! 宏来检查结果"></a>使用 <code>assert!</code> 宏来检查结果</h3><p><code>assert!</code> 宏由标准库提供，在希望确保测试中一些条件为 <code>true</code> 时非常有用。需要向 <code>assert!</code> 宏提供一个求值为布尔值的参数。如果值是 <code>true</code>，<code>assert!</code> 什么也不做，同时测试会通过。如果值为 <code>false</code>，<code>assert!</code> 调用 <code>panic!</code> 宏，这会导致测试失败。<code>assert!</code> 宏帮助我们检查代码是否以期望的方式运行。</p>
<p>回忆一下第五章中，示例 5-15 中有一个 <code>Rectangle</code> 结构体和一个 <code>can_hold</code> 方法，在示例 11-5 中再次使用它们。将它们放进 <em>src&#x2F;lib.rs</em> 并使用 <code>assert!</code> 宏编写一些测试。</p>
<p>文件名：src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">can_hold</span>(&amp;<span class="keyword">self</span>, other: &amp;Rectangle) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width &gt; other.width &amp;&amp; <span class="keyword">self</span>.height &gt; other.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 11-5：第五章中 <code>Rectangle</code> 结构体和其 <code>can_hold</code> 方法</p>
<p><code>can_hold</code> 方法返回一个布尔值，这意味着它完美符合 <code>assert!</code> 宏的使用场景。在示例 11-6 中，让我们编写一个 <code>can_hold</code> 方法的测试来作为练习，这里创建一个宽为 8 高为 7 的 <code>Rectangle</code> 实例，并假设它可以放得下另一个宽为 5 高为 1 的 <code>Rectangle</code> 实例：</p>
<p>文件名：src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">larger_can_hold_smaller</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">larger</span> = Rectangle &#123;</span><br><span class="line">            width: <span class="number">8</span>,</span><br><span class="line">            height: <span class="number">7</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">smaller</span> = Rectangle &#123;</span><br><span class="line">            width: <span class="number">5</span>,</span><br><span class="line">            height: <span class="number">1</span>,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert!</span>(larger.<span class="title function_ invoke__">can_hold</span>(&amp;smaller));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 11-6：一个 <code>can_hold</code> 的测试，检查一个较大的矩形确实能放得下一个较小的矩形</p>
<p>注意在 <code>tests</code> 模块中新增加了一行：<code>use super::*;</code>。<code>tests</code> 是一个普通的模块，它遵循第七章 [“路径用于引用模块树中的项”](.&#x2F;07.3 引用模块项目的路径) 部分介绍的可见性规则。因为 <code>tests</code> 模块是一个内部模块，要测试外部模块中的代码，需要将其引入到内部模块的作用域中。这里选择使用 glob 全局导入，以便在 <code>tests</code> 模块中使用所有在外部模块定义的内容。</p>
<p>我们将测试命名为 <code>larger_can_hold_smaller</code>，并创建所需的两个 <code>Rectangle</code> 实例。接着调用 <code>assert!</code> 宏并传递 <code>larger.can_hold(&amp;smaller)</code> 调用的结果作为参数。这个表达式预期会返回 <code>true</code>，所以测试应该通过。让我们拭目以待！</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo <span class="built_in">test</span></span></span><br><span class="line">   Compiling rectangle v0.1.0 (file:///projects/rectangle)</span><br><span class="line">    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s</span><br><span class="line">     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)</span><br><span class="line"></span><br><span class="line">running 1 test</span><br><span class="line">test tests::larger_can_hold_smaller ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br><span class="line"></span><br><span class="line">   Doc-tests rectangle</span><br><span class="line"></span><br><span class="line">running 0 tests</span><br><span class="line"></span><br><span class="line">test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br></pre></td></tr></table></figure>

<p>它确实通过了！再来增加另一个测试，这一回断言一个更小的矩形不能放下一个更大的矩形：</p>
<p>文件名：src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">larger_can_hold_smaller</span>() &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">smaller_cannot_hold_larger</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">larger</span> = Rectangle &#123;</span><br><span class="line">            width: <span class="number">8</span>,</span><br><span class="line">            height: <span class="number">7</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">smaller</span> = Rectangle &#123;</span><br><span class="line">            width: <span class="number">5</span>,</span><br><span class="line">            height: <span class="number">1</span>,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert!</span>(!smaller.<span class="title function_ invoke__">can_hold</span>(&amp;larger));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为这里 <code>can_hold</code> 函数的正确结果是 <code>false</code> ，我们需要将这个结果取反后传递给 <code>assert!</code> 宏。因此 <code>can_hold</code> 返回 <code>false</code> 时测试就会通过：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo <span class="built_in">test</span></span></span><br><span class="line">   Compiling rectangle v0.1.0 (file:///projects/rectangle)</span><br><span class="line">    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s</span><br><span class="line">     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)</span><br><span class="line"></span><br><span class="line">running 2 tests</span><br><span class="line">test tests::larger_can_hold_smaller ... ok</span><br><span class="line">test tests::smaller_cannot_hold_larger ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br><span class="line"></span><br><span class="line">   Doc-tests rectangle</span><br><span class="line"></span><br><span class="line">running 0 tests</span><br><span class="line"></span><br><span class="line">test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br></pre></td></tr></table></figure>

<p>两个测试通过了！现在让我们看看如果引入一个 bug 的话测试结果会发生什么。将 <code>can_hold</code> 方法中比较宽度时本应使用大于号的地方改成小于号：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --snip--</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">can_hold</span>(&amp;<span class="keyword">self</span>, other: &amp;Rectangle) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width &lt; other.width &amp;&amp; <span class="keyword">self</span>.height &gt; other.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在运行测试会产生以下结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo <span class="built_in">test</span></span></span><br><span class="line">   Compiling rectangle v0.1.0 (file:///projects/rectangle)</span><br><span class="line">    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s</span><br><span class="line">     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)</span><br><span class="line"></span><br><span class="line">running 2 tests</span><br><span class="line">test tests::larger_can_hold_smaller ... FAILED</span><br><span class="line">test tests::smaller_cannot_hold_larger ... ok</span><br><span class="line"></span><br><span class="line">failures:</span><br><span class="line"></span><br><span class="line">---- tests::larger_can_hold_smaller stdout ----</span><br><span class="line"></span><br><span class="line">thread &#x27;tests::larger_can_hold_smaller&#x27; panicked at src/lib.rs:28:9:</span><br><span class="line">assertion failed: larger.can_hold(&amp;smaller)</span><br><span class="line">note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">failures:</span><br><span class="line">    tests::larger_can_hold_smaller</span><br><span class="line"></span><br><span class="line">test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br><span class="line"></span><br><span class="line">error: test failed, to rerun pass `--lib`</span><br></pre></td></tr></table></figure>

<p>我们的测试捕获了 bug！因为 <code>larger.width</code> 是 8 而 <code>smaller.width</code> 是 5，<code>can_hold</code> 中的宽度比较现在因为 8 不小于 5 而返回 <code>false</code>：8 并不小于 5。</p>
<h3 id="使用-assert-eq-和-assert-ne-宏测试相等"><a href="#使用-assert-eq-和-assert-ne-宏测试相等" class="headerlink" title="使用 assert_eq! 和 assert_ne! 宏测试相等"></a>使用 <code>assert_eq!</code> 和 <code>assert_ne!</code> 宏测试相等</h3><p>测试功能的一个常用方法是将需要测试代码的值与期望值做比较，并检查是否相等。可以通过向 <code>assert!</code> 宏传递一个使用 <code>==</code> 运算符的表达式来做到。不过这个操作实在是太常见了，以至于标准库提供了一对宏来更方便的处理这些操作 —— <code>assert_eq!</code> 和 <code>assert_ne!</code>。这两个宏分别比较两个值是相等还是不相等。当断言失败时它们也会打印出这两个值具体是什么，以便于观察测试<strong>为什么</strong>失败，而 <code>assert!</code> 只会打印出它从 <code>==</code> 表达式中得到了 <code>false</code> 值，而不是打印导致 <code>false</code> 的具体值。</p>
<p>示例 11-7 中，让我们编写一个对其参数加二并返回结果的函数 <code>add_two</code>。接着使用 <code>assert_eq!</code> 宏测试这个函数。</p>
<p>文件名：src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_two</span>(a: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    a + <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">it_adds_two</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">add_two</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">assert_eq!</span>(result, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 11-7：使用 <code>assert_eq!</code> 宏测试 <code>add_two</code> 函数</p>
<p>测试通过了！</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo <span class="built_in">test</span></span></span><br><span class="line">   Compiling adder v0.1.0 (file:///projects/adder)</span><br><span class="line">    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.58s</span><br><span class="line">     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)</span><br><span class="line"></span><br><span class="line">running 1 test</span><br><span class="line">test tests::it_adds_two ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br><span class="line"></span><br><span class="line">   Doc-tests adder</span><br><span class="line"></span><br><span class="line">running 0 tests</span><br><span class="line"></span><br><span class="line">test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br></pre></td></tr></table></figure>

<p>我们创建一个名为 <code>result</code> 的变量，用于保存调用 <code>add_two(2)</code> 的结果。然后我们将 <code>result</code> 和 <code>4</code> 作为参数传递给 <code>assert_eq!</code>。测试中的这一行 <code>test tests::it_adds_two ... ok</code> 中 <code>ok</code> 表明测试通过！</p>
<p>在代码中引入一个 bug 来看看使用 <code>assert_eq!</code> 的测试失败是什么样的。修改 <code>add_two</code> 函数的实现使其加 <code>3</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_two</span>(a: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    a + <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次运行测试：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo <span class="built_in">test</span></span></span><br><span class="line">   Compiling adder v0.1.0 (file:///projects/adder)</span><br><span class="line">    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.61s</span><br><span class="line">     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)</span><br><span class="line"></span><br><span class="line">running 1 test</span><br><span class="line">test tests::it_adds_two ... FAILED</span><br><span class="line"></span><br><span class="line">failures:</span><br><span class="line"></span><br><span class="line">---- tests::it_adds_two stdout ----</span><br><span class="line"></span><br><span class="line">thread &#x27;tests::it_adds_two&#x27; panicked at src/lib.rs:12:9:</span><br><span class="line">assertion `left == right` failed</span><br><span class="line">  left: 5</span><br><span class="line"> right: 4</span><br><span class="line">note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">failures:</span><br><span class="line">    tests::it_adds_two</span><br><span class="line"></span><br><span class="line">test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br><span class="line"></span><br><span class="line">error: test failed, to rerun pass `--lib`</span><br></pre></td></tr></table></figure>

<p>测试捕获到了 bug！<code>it_adds_two</code> 测试失败，错误信息告诉我们断言失败了，它告诉我们 <code>assertion </code>left &#x3D;&#x3D; right<code> failed</code> 以及 <code>left</code> 和 <code>right</code> 的值是什么。这个错误信息有助于我们开始调试：它说 <code>assert_eq!</code> 的 <code>left</code> 参数（也就是 <code>add_two(2)</code> 的结果）是 <code>5</code>，而 <code>right</code> 参数是 <code>4</code>。可以想象当有很多测试在运行时这些信息是多么的有用。</p>
<p>需要注意的是，在一些语言和测试框架中，断言两个值相等的函数的参数被称为 <code>expected</code> 和 <code>actual</code>，而且指定参数的顺序非常重要。然而在 Rust 中，它们则叫做 <code>left</code> 和 <code>right</code>，同时指定期望的值和被测试代码产生的值的顺序并不重要。这个测试中的断言也可以写成 <code>assert_eq!(add_two(2), result)</code>，这时失败信息仍同样是 <code>assertion failed: </code>(left &#x3D;&#x3D; right)&#96;&#96;。</p>
<p><code>assert_ne!</code> 宏在传递给它的两个值不相等时通过，而在相等时失败。当我们不确定值<strong>会</strong>是什么，不过能确定值绝对<strong>不会</strong>_ **是什么的时候，这个宏最有用处。例如，如果一个函数保证会以某种方式改变其输入，不过这种改变方式是由运行测试时是星期几来决定的，这时最好的断言可能就是函数的输出不等于其输入。</p>
<p><code>assert_eq!</code> 和 <code>assert_ne!</code> 宏在底层分别使用了 <code>==</code> 和 <code>!=</code>。当断言失败时，这些宏会使用调试格式打印出其参数，这意味着被比较的值必须实现了 <code>PartialEq</code> 和 <code>Debug</code> trait。所有的基本类型和大部分标准库类型都实现了这些 trait。对于自定义的结构体和枚举，需要实现 <code>PartialEq</code> 才能断言它们的值是否相等。需要实现 <code>Debug</code> 才能在断言失败时打印它们的值。因为这两个 trait 都是派生 trait，如第五章示例 5-12 所提到的，通常可以直接在结构体或枚举上添加 <code>#[derive(PartialEq, Debug)]</code> 注解。附录 C [“可派生 trait”](.&#x2F;22.3 C) 中有更多关于这些和其他派生 trait 的详细信息。</p>
<h3 id="自定义失败信息"><a href="#自定义失败信息" class="headerlink" title="自定义失败信息"></a>自定义失败信息</h3><p>你也可以向 <code>assert!</code>、<code>assert_eq!</code> 和 <code>assert_ne!</code> 宏传递一个可选的失败信息参数，可以在测试失败时将自定义失败信息一同打印出来。任何在 <code>assert!</code> 的一个必需参数和 <code>assert_eq!</code> 和 <code>assert_ne!</code> 的两个必需参数之后指定的参数都会传递给 <code>format!</code> 宏（在第八章的 [“使用 <code>+</code> 运算符或 <code>format!</code> 宏拼接字符串”](.&#x2F;08.2 使用字符串储存 UTF-8 编码的文本) 部分讨论过），所以可以传递一个包含 <code>&#123;&#125;</code> 占位符的格式字符串和需要放入占位符的值。自定义信息有助于记录断言的意义；当测试失败时就能更好的理解代码出了什么问题。</p>
<p>例如，比如说有一个根据人名进行问候的函数，而我们希望测试将传递给函数的人名显示在输出中：</p>
<p>文件名：src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">greeting</span>(name: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="built_in">format!</span>(<span class="string">&quot;Hello &#123;name&#125;!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">greeting_contains_name</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">greeting</span>(<span class="string">&quot;Carol&quot;</span>);</span><br><span class="line">        <span class="built_in">assert!</span>(result.<span class="title function_ invoke__">contains</span>(<span class="string">&quot;Carol&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序的需求还没有被确定，因此问候文本开头的 <code>Hello</code> 文本很可能会改变。然而我们并不想在需求改变时不得不更新测试，所以相比检查 <code>greeting</code> 函数返回的确切值，我们将仅仅断言输出的文本中包含输入参数。</p>
<p>让我们通过将 <code>greeting</code> 改为不包含 <code>name</code> 在代码中引入一个 bug 来测试失败时是怎样的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">greeting</span>(name: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行测试会产生：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo <span class="built_in">test</span></span></span><br><span class="line">   Compiling greeter v0.1.0 (file:///projects/greeter)</span><br><span class="line">    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.91s</span><br><span class="line">     Running unittests src/lib.rs (target/debug/deps/greeter-170b942eb5bf5e3a)</span><br><span class="line"></span><br><span class="line">running 1 test</span><br><span class="line">test tests::greeting_contains_name ... FAILED</span><br><span class="line"></span><br><span class="line">failures:</span><br><span class="line"></span><br><span class="line">---- tests::greeting_contains_name stdout ----</span><br><span class="line"></span><br><span class="line">thread &#x27;tests::greeting_contains_name&#x27; panicked at src/lib.rs:12:9:</span><br><span class="line">assertion failed: result.contains(&quot;Carol&quot;)</span><br><span class="line">note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">failures:</span><br><span class="line">    tests::greeting_contains_name</span><br><span class="line"></span><br><span class="line">test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br><span class="line"></span><br><span class="line">error: test failed, to rerun pass `--lib`</span><br></pre></td></tr></table></figure>

<p>结果仅仅告诉了我们断言失败了和失败的行号。一个更有用的失败信息应该打印出 <code>greeting</code> 函数的值。让我们为测试函数增加一个自定义失败信息参数：带占位符的格式字符串，以及 <code>greeting</code> 函数的值：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">greeting_contains_name</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">greeting</span>(<span class="string">&quot;Carol&quot;</span>);</span><br><span class="line">    <span class="built_in">assert!</span>(</span><br><span class="line">        result.<span class="title function_ invoke__">contains</span>(<span class="string">&quot;Carol&quot;</span>),</span><br><span class="line">        <span class="string">&quot;Greeting did not contain name, value was `&#123;result&#125;`&quot;</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在如果再次运行测试，将会看到更有价值的信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo <span class="built_in">test</span></span></span><br><span class="line">   Compiling greeter v0.1.0 (file:///projects/greeter)</span><br><span class="line">    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.93s</span><br><span class="line">     Running unittests src/lib.rs (target/debug/deps/greeter-170b942eb5bf5e3a)</span><br><span class="line"></span><br><span class="line">running 1 test</span><br><span class="line">test tests::greeting_contains_name ... FAILED</span><br><span class="line"></span><br><span class="line">failures:</span><br><span class="line"></span><br><span class="line">---- tests::greeting_contains_name stdout ----</span><br><span class="line"></span><br><span class="line">thread &#x27;tests::greeting_contains_name&#x27; panicked at src/lib.rs:12:9:</span><br><span class="line">Greeting did not contain name, value was `Hello!`</span><br><span class="line">note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">failures:</span><br><span class="line">    tests::greeting_contains_name</span><br><span class="line"></span><br><span class="line">test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br><span class="line"></span><br><span class="line">error: test failed, to rerun pass `--lib`</span><br></pre></td></tr></table></figure>

<p>可以在测试输出中看到所取得的确切的值，这会帮助我们调试真正发生了什么，而不是期望发生什么。</p>
<h3 id="使用-should-panic-检查-panic"><a href="#使用-should-panic-检查-panic" class="headerlink" title="使用 should_panic 检查 panic"></a>使用 <code>should_panic</code> 检查 panic</h3><p>除了检查返回值之外，检查代码是否按照期望处理错误也是很重要的。例如，考虑第九章示例 9-13 创建的 <code>Guess</code> 类型。其他使用 <code>Guess</code> 的代码都是基于 <code>Guess</code> 实例仅有的值范围在 1 到 100 的前提。可以编写一个测试来确保创建一个超出范围的值的 <code>Guess</code> 实例会 panic。</p>
<p>可以通过对函数增加另一个属性 <code>should_panic</code> 来实现这些。这个属性在函数中的代码 panic 时会通过，而在其中的代码没有 panic 时失败。</p>
<p>示例 11-8 展示了一个测试，检查 <code>Guess::new</code> 在错误条件下是否如我们所料那样。</p>
<p>文件名：src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Guess</span> &#123;</span><br><span class="line">    value: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Guess</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(value: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> Guess &#123;</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">1</span> || value &gt; <span class="number">100</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;Guess value must be between 1 and 100, got &#123;value&#125;.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Guess &#123; value &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="meta">#[should_panic]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">greater_than_100</span>() &#123;</span><br><span class="line">        Guess::<span class="title function_ invoke__">new</span>(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 11-8：测试会造成 <code>panic!</code> 的条件</p>
<p><code>#[should_panic]</code> 属性位于 <code>#[test]</code> 之后，对应的测试函数之前。让我们看看测试通过时它是什么样子：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo <span class="built_in">test</span></span></span><br><span class="line">   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)</span><br><span class="line">    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.58s</span><br><span class="line">     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)</span><br><span class="line"></span><br><span class="line">running 1 test</span><br><span class="line">test tests::greater_than_100 - should panic ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br><span class="line"></span><br><span class="line">   Doc-tests guessing_game</span><br><span class="line"></span><br><span class="line">running 0 tests</span><br><span class="line"></span><br><span class="line">test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br></pre></td></tr></table></figure>

<p>看起来不错！现在在代码中引入 bug，移除 <code>new</code> 函数在值大于 100 时会 panic 的条件：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --snip--</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Guess</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(value: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> Guess &#123;</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">1</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;Guess value must be between 1 and 100, got &#123;value&#125;.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Guess &#123; value &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果运行示例 11-8 的测试，它会失败：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo <span class="built_in">test</span></span></span><br><span class="line">   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)</span><br><span class="line">    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.62s</span><br><span class="line">     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)</span><br><span class="line"></span><br><span class="line">running 1 test</span><br><span class="line">test tests::greater_than_100 - should panic ... FAILED</span><br><span class="line"></span><br><span class="line">failures:</span><br><span class="line"></span><br><span class="line">---- tests::greater_than_100 stdout ----</span><br><span class="line">note: test did not panic as expected</span><br><span class="line"></span><br><span class="line">failures:</span><br><span class="line">    tests::greater_than_100</span><br><span class="line"></span><br><span class="line">test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br><span class="line"></span><br><span class="line">error: test failed, to rerun pass `--lib`</span><br></pre></td></tr></table></figure>

<p>这回并没有得到非常有用的信息，不过一旦我们观察测试函数，会发现它标注了 <code>#[should_panic]</code>。这个错误意味着代码中测试函数 <code>Guess::new(200)</code> 并没有产生 panic。</p>
<p>然而 <code>should_panic</code> 测试结果可能会非常含糊不清。<code>should_panic</code> 甚至在一些不是我们期望的原因而导致 panic 时也会通过。为了使 <code>should_panic</code> 测试结果更精确，我们可以给 <code>should_panic</code> 属性增加一个可选的 <code>expected</code> 参数。测试工具会确保错误信息中包含其提供的文本。例如，考虑示例 11-9 中修改过的 <code>Guess</code>，这里 <code>new</code> 函数根据其值是过大还或者过小而提供不同的 panic 信息：</p>
<p>文件名：src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Guess</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(value: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> Guess &#123;</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">1</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(</span><br><span class="line">                <span class="string">&quot;Guess value must be greater than or equal to 1, got &#123;value&#125;.&quot;</span></span><br><span class="line">            );</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> value &gt; <span class="number">100</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(</span><br><span class="line">                <span class="string">&quot;Guess value must be less than or equal to 100, got &#123;value&#125;.&quot;</span></span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Guess &#123; value &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="meta">#[should_panic(expected = <span class="string">&quot;less than or equal to 100&quot;</span>)]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">greater_than_100</span>() &#123;</span><br><span class="line">        Guess::<span class="title function_ invoke__">new</span>(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 11-9：一个错误信息包含特定子字符串的 <code>panic!</code> 条件的测试</p>
<p>这个测试会通过，因为 <code>should_panic</code> 属性中 <code>expected</code> 参数提供的值是 <code>Guess::new</code> 函数 panic 信息的子串。我们可以指定期望的整个 panic 信息，在这个例子中是 <code>Guess value must be less than or equal to 100, got 200</code> 。信息的选择取决于 panic 信息有多独特或动态，和你希望测试有多准确。在这个例子中，错误信息的子字符串足以确保函数在 <code>else if value &gt; 100</code> 的情况下运行。</p>
<p>为了观察带有 <code>expected</code> 信息的 <code>should_panic</code> 测试失败时会发生什么，让我们再次引入一个 bug，将 <code>if value &lt; 1</code> 和 <code>else if value &gt; 100</code> 的代码块对换：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> value &lt; <span class="number">1</span> &#123;</span><br><span class="line">    <span class="built_in">panic!</span>(</span><br><span class="line">        <span class="string">&quot;Guess value must be less than or equal to 100, got &#123;value&#125;.&quot;</span></span><br><span class="line">    );</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> value &gt; <span class="number">100</span> &#123;</span><br><span class="line">    <span class="built_in">panic!</span>(</span><br><span class="line">        <span class="string">&quot;Guess value must be greater than or equal to 1, got &#123;value&#125;.&quot;</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一次运行 <code>should_panic</code> 测试，它会失败：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo <span class="built_in">test</span></span></span><br><span class="line">   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)</span><br><span class="line">    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s</span><br><span class="line">     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)</span><br><span class="line"></span><br><span class="line">running 1 test</span><br><span class="line">test tests::greater_than_100 - should panic ... FAILED</span><br><span class="line"></span><br><span class="line">failures:</span><br><span class="line"></span><br><span class="line">---- tests::greater_than_100 stdout ----</span><br><span class="line"></span><br><span class="line">thread &#x27;tests::greater_than_100&#x27; panicked at src/lib.rs:12:13:</span><br><span class="line">Guess value must be greater than or equal to 1, got 200.</span><br><span class="line">note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace</span><br><span class="line">note: panic did not contain expected string</span><br><span class="line">      panic message: `&quot;Guess value must be greater than or equal to 1, got 200.&quot;`,</span><br><span class="line"> expected substring: `&quot;less than or equal to 100&quot;`</span><br><span class="line"></span><br><span class="line">failures:</span><br><span class="line">    tests::greater_than_100</span><br><span class="line"></span><br><span class="line">test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br><span class="line"></span><br><span class="line">error: test failed, to rerun pass `--lib`</span><br></pre></td></tr></table></figure>

<p>失败信息表明测试确实如期望 panic 了，不过 panic 信息中并没有包含期望的信息 <code>less than or equal to 100</code>。而我们得到的 panic 信息是 <code>Guess value must be greater than or equal to 1, got 200.</code>。这样就可以开始寻找 bug 在哪了！</p>
<h3 id="在测试中使用-Result"><a href="#在测试中使用-Result" class="headerlink" title="在测试中使用 Result"></a>在测试中使用 <code>Result</code></h3><p>目前为止，我们编写的测试在失败时都会 panic。我们也可以使用 <code>Result&lt;T, E&gt;</code> 编写测试！这是一个延伸自示例 11-1 的测试，使用 <code>Result&lt;T, E&gt;</code> 重写，并在失败时返回 <code>Err</code> 而非 panic：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">it_works</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">add</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> result == <span class="number">4</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;two plus two does not equal four&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在 <code>it_works</code> 函数的返回值类型为 <code>Result&lt;(), String&gt;</code>。在函数体中，不同于调用 <code>assert_eq!</code> 宏，而是在测试通过时返回 <code>Ok(())</code>，在测试失败时返回带有 <code>String</code> 的 <code>Err</code>。</p>
<p>这样编写测试来返回 <code>Result&lt;T, E&gt;</code> 就可以在函数体中使用问号运算符，如此可以方便的编写任何运算符会返回 <code>Err</code> 成员的测试。</p>
<p>不能对这些使用 <code>Result&lt;T, E&gt;</code> 的测试使用 <code>#[should_panic]</code> 注解。为了断言一个操作返回 <code>Err</code> 成员，<strong>不要</strong>对 <code>Result&lt;T, E&gt;</code> 值使用问号表达式（<code>?</code>）。而是使用 <code>assert!(value.is_err())</code>。</p>
<p>现在你知道了几种编写测试的方法，让我们看看运行测试时会发生什么，以及可以用于 <code>cargo test</code> 的不同选项。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-05-27T07:00:26.000Z" title="2025/5/27 15:00:26">2025-05-27</time>发表</span><span class="level-item"><time dateTime="2025-05-27T10:24:38.309Z" title="2025/5/27 18:24:38">2025-05-27</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Rust/">Rust</a><span> / </span><a class="link-muted" href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></span><span class="level-item">1 小时读完 (大约7835个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/05/27/Rust/The%20Rust%20Programming%20Language/10.3%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%A1%AE%E4%BF%9D%E5%BC%95%E7%94%A8%E6%9C%89%E6%95%88/">10.3 生命周期确保引用有效</a></p><div class="content"><h2 id="生命周期确保引用有效"><a href="#生命周期确保引用有效" class="headerlink" title="生命周期确保引用有效"></a>生命周期确保引用有效</h2><p>生命周期是另一类我们已经使用过的泛型。不同于确保类型有期望的行为，生命周期用于保证引用在我们需要的整个期间内都是有效的。</p>
<p>当在第四章讨论 [“引用和借用”](.&#x2F;04.2 引用与借用) 部分时，我们遗漏了一个重要的细节：Rust 中的每一个引用都有其<strong>生命周期</strong>（<em>lifetime</em>），也就是引用保持有效的作用域。大部分时候生命周期是隐含并可以推断的，正如大部分时候类型也是可以推断的一样。类似于当因为有多种可能类型的时候必须注明类型，也会出现引用的生命周期以一些不同方式相关联的情况，所以 Rust 需要我们使用泛型生命周期参数来注明它们的关系，这样就能确保运行时实际使用的引用绝对是有效的。</p>
<p>生命周期注解甚至不是一个大部分语言都有的概念，所以这可能感觉起来有些陌生。虽然本章不可能涉及到它全部的内容，我们会讲到一些通常你可能会遇到的生命周期语法以便你熟悉这个概念。</p>
<h3 id="生命周期避免了悬垂引用"><a href="#生命周期避免了悬垂引用" class="headerlink" title="生命周期避免了悬垂引用"></a>生命周期避免了悬垂引用</h3><p>生命周期的主要目标是避免<strong>悬垂引用</strong>（<em>dangling references</em>），后者会导致程序引用了非预期引用的数据。考虑一下示例 10-16 中的程序，它有一个外部作用域和一个内部作用域。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">        r = &amp;x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;r: &#123;r&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 10-16：尝试使用离开作用域的值的引用</p>
<blockquote>
<p>注意：示例 10-16、10-17 和 10-23 中声明了没有初始值的变量，所以这些变量存在于外部作用域。这乍看之下好像和 Rust 不允许存在空值相冲突。然而如果尝试在给它一个值之前使用这个变量，会出现一个编译时错误，这就说明了 Rust 确实不允许空值。</p>
</blockquote>
<p>外部作用域声明了一个没有初值的变量 <code>r</code>，而内部作用域声明了一个初值为 <code>5</code> 的变量<code>x</code>。在内部作用域中，我们尝试将 <code>r</code> 的值设置为一个 <code>x</code> 的引用。接着在内部作用域结束后，尝试打印出 <code>r</code> 的值。这段代码不能编译因为 <code>r</code> 引用的值在尝试使用之前就离开了作用域。如下是错误信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">   Compiling chapter10 v0.1.0 (file:///projects/chapter10)</span><br><span class="line">error[E0597]: `x` does not live long enough</span><br><span class="line"><span class="meta prompt_"> --&gt; </span><span class="language-bash">src/main.rs:6:13</span></span><br><span class="line">  |</span><br><span class="line">5 |         let x = 5;</span><br><span class="line">  |             - binding `x` declared here</span><br><span class="line">6 |         r = &amp;x;</span><br><span class="line">  |             ^^ borrowed value does not live long enough</span><br><span class="line">7 |     &#125;</span><br><span class="line">  |     - `x` dropped here while still borrowed</span><br><span class="line">8 |</span><br><span class="line">9 |     println!(&quot;r: &#123;r&#125;&quot;);</span><br><span class="line">  |                  --- borrow later used here</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0597`.</span><br><span class="line">error: could not compile `chapter10` (bin &quot;chapter10&quot;) due to 1 previous error</span><br></pre></td></tr></table></figure>

<p>变量 <code>x</code> 并没有 “存在的足够久”。其原因是 <code>x</code> 在到达第 7 行内部作用域结束时就离开了作用域。不过 <code>r</code> 在外部作用域仍是有效的；作用域越大我们就说它 “存在的越久”。如果 Rust 允许这段代码工作，<code>r</code> 将会引用在 <code>x</code> 离开作用域时被释放的内存，这时尝试对 <code>r</code> 做任何操作都不能正常工作。那么 Rust 是如何决定这段代码是不被允许的呢？这得益于借用检查器。</p>
<h4 id="借用检查器"><a href="#借用检查器" class="headerlink" title="借用检查器"></a>借用检查器</h4><p>Rust 编译器有一个<strong>借用检查器</strong>（<em>borrow checker</em>），它比较作用域来确保所有的借用都是有效的。示例 10-17 展示了与示例 10-16 相同的例子不过带有变量生命周期的注释：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span>;                <span class="comment">// ---------+-- &#x27;a</span></span><br><span class="line">                          <span class="comment">//          |</span></span><br><span class="line">    &#123;                     <span class="comment">//          |</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;        <span class="comment">// -+-- &#x27;b  |</span></span><br><span class="line">        r = &amp;x;           <span class="comment">//  |       |</span></span><br><span class="line">    &#125;                     <span class="comment">// -+       |</span></span><br><span class="line">                          <span class="comment">//          |</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;r: &#123;r&#125;&quot;</span>);   <span class="comment">//          |</span></span><br><span class="line">&#125;                         <span class="comment">// ---------+</span></span><br></pre></td></tr></table></figure>

<p>示例 10-17：<code>r</code> 和 <code>x</code> 的生命周期注解，分别叫做 <code>&#39;a</code> 和 <code>&#39;b</code></p>
<p>这里将 <code>r</code> 的生命周期标记为 <code>&#39;a</code> 并将 <code>x</code> 的生命周期标记为 <code>&#39;b</code>。如你所见，内部的 <code>&#39;b</code> 块要比外部的生命周期 <code>&#39;a</code> 小得多。在编译时，Rust 比较这两个生命周期的大小，并发现 <code>r</code> 拥有生命周期 <code>&#39;a</code>，不过它引用了一个拥有生命周期 <code>&#39;b</code> 的对象。程序被拒绝编译，因为生命周期 <code>&#39;b</code> 比生命周期 <code>&#39;a</code> 要小：被引用的对象比它的引用者存在的时间更短。</p>
<p>让我们看看示例 10-18 中这个并没有产生悬垂引用且可以正确编译的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;            <span class="comment">// ----------+-- &#x27;b</span></span><br><span class="line">                          <span class="comment">//           |</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span> = &amp;x;           <span class="comment">// --+-- &#x27;a  |</span></span><br><span class="line">                          <span class="comment">//   |       |</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;r: &#123;r&#125;&quot;</span>);   <span class="comment">//   |       |</span></span><br><span class="line">                          <span class="comment">// --+       |</span></span><br><span class="line">&#125;                         <span class="comment">// ----------+</span></span><br></pre></td></tr></table></figure>

<p>示例 10-18：一个有效的引用，因为数据比引用有着更长的生命周期</p>
<p>这里 <code>x</code> 拥有生命周期 <code>&#39;b</code>，比 <code>&#39;a</code> 要大。这就意味着 <code>r</code> 可以引用 <code>x</code>：Rust 知道 <code>r</code> 中的引用在 <code>x</code> 有效的时候也总是有效的。</p>
<p>现在我们已经在一个具体的例子中展示了引用的生命周期位于何处，并讨论了 Rust 如何分析生命周期来保证引用总是有效的，接下来让我们聊聊在函数的上下文中参数和返回值的泛型生命周期。</p>
<h3 id="函数中的泛型生命周期"><a href="#函数中的泛型生命周期" class="headerlink" title="函数中的泛型生命周期"></a>函数中的泛型生命周期</h3><p>让我们来编写一个返回两个字符串 slice 中较长者的函数。这个函数获取两个字符串 slice 并返回一个字符串 slice。一旦我们实现了 <code>longest</code> 函数，示例 10-19 中的代码应该会打印出 <code>The longest string is abcd</code>：</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string2</span> = <span class="string">&quot;xyz&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">longest</span>(string1.<span class="title function_ invoke__">as_str</span>(), string2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;result&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 10-19：<code>main</code> 函数调用 <code>longest</code> 函数来寻找两个字符串 slice 中较长的一个</p>
<p>注意这个函数获取作为引用的字符串 slice，而不是字符串，因为我们不希望 <code>longest</code> 函数获取参数的所有权。参考之前第四章中的[“字符串 slice 作为参数”](.&#x2F;04.3 Slice 类型)部分中更多关于为什么示例 10-19 的参数正符合我们期望的讨论。</p>
<p>如果尝试像示例 10-20 中那样实现 <code>longest</code> 函数，它并不能编译：</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>(x: &amp;<span class="type">str</span>, y: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123; x &#125; <span class="keyword">else</span> &#123; y &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 10-20：一个 <code>longest</code> 函数的实现，它返回两个字符串 slice 中较长者，现在还不能编译</p>
<p>相应地会出现如下有关生命周期的错误：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">   Compiling chapter10 v0.1.0 (file:///projects/chapter10)</span><br><span class="line">error[E0106]: missing lifetime specifier</span><br><span class="line"><span class="meta prompt_"> --&gt; </span><span class="language-bash">src/main.rs:9:33</span></span><br><span class="line">  |</span><br><span class="line">9 | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str &#123;</span><br><span class="line">  |               ----     ----     ^ expected named lifetime parameter</span><br><span class="line">  |</span><br><span class="line">  = help: this function&#x27;s return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`</span><br><span class="line">help: consider introducing a named lifetime parameter</span><br><span class="line">  |</span><br><span class="line">9 | fn longest&lt;&#x27;a&gt;(x: &amp;&#x27;a str, y: &amp;&#x27;a str) -&gt; &amp;&#x27;a str &#123;</span><br><span class="line">  |           ++++     ++          ++          ++</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0106`.</span><br><span class="line">error: could not compile `chapter10` (bin &quot;chapter10&quot;) due to 1 previous error</span><br></pre></td></tr></table></figure>

<p>提示文本揭示了返回值需要一个泛型生命周期参数，因为 Rust 并不知道将要返回的引用是指向 <code>x</code> 或 <code>y</code>。事实上我们也不知道，因为函数体中 <code>if</code> 块返回一个 <code>x</code> 的引用而 <code>else</code> 块返回一个 <code>y</code> 的引用！</p>
<p>当我们定义这个函数的时候，并不知道传递给函数的具体值，所以也不知道到底是 <code>if</code> 还是 <code>else</code> 会被执行。我们也不知道传入的引用的具体生命周期，所以也就不能像示例 10-17 和 10-18 那样通过观察作用域来确定返回的引用是否总是有效。借用检查器自身同样也无法确定，因为它不知道 <code>x</code> 和 <code>y</code> 的生命周期是如何与返回值的生命周期相关联的。为了修复这个错误，我们将增加泛型生命周期参数来定义引用间的关系以便借用检查器可以进行分析。</p>
<h3 id="生命周期注解语法"><a href="#生命周期注解语法" class="headerlink" title="生命周期注解语法"></a>生命周期注解语法</h3><p>生命周期注解并不改变任何引用的生命周期的长短。相反它们描述了多个引用生命周期相互的关系，而不影响其生命周期。与当函数签名中指定了泛型类型参数后就可以接受任何类型一样，当指定了泛型生命周期后函数也能接受任何生命周期的引用。</p>
<p>生命周期注解有着一个不太常见的语法：生命周期参数名称必须以撇号（<code>&#39;</code>）开头，其名称通常全是小写，类似于泛型其名称非常短。大多数人使用 <code>&#39;a</code> 作为第一个生命周期注解。生命周期参数注解位于引用的 <code>&amp;</code> 之后，并有一个空格来将引用类型与生命周期注解分隔开。</p>
<p>这里有一些例子：我们有一个没有生命周期参数的 <code>i32</code> 的引用，一个有叫做 <code>&#39;a</code> 的生命周期参数的 <code>i32</code> 的引用，和一个生命周期也是 <code>&#39;a</code> 的 <code>i32</code> 的可变引用：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;<span class="type">i32</span>        <span class="comment">// 引用</span></span><br><span class="line">&amp;<span class="string">&#x27;a i32     // 带有显式生命周期的引用</span></span><br><span class="line"><span class="string">&amp;&#x27;</span>a <span class="keyword">mut</span> <span class="type">i32</span> <span class="comment">// 带有显式生命周期的可变引用</span></span><br></pre></td></tr></table></figure>

<p>单个的生命周期注解本身没有多少意义，因为生命周期注解告诉 Rust 多个引用的泛型生命周期参数如何相互联系的。让我们在 <code>longest</code> 函数的上下文中理解生命周期注解如何相互联系。</p>
<h3 id="函数签名中的生命周期注解"><a href="#函数签名中的生命周期注解" class="headerlink" title="函数签名中的生命周期注解"></a>函数签名中的生命周期注解</h3><p>为了在函数签名中使用生命周期注解，需要在函数名和参数列表间的尖括号中声明泛型生命周期（<em>lifetime</em>）参数，就像泛型类型（<em>type</em>）参数一样。</p>
<p>我们希望函数签名表达如下限制：也就是这两个参数和返回的引用存活的一样久。（两个）参数和返回的引用的生命周期是相关的。就像示例 10-21 中在每个引用中都加上了 <code>&#39;a</code> 那样。</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="string">&#x27;a&gt;(x: &amp;&#x27;</span>a <span class="type">str</span>, y: &amp;<span class="string">&#x27;a str) -&gt; &amp;&#x27;</span>a <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123; x &#125; <span class="keyword">else</span> &#123; y &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 10-21：<code>longest</code> 函数定义指定了签名中所有的引用必须有相同的生命周期 <code>&#39;a</code></p>
<p>这段代码能够编译并会产生我们希望得到的示例 10-19 中的 <code>main</code> 函数的结果。</p>
<p>现在函数签名表明对于某些生命周期 <code>&#39;a</code>，函数会获取两个参数，它们都是与生命周期 <code>&#39;a</code> 存在的至少一样长的字符串 slice。函数会返回一个同样也与生命周期 <code>&#39;a</code> 存在的至少一样长的字符串 slice。它的实际含义是 <code>longest</code> 函数返回的引用的生命周期与函数参数所引用的值的生命周期的较小者一致。这些关系就是我们希望 Rust 分析代码时所使用的。</p>
<p>记住通过在函数签名中指定生命周期参数时，我们并没有改变任何传入值或返回值的生命周期，而是指出任何不满足这个约束条件的值都将被借用检查器拒绝。注意 <code>longest</code> 函数并不需要知道 <code>x</code> 和 <code>y</code> 具体会存在多久，而只需要知道有某个可以被 <code>&#39;a</code> 替代的作用域将会满足这个签名。</p>
<p>当在函数中使用生命周期注解时，这些注解出现在函数签名中，而不存在于函数体中的任何代码中。生命周期注解成为了函数约定的一部分，非常像签名中的类型。让函数签名包含生命周期约定意味着 Rust 编译器的工作变得更简单了。如果函数注解有误或者调用方法不对，编译器错误可以更准确地指出代码和限制的部分。如果不这么做的话，Rust 编译会对我们期望的生命周期关系做更多的推断，这样编译器可能只能指出离出问题地方很多步之外的代码。</p>
<p>当具体的引用被传递给 <code>longest</code> 时，被 <code>&#39;a</code> 所替代的具体生命周期是 <code>x</code> 的作用域与 <code>y</code> 的作用域相重叠的那一部分。换一种说法就是泛型生命周期 <code>&#39;a</code> 的具体生命周期等同于 <code>x</code> 和 <code>y</code> 的生命周期中较小的那一个。因为我们用相同的生命周期参数 <code>&#39;a</code> 标注了返回的引用值，所以返回的引用值就能保证在 <code>x</code> 和 <code>y</code> 中较短的那个生命周期结束之前保持有效。</p>
<p>让我们看看如何通过传递拥有不同具体生命周期的引用来限制 <code>longest</code> 函数的使用。示例 10-22 是一个很直观的例子。</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;long string is long&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">string2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">longest</span>(string1.<span class="title function_ invoke__">as_str</span>(), string2.<span class="title function_ invoke__">as_str</span>());</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;result&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 10-22：通过拥有不同的具体生命周期的 <code>String</code> 值调用 <code>longest</code> 函数</p>
<p>在这个例子中，<code>string1</code> 直到外部作用域结束都是有效的，<code>string2</code> 则在内部作用域中是有效的，而 <code>result</code> 则引用了一些直到内部作用域结束都是有效的值。借用检查器认可这些代码；它能够编译和运行，并打印出 <code>The longest string is long string is long</code>。</p>
<p>接下来，让我们尝试另外一个例子，该例子揭示了 <code>result</code> 的引用的生命周期必须是两个参数中较短的那个。以下代码将 <code>result</code> 变量的声明移动出内部作用域，但是将 <code>result</code> 和 <code>string2</code> 变量的赋值语句一同留在内部作用域中。接着，使用了变量 <code>result</code> 的 <code>println!</code> 也被移动到内部作用域之外。注意示例 10-23 中的代码不能通过编译：</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;long string is long&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">string2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line">        result = <span class="title function_ invoke__">longest</span>(string1.<span class="title function_ invoke__">as_str</span>(), string2.<span class="title function_ invoke__">as_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;result&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 10-23：尝试在 <code>string2</code> 离开作用域之后使用 <code>result</code></p>
<p>如果尝试编译这段代码会出现如下错误：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">   Compiling chapter10 v0.1.0 (file:///projects/chapter10)</span><br><span class="line">error[E0597]: `string2` does not live long enough</span><br><span class="line"><span class="meta prompt_"> --&gt; </span><span class="language-bash">src/main.rs:6:44</span></span><br><span class="line">  |</span><br><span class="line">5 |         let string2 = String::from(&quot;xyz&quot;);</span><br><span class="line">  |             ------- binding `string2` declared here</span><br><span class="line">6 |         result = longest(string1.as_str(), string2.as_str());</span><br><span class="line">  |                                            ^^^^^^^ borrowed value does not live long enough</span><br><span class="line">7 |     &#125;</span><br><span class="line">  |     - `string2` dropped here while still borrowed</span><br><span class="line">8 |     println!(&quot;The longest string is &#123;result&#125;&quot;);</span><br><span class="line">  |                                     -------- borrow later used here</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0597`.</span><br><span class="line">error: could not compile `chapter10` (bin &quot;chapter10&quot;) due to 1 previous error</span><br></pre></td></tr></table></figure>

<p>错误表明为了保证 <code>println!</code> 中的 <code>result</code> 是有效的，<code>string2</code> 需要直到外部作用域结束都是有效的。Rust 知道这些是因为（<code>longest</code>）函数的参数和返回值都使用了相同的生命周期参数 <code>&#39;a</code>。</p>
<p>作为人类，我们可以直观地发现 <code>string1</code> 比 <code>string2</code> 更长，因此 <code>result</code> 会包含指向 <code>string1</code> 的引用。因为 <code>string1</code> 尚未离开作用域，对于 <code>println!</code> 来说 <code>string1</code> 的引用仍然是有效的。然而，编译器并不能识别出这种情况。我们通过生命周期参数告诉 Rust 的是： <code>longest</code> 函数返回的引用的生命周期应该与传入参数的生命周期中较短那个保持一致。因此，借用检查器不允许示例 10-23 中的代码，因为它可能会存在无效的引用。</p>
<p>请尝试更多采用不同的值和不同生命周期的引用作为 <code>longest</code> 函数的参数和返回值的实验。并在开始编译前猜想你的实验能否通过借用检查器，接着编译一下看看你的理解是否正确！</p>
<h3 id="深入理解生命周期"><a href="#深入理解生命周期" class="headerlink" title="深入理解生命周期"></a>深入理解生命周期</h3><p>指定生命周期参数的正确方式依赖函数实现的具体功能。例如，如果将 <code>longest</code> 函数的实现修改为总是返回第一个参数而不是最长的字符串 slice，就不需要为参数 <code>y</code> 指定一个生命周期。如下代码将能够编译：</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="string">&#x27;a&gt;(x: &amp;&#x27;</span>a <span class="type">str</span>, y: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="string">&#x27;a str &#123;</span></span><br><span class="line"><span class="string">    x</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>我们为参数 <code>x</code> 和返回值指定了生命周期参数 <code>&#39;a</code>，不过没有为参数 <code>y</code> 指定，因为 <code>y</code> 的生命周期与参数 <code>x</code> 和返回值的生命周期没有任何关系。</p>
<p>当从函数返回一个引用，返回值的生命周期参数需要与一个参数的生命周期参数相匹配。如果返回的引用<strong>没有</strong>指向任何一个参数，那么唯一的可能就是它指向一个函数内部创建的值。然而它将会是一个悬垂引用，因为它将会在函数结束时离开作用域。尝试考虑这个并不能编译的 <code>longest</code> 函数实现：</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="string">&#x27;a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;&#x27;</span>a <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;really long string&quot;</span>);</span><br><span class="line">    result.<span class="title function_ invoke__">as_str</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即便我们为返回值指定了生命周期参数 <code>&#39;a</code>，这个实现却编译失败了，因为返回值的生命周期与参数完全没有关联。这里是会出现的错误信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">   Compiling chapter10 v0.1.0 (file:///projects/chapter10)</span><br><span class="line">error[E0515]: cannot return value referencing local variable `result`</span><br><span class="line"><span class="meta prompt_">  --&gt; </span><span class="language-bash">src/main.rs:11:5</span></span><br><span class="line">   |</span><br><span class="line">11 |     result.as_str()</span><br><span class="line">   |     ------^^^^^^^^^</span><br><span class="line">   |     |</span><br><span class="line">   |     returns a value referencing data owned by the current function</span><br><span class="line">   |     `result` is borrowed here</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0515`.</span><br><span class="line">error: could not compile `chapter10` (bin &quot;chapter10&quot;) due to 1 previous error</span><br></pre></td></tr></table></figure>

<p>出现的问题是 <code>result</code> 在 <code>longest</code> 函数的结尾将离开作用域并被清理，而我们尝试从函数返回一个 <code>result</code> 的引用。无法指定生命周期参数来改变悬垂引用，而且 Rust 也不允许我们创建一个悬垂引用。在这种情况，最好的解决方案是返回一个有所有权的数据类型而不是一个引用，这样函数调用者就需要负责清理这个值了。</p>
<p>综上，生命周期语法是用于将函数的多个参数与其返回值的生命周期进行关联的。一旦它们形成了某种关联，Rust 就有了足够的信息来允许内存安全的操作并阻止会产生悬垂指针亦或是违反内存安全的行为。</p>
<h3 id="结构体定义中的生命周期注解"><a href="#结构体定义中的生命周期注解" class="headerlink" title="结构体定义中的生命周期注解"></a>结构体定义中的生命周期注解</h3><p>目前为止，我们定义的结构体全都包含拥有所有权的类型。也可以定义包含引用的结构体，不过这需要为结构体定义中的每一个引用添加生命周期注解。示例 10-24 中有一个存放了一个字符串 slice 的结构体 <code>ImportantExcerpt</code>。</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ImportantExcerpt</span>&lt;<span class="string">&#x27;a&gt; &#123;</span></span><br><span class="line"><span class="string">    part: &amp;&#x27;</span>a <span class="type">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">novel</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Call me Ishmael. Some years ago...&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">first_sentence</span> = novel.<span class="title function_ invoke__">split</span>(<span class="string">&#x27;.&#x27;</span>).<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i</span> = ImportantExcerpt &#123;</span><br><span class="line">        part: first_sentence,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 10-24：一个存放引用的结构体，所以其定义需要生命周期注解</p>
<h3 id="生命周期省略（Lifetime-Elision）"><a href="#生命周期省略（Lifetime-Elision）" class="headerlink" title="生命周期省略（Lifetime Elision）"></a>生命周期省略（Lifetime Elision）</h3><p>现在我们已经知道了每一个引用都有一个生命周期，而且我们需要为那些使用了引用的函数或结构体指定生命周期。然而，第四章的示例 4-9 中有一个函数，再次展示为如示例 10-25 所示，它没有生命周期注解却能编译成功：</p>
<p>文件名：src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bytes</span> = s.<span class="title function_ invoke__">as_bytes</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">b&#x27; &#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;s[<span class="number">0</span>..i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &amp;s[..]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 10-25：示例 4-9 定义了一个没有使用生命周期注解的函数，即便其参数和返回值都是引用</p>
<p>这个函数没有生命周期注解却能编译是由于一些历史原因：在早期版本（pre-1.0）的 Rust 中，这的确是不能编译的。每一个引用都必须有明确的生命周期。那时的函数签名将会写成这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>&lt;<span class="string">&#x27;a&gt;(s: &amp;&#x27;</span>a <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="string">&#x27;a str &#123;</span></span><br></pre></td></tr></table></figure>

<p>在编写了很多 Rust 代码后，Rust 团队发现在特定情况下 Rust 程序员们总是重复地编写一模一样的生命周期注解。这些场景是可预测的并且遵循几个明确的模式。接着 Rust 团队就把这些模式编码进了 Rust 编译器中，如此借用检查器在这些情况下就能推断出生命周期而不再强制程序员显式的增加注解。</p>
<p>这里我们提到一些 Rust 的历史是因为更多的明确的模式被合并和添加到编译器中是完全可能的。未来可能只需要更少的生命周期注解。</p>
<p>被编码进 Rust 引用分析的模式被称为 <strong>生命周期省略规则</strong>（<em>lifetime elision rules</em>）。这并不是需要程序员遵守的规则；这些规则是一系列特定的场景，此时编译器会考虑，如果代码符合这些场景，就无需明确指定生命周期。</p>
<p>省略规则并不提供完整的推断。如果 Rust 在明确遵守这些规则的前提下变量的生命周期仍然是模棱两可的话，它不会猜测剩余引用的生命周期应该是什么。编译器会在可以通过增加生命周期注解来解决错误问题的地方给出一个错误提示，而不是进行推断或猜测。</p>
<p>函数或方法的参数的生命周期被称为 <strong>输入生命周期</strong>（<em>input lifetimes</em>），而返回值的生命周期被称为 <strong>输出生命周期</strong>（<em>output lifetimes</em>）。</p>
<p>编译器采用三条规则来判断引用何时不需要明确的注解。第一条规则适用于输入生命周期，后两条规则适用于输出生命周期。如果编译器检查完这三条规则后仍然存在没有计算出生命周期的引用，编译器将会停止并生成错误。这些规则适用于 <code>fn</code> 定义，以及 <code>impl</code> 块。</p>
<p>第一条规则是编译器为每一个引用参数都分配一个生命周期参数。换句话说就是，函数有一个引用参数的就有一个生命周期参数：<code>fn foo&lt;&#39;a&gt;(x: &amp;&#39;a i32)</code>，有两个引用参数的函数就有两个不同的生命周期参数，<code>fn foo&lt;&#39;a, &#39;b&gt;(x: &amp;&#39;a i32, y: &amp;&#39;b i32)</code>，依此类推。</p>
<p>第二条规则是如果只有一个输入生命周期参数，那么它被赋予所有输出生命周期参数：<code>fn foo&lt;&#39;a&gt;(x: &amp;&#39;a i32) -&gt; &amp;&#39;a i32</code>。</p>
<p>第三条规则是如果方法有多个输入生命周期参数并且其中一个参数是 <code>&amp;self</code> 或 <code>&amp;mut self</code>，说明这是个方法，那么所有输出生命周期参数被赋予 <code>self</code> 的生命周期。第三条规则使得方法更容易读写，因为只需更少的符号。</p>
<p>假设我们自己就是编译器。并应用这些规则来计算示例 10-25 中 <code>first_word</code> 函数签名中的引用的生命周期。开始时签名中的引用并没有关联任何生命周期：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br></pre></td></tr></table></figure>

<p>接着编译器应用第一条规则，也就是每个引用参数都有其自己的生命周期。我们像往常一样称之为 <code>&#39;a</code>，所以现在签名看起来像这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>&lt;<span class="string">&#x27;a&gt;(s: &amp;&#x27;</span>a <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br></pre></td></tr></table></figure>

<p>对于第二条规则，因为这里正好只有一个输入生命周期参数所以是适用的。第二条规则表明输入参数的生命周期将被赋予输出生命周期参数，所以现在签名看起来像这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>&lt;<span class="string">&#x27;a&gt;(s: &amp;&#x27;</span>a <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="string">&#x27;a str &#123;</span></span><br></pre></td></tr></table></figure>

<p>现在这个函数签名中的所有引用都有了生命周期，如此编译器可以继续它的分析而无须程序员标记这个函数签名中的生命周期。</p>
<p>让我们再看看另一个例子，这次我们从示例 10-20 中没有生命周期参数的 <code>longest</code> 函数开始：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>(x: &amp;<span class="type">str</span>, y: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br></pre></td></tr></table></figure>

<p>再次假设我们自己就是编译器并应用第一条规则：每个引用参数都有其自己的生命周期。这次有两个参数，所以就有两个（不同的）生命周期：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="string">&#x27;a, &#x27;</span>b&gt;(x: &amp;<span class="string">&#x27;a str, y: &amp;&#x27;</span>b <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br></pre></td></tr></table></figure>

<p>再来应用第二条规则，因为函数存在多个输入生命周期，它并不适用于这种情况。再来看第三条规则，它同样也不适用，这是因为没有 <code>self</code> 参数。应用了三个规则之后编译器还没有计算出返回值类型的生命周期。这就是在编译示例 10-20 的代码时会出现错误的原因：编译器使用所有已知的生命周期省略规则，仍不能计算出签名中所有引用的生命周期。</p>
<p>因为第三条规则真正能够适用的就只有方法签名，现在就让我们看看那种情况中的生命周期，并看看为什么这条规则意味着我们经常不需要在方法签名中标注生命周期。</p>
<h3 id="方法定义中的生命周期注解"><a href="#方法定义中的生命周期注解" class="headerlink" title="方法定义中的生命周期注解"></a>方法定义中的生命周期注解</h3><p>当为带有生命周期的结构体实现方法时，其语法依然类似示例 10-11 中展示的泛型类型参数的语法。我们在哪里声明和使用生命周期参数，取决于它们是与结构体字段相关还是与方法参数和返回值相关。</p>
<p>（实现方法时）结构体字段的生命周期必须总是在 <code>impl</code> 关键字之后声明并在结构体名称之后被使用，因为这些生命周期是结构体类型的一部分。</p>
<p><code>impl</code> 块里的方法签名中，引用可能与结构体字段中的引用相关联，也可能是独立的。另外，生命周期省略规则也经常让我们无需在方法签名中使用生命周期注解。让我们看看一些使用示例 10-24 中定义的结构体 <code>ImportantExcerpt</code> 的例子。</p>
<p>首先，这里有一个方法 <code>level</code>。其唯一的参数是 <code>self</code> 的引用，而且返回值只是一个 <code>i32</code>，并不引用任何值：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="string">&#x27;a&gt; ImportantExcerpt&lt;&#x27;</span>a&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">level</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>impl</code> 之后和类型名称之后的生命周期参数是必要的，不过因为第一条生命周期规则我们并不必须标注 <code>self</code> 引用的生命周期。</p>
<p>这里是一个适用于第三条生命周期省略规则的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="string">&#x27;a&gt; ImportantExcerpt&lt;&#x27;</span>a&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">announce_and_return_part</span>(&amp;<span class="keyword">self</span>, announcement: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Attention please: &#123;announcement&#125;&quot;</span>);</span><br><span class="line">        <span class="keyword">self</span>.part</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有两个输入生命周期，所以 Rust 应用第一条生命周期省略规则并给予 <code>&amp;self</code> 和 <code>announcement</code> 它们各自的生命周期。接着，因为其中一个参数是 <code>&amp;self</code>，返回值类型被赋予了 <code>&amp;self</code> 的生命周期，这样所有的生命周期都被计算出来了。</p>
<h3 id="静态生命周期"><a href="#静态生命周期" class="headerlink" title="静态生命周期"></a>静态生命周期</h3><p>这里有一种特殊的生命周期值得讨论：<code>&#39;static</code>，其生命周期<strong>能够</strong>存活于整个程序期间。所有的字符串字面值都拥有 <code>&#39;static</code> 生命周期，我们也可以选择像下面这样标注出来：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span>: &amp;<span class="string">&#x27;static str = &quot;I have a static lifetime.&quot;;</span></span><br></pre></td></tr></table></figure>

<p>这个字符串的文本被直接储存在程序的二进制文件中而这个文件总是可用的。因此所有的字符串字面值都是 <code>&#39;static</code> 的。</p>
<p>你可能在错误信息的帮助文本中见过使用 <code>&#39;static</code> 生命周期的建议，不过将引用指定为 <code>&#39;static</code> 之前，思考一下这个引用是否真的在整个程序的生命周期里都有效，以及你是否希望它存在得这么久。大部分情况中，推荐 <code>&#39;static</code> 生命周期的错误信息都是尝试创建一个悬垂引用或者可用的生命周期不匹配的结果。在这种情况下的解决方案是修复这些问题而不是指定一个 <code>&#39;static</code> 的生命周期。</p>
<h3 id="结合泛型类型参数、trait-bounds-和生命周期"><a href="#结合泛型类型参数、trait-bounds-和生命周期" class="headerlink" title="结合泛型类型参数、trait bounds 和生命周期"></a>结合泛型类型参数、trait bounds 和生命周期</h3><p>让我们简要的看一下在同一函数中指定泛型类型参数、trait bounds 和生命周期的语法！</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">longest_with_an_announcement</span>&lt;<span class="string">&#x27;a, T&gt;(</span></span><br><span class="line"><span class="string">    x: &amp;&#x27;</span>a <span class="type">str</span>,</span><br><span class="line">    y: &amp;<span class="string">&#x27;a str,</span></span><br><span class="line"><span class="string">    ann: T,</span></span><br><span class="line"><span class="string">) -&gt; &amp;&#x27;</span>a <span class="type">str</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Display,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Announcement! &#123;ann&#125;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123; x &#125; <span class="keyword">else</span> &#123; y &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个是示例 10-21 中那个返回两个字符串 slice 中较长者的 <code>longest</code> 函数，不过带有一个额外的参数 <code>ann</code>。<code>ann</code> 的类型是泛型 <code>T</code>，它可以被放入任何实现了 <code>where</code> 从句中指定的 <code>Display</code> trait 的类型。这个额外的参数会使用 <code>&#123;&#125;</code> 打印，这也就是为什么 <code>Display</code> trait bound 是必须的。因为生命周期也是泛型，所以生命周期参数 <code>&#39;a</code> 和泛型类型参数 <code>T</code> 都位于函数名后的同一尖括号列表中。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一章介绍了很多的内容！现在你知道了泛型类型参数、trait 和 trait bounds 以及泛型生命周期类型，你已经准备好编写既不重复又能适用于多种场景的代码了。泛型类型参数意味着代码可以适用于不同的类型。trait 和 trait bounds 保证了即使类型是泛型的，这些类型也会拥有所需要的行为。由生命周期注解所指定的引用生命周期之间的关系保证了这些灵活多变的代码不会出现悬垂引用。而所有的这一切发生在编译时所以不会影响运行时效率！</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-05-27T06:50:26.000Z" title="2025/5/27 14:50:26">2025-05-27</time>发表</span><span class="level-item"><time dateTime="2025-05-27T10:04:03.403Z" title="2025/5/27 18:04:03">2025-05-27</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Rust/">Rust</a><span> / </span><a class="link-muted" href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></span><span class="level-item">28 分钟读完 (大约4172个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/05/27/Rust/The%20Rust%20Programming%20Language/10.2%20Trait%EF%BC%9A%E5%AE%9A%E4%B9%89%E5%85%B1%E5%90%8C%E8%A1%8C%E4%B8%BA/">10.2 Trait：定义共同行为</a></p><div class="content"><h2 id="Trait：定义共同行为"><a href="#Trait：定义共同行为" class="headerlink" title="Trait：定义共同行为"></a>Trait：定义共同行为</h2><p><em>trait</em> 定义了某个特定类型拥有可能与其他类型共享的功能。可以通过 trait 以一种抽象的方式定义共同行为。可以使用 <em>trait bounds</em> 指定泛型是任何拥有特定行为的类型。</p>
<blockquote>
<p>注意：<em>trait</em> 类似于其他语言中的常被称为 <strong>接口</strong>（<em>interfaces</em>）的功能，虽然有一些不同。</p>
</blockquote>
<h3 id="定义-trait"><a href="#定义-trait" class="headerlink" title="定义 trait"></a>定义 trait</h3><p>一个类型的行为由其可供调用的方法构成。如果可以对不同类型调用相同的方法的话，这些类型就可以共享相同的行为了。trait 定义是一种将方法签名组合起来的方法，目的是定义一个实现某些目的所必需的行为的集合。</p>
<p>例如，这里有多个存放了不同类型和属性文本的结构体：结构体 <code>NewsArticle</code> 用于存放发生于世界各地的新闻故事，而结构体 <code>SocialPost</code> 最多只能存放 280 个字符的内容，以及指示该帖子是新发布的、转发的还是对另一条帖子的回复的元数据。</p>
<p>我们想要创建一个名为 <code>aggregator</code> 的多媒体聚合库用来显示可能储存在 <code>NewsArticle</code> 或 <code>SocialPost</code> 实例中的数据摘要。为了实现功能，每个结构体都要能够获取摘要，这样的话就可以调用实例的 <code>summarize</code> 方法来请求摘要。示例 10-12 中展示了一个表现这个概念的公有 <code>Summary</code> trait 的定义：</p>
<p>文件名：src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 10-12：<code>Summary</code> trait 定义，它包含由 <code>summarize</code> 方法提供的行为</p>
<p>这里使用 <code>trait</code> 关键字来声明一个 trait，后面是 trait 的名字，在这个例子中是 <code>Summary</code>。我们也声明 <code>trait</code> 为 <code>pub</code> 以便依赖这个 crate 的其它 crate 也可以使用这个 trait，正如我们见过的一些示例一样。在大括号中声明描述实现这个 trait 的类型所需要的行为的方法签名，在这个例子中是 <code>fn summarize(&amp;self) -&gt; String</code>。</p>
<p>在方法签名后跟分号，而不是在大括号中提供其实现。接着每一个实现这个 trait 的类型都需要提供其自定义行为的方法体，编译器也会确保任何实现 <code>Summary</code> trait 的类型都拥有与这个签名的定义完全一致的 <code>summarize</code> 方法。</p>
<p>trait 体中可以有多个方法：一行一个方法签名且都以分号结尾。</p>
<h3 id="为类型实现-trait"><a href="#为类型实现-trait" class="headerlink" title="为类型实现 trait"></a>为类型实现 trait</h3><p>现在我们定义了 <code>Summary</code> trait 的签名，接着就可以在多媒体聚合库中实现这个类型了。示例 10-13 中展示了 <code>NewsArticle</code> 结构体上 <code>Summary</code> trait 的一个实现，它使用标题、作者和创建的位置作为 <code>summarize</code> 的返回值。对于 <code>SocialPost</code> 结构体，我们选择将 <code>summarize</code> 定义为用户名后跟帖子全文作为返回值，并假设帖子内容已经被限制为 280 字符以内。</p>
<p>文件名：src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">NewsArticle</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> headline: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> location: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> author: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">NewsArticle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;, by &#123;&#125; (&#123;&#125;)&quot;</span>, <span class="keyword">self</span>.headline, <span class="keyword">self</span>.author, <span class="keyword">self</span>.location)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">SocialPost</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> username: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> reply: <span class="type">bool</span>,</span><br><span class="line">    <span class="keyword">pub</span> repost: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">SocialPost</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 10-13：在 <code>NewsArticle</code> 和 <code>SocialPost</code> 类型上实现 <code>Summary</code> trait</p>
<p>在类型上实现 trait 类似于实现常规方法。区别在于 <code>impl</code> 关键字之后，我们提供需要实现 trait 的名称，接着是 <code>for</code> 和需要实现 trait 的类型的名称。在 <code>impl</code> 块中，使用 trait 定义中的方法签名，不过不再后跟分号，而是需要在大括号中编写函数体来为特定类型实现 trait 方法所拥有的行为。</p>
<p>现在库在 <code>NewsArticle</code> 和 <code>SocialPost</code> 上实现了<code>Summary</code> trait，crate 的用户可以像调用常规方法一样调用 <code>NewsArticle</code> 和 <code>SocialPost</code> 实例的 trait 方法了。唯一的区别是 trait 必须和类型一起引入作用域以便使用额外的 trait 方法。这是一个二进制 crate 如何利用 <code>aggregator</code> 库 crate 的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> aggregator::&#123;SocialPost, Summary&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">post</span> = SocialPost &#123;</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;horse_ebooks&quot;</span>),</span><br><span class="line">        content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(</span><br><span class="line">            <span class="string">&quot;of course, as you probably already know, people&quot;</span>,</span><br><span class="line">        ),</span><br><span class="line">        reply: <span class="literal">false</span>,</span><br><span class="line">        repost: <span class="literal">false</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;1 new social post: &#123;&#125;&quot;</span>, post.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这会打印出 <code>1 new post: horse_ebooks: of course, as you probably already know, people</code>。</p>
<p>其他依赖 <code>aggregator</code> crate 的 crate 也可以将 <code>Summary</code> 引入作用域以便为其自己的类型实现该 trait。需要注意的限制是，只有在 trait 或类型至少有一个属于当前 crate 时，我们才能对类型实现该 trait。例如，可以为 <code>aggregator</code> crate 的自定义类型 <code>SocialPost</code> 实现如标准库中的 <code>Display</code> trait，这是因为 <code>SocialPost</code> 类型位于 <code>aggregator</code> crate 本地的作用域中。类似地，也可以在 <code>aggregator</code> crate 中为 <code>Vec&lt;T&gt;</code> 实现 <code>Summary</code>，这是因为 <code>Summary</code> trait 位于 <code>aggregator</code> crate 本地作用域中。</p>
<p>但是不能为外部类型实现外部 trait。例如，不能在 <code>aggregator</code> crate 中为 <code>Vec&lt;T&gt;</code> 实现 <code>Display</code> trait。这是因为 <code>Display</code> 和 <code>Vec&lt;T&gt;</code> 都定义于标准库中，它们并不位于 <code>aggregator</code> crate 本地作用域中。这个限制是被称为<strong>相干性</strong>（<em>coherence</em>）的程序属性的一部分，或者更具体的说是 <strong>孤儿规则</strong>（<em>orphan rule</em>），其得名于不存在父类型。这条规则确保了其他人编写的代码不会破坏你的代码，反之亦然。没有这条规则的话，两个 crate 可以分别对相同类型实现相同的 trait，而 Rust 将无从得知应该使用哪一个实现。</p>
<h3 id="默认实现"><a href="#默认实现" class="headerlink" title="默认实现"></a>默认实现</h3><p>有时为 trait 中的某些或全部方法提供默认的行为，而不是在每个类型的每个实现中都定义自己的行为是很有用的。这样当为某个特定类型实现 trait 时，可以选择保留或重载每个方法的默认行为。</p>
<p>示例 10-14 中我们为 <code>Summary</code> trait 的 <code>summarize</code> 方法指定一个默认的字符串值，而不是像示例 10-12 中那样只是定义方法签名：</p>
<p>文件名：src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;(Read more...)&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 10-14：<code>Summary</code> trait 的定义，带有一个 <code>summarize</code> 方法的默认实现</p>
<p>如果想要对 <code>NewsArticle</code> 实例使用这个默认实现，可以通过 <code>impl Summary for NewsArticle &#123;&#125;</code> 指定一个空的 <code>impl</code> 块。</p>
<p>虽然我们不再直接为 <code>NewsArticle</code> 定义 <code>summarize</code> 方法了，但是我们提供了一个默认实现并且指定 <code>NewsArticle</code> 实现 <code>Summary</code> trait。因此，我们仍然可以对 <code>NewsArticle</code> 实例调用 <code>summarize</code> 方法，如下所示：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">article</span> = NewsArticle &#123;</span><br><span class="line">    headline: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Penguins win the Stanley Cup Championship!&quot;</span>),</span><br><span class="line">    location: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Pittsburgh, PA, USA&quot;</span>),</span><br><span class="line">    author: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Iceburgh&quot;</span>),</span><br><span class="line">    content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(</span><br><span class="line">        <span class="string">&quot;The Pittsburgh Penguins once again are the best \</span></span><br><span class="line"><span class="string">         hockey team in the NHL.&quot;</span>,</span><br><span class="line">    ),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;New article available! &#123;&#125;&quot;</span>, article.<span class="title function_ invoke__">summarize</span>());</span><br></pre></td></tr></table></figure>

<p>这段代码会打印 <code>New article available! (Read more...)</code>。</p>
<p>为 <code>summarize</code> 创建默认实现并不要求对示例 10-13 中 <code>SocialPost</code> 上的 <code>Summary</code> 实现做任何改变。其原因是重载一个默认实现的语法与实现没有默认实现的 trait 方法的语法一样。</p>
<p>默认实现允许调用相同 trait 中的其他方法，哪怕这些方法没有默认实现。如此，trait 可以提供很多有用的功能而只需要实现指定一小部分内容。例如，我们可以定义 <code>Summary</code> trait，使其具有一个需要实现的 <code>summarize_author</code> 方法，然后定义一个 <code>summarize</code> 方法，此方法的默认实现调用 <code>summarize_author</code> 方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize_author</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;(Read more from &#123;&#125;...)&quot;</span>, <span class="keyword">self</span>.<span class="title function_ invoke__">summarize_author</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了使用这个版本的 <code>Summary</code>，只需在为类型实现 trait 时定义 <code>summarize_author</code> 即可：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">SocialPost</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize_author</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;@&#123;&#125;&quot;</span>, <span class="keyword">self</span>.username)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦定义了 <code>summarize_author</code>，我们就可以对 <code>SocialPost</code> 结构体的实例调用 <code>summarize</code> 了，而 <code>summarize</code> 的默认实现会调用我们提供的 <code>summarize_author</code> 定义。因为实现了 <code>summarize_author</code>，<code>Summary</code> trait 就提供了 <code>summarize</code> 方法的功能，且无需编写更多的代码。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">post</span> = SocialPost &#123;</span><br><span class="line">    username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;horse_ebooks&quot;</span>),</span><br><span class="line">    content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(</span><br><span class="line">        <span class="string">&quot;of course, as you probably already know, people&quot;</span>,</span><br><span class="line">    ),</span><br><span class="line">    reply: <span class="literal">false</span>,</span><br><span class="line">    repost: <span class="literal">false</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;1 new social post: &#123;&#125;&quot;</span>, post.<span class="title function_ invoke__">summarize</span>());</span><br></pre></td></tr></table></figure>

<p>这会打印出 <code>1 new post: (Read more from @horse_ebooks...)</code>。</p>
<p>注意无法从相同方法的重载实现中调用默认方法。</p>
<h3 id="trait-作为参数"><a href="#trait-作为参数" class="headerlink" title="trait 作为参数"></a>trait 作为参数</h3><p>知道了如何定义 trait 和在类型上实现这些 trait 之后，我们可以探索一下如何使用 trait 来接受多种不同类型的参数。示例 10-13 中为 <code>NewsArticle</code> 和 <code>SocialPost</code> 类型实现了 <code>Summary</code> trait，用其来定义了一个函数 <code>notify</code> 来调用其参数 <code>item</code> 上的 <code>summarize</code> 方法，该参数是实现了 <code>Summary</code> trait 的某种类型。为此可以使用 <code>impl Trait</code> 语法，像这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>(item: &amp;<span class="keyword">impl</span> <span class="title class_">Summary</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 <code>item</code> 参数，我们指定了 <code>impl</code> 关键字和 trait 名称，而不是具体的类型。该参数支持任何实现了指定 trait 的类型。在 <code>notify</code> 函数体中，可以调用任何来自 <code>Summary</code> trait 的方法，比如 <code>summarize</code>。我们可以传递任何 <code>NewsArticle</code> 或 <code>SocialPost</code> 的实例来调用 <code>notify</code>。任何用其它如 <code>String</code> 或 <code>i32</code> 的类型调用该函数的代码都不能编译，因为它们没有实现 <code>Summary</code>。</p>
<h4 id="Trait-Bound-语法"><a href="#Trait-Bound-语法" class="headerlink" title="Trait Bound 语法"></a>Trait Bound 语法</h4><p><code>impl Trait</code> 语法更直观，但它实际上是更长形式的 <em>trait bound</em> 语法的语法糖。它看起来像：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary&gt;(item: &amp;T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种更冗长的写法与上一节的示例等价，但更为冗长。trait bound 与泛型参数声明在一起，位于尖括号中的冒号后面。</p>
<p><code>impl Trait</code> 很方便，适用于短小的例子。更长的 trait bound 则适用于更复杂的场景。例如，可以获取两个实现了 <code>Summary</code> 的参数。使用 <code>impl Trait</code> 的语法看起来像这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>(item1: &amp;<span class="keyword">impl</span> <span class="title class_">Summary</span>, item2: &amp;<span class="keyword">impl</span> <span class="title class_">Summary</span>) &#123;</span><br></pre></td></tr></table></figure>

<p>这适用于 <code>item1</code> 和 <code>item2</code> 允许是不同类型的情况（只要它们都实现了 <code>Summary</code>）。不过如果你希望强制它们都是相同类型呢？但如果我们希望强制两个参数必须具有相同类型，则必须使用 trait bound，如下所示：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) &#123;</span><br></pre></td></tr></table></figure>

<p>泛型 <code>T</code> 被指定为 <code>item1</code> 和 <code>item2</code> 的参数限制，如此传递给参数 <code>item1</code> 和 <code>item2</code> 值的具体类型必须一致。</p>
<h4 id="通过-指定多个-trait-bound"><a href="#通过-指定多个-trait-bound" class="headerlink" title="通过 + 指定多个 trait bound"></a>通过 <code>+</code> 指定多个 trait bound</h4><p>我们也可以指定多个 trait bound。假设我们希望 <code>notify</code> 在 <code>item</code> 上既能使用格式化显示，又能使用 <code>summarize</code> 方法：在 <code>notify</code> 的定义中，指定 <code>item</code> 必须同时实现 <code>Display</code> 和 <code>Summary</code> 两个 trait。这可以通过 <code>+</code> 语法实现：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>(item: &amp;(<span class="keyword">impl</span> <span class="title class_">Summary</span> + Display)) &#123;</span><br></pre></td></tr></table></figure>

<p><code>+</code> 语法也适用于泛型的 trait bound：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary + Display&gt;(item: &amp;T) &#123;</span><br></pre></td></tr></table></figure>

<p>通过指定这两个 trait bound，<code>notify</code> 的函数体可以调用 <code>summarize</code> 并使用 <code>&#123;&#125;</code> 来格式化 <code>item</code>。</p>
<h4 id="通过-where-简化-trait-bound"><a href="#通过-where-简化-trait-bound" class="headerlink" title="通过 where 简化 trait bound"></a>通过 <code>where</code> 简化 trait bound</h4><p>然而，使用过多的 trait bound 也有缺点。每个泛型有其自己的 trait bound，所以有多个泛型参数的函数在名称和参数列表之间会有很长的 trait bound 信息，这使得函数签名难以阅读。为此，Rust 有另一个在函数签名之后的 <code>where</code> 从句中指定 trait bound 的语法。所以除了这么写：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">some_function</span>&lt;T: Display + <span class="built_in">Clone</span>, U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span>&gt;(t: &amp;T, u: &amp;U) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br></pre></td></tr></table></figure>

<p>还可以像这样使用 <code>where</code> 从句：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">some_function</span>&lt;T, U&gt;(t: &amp;T, u: &amp;U) <span class="punctuation">-&gt;</span> <span class="type">i32</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Display + <span class="built_in">Clone</span>,</span><br><span class="line">    U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span>,</span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure>

<p>这个函数签名就显得不那么杂乱，函数名、参数列表和返回值类型都离得很近，看起来跟没有那么多 trait bounds 的函数很像。</p>
<h3 id="返回实现了-trait-的类型"><a href="#返回实现了-trait-的类型" class="headerlink" title="返回实现了 trait 的类型"></a>返回实现了 trait 的类型</h3><p>也可以在返回值中使用 <code>impl Trait</code> 语法，来返回实现了某个 trait 的类型：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">returns_summarizable</span>() <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    SocialPost &#123;</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;horse_ebooks&quot;</span>),</span><br><span class="line">        content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(</span><br><span class="line">            <span class="string">&quot;of course, as you probably already know, people&quot;</span>,</span><br><span class="line">        ),</span><br><span class="line">        reply: <span class="literal">false</span>,</span><br><span class="line">        repost: <span class="literal">false</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过使用 <code>impl Summary</code> 作为返回值类型，我们指定了 <code>returns_summarizable</code> 函数返回某个实现了 <code>Summary</code> trait 的类型，但是不确定其具体的类型。在这个例子中 <code>returns_summarizable</code> 返回了一个 <code>SocialPost</code>，不过调用方并不知情。</p>
<p>返回一个只是指定了需要实现的 trait 的类型的能力在闭包和迭代器场景十分的有用，第十三章会介绍它们。闭包和迭代器创建只有编译器知道的类型，或者是非常非常长的类型。<code>impl Trait</code> 允许你简单的指定函数返回一个 <code>Iterator</code> 而无需写出实际的冗长的类型。</p>
<p>不过这只适用于返回单一类型的情况。例如，这段代码的返回值类型指定为返回 <code>impl Summary</code>，但是返回了 <code>NewsArticle</code> 或 <code>SocialPost</code> 就行不通：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">returns_summarizable</span>(switch: <span class="type">bool</span>) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> switch &#123;</span><br><span class="line">        NewsArticle &#123;</span><br><span class="line">            headline: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(</span><br><span class="line">                <span class="string">&quot;Penguins win the Stanley Cup Championship!&quot;</span>,</span><br><span class="line">            ),</span><br><span class="line">            location: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Pittsburgh, PA, USA&quot;</span>),</span><br><span class="line">            author: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Iceburgh&quot;</span>),</span><br><span class="line">            content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(</span><br><span class="line">                <span class="string">&quot;The Pittsburgh Penguins once again are the best \</span></span><br><span class="line"><span class="string">                 hockey team in the NHL.&quot;</span>,</span><br><span class="line">            ),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        SocialPost &#123;</span><br><span class="line">            username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;horse_ebooks&quot;</span>),</span><br><span class="line">            content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(</span><br><span class="line">                <span class="string">&quot;of course, as you probably already know, people&quot;</span>,</span><br><span class="line">            ),</span><br><span class="line">            reply: <span class="literal">false</span>,</span><br><span class="line">            repost: <span class="literal">false</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里尝试返回 <code>NewsArticle</code> 或 <code>SocialPost</code> 是不被允许的，原因在于编译器中 <code>impl Trait</code> 语法的实现限制。第十八章的 [“顾及不同类型值的 trait 对象”](.&#x2F;18.2 顾及不同类型值的 trait 对象) 部分会介绍如何编写这样一个函数。</p>
<h3 id="使用-trait-bound-有条件地实现方法"><a href="#使用-trait-bound-有条件地实现方法" class="headerlink" title="使用 trait bound 有条件地实现方法"></a>使用 trait bound 有条件地实现方法</h3><p>通过使用带有 trait bound 的泛型参数的 <code>impl</code> 块，可以有条件地只为那些实现了特定 trait 的类型实现方法。例如，示例 10-15 中的类型 <code>Pair&lt;T&gt;</code> 总是实现了 <code>new</code> 方法并返回一个 <code>Pair&lt;T&gt;</code> 的实例（回忆一下第五章的 [“定义方法”](.&#x2F;05.3 方法语法) 部分，<code>Self</code> 是一个 <code>impl</code> 块类型的类型别名（type alias），在这里是 <code>Pair&lt;T&gt;</code>）。不过在下一个 <code>impl</code> 块中，只有那些为 <code>T</code> 类型实现了 <code>PartialOrd</code> trait（来允许比较） <strong>和</strong> <code>Display</code> trait（来启用打印）的 <code>Pair&lt;T&gt;</code> 才会实现 <code>cmp_display</code> 方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(x: T, y: T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123; x, y &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: Display + <span class="built_in">PartialOrd</span>&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">cmp_display</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.x &gt;= <span class="keyword">self</span>.y &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;The largest member is x = &#123;&#125;&quot;</span>, <span class="keyword">self</span>.x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;The largest member is y = &#123;&#125;&quot;</span>, <span class="keyword">self</span>.y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 10-15：根据 trait bound 在泛型上有条件的实现方法</p>
<p>也可以对任何实现了特定 trait 的类型有条件地实现 trait。对任何满足特定 trait bound 的类型实现 trait 被称为 <em>blanket implementations</em>，它们被广泛的用于 Rust 标准库中。例如，标准库为任何实现了 <code>Display</code> trait 的类型实现了 <code>ToString</code> trait。这个 <code>impl</code> 块看起来像这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: Display&gt; <span class="built_in">ToString</span> <span class="keyword">for</span> <span class="title class_">T</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为标准库有了这些 blanket implementation，我们可以对任何实现了 <code>Display</code> trait 的类型调用由 <code>ToString</code> 定义的 <code>to_string</code> 方法。例如，可以将整型转换为对应的 <code>String</code> 值，因为整型实现了 <code>Display</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="number">3</span>.<span class="title function_ invoke__">to_string</span>();</span><br></pre></td></tr></table></figure>

<p>Blanket implementation 会出现在 trait 文档的 “Implementers” 部分。</p>
<p>Trait 和 trait bound 让我们能够使用泛型类型参数来减少重复，而且能够向编译器明确指定泛型类型需要拥有哪些行为。然后编译器可以利用 trait bound 信息检查代码中所用到的具体类型是否提供了正确的行为。在动态类型语言中，如果我们调用了一个未定义的方法，会在运行时出现错误。Rust 将这些错误移动到了编译时，甚至在代码能够运行之前就强迫我们修复问题。另外，我们也无需编写运行时检查行为的代码，因为在编译时就已经检查过了。这样既提升了性能又不必放弃泛型的灵活性。</p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/tags/Rust/">上一页</a></div><div class="pagination-next"><a href="/tags/Rust/page/3/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/tags/Rust/">1</a></li><li><a class="pagination-link is-current" href="/tags/Rust/page/2/">2</a></li><li><a class="pagination-link" href="/tags/Rust/page/3/">3</a></li><li><a class="pagination-link" href="/tags/Rust/page/4/">4</a></li><li><a class="pagination-link" href="/tags/Rust/page/5/">5</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.jpg" alt="Rossignol"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Rossignol</p><p class="is-size-6 is-block">NaN</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Mars</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives/"><p class="title">82</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories/"><p class="title">15</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags/"><p class="title">13</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/0xRossignol" target="_blank" rel="me noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/0xRossignol"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Golang/"><span class="level-start"><span class="level-item">Golang</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/Golang/basics/"><span class="level-start"><span class="level-item">basics</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/Java/basics/"><span class="level-start"><span class="level-item">basics</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/Java/basics/Thinking-in-Java/"><span class="level-start"><span class="level-item">Thinking in Java</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/Linux/Arch-Linux/"><span class="level-start"><span class="level-item">Arch Linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/OS/"><span class="level-start"><span class="level-item">OS</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Rust/"><span class="level-start"><span class="level-item">Rust</span></span><span class="level-end"><span class="level-item tag">48</span></span></a><ul><li><a class="level is-mobile" href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">Rust程序设计语言</span></span><span class="level-end"><span class="level-item tag">48</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/test/"><span class="level-start"><span class="level-item">test</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/toy-projects/"><span class="level-start"><span class="level-item">toy projects</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%85%AB%E8%82%A1/"><span class="level-start"><span class="level-item">八股</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%85%AB%E8%82%A1/JavaSE/"><span class="level-start"><span class="level-item">JavaSE</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%85%AB%E8%82%A1/Java%E9%9B%86%E5%90%88/"><span class="level-start"><span class="level-item">Java集合</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-06-27T12:30:26.000Z">2025-06-27</time></p><p class="title"><a href="/2025/06/27/Rust/The%20Rust%20Programming%20Language/13.4%20%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94%EF%BC%9A%E5%BE%AA%E7%8E%AF%20VS%20%E8%BF%AD%E4%BB%A3%E5%99%A8/">13.4 性能对比：循环 VS 迭代器</a></p><p class="categories"><a href="/categories/Rust/">Rust</a> / <a href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-06-27T10:30:26.000Z">2025-06-27</time></p><p class="title"><a href="/2025/06/27/Rust/The%20Rust%20Programming%20Language/13.3%20%E6%94%B9%E8%BF%9B%20IO%20%E9%A1%B9%E7%9B%AE/">13.3 改进 IO 项目</a></p><p class="categories"><a href="/categories/Rust/">Rust</a> / <a href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-06-08T14:20:26.000Z">2025-06-08</time></p><p class="title"><a href="/2025/06/08/Rust/The%20Rust%20Programming%20Language/14.5%20Cargo%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%89%A9%E5%B1%95%E5%91%BD%E4%BB%A4/">14.5 Cargo 自定义扩展命令</a></p><p class="categories"><a href="/categories/Rust/">Rust</a> / <a href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-06-08T14:10:26.000Z">2025-06-08</time></p><p class="title"><a href="/2025/06/08/Rust/The%20Rust%20Programming%20Language/14.4%20%E4%BD%BF%E7%94%A8%20cargo%20install%20%E5%AE%89%E8%A3%85%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6/">14.4 使用 cargo install 安装二进制文件</a></p><p class="categories"><a href="/categories/Rust/">Rust</a> / <a href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-06-08T14:00:26.000Z">2025-06-08</time></p><p class="title"><a href="/2025/06/08/Rust/The%20Rust%20Programming%20Language/14.3%20Cargo%20%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4/">14.3 Cargo 工作空间</a></p><p class="categories"><a href="/categories/Rust/">Rust</a> / <a href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2025/06/"><span class="level-start"><span class="level-item">六月 2025</span></span><span class="level-end"><span class="level-item tag">15</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/05/"><span class="level-start"><span class="level-item">五月 2025</span></span><span class="level-end"><span class="level-item tag">47</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/04/"><span class="level-start"><span class="level-item">四月 2025</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/03/"><span class="level-start"><span class="level-item">三月 2025</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/02/"><span class="level-start"><span class="level-item">二月 2025</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/12/"><span class="level-start"><span class="level-item">十二月 2024</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Arch-Linux/"><span class="tag">Arch Linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/English/"><span class="tag">English</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Golang/"><span class="tag">Golang</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OS/"><span class="tag">OS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Rust/"><span class="tag">Rust</span><span class="tag">48</span></a></div><div class="control"><a class="tags has-addons" href="/tags/git/"><span class="tag">git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/python/"><span class="tag">python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/test/"><span class="tag">test</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/toy-projects/"><span class="tag">toy projects</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%B8%AD%E6%96%87/"><span class="tag">中文</span><span class="tag">59</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%85%AB%E8%82%A1/"><span class="tag">八股</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BF%BB%E8%AF%91/"><span class="tag">翻译</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="MyBlog" height="28"></a><p class="is-size-7"><span>&copy; 2025 Rossignol</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>