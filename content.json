{"posts":[{"title":"Test","text":"Testit’s a test file for hexo","link":"/2024/12/21/test/Test/"},{"title":"test-pic","text":"test file for insert imgs","link":"/2024/12/21/test/test-pic/"},{"title":"Operating System pt.01","text":"Write your Own Operating System in 1 hour1. 准备四个文件1234kernel.cpplinker.ldloader.sMakefile 2. 编写Makefile12345678910111213141516GPPPARAMS = -m32ASPARAMS = --32LDPARAMS = -melf_i386objects = loader.o kernel.o%.o: %.cpp g++ $(GPPPARAMS) -o $@ -c $&lt;%.o: %.s as $(ASPARAMS) -o $@ $&lt;mykernel.bin: linker.ld $(objects) ld $(LDPARAMS) -T $&lt; -o $@ $(objects)install: mykernel.bin sudo cp $&lt; /boot/mykernel.bin 这段Makefile用于编译和链接一个简单的内核项目。它定义了如何从C++源文件、汇编源文件生成目标文件，并将这些目标文件链接成一个内核二进制文件。最后，它还定义了一个install目标，用于将生成的内核二进制文件复制到系统的/boot目录下。 1. 变量定义1234GPPPARAMS = -m32ASPARAMS = --32LDPARAMS = -melf_i386objects = loader.o kernel.o GPPPARAMS = -m32: 定义了一个变量GPPPARAMS，用于指定g++编译器的参数。-m32表示生成32位的代码。 ASPARAMS = --32: 定义了一个变量ASPARAMS，用于指定as汇编器的参数。--32表示生成32位的汇编代码。 LDPARAMS = -melf_i386: 定义了一个变量LDPARAMS，用于指定ld链接器的参数。-melf_i386表示生成32位的ELF格式的可执行文件。 objects = loader.o kernel.o: 定义了一个变量objects，包含了需要链接的目标文件列表。 2.编译C++源文件12%.o: %.cpp g++ $(GPPPARAMS) -o $@ -c $&lt; %.o: %.cpp: 这是一个模式规则，表示如何从.cpp文件生成对应的.o目标文件。 g++ $(GPPPARAMS) -o $@ -c $&lt;: 使用g++编译器编译.cpp文件。$(GPPPARAMS)展开为-m32，-o $@指定输出文件名为目标文件（即.o文件），-c表示只编译不链接，$&lt;表示第一个依赖文件（即.cpp文件）。 3.编译汇编源文件12%.o: %.s as $(ASPARAMS) -o $@ $&lt; %.o: %.s: 这是一个模式规则，表示如何从.s汇编文件生成对应的.o目标文件。 as $(ASPARAMS) -o $@ $&lt;: 使用as汇编器编译.s文件。$(ASPARAMS)展开为--32，-o $@指定输出文件名为目标文件（即.o文件），$&lt;表示第一个依赖文件（即.s文件）。 4.链接目标文件生成内核二进制文件 12mykernel.bin: linker.ld $(objects) ld $(LDPARAMS) -T $&lt; -o $@ $(objects) mykernel.bin: linker.ld $(objects): 定义了一个目标mykernel.bin，它依赖于linker.ld链接脚本和$(objects)中的目标文件。 ld $(LDPARAMS) -T $&lt; -o $@ $(objects): 使用ld链接器将目标文件链接成mykernel.bin。$(LDPARAMS)展开为-melf_i386，-T $&lt;指定链接脚本为linker.ld，-o $@指定输出文件名为mykernel.bin，$(objects)是要链接的目标文件列表。 安装内核二进制文件: 12install: mykernel.bin sudo cp $&lt; /boot/mykernel.bin install: mykernel.bin: 定义了一个目标install，它依赖于mykernel.bin。 sudo cp $&lt; /boot/mykernel.bin: 使用sudo权限将mykernel.bin复制到/boot目录下。$&lt;表示第一个依赖文件（即mykernel.bin）。 3.kernel.cpp12345void kernelMain(){ printf(&quot;Hello World!\\n&quot;); while(1);} 由于缺少printf函数的定义导致编译失败 4.loader.s1234567891011121314151617181920212223242526272829.set MAGIC, 0x1badb002.set FLAGS, (1&lt;&lt;0 | 1&lt;&lt;1).set CHECKSUM, -(MAGIC + FLAGS).section .multiboot .long MAGIC .long FLAGS .long CHECKSUM.section .text.extern kernelMain.global loaderloader: mov $kernel_stack, %esp push %eax push %ebx call kernelMain_stop: cli hlt jmp _stop.section .bss.space 2*1024*1024; # 2MBkernel_stack: 这段程序是一个简单的操作系统引导程序，使用了Multiboot标准来确保与兼容Multiboot的引导加载程序（如GRUB）兼容。以下是对这段程序的详细解释： 1. 定义常量123.set MAGIC, 0x1badb002.set FLAGS, (1&lt;&lt;0 | 1&lt;&lt;1).set CHECKSUM, -(MAGIC + FLAGS) MAGIC：这是一个魔数，值为 0x1badb002，用于标识这是一个Multiboot兼容的内核。引导加载程序会检查这个值来确定内核是否遵循Multiboot标准。 FLAGS：这是一个标志位，用于指定内核需要的特性。1&lt;&lt;0 表示要求引导加载程序在加载内核时提供内存布局信息，1&lt;&lt;1 表示要求提供引导设备信息。 CHECKSUM：这是一个校验和，用于验证Multiboot头的完整性。它的值是 -(MAGIC + FLAGS)，确保 MAGIC + FLAGS + CHECKSUM 的结果为0。 2. Multiboot头1234.section .multiboot .long MAGIC .long FLAGS .long CHECKSUM .section .multiboot：定义了一个名为 .multiboot 的节，用于存放Multiboot头。 .long MAGIC、.long FLAGS、.long CHECKSUM：分别将 MAGIC、FLAGS 和 CHECKSUM 的值写入Multiboot头。引导加载程序会读取这些值来验证内核的兼容性。 3. 代码段1234567891011121314.section .text.extern kernelMain.global loaderloader: mov $kernel_stack, %esp push %eax push %ebx call kernelMain_stop: cli hlt jmp _stop .section .text：定义了一个名为 .text 的节，用于存放代码。 .extern kernelMain：声明 kernelMain 是一个外部函数，通常这是操作系统内核的主函数。 .global loader：声明 loader 是一个全局符号，表示操作系统的入口点。 loader:：这是操作系统的入口点。引导加载程序在加载内核后会跳转到这个标签处执行。 mov $kernel_stack, %esp：将栈指针 esp 设置为 kernel_stack 的地址，初始化栈。 push %eax 和 push %ebx：将寄存器 eax 和 ebx 的值压入栈中。根据Multiboot标准，eax 包含魔数 0x2BADB002，ebx 包含Multiboot信息结构的地址。 call kernelMain：调用 kernelMain 函数，进入操作系统内核的主逻辑。 _stop:：这是一个无限循环，用于在 kernelMain 返回后停止CPU的执行。 cli：禁用中断。 hlt：使CPU进入休眠状态。 jmp _stop：跳转到 _stop 标签，形成一个无限循环。 4. 未初始化数据段123.section .bss.space 2*1024*1024; # 2MBkernel_stack: .section .bss：定义了一个名为 .bss 的节，用于存放未初始化的数据。 .space 2*1024*1024：在 .bss 节中分配了2MB的空间，用于内核栈。 kernel_stack:：这是内核栈的起始地址，loader 标签处的代码将栈指针 esp 设置为这个地址。 总结这段程序是一个简单的操作系统引导程序，它遵循Multiboot标准，确保与兼容Multiboot的引导加载程序（如GRUB）兼容。程序的主要功能是初始化栈，保存引导加载程序传递的参数，并跳转到操作系统内核的主函数 kernelMain。如果 kernelMain 返回，程序将进入一个无限循环，停止CPU的执行。 5. 编写自己的printf函数1234567void printf(char* str) { unsigned short* VideoMemory = (unsigned short*) 0xB8000; for(int i = 0; str[i] != '\\0'; ++i) { VideoMemory[i] = (VideoMemory[i] &amp; 0xFF00) | str[i]; }} 这段代码实现了一个简单的 printf 函数，用于在文本模式下将字符串输出到屏幕。它直接操作显存，将字符写入显存地址 0xB8000，这是x86架构中文本模式下的显存起始地址。以下是对代码的详细解释： 1. 函数定义1void printf(char* str) { 这是一个名为 printf 的函数，接受一个 char* 类型的参数 str，表示要输出的字符串。 2. 显存地址1unsigned short* VideoMemory = (unsigned short*) 0xB8000; 0xB8000 是x86架构中文本模式下的显存起始地址。在文本模式下，屏幕上的每个字符由两个字节表示： 低字节：字符的ASCII码。 高字节：字符的属性（如颜色、背景等）。 VideoMemory 是一个指向 unsigned short 类型的指针，每个 unsigned short（16位）对应屏幕上的一个字符。 将 0xB8000 强制转换为 unsigned short* 类型，表示从该地址开始，每两个字节对应屏幕上的一个字符。 3. 循环输出字符123for(int i = 0; str[i] != '\\0'; ++i) { VideoMemory[i] = (VideoMemory[i] &amp; 0xFF00) | str[i];} 这是一个 for 循环，用于遍历字符串 str 中的每个字符，直到遇到字符串结束符 \\0。 对于每个字符 str[i]： VideoMemory[i] &amp; 0xFF00：保留当前显存位置的高字节（属性部分），清除低字节（字符部分）。 | str[i]：将字符 str[i] 的ASCII码写入低字节。 最终结果是将字符 str[i] 写入显存，同时保留原有的属性（如颜色）。 4. 显存写入的细节 在文本模式下，显存的每个字符由两个字节组成： 低字节：字符的ASCII码。 高字节：字符的属性（如前景色、背景色等）。 例如，如果 VideoMemory[i] 的当前值是 0x0720： 0x07 是属性（灰色前景，黑色背景）。 0x20 是字符（空格）。 如果 str[i] 是字符 A（ASCII码为 0x41），则： VideoMemory[i] = (0x0720 &amp; 0xFF00) | 0x41 的结果是 0x0741。 屏幕上的对应位置会显示字符 A，颜色为灰色前景，黑色背景。 6.linker.ld123456789101112131415161718192021222324252627282930313233343536ENTRY(loader)OUTPUT_FORMAT(elf32-i386)OUTPUT_ARCH(i386:i386)SECTIONS{ . = 0x0100000; .text : { *(.mutiboot) *(.text*) *(.rodata) } .data : { start_ctors = .; KEEP(*( .init_array )); KEEP(*(SORT_BY_INIT_PRIORITY( .init_array*))); end_ctors = .; *(.data) } .bss : { *(.bss) } /DISCARD/ : { *(.fini_array*) *(.comment) }} 这是一个链接器脚本（Linker Script），用于定义操作系统内核的内存布局和段（Section）的组织方式。它指定了内核的入口点、输出格式、架构以及各个段（如 .text、.data、.bss 等）的加载地址和顺序。以下是对脚本的详细解释： 1. 入口点和输出格式123ENTRY(loader)OUTPUT_FORMAT(elf32-i386)OUTPUT_ARCH(i386:i386) **ENTRY(loader)**：指定程序的入口点为 loader 符号。这是操作系统内核的启动代码，通常是引导加载程序（如 GRUB）跳转到的第一个函数。 **OUTPUT_FORMAT(elf32-i386)**：指定输出文件的格式为 32 位 ELF 格式，适用于 x86 架构。 **OUTPUT_ARCH(i386:i386 )**：指定输出文件的架构为 32 位 x86（i386）。 2. 内存布局123SECTIONS{ . = 0x0100000; SECTIONS：定义内存布局的起始。 . = 0x0100000：设置当前地址为 0x0100000（1 MB）。这是内核加载的起始地址，通常用于操作系统内核的加载地址。 3. .text 段123456.text :{ *(.mutiboot) *(.text*) *(.rodata)} .text：定义代码段（.text），包含可执行代码和只读数据。 ***(.mutiboot)**：包含所有输入文件中的 .multiboot 段（Multiboot 头）。 ***(.text*)**：包含所有输入文件中的代码段（.text 及其变体）。 ***(.rodata)**：包含所有输入文件中的只读数据段（.rodata）。 4. .data 段123456789.data :{ start_ctors = .; KEEP(*( .init_array )); KEEP(*(SORT_BY_INIT_PRIORITY( .init_array*))); end_ctors = .; *(.data)} .data：定义数据段（.data），包含已初始化的全局变量和静态变量。 **start_ctors = .;**：定义一个符号 start_ctors，表示构造函数（全局对象的构造函数）的起始地址。 **KEEP(*( .init_array ))**：保留所有输入文件中的 .init_array 段，用于存放全局对象的构造函数指针。 **KEEP(*(SORT_BY_INIT_PRIORITY( .init_array* )))**：保留所有输入文件中的 .init_array* 段，并按初始化优先级排序。 **end_ctors = .;**：定义一个符号 end_ctors，表示构造函数的结束地址。 ***(.data)**：包含所有输入文件中的数据段（.data）。 5. .bss 段1234.bss :{ *(.bss)} .bss：定义未初始化数据段（.bss），包含未初始化的全局变量和静态变量。 ***(.bss)**：包含所有输入文件中的 .bss 段。 6. 丢弃的段12345/DISCARD/ : { *(.fini_array*) *(.comment)} **/DISCARD/**：定义需要丢弃的段。 ***(.fini_array*)**：丢弃所有输入文件中的 .fini_array* 段（析构函数表）。 ***(.comment)**：丢弃所有输入文件中的 .comment 段（注释信息）。 7. 总结这个链接器脚本的主要功能是： 定义内核的入口点为 loader。 指定输出文件为 32 位 ELF 格式，适用于 x86 架构。 设置内核的加载地址为 0x0100000（1 MB）。 组织代码段（.text）、数据段（.data）和未初始化数据段（.bss）的内存布局。 保留构造函数表（.init_array），丢弃析构函数表（.fini_array）和注释信息（.comment）。 8. 关键点 Multiboot 头：.multiboot 段必须位于内核的最开始，以便引导加载程序（如 GRUB）能够正确识别内核。 构造函数和析构函数：.init_array 和 .fini_array 用于全局对象的构造和析构。操作系统内核通常不需要析构函数，因此丢弃 .fini_array。 内存布局：内核的加载地址和段的组织方式对操作系统的正常运行至关重要。 9. 示例内核的加载过程 引导加载程序（如 GRUB）将内核加载到 0x0100000 地址。 跳转到 loader 入口点，开始执行内核代码。 内核的代码段、数据段和未初始化数据段按照链接器脚本的定义进行布局。 全局对象的构造函数在启动时被调用（通过 .init_array）。 通过这个链接器脚本，操作系统内核可以正确地加载到内存中，并按照预期的布局运行。 7.kernelMain函数修改12345extern &quot;C&quot; void kernelMain(void* multiboot_structure, unsigned int magicnumber) { printf(&quot;Hello World!\\n&quot;); while(1);} extern &quot;C&quot; 是 C++ 中的一个关键字，用于指定函数使用 C 语言的链接规则（linkage）。它的主要作用是防止 C++ 编译器对函数名进行名称修饰（name mangling），从而确保函数名在编译后的目标文件中保持原样，以便与 C 代码或其他外部代码正确链接。 1. C++ 的名称修饰（Name Mangling）在 C++ 中，函数名在编译时会被编译器修饰（mangled），以支持函数重载和其他 C++ 特性。例如，一个函数 void foo(int) 可能会被修饰为 _Z3fooi。这种修饰后的名称包含了函数的参数类型和返回类型信息。 然而，C 语言没有名称修饰的概念。C 编译器会直接使用函数名作为符号名。因此，如果 C++ 代码需要与 C 代码或其他外部代码（如汇编代码或操作系统引导加载程序）交互，就需要使用 extern &quot;C&quot; 来禁用名称修饰。 2. extern &quot;C&quot; 的作用extern &quot;C&quot; 的作用是告诉 C++ 编译器： 按照 C 语言的规则处理函数的链接。 不进行名称修饰，直接使用函数名作为符号名。 8. 修改grub.cfg123456### BEGIN MYKERNEL ###menuentry 'My Operating System'{ mutiboot /boot/mykernel.bin boot}### END MYKERNEL ### 这段代码是一个 GRUB 引导加载程序的配置文件片段，用于定义一个名为 “My Operating System” 的菜单项，并指定如何加载和启动你的操作系统内核（mykernel.bin）。以下是对这段配置的详细解释： 1. 配置文件的作用GRUB（Grand Unified Bootloader）是一个常用的引导加载程序，用于加载操作系统内核。GRUB 的配置文件（通常是 /boot/grub/grub.cfg 或 /boot/grub2/grub.cfg）定义了启动菜单和启动选项。 这段代码是 GRUB 配置文件的一部分，用于添加一个自定义的启动项，加载你的操作系统内核。 2. 配置内容解析123456### BEGIN MYKERNEL ###menuentry 'My Operating System'{ multiboot /boot/mykernel.bin boot}### END MYKERNEL ### (1) ### BEGIN MYKERNEL ### 和 ### END MYKERNEL ### 这是注释，用于标记配置文件的开始和结束。GRUB 会忽略这些注释。 它们的作用是帮助开发者识别和区分不同的配置块。 (2) menuentry 'My Operating System' { ... } menuentry 是 GRUB 配置中的一个关键字，用于定义一个启动菜单项。 'My Operating System' 是菜单项的名称，显示在 GRUB 启动菜单中。 { ... } 中是菜单项的具体配置。 (3) multiboot /boot/mykernel.bin multiboot 是 GRUB 的一个命令，用于加载符合 Multiboot 规范 的内核文件。 /boot/mykernel.bin 是你的操作系统内核文件的路径。GRUB 会从文件系统中加载这个文件。 /boot/ 是内核文件通常存放的目录。 mykernel.bin 是你的内核文件名。 (4) boot boot 是 GRUB 的一个命令，用于启动已加载的内核。 执行 boot 后，GRUB 会将控制权交给内核，开始操作系统的启动过程。 9.Addendum12345678typedef void (*constructor)();extern &quot;C&quot; constructor start_ctors;extern &quot;C&quot; constructor end_ctors;extern &quot;C&quot; void callConstructors() { for(constructor* i = &amp;start_ctors; i != &amp;end_ctors; i++) { (*i)(); }} 12345678910111213.section .text.extern kernelMain.extern callConstructors.global loaderloader: mov $kernel_stack, %esp call callConstructors push %eax push %ebx call kernelMain 这段代码是操作系统内核启动代码的一部分，主要用于调用全局对象的构造函数（constructors），然后跳转到内核的主函数 kernelMain。以下是对代码的详细解释： 1. 构造函数指针类型1typedef void (*constructor)(); 定义了一个函数指针类型 constructor，指向一个没有参数和返回值的函数。 这种类型的函数通常用于全局对象的构造函数。 2. 外部符号声明12extern &quot;C&quot; constructor start_ctors;extern &quot;C&quot; constructor end_ctors; start_ctors 和 end_ctors 是两个外部符号，分别表示构造函数表的起始和结束地址。 这些符号通常在链接器脚本中定义，用于标记全局构造函数表的范围。 extern &quot;C&quot; 用于禁用 C++ 的名称修饰（name mangling），确保符号名在链接时保持一致。 3. 调用构造函数12345extern &quot;C&quot; void callConstructors() { for(constructor* i = &amp;start_ctors; i != &amp;end_ctors; i++) { (*i)(); }} callConstructors 是一个函数，用于遍历构造函数表并调用每个构造函数。 start_ctors 和 end_ctors 分别指向构造函数表的起始和结束地址。 通过 for 循环遍历构造函数表，依次调用每个构造函数。 4. 汇编代码12345678910111213.section .text.extern kernelMain.extern callConstructors.global loaderloader: mov $kernel_stack, %esp call callConstructors push %eax push %ebx call kernelMain (1) .section .text 定义代码段（.text），用于存放可执行代码。 (2) .extern kernelMain 和 .extern callConstructors 声明 kernelMain 和 callConstructors 是外部符号，分别表示内核的主函数和构造函数调用函数。 (3) .global loader 声明 loader 是一个全局符号，表示操作系统的入口点。 (4) loader: 这是操作系统的入口点，引导加载程序（如 GRUB）会跳转到这个标签处执行。 (5) mov $kernel_stack, %esp 将栈指针 esp 设置为 kernel_stack 的地址，初始化栈。 kernel_stack 是一个符号，通常在链接器脚本中定义，表示内核栈的起始地址。 (6) call callConstructors 调用 callConstructors 函数，遍历并调用所有全局对象的构造函数。 (7) push %eax 和 push %ebx 将寄存器 eax 和 ebx 的值压入栈中。 根据 Multiboot 规范，eax 包含魔数 0x2BADB002，ebx 包含 Multiboot 信息结构的地址。 (8) call kernelMain 调用 kernelMain 函数，进入操作系统内核的主逻辑。 5. 链接器脚本中的构造函数表在链接器脚本中，通常会定义 start_ctors 和 end_ctors 符号，用于标记构造函数表的范围。例如： 12345678910111213141516171819202122232425SECTIONS{ . = 0x0100000; .text : { *(.multiboot) *(.text*) } .data : { start_ctors = .; KEEP(*(.init_array)); KEEP(*(SORT_BY_INIT_PRIORITY(.init_array.*))); end_ctors = .; *(.data) } .bss : { *(.bss) }} start_ctors 和 end_ctors 分别指向 .init_array 段的起始和结束地址。 .init_array 段存放全局对象的构造函数指针。 6. 总结这段代码的主要功能是： 定义构造函数指针类型 constructor。 声明外部符号 start_ctors 和 end_ctors，表示构造函数表的范围。 实现 callConstructors 函数，遍历并调用所有全局对象的构造函数。 在汇编代码中，初始化栈，调用构造函数，然后跳转到内核的主函数 kernelMain。 通过这种方式，操作系统内核可以在启动时正确初始化全局对象，然后进入主逻辑。","link":"/2025/01/10/Write%20your%20own%20Operating%20System/Operating-System-pt-1/"},{"title":"goByExample pt.2","text":"FunctionsGo by Example: Functions 1234567891011121314151617181920package mainimport &quot;fmt&quot;func plus(a, b int) int { return a + b}func plusPlus(a, b, c int) int { return a + b + c}func main(){ res := plus(1, 2) fmt.Println(&quot;1 + 2 =&quot;, res) res = plusPlus(1, 2, 3) fmt.Println( &quot;1 + 2 + 3 =&quot;, res)} Functions are central (核心/中心) in Go. We’ll learn about functions with a few different examples. Here’s a function that takes two ints and returns their sum as an int. Go requires explicit returns, i.e. (即 ) it won’t automatically return the value of the last expression. When you have multiple consecutive (连续的 ) parameters of the same type, you may omit (省略 ) the type name for the like-typed (相同类型的 ) parameters up to the final parameter that declares the type. Call a function just as you’d expect, with name(args). There are several other features to Go functions. One is multiple return values, which we’ll look at next. 123goByExample&gt; go run .\\11.functions.go1 + 2 = 31 + 2 + 3 = 6 Multiple Return ValuesGo by Example: Multiple Return Values 1234567891011121314151617package mainimport &quot;fmt&quot;func vals() (int, int) { return 3, 7}func main() { a, b := vals() fmt.Println(a) fmt.Println(b) _, c := vals() fmt.Println(c)} Go has built-in support for multiple return values. This feature is used often in idiomatic Go (这个特性在 Go 语言中经常用到), for example to return both result and error values from a function. The (int, int) in this function signature shows that the function returns 2 ints. Here we use the 2 different return values from the call with multiple assignment (多赋值操作). If you only want a subset (子集 / 一部分) of the returned values, use the blank identifier _. Accepting a variable (可变的 ) number of arguments is another nice feature of Go functions; we’ll look at this next. 1234goByExample&gt; go run '.\\12.multiple return values.go'377 Variadic FunctionsGo by Example: Variadic Functions 12345678910111213141516171819202122package mainimport &quot;fmt&quot;func sum(nums ...int) { fmt.Print(nums, &quot; &quot;) total := 0 for _, num := range nums { total += num } fmt.Println(total)}func main() { sum(1, 2) sum(1, 2, 3) nums := []int{1, 2, 3, 4} sum(nums...)} Variadic functions can be called with any number of trailing (尾随 ) arguments. For example, fmt.Println is a common variadic function. Here’s a function that will take an arbitrary (随意的 ) number of ints as arguments. Within the function, the type of nums is equivalent to []int. We can call len(nums), iterate over it with range, etc. for _, num := range nums 解释： range 表达式通常返回两个值：一个是索引，另一个是值。在这段代码中 第一个值是数组 nums 中每个元素的索引。 第二个值是数组中相应位置的元素值。 Variadic functions can be called in the usual way with individual arguments. If you already have multiple args in a slice, apply them to a variadic function using func(slice...) like this. Another key aspect of functions in Go is their ability to form closures (闭包 ) , which we’ll look at next. 1234goByExample&gt; go run '.\\13.Variadic Functions.go' [1 2] 3[1 2 3] 6[1 2 3 4] 10 ClosuresGo by Example: Closures 1234567891011121314151617181920212223package mainimport &quot;fmt&quot;func intSeq() func() int { i := 0 return func() int { i++ return i }}func main() { nextInt := intSeq() fmt.Println(nextInt()) fmt.Println(nextInt()) fmt.Println(nextInt()) newInts := intSeq() fmt.Println(newInts())} Go supports anonymous functions, which can form closures. Anonymous functions are useful when you want to define a function inline without having to name it. This function intSeq returns another function, which we define anonymously in the body of intSeq. The returned function closes over the variable i to form a closure. We call intSeq, assigning the result (a function) to nextInt. This function value captures its own i value, which will be updated each time we call nextInt. See the effect of the closure by calling nextInt a few times. To confirm that the state is unique to that particular function, create and test a new one. The last feature of functions we’ll look at for now is recursion. 12345goByExample&gt; go run '.\\14.closures.go' 1231 RecursionGo by Example: Recursion 1234567891011121314151617181920212223242526package mainimport &quot;fmt&quot;func fact(n int) int { if n == 0 { return 1 } return n * fact(n-1)}func main() { fmt.Println(fact(7)) var fib func(n int) int fib = func(n int) int { if n &lt; 2 { return n } return fib(n-1) + fib(n-2) } fmt.Println(fib(7))} Go supports recursive functions. Here’s a classic example. This fact function calls itself until it reaches the base case of fact(0). Anonymous functions can also be recursive, but this requires explicitly declaring a variable with var to store the function before it’s defined. Since fib was previously declared in main, Go knows which function to call with fib here. 123goByExample&gt; go run '.\\15.recursion.go'504013 Range over Built-in TypesGo by Example: Range over Built-in Types 1234567891011121314151617181920212223242526272829303132package mainimport &quot;fmt&quot;func main() { nums := []int{2, 3, 4} sum := 0 for _, num := range nums { sum += num } fmt.Println(&quot;sum:&quot;, sum) for i, num := range nums { if num == 3 { fmt.Println(&quot;index:&quot;, i) } } kvs := map[string]string{&quot;a&quot;: &quot;apple&quot;, &quot;b&quot;: &quot;banana&quot;} for k, v := range kvs { fmt.Printf(&quot;%s -&gt; %s\\n&quot;, k, v) } for k := range kvs { fmt.Println(&quot;key:&quot;, k) } for i, c := range &quot;go&quot; { fmt.Println(i, c) }} range iterates over elements in a variety of built-in data structures. Let’s see how to use range with some of the data structures we’ve already learned. Here we use range to sum the numbers in a slice. Arrays work like this too. range on arrays and slices provides both the index and value for each entry. Above we didn’t need the index, so we ignored it with the blank identifier _. Sometimes we actually want the indexes though. range on map iterates over key/value pairs. range can also iterate over just the keys of a map. range on strings iterates over Unicode code points. The first value is the starting byte index of the rune and the second the rune itself. See [Strings and Runes](##Strings and Runes) for more details. 123456789goByExample&gt; go run '.\\16.Range over Built-in Types.go'sum: 9index: 1a -&gt; appleb -&gt; bananakey: akey: b0 1031 111 PointersGo by Example: Pointers 123456789101112131415161718192021222324package mainimport &quot;fmt&quot;func zeroval(ival int) { ival = 0}func zeroptr(iptr *int) { *iptr = 0}func main() { i := 1 fmt.Println(&quot;initial:&quot;, i) zeroval(i) fmt.Println(&quot;zeroval:&quot;, i) zeroptr(&amp;i) fmt.Println(&quot;zeroptr:&quot;, i) fmt.Println(&quot;pointer:&quot;, &amp;i)} Go supports pointers, allowing you to pass references to values and records within your program. We’ll show how pointers work in contrast to values with 2 functions: zeroval and zeroptr. zeroval has an int parameter, so arguments will be passed to it by value. zeroval will get a copy of ival distinct from the one in the calling function. zeroptr in contrast has an *int parameter, meaning that it takes an int pointer. The *iptr code in the function body then dereferences the pointer from its memory address to the current value at that address. Assigning a value to a dereferenced pointer changes the value at the referenced address. The &amp;i syntax gives the memory address of i, i.e. a pointer to i. Pointers can be printed too. zeroval doesn’t change the i in main, but zeroptr does because it has a reference to the memory address for that variable. 12345goByExample&gt; go run '.\\17.pointers.go' initial: 1zeroval: 1zeroptr: 0pointer: 0xc00000a0d8 Strings and RunesGo by Example: Strings and Runes 123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport ( &quot;fmt&quot; &quot;unicode/utf8&quot;)func main() { const s = &quot;สวัสดี&quot; fmt.Println(&quot;Len:&quot;, len(s)) for i := 0; i &lt; len(s); i++ { fmt.Printf(&quot;%x &quot;, s[i]) } fmt.Println() fmt.Println(&quot;Rune count:&quot;, utf8.RuneCountInString(s)) for idx, runeValue := range s { fmt.Printf(&quot;%#U starts at %d\\n&quot;, runeValue, idx) } fmt.Println(&quot;\\nUsing DecodeRuneInString&quot;) for i, w := 0, 0; i &lt; len(s); i += w { runeValue, width := utf8.DecodeRuneInString(s[i:]) fmt.Printf(&quot;%#U starts at %d\\n&quot;, runeValue, i) w = width examineRune(runeValue) }}func examineRune(r rune) { if r == 't' { fmt.Println(&quot;found tee&quot;) } else if r == 'ส' { fmt.Println(&quot;found so sua&quot;) }} A Go string is a read-only slice of bytes. The language and the standard library treat strings specially - as containers of text encoded in UTF-8. In other languages, strings are made of “characters”. In Go, the concept of a character is called a rune - it’s an integer that represents a Unicode code point. This Go blog post (maybe another blog) is a good introduction to the topic. s is a string assigned a literal value representing the word “hello” in the Thai language. Go string literals are UTF-8 encoded text. Since strings are equivalent to []byte, this will produce the length of the raw bytes stored within. 因为字符串等价于 []byte， 这会产生存储在其中的原始字节的长度。 Indexing into a string produces the raw byte values at each index. This loop generates the hex values of all the bytes that constitute the code points in s. To count how many runes are in a string, we can use the utf8 package. Note that the run-time of RuneCountInString depends on the size of the string, because it has to decode each UTF-8 rune sequentially. Some Thai characters are represented by UTF-8 code points that can span multiple bytes, so the result of this count may be surprising. 要计算字符串中有多少rune，我们可以使用utf8包。 注意RuneCountInString的运行时取决于字符串的大小。 因为它必须按顺序解码每个 UTF-8 rune。 一些泰语字符由多个 UTF-8 code point 表示， 所以这个计数的结果可能会令人惊讶。 A range loop handles strings specially and decodes each rune along with its offset in the string. We can achieve the same iteration by using the utf8.DecodeRuneInString function explicitly. This demonstrates passing a rune value to a function. Values enclosed in single quotes are rune literals. We can compare a rune value to a rune literal directly. 1234567891011121314151617181920goByExample&gt; go run '.\\18.Strings and Runes.go'Len: 18e0 b8 aa e0 b8 a7 e0 b8 b1 e0 b8 aa e0 b8 94 e0 b8 b5Rune count: 6U+0E2A 'ส' starts at 0U+0E27 'ว' starts at 3U+0E31 'ั' starts at 6U+0E2A 'ส' starts at 9U+0E14 'ด' starts at 12U+0E35 'ี' starts at 15Using DecodeRuneInStringU+0E2A 'ส' starts at 0found so suaU+0E27 'ว' starts at 3U+0E31 'ั' starts at 6U+0E2A 'ส' starts at 9found so suaU+0E14 'ด' starts at 12U+0E35 'ี' starts at 15 StructsGo by Example: Structs 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package mainimport &quot;fmt&quot;type person struct { name string age int}func newPerson(name string) *person { p := person{name: name} p.age = 42 return &amp;p}func main() { fmt.Println(person{&quot;Bob&quot;, 20}) fmt.Println(person{name: &quot;Alice&quot;, age: 30}) fmt.Println(person{name: &quot;Fred&quot;}) fmt.Println(&amp;person{name: &quot;Ann&quot;, age: 40}) fmt.Println(newPerson(&quot;Jon&quot;)) s := person{name: &quot;Sean&quot;, age: 50} fmt.Println(s.name) sp := &amp;s fmt.Println(sp.age) sp.age = 51 fmt.Println(sp.age) dog := struct { name string isGood bool }{ &quot;Rex&quot;, true, } fmt.Println(dog)} Go’s structs are typed collections of fields. They’re useful for grouping data together to form records. This person struct type has name and age fields. newPerson constructs a new person struct with the given name. Go is a garbage collected language; you can safely return a pointer to a local variable - it will only be cleaned up by the garbage collector when there are no active references to it. This syntax creates a new struct. You can name the fields when initializing a struct. Omitted fields will be zero-valued. An &amp; prefix yields a pointer to the struct. It’s idiomatic to encapsulate new struct creation in constructor functions 在构造函数中封装创建新的结构实例是一种习惯用法 Access struct fields with a dot. You can also use dots with struct pointers - the pointers are automatically dereferenced. Structs are mutable (可变的 ). If a struct type is only used for a single value, we don’t have to give it a name. The value can have an anonymous struct type. This technique is commonly used for table-driven tests (goByExample pt.8). 12345678910goByExample&gt; go run '.\\19.structs.go' {Bob 20}{Alice 30}{Fred 0}&amp;{Ann 40}&amp;{Jon 42}Sean5051{Rex true} MethodsGo by Example: Methods 1234567891011121314151617181920212223242526package mainimport &quot;fmt&quot;type rect struct { width, height int}func (r *rect) area() int { return r.width * r.height}func (r rect) perim() int { return 2*r.width + 2*r.height}func main() { r := rect{width: 10, height: 5} fmt.Println(&quot;area: &quot;, r.area()) fmt.Println(&quot;perim:&quot;, r.perim()) rp := &amp;r fmt.Println(&quot;area: &quot;, rp.area()) fmt.Println(&quot;perim:&quot;, rp.perim())} Go supports methods defined on struct types. This area method has a receiver type of *rect. Methods can be defined for either pointer or value receiver types. Here’s an example of a value receiver. Here we call the 2 methods defined for our struct. Go automatically handles conversion between values and pointers for method calls. You may want to use a pointer receiver type to avoid copying on method calls or to allow the method to mutate the receiving struct. Next we’ll look at Go’s mechanism (机制 ) for grouping and naming related sets of methods: interfaces. 12345goByExample&gt; go run '.\\20.Methods.go'area: 50perim: 30area: 50perim: 30","link":"/2024/12/23/goByExample/goByExample-pt-2/"},{"title":"goByExample pt.3","text":"InterfacesGo by Example: Interfaces 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package mainimport ( &quot;fmt&quot; &quot;math&quot;)type geometry interface { area() float64 perim() float64}type rect struct { width, height float64}type circle struct { radius float64}func (r rect) area() float64 { return r.width * r.height}func (r rect) perim() float64 { return 2*r.width + 2*r.height}func (c circle) area() float64 { return math.Pi * c.radius * c.radius}func (c circle) perim() float64 { return 2 * math.Pi * c.radius}func measure(g geometry) { fmt.Println(g) fmt.Println(g.area()) fmt.Println(g.perim())}func main() { r := rect{width: 3, height: 4} c := circle{radius: 5} measure(r) measure(c)} Interfaces are named collections of method signatures. Here’s a basic interface for geometric shapes. For our example we’ll implement this interface on rect and circle types. To implement an interface in Go, we just need to implement all the methods in the interface. Here we implement geometry on rects. The implementation for circles. If a variable has an interface type, then we can call methods that are in the named interface. Here’s a generic measure function taking advantage of this to work on any geometry. The circle and rect struct types both implement the geometry interface so we can use instances of these structs as arguments to measure. To learn more about Go’s interfaces, check out this great blog post (maybe another blog). 1234567goByExample&gt; go run .\\21.Interfaces.go{3 4}1214{5}78.5398163397448331.41592653589793 EnumsGo by Example: Enums 1234567891011121314151617181920212223242526272829303132333435363738394041424344package mainimport &quot;fmt&quot;type ServerState intconst ( StateIdle ServerState = iota StateConnected StateError StateRetrying)var stateName = map[ServerState]string{ StateIdle: &quot;idle&quot;, StateConnected: &quot;connected&quot;, StateError: &quot;error&quot;, StateRetrying: &quot;retrying&quot;,}func (ss ServerState) String() string { return stateName[ss]}func main() { ns := transition(StateIdle) fmt.Println(ns) ns2 := transition(ns) fmt.Println(ns2)}func transition(s ServerState) ServerState { switch s { case StateIdle: return StateConnected case StateConnected, StateRetrying: return StateIdle case StateError: return StateError default: panic(fmt.Errorf(&quot;unknown state: %s&quot;, s)) }} Enumerated types (enums) are a special case of sum types. An enum is a type that has a fixed number of possible values, each with a distinct name. Go doesn’t have an enum type as a distinct language feature, but enums are simple to implement using existing language idioms. Our enum type ServerState has an underlying int type. The possible values for ServerState are defined as constants. The special keyword iota generates successive (连续 ) constant values automatically; in this case 0, 1, 2 and so on. 特殊关键字 iota 自动生成连续的常量值；在本例中为 0、1、2 等等。 By implementing the fmt.Stringer interface, values of ServerState can be printed out or converted to strings. 通过实现 fmt.Stringer 接口，可以打印出 ServerState 的值或将其转换为字符串。 This can get cumbersome (繁琐 ) if there are many possible values. In such cases the [stringer tool](###stringer tool) can be used in conjunction with go:generate to automate the process. See this post(maybe another blog) for a longer explanation. 如果可能的值太多，这可能会变得很麻烦。在这种情况下，stringer 工具可以与 go:generate 结合使用来自动化该过程。 If we have a value of type int, we cannot pass it to transition - the compiler will complain about type mismatch. This provides some degree of compile-time type safety for enums. transition emulates a state transition for a server; it takes the existing state and returns a new state. Suppose we check some predicates here to determine the next state… 123goByExample&gt; go run .\\22.Enums.go connectedidle Struct EmbeddingGo by Example: Struct Embedding 123456789101112131415161718192021222324252627282930313233343536373839package mainimport &quot;fmt&quot;type base struct { num int}func (b base) describe() string { return fmt.Sprintf(&quot;base with num=%v&quot;, b.num)}type container struct { base str string}func main() { co := container{ base: base{ num: 1, }, str: &quot;some name&quot;, } fmt.Printf(&quot;co={num: %v, str: %v}\\n&quot;, co.num, co.str) fmt.Println(&quot;also num:&quot;, co.base.num) fmt.Println(&quot;describe:&quot;, co.describe()) type describer interface { describe() string } var d describer = co fmt.Println(&quot;describer:&quot;, d.describe())} Go supports embedding (嵌入 ) of structs and interfaces to express a more seamless (无缝的 ) composition of types. This is not to be confused with //go:embed which is a go directive introduced (go 指令 ) in Go version 1.16+ to embed files and folders into the application binary. A container embeds a base. An embedding looks like a field without a name. When creating structs with literals, we have to initialize the embedding explicitly; here the embedded type serves as the field name. We can access the base’s fields directly on co, e.g. co.num. Alternatively, we can spell out the full path using the embedded type name. Since container embeds base, the methods of base also become methods of a container. Here we invoke a method that was embedded from base directly on co. Embedding structs with methods may be used to bestow (赋予 ) interface implementations onto other structs. Here we see that a container now implements the describer interface because it embeds base. 12345goByExample&gt; go run '.\\23.Struct Embedding.go'co={num: 1, str: some name}also num: 1describe: base with num=1describer: base with num=1 Generics(泛型)Go by Example: Generics 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package mainimport &quot;fmt&quot;func SlicesIndex[S ~[]E, E comparable](s S, v E) int { for i := range s { if v == s[i] { return i } } return -1}type List[T any] struct { head, tail *element[T]}type element[T any] struct { next *element[T] val T}func (lst *List[T]) Push(v T) { if lst.tail == nil { lst.head = &amp;element[T]{val: v} lst.tail = lst.head } else { lst.tail.next = &amp;element[T]{val: v} lst.tail = lst.tail.next }}func (lst *List[T]) AllElements() []T { var elems []T for e := lst.head; e != nil; e = e.next { elems = append(elems, e.val) } return elems}func main() { var s = []string{&quot;foo&quot;, &quot;bar&quot;, &quot;zoo&quot;} fmt.Println(&quot;index of zoo:&quot;, SlicesIndex(s, &quot;zoo&quot;)) _ = SlicesIndex[[]string, string](s, &quot;zoo&quot;) lst := List[int]{} lst.Push(10) lst.Push(13) lst.Push(23) fmt.Println(&quot;list:&quot;, lst.AllElements())} Starting with version 1.18, Go has added support for generics, also known as type parameters. As an example of a generic function, SlicesIndex takes a slice of any comparable type and an element of that type and returns the index of the first occurrence of v in s, or -1 if not present. The comparable constraint means that we can compare values of this type with the == and != operators. For a more thorough explanation of this type signature, see this blog post (maybe another blog). Note that this function exists in the standard library as slices.Index. As an example of a generic type, List is a singly-linked list with values of any type. We can define methods on generic types just like we do on regular types, but we have to keep the type parameters in place. The type is List[T], not List. AllElements returns all the List elements as a slice. In the next example we’ll see a more idiomatic way of iterating over all elements of custom types. When invoking generic functions, we can often rely on type inference. Note that we don’t have to specify the types for S and E when calling SlicesIndex - the compiler infers them automatically. … though we could also specify them explicitly. 123goByExample&gt; go run '.\\24.generics.go' index of zoo: 2list: [10 13 23] Range over IteratorsGo by Example: Range over Iterators 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package mainimport ( &quot;fmt&quot; &quot;iter&quot; &quot;slices&quot;)type List[T any] struct { head, tail *element[T]}type element[T any] struct { next *element[T] val T}func (lst *List[T]) Push(v T) { if lst.tail == nil { lst.head = &amp;element[T]{val: v} lst.tail = lst.head } else { lst.tail.next = &amp;element[T]{val: v} lst.tail = lst.tail.next }}func (lst *List[T]) All() iter.Seq[T] { return func(yield func(T) bool) { for e := lst.head; e != nil; e = e.next { if !yield(e.val) { return } } }}func genFib() iter.Seq[int] { return func(yield func(int) bool) { a, b := 1, 1 for { if !yield(a) { return } a, b = b, a+b } }}func main() { lst := List[int]{} lst.Push(10) lst.Push(13) lst.Push(23) for e := range lst.All() { fmt.Println(e) } all := slices.Collect(lst.All()) fmt.Println(&quot;all:&quot;, all) for n := range genFib() { if n &gt;= 10 { break } fmt.Println(n) }} Starting with version 1.23, Go has added support for iterators, which lets us range over pretty much anything! Let’s look at the List type from the previous example again. In that example we had an AllElements method that returned a slice of all elements in the list. With Go iterators, we can do it better - as shown below. All returns an iterator, which in Go is a function with a special signature. The iterator function takes another function as a parameter, called yield by convention (but the name can be arbitrary). It will call yield for every element we want to iterate over, and note yield’s return value for a potential early termination. 迭代器函数将另一个函数作为参数，按照惯例称为yield（但名称可以任意）。它将为我们想要迭代的每个元素调用yield，并记录yield的返回值以防可能提前终止。 Iteration doesn’t require an underlying data structure, and doesn’t even have to be finite! Here’s a function returning an iterator over Fibonacci numbers: it keeps running as long as yield keeps returning true. 迭代不需要底层数据结构，甚至不必是有限的！这是一个返回斐波那契数列迭代器的函数：只要yield一直返回true，它就会一直运行。 Since List.All returns an iterator, we can use it in a regular range loop. Packages like slices have a number of useful functions to work with iterators. For example, Collect takes any iterator and collects all its values into a slice. Once the loop hits break or an early return, the yield function passed to the iterator will return false. 1234567891011goByExample&gt; go run '.\\25.Range over Iterators.go'101323all: [10 13 23]112358 ErrorsGo by Example: Errors 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package mainimport ( &quot;errors&quot; &quot;fmt&quot;)func f(arg int) (int, error) { if arg == 42 { return -1, errors.New(&quot;can't work with 42&quot;) } return arg + 3, nil}var ErrOutOfTea = fmt.Errorf(&quot;no more tea available&quot;)var ErrPower = fmt.Errorf(&quot;can't boil water&quot;)func makeTea(arg int) error { if arg == 2 { return ErrOutOfTea } else if arg == 4 { return fmt.Errorf(&quot;making tea: %w&quot;, ErrPower) } return nil}func main() { for _, i := range []int{7, 42} { if r, e := f(i); e != nil { fmt.Println(&quot;f failed:&quot;, e) } else { fmt.Println(&quot;f worked:&quot;, r) } } for i := range 5 { if err := makeTea(i); err != nil { if errors.Is(err, ErrOutOfTea) { fmt.Println(&quot;We should buy new tea!&quot;) } else if errors.Is(err, ErrPower) { fmt.Println(&quot;Now it is dark.&quot;) } else { fmt.Printf(&quot;unknown error: %s\\n&quot;, err) } continue } fmt.Println(&quot;Tea is ready!&quot;) }} In Go it’s idiomatic to communicate errors via an explicit, separate return value. This contrasts with the exceptions used in languages like Java and Ruby and the overloaded single result / error value sometimes used in C. Go’s approach makes it easy to see which functions return errors and to handle them using the same language constructs employed for other, non-error tasks. 扩展：fmt.Stringer官方文档：fmt.Stringer type Stringer : 123type Stringer interface { String() string} Stringer is implemented by any value that has a String method, which defines the “native” format for that value. The String method is used to print values passed as an operand to any format that accepts a string or to an unformatted printer such as Print. Example: 12345678910111213141516171819202122232425package mainimport ( &quot;fmt&quot;)// Animal has a Name and an Age to represent an animal.type Animal struct { Name string Age uint}// String makes Animal satisfy the Stringer interface.func (a Animal) String() string { return fmt.Sprintf(&quot;%v (%d)&quot;, a.Name, a.Age)}func main() { a := Animal{ Name: &quot;Gopher&quot;, Age: 2, } fmt.Println(a)} 123Output:Gopher (2) stringer toolStringer is a tool to automate the creation of methods that satisfy the fmt.Stringer interface. Given the name of a (signed or unsigned) integer type T that has constants defined, stringer will create a new self-contained Go source file implementing 1func (t T) String() string The file is created in the same package and directory as the package that defines T. It has helpful defaults designed for use with go generate. Stringer works best with constants that are consecutive values such as created using iota, but creates good code regardless. In the future it might also provide custom support for constant sets that are bit patterns. For example, given this snippet, 1234567891011package painkillertype Pill intconst ( Placebo Pill = iota Aspirin Ibuprofen Paracetamol Acetaminophen = Paracetamol) running this command 1stringer -type=Pill in the same directory will create the file pill_string.go, in package painkiller, containing a definition of 1func (Pill) String() string That method will translate the value of a Pill constant to the string representation of the respective constant name, so that the call fmt.Print(painkiller.Aspirin) will print the string “Aspirin”. Typically this process would be run using go generate, like this: 1//go:generate stringer -type=Pill If multiple constants have the same value, the lexically (词汇上 ) first matching name will be used (in the example, Acetaminophen will print as “Paracetamol”). With no arguments, it processes the package in the current directory. Otherwise, the arguments must name a single directory holding a Go package or a set of Go source files that represent a single Go package. The -type flag accepts a comma-separated list of types so a single run can generate methods for multiple types. The default output file is t_string.go, where t is the lower-cased name of the first type listed. It can be overridden with the -output flag. Types can also be declared in tests, in which case type declarations in the non-test package or its test variant are preferred over types defined in the package with suffix “_test”. The default output file for type declarations in tests is t_string_test.go with t picked as above. The -linecomment flag tells stringer to generate the text of any line comment, trimmed of leading spaces (去掉前导空格 ), instead of the constant name. For instance, if the constants above had a Pill prefix, one could write 1PillAspirin // Aspirin to suppress it in the output. slices.Indexfunc Index 1func Index[S ~[]E, E comparable](s S, v E) int Index returns the index of the first occurrence of v in s, or -1 if not present. Example: 123456789101112package mainimport ( &quot;fmt&quot; &quot;slices&quot;)func main() { numbers := []int{0, 42, 8} fmt.Println(slices.Index(numbers, 8)) fmt.Println(slices.Index(numbers, 7))} 1234Output:2-1","link":"/2024/12/24/goByExample/goByExample-pt-3/"},{"title":"goByExample pt.1","text":"Hello WorldGo by Example: hello-world 123456789package mainimport ( &quot;fmt&quot;)func main() { fmt.Println(&quot;Hello World&quot;)} To run the program, put the code in hello-world.go and use go run. Sometimes we’ll want to build our programs into binaries. We can do this using go build. We can then execute the built binary directly. Now that we can run and build basic Go programs, let’s learn more about the language. ValuesGo by Example: values 1234567891011121314151617181920212223package mainimport ( &quot;fmt&quot;)func main() { // &quot;golang&quot; fmt.Println(&quot;go&quot; + &quot;lang&quot;) // &quot;1 + 1 = 2&quot; fmt.Println(&quot;1 + 1 =&quot;, 1 + 1) // &quot;7.0 / 3.0 = 2.3333333333333335&quot; fmt.Println(&quot;7.0 / 3.0 =&quot;, 7.0 / 3.0) // false fmt.Println(true &amp;&amp; false) // true fmt.Println(true || false) // false fmt.Println(!true)} Go has various value types including strings, integers, floats, booleans, etc. Here are a few basic examples. VariablesGo by Example: Variables 1234567891011121314151617181920package mainimport &quot;fmt&quot;func main() { var a = &quot;initial&quot; fmt.Println(a) var b, c int= 1, 2 fmt.Println(b, c) var d = true fmt.Println(d) var e int fmt.Println(e) f := &quot;apple&quot; fmt.Println(f)} In Go, variables are explicitly (明确的) declared and used by the compiler to e.g. check type-correctness of function calls. var declares 1 or more variables. You can declare multiple variables at once. Go will infer the type of initialized variables. Variables declared without a corresponding initialization are zero-valued. For example, the zero value for an int is 0. The := syntax is shorthand for declaring and initializing a variable, e.g. for var f string = &quot;apple&quot; in this case. This syntax is only available inside functions. ConstantsGo by Example: Constants 123456789101112131415161718192021package mainimport ( &quot;fmt&quot; &quot;math&quot;)const s string = &quot;constant&quot;func main(){ fmt.Println(s) const n = 500000000 const d = 3e20 / n fmt.Println(d) fmt.Println(int64(d)) fmt.Println(math.Sin(n))} Go supports constants of character, string, boolean, and numeric (数学) values. const declares a constant value. A const statement can appear anywhere a var statement can. Constant expressions perform arithmetic (算数) with arbitrary precision (任意精度). A numeric constant has no type until it’s given one, such as by an explicit conversion (转换). A number can be given a type by using it in a context that requires one, such as a variable assignment or function call. For example, here math.Sin expects a float64. ForGo by Example: For 1234567891011121314151617181920212223242526272829303132package mainimport &quot;fmt&quot;func main() { i := 1 for i &lt;= 3 { fmt.Println(i) i = i + 1 } for j := 0; j &lt; 3; j++ { fmt.Println(j) } for i := range 3 { fmt.Println(&quot;range&quot;, i) } for { fmt.Println(&quot;loop&quot;) break } for n := range 6 { if n % 2 == 0 { continue } fmt.Println(n) }} for is Go’s only looping construct. Here are some basic types of for loops. 1st: The most basic type, with a single condition. 2nd: A classic initial/condition/after for loop. 3rd: Another way of accomplishing the basic “do this N times” iteration is range over an integer. 4th: for without a condition will loop repeatedly until you break out of the loop or return from the enclosing function.(the while in go) 5th: You can also continue to the next iteration of the loop. If/ElseGo by Example: If/Else 12345678910111213141516171819202122232425262728package mainimport &quot;fmt&quot;func main() { if 7%2 == 0 { fmt.Println(&quot;7 is even&quot;) } else { fmt.Println(&quot;7 is odd&quot;) } if 8%4 == 0 { fmt.Println(&quot;8 is divisible by 4&quot;) } if 8%2 == 0 || 7%2 == 0 { fmt.Println(&quot;either 8 or 7 are even&quot;) } if num := 9; num &lt; 0 { fmt.Println(num, &quot;is negative&quot;) } else if num &lt; 10 { fmt.Println(num, &quot;has 1 digit&quot;) } else { fmt.Println(num, &quot;has multiple digits&quot;) }} Branching with if and else in Go is straight-forward. You can have an if statement without an else. Logical operators like &amp;&amp; and || are often useful in conditions. A statement can precede conditionals; any variables declared in this statement are available in the current and all subsequent branches. 语句可以位于条件之前；此语句中声明的任何变量均可在当前分支和所有后续分支中使用。 Note that you don’t need parentheses (小括号) around conditions in Go, but that the braces (大括号) are required. There is no ternary if (三元运算符) in Go, so you’ll need to use a full if statement even for basic conditions. SwitchGo by Example: Switch 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package mainimport ( &quot;fmt&quot; &quot;time&quot;)func main() { i := 2 fmt.Print(&quot;Write &quot;, i, &quot; as &quot;) switch i { case 1: fmt.Println(&quot;one&quot;) case 2: fmt.Println(&quot;two&quot;) case 3: fmt.Println(&quot;three&quot;) } switch time.Now().Weekday() { case time.Saturday, time.Sunday: fmt.Println(&quot;It's the weekend&quot;) default: fmt.Println(&quot;It's a weekday&quot;) } t := time.Now() switch { case t.Hour() &lt; 12: fmt.Println(&quot;It's before noon&quot;) default: fmt.Println(&quot;It's after noon&quot;) } whatAmI := func(i interface{}) { switch t := i.(type) { case bool: fmt.Println(&quot;I'm a bool&quot;) case int: fmt.Println(&quot;I'm an int&quot;) default: fmt.Printf(&quot;Don't know type %T\\n&quot;, t) } } whatAmI(true) whatAmI(1) whatAmI(&quot;hey&quot;)} Switch statements express conditionals across many branches. You can use commas to separate multiple expressions in the same case statement. We use the optional default case in this example as well. switch without an expression is an alternate way to express if/else logic. Here we also show how the case expressions can be non-constants (case 表达式如何可以是非常量). A type switch compares types instead of values. You can use this to discover the type of an interface value. In this example, the variable t will have the type corresponding to its clause. ArraysGo by Example: Arrays 12345678910111213141516171819202122232425262728293031323334353637383940414243package mainimport &quot;fmt&quot;func main() { // a: 0 0 0 0 0 var a [5]int fmt.Println(&quot;emp:&quot;, a) // a: 0 0 0 0 100 a[4] = 100 fmt.Println(&quot;set:&quot;, a) fmt.Println(&quot;get:&quot;, a[4]) fmt.Println(&quot;len:&quot;, len(a)) // b: 1 2 3 4 5 b := [5]int{1, 2, 3, 4, 5} fmt.Println(&quot;dcl:&quot;, b) // b: 1 2 3 4 5 // len = 5 b = [...]int{1, 2, 3, 4, 5} fmt.Println(&quot;dcl:&quot;, b) b = [...]int{100, 3: 400, 500} fmt.Println(&quot;idx:&quot;, b) var twoD [2][3]int for i := 0; i &lt; 2; i++ { for j := 0; j &lt; 3; j++ { twoD[i][j] = i + j } } fmt.Println(&quot;2d: &quot;, twoD) twoD = [2][3]int{ {1, 2, 3}, {1, 2, 3}, } fmt.Println(&quot;2d: &quot;, twoD)} In Go, an array is a numbered sequence of elements of a specific length. In typical Go code, slices (the next) are much more common; arrays are useful in some special scenarios (场景). Here we create an array a that will hold exactly 5 ints. The type of elements and length are both part of the array’s type. By default an array is zero-valued, which for ints means 0s. We can set a value at an index using the array[index] = value syntax, and get a value with array[index]. The builtin len returns the length of an array. Use this syntax to declare and initialize an array in one line. You can also have the compiler count the number of elements for you with ... If you specify the index with :, the elements in between will be zeroed. 如果使用 : 指定索引，则其间的元素将被清零 b = [...]int{100, 3: 400, 500} [...]int 表示一个整数类型的数组，Go会根据初始化时的元素数量自动推断数组的大小。 100 赋值给数组的第一个位置，b[0] = 100。 3: 400 表示将数组的索引 3 设置为 400，即 b[3] = 400。这里使用了索引赋值的语法：索引:值，它将数组的特定位置初始化为给定的值。 500 会自动赋值给数组的最后一个位置，也就是 b[4] = 500。 Array types are one-dimensional, but you can compose types to build multi-dimensional data structures. You can create and initialize multi-dimensional arrays at once too. Note that arrays appear in the form [v1 v2 v3 ...] when printed with fmt.Println. SlicesGo by Example: Slices 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package mainimport ( &quot;fmt&quot; &quot;slices&quot;)func main() { var s []string fmt.Println(&quot;uninit:&quot;, s, s == nil, len(s) == 0) s = make([]string, 3) fmt.Println(&quot;emp:&quot;, s, &quot;len:&quot;, len(s), &quot;cap:&quot;, cap(s)) s[0] = &quot;a&quot; s[1] = &quot;b&quot; s[2] = &quot;c&quot; fmt.Println(&quot;set:&quot;, s) fmt.Println(&quot;get:&quot;, s[2]) fmt.Println(&quot;len:&quot;, len(s)) s = append(s, &quot;d&quot;) s = append(s, &quot;e&quot;, &quot;f&quot;) fmt.Println(&quot;apd:&quot;, s) c := make([]string, len(s)) copy(c, s) fmt.Println(&quot;cpy:&quot;, c) l := s[2:5] fmt.Println(&quot;sl1:&quot;, l) l = s[:5] fmt.Println(&quot;sl2:&quot;, l) l = s[2:] fmt.Println(&quot;sl3:&quot;, l) t := []string{&quot;g&quot;, &quot;h&quot;, &quot;i&quot;} fmt.Println(&quot;dcl:&quot;, t) t2 := []string{&quot;g&quot;, &quot;h&quot;, &quot;i&quot;} if slices.Equal(t, t2) { fmt.Println(&quot;t == t2&quot;) } twoD := make([][]int, 3) for i := 0; i &lt; 3; i++ { innerLen := i + 1 twoD[i] = make([]int, innerLen) for j := 0; j &lt; innerLen; j++ { twoD[i][j] = i + j } } fmt.Println(&quot;2d: &quot;, twoD)} Slices are an important data type in Go, giving a more powerful interface to sequences than arrays. Unlike arrays, slices are typed only by the elements they contain (not the number of elements). An uninitialized slice equals to nil and has length 0. To create an empty slice with non-zero length, use the builtin make. Here we make a slice of strings of length 3 (initially zero-valued). By default a new slice’s capacity is equal to its length; if we know the slice is going to grow ahead of time, it’s possible to pass a capacity explicitly as an additional parameter to make. We can set and get just like with arrays. len returns the length of the slice as expected. In addition to these basic operations, slices support several more that make them richer than arrays. One is the builtin append, which returns a slice containing one or more new values. Note that we need to accept a return value from append as we may get a new slice value. Slices can also be copy’d. Here we create an empty slice c of the same length as s and copy into c from s. Slices support a “slice” operator with the syntax slice[low:high]. For example, this gets a slice of the elements s[2], s[3], and s[4]. This slices up to (but excluding) s[5]. And this slices up from (and including) s[2]. We can declare and initialize a variable for slice in a single line as well. The slices package contains a number of useful utility functions for slices. Slices can be composed into multi-dimensional data structures. The length of the inner slices can vary, unlike with multi-dimensional arrays. Note that while slices are different types than arrays, they are rendered (呈现) similarly by fmt.Println. Check out this great blog post (maybe in another blog) by the Go team for more details on the design and implementation of slices in Go.Now that we’ve seen arrays and slices we’ll look at Go’s other key builtin data structure: maps. MapsGo by Example: Maps 1234567891011121314151617181920212223242526272829303132333435363738394041package mainimport ( &quot;fmt&quot; &quot;maps&quot;)func main() { m := make(map[string]int) m[&quot;k1&quot;] = 7 m[&quot;k2&quot;] = 13 fmt.Println(&quot;map:&quot;, m) v1 := m[&quot;k1&quot;] fmt.Println(&quot;v1:&quot;, v1) v3 := m[&quot;k3&quot;] fmt.Println(&quot;v3:&quot;, v3) fmt.Println(&quot;len:&quot;, len(m)) delete(m, &quot;k2&quot;) fmt.Println(&quot;map:&quot;, m) clear(m) fmt.Println(&quot;map:&quot;, m) _, prs := m[&quot;k2&quot;] fmt.Println(&quot;prs:&quot;, prs) n := map[string]int{&quot;foo&quot;: 1, &quot;bar&quot;: 2} fmt.Println(&quot;map:&quot;, n) n2 := map[string]int{&quot;foo&quot;: 1, &quot;bar&quot;: 2} if maps.Equal(n, n2) { fmt.Println(&quot;n == n2&quot;) }} Maps are Go’s built-in associative data type (内置关联数据类型) (sometimes called hashes or dicts in other languages). To create an empty map, use the builtin make: make(map[key-type]val-type). Set key/value pairs using typical name[key] = val syntax. Printing a map with e.g. fmt.Println will show all of its key/value pairs. Get a value for a key with name[key]. If the key doesn’t exist, the zero value (maybe another blog) of the value type is returned. The builtin len returns the number of key/value pairs when called on a map. The builtin delete removes key/value pairs from a map. To remove all key/value pairs from a map, use the clear builtin. The optional second return value when getting a value from a map indicates if the key was present in the map. This can be used to disambiguate between missing keys and keys with zero values like 0 or &quot;&quot;. Here we didn’t need the value itself, so we ignored it with the blank identifier _. 当从一个 map 中取值时，还有可以选择是否接收的第二个返回值，该值表明了 map 中是否存在这个键。 这可以用来消除 键不存在 和 键的值为零值 产生的歧义， 例如 0 和 &quot;&quot;。这里我们不需要值，所以用 空白标识符(blank identifier) _ 将其忽略。 You can also declare and initialize a new map in the same line with this syntax. The maps package contains a number of useful utility functions for maps. Note that maps appear in the form map[k:v k:v] when printed with fmt.Println. next part: goByExample pt.2","link":"/2024/12/21/goByExample/goByExample-pt-1/"},{"title":"Thinking in Java pt.1","text":"Chapter 1 Introduction to ObjectsThe progress of abstractionAlan Kay summarized five basic characteristics of Smalltalk, the first successful object-oriented language and one of the languages upon which Java is based. These characteristics represent a pure approach to object-oriented programming: Everything is an object. Think of an object as a fancy variable; it stores data, but you can “make requests” to that object, asking it to perform operations on itself. In theory, you can take any conceptual(概念性的 ) component in the problem you’re trying to solve (dogs, buildings, services, etc.) and represent it as an object in your program. A program is a bunch of objects telling each other what to do by sending messages. To make a request of an object, you “send a message” to that object. More concretely, you can think of a message as a request to call a method that belongs to a particular object. Each object has its own memory made up of other objects. Put another way, you create a new kind of object by making a package containing existing objects. Thus, you can build complexity into a program while hiding it behind the simplicity of objects. Every object has a type. Using the parlance(按照这种说法 ), each object is an instance of a class, in which “class” is synonymous with “type.” The most important distinguishing characteristic of a class is “What messages can you send to it?” All objects of a particular type can receive the same messages. This is actually a loaded statement, as you will see later. Because an object of type “circle” is also an object of type “shape,” a circle is guaranteed to accept shape messages. This means you can write code that talks to shapes and automatically handle anything that fits the description of a shape. This substitutability is one of the powerful concepts in OOP. An object has an interface","link":"/2025/01/03/Thinking-in-Java/Thinking-in-Java-pt-1/"},{"title":"Operating System pt.2","text":"Install Your OS in a Virtual Machine1. 修改Makefile制作iso文件1234567891011121314mykernel.iso: mykernel.bin mkdir iso mkdir iso/boot mkdir iso/boot/grub cp $&lt; iso/boot echo 'set timeout=0' &gt;&gt; iso/boot/grub/grub.cfg echo 'set default=0' &gt;&gt; iso/boot/grub/grub.cfg echo '' &gt;&gt; iso/boot/grub/grub.cfg echo 'menuentry &quot;My Operating System&quot;{' &gt;&gt; iso/boot/grub/grub.cfg echo ' multiboot /boot/mykernel.bin' &gt;&gt; iso/boot/grub/grub.cfg echo ' boot' &gt;&gt; iso/boot/grub/grub.cfg echo '}' &gt;&gt; iso/boot/grub/grub.cfg grub-mkrescue --output=$@ iso rm -rf iso 这段Makefile用于生成一个名为mykernel.iso的可启动ISO镜像文件。它依赖于一个名为mykernel.bin的二进制文件，该文件通常是一个操作系统内核或引导程序。以下是逐行解释： mykernel.iso: mykernel.bin: 这行定义了目标文件mykernel.iso和它的依赖文件mykernel.bin。当mykernel.bin发生变化时，mykernel.iso将会被重新生成。 mkdir iso: 创建一个名为iso的目录，用于临时存放构建ISO文件所需的文件。 mkdir iso/boot: 在iso目录下创建一个boot子目录，用于存放引导相关的文件。 mkdir iso/boot/grub: 在iso/boot目录下创建一个grub子目录，用于存放GRUB引导加载器的配置文件。 cp $&lt; iso/boot: 将依赖文件mykernel.bin复制到iso/boot目录中。$&lt;是Makefile中的自动变量，表示第一个依赖文件（即mykernel.bin）。 echo 'set timeout=0' &gt;&gt; iso/boot/grub/grub.cfg: 向iso/boot/grub/grub.cfg文件中追加一行，设置GRUB菜单的超时时间为0秒，即不显示菜单直接启动。 echo 'set default=0' &gt;&gt; iso/boot/grub/grub.cfg: 向grub.cfg文件中追加一行，设置默认启动项为第一个菜单项。 echo '' &gt;&gt; iso/boot/grub/grub.cfg: 向grub.cfg文件中追加一个空行。 echo 'menuentry &quot;My Operating System&quot;{' &gt;&gt; iso/boot/grub/grub.cfg: 向grub.cfg文件中追加一行，定义一个名为”My Operating System”的菜单项。 echo ' multiboot /boot/mykernel.bin' &gt;&gt; iso/boot/grub/grub.cfg: 向grub.cfg文件中追加一行，指定使用multiboot命令加载/boot/mykernel.bin文件。 echo ' boot' &gt;&gt; iso/boot/grub/grub.cfg: 向grub.cfg文件中追加一行，执行boot命令以启动加载的内核。 echo '}' &gt;&gt; iso/boot/grub/grub.cfg: 向grub.cfg文件中追加一行，结束菜单项的定义。 grub-mkrescue --output=$@ iso: 使用grub-mkrescue命令将iso目录中的内容打包成一个可启动的ISO镜像文件。$@是Makefile中的自动变量，表示目标文件（即mykernel.iso）。 rm -rf iso: 删除临时创建的iso目录及其内容，以清理构建过程中生成的临时文件。 这段Makefile的作用是将mykernel.bin文件打包成一个可启动的ISO镜像文件mykernel.iso。它使用GRUB作为引导加载器，并配置GRUB直接启动mykernel.bin。构建完成后，临时目录iso会被删除 2. 定义types.h12345678910111213141516#ifndef __TYPES_H__#define __TYPES_H__ typedef char int8_t; typedef unsigned char uint8_t; typedef short int16_t; typedef unsigned short uint16_t; typedef int int32_t; typedef unsigned int uint32_t; typedef long long int int64_t; typedef unsigned long long int uint64_t;#endif 3. 修改kernel.cpp123456789101112131415161718192021222324#include &lt;types.h&gt;void printf(char* str) { uint16_t* VideoMemory = (uint16_t*) 0xB8000; for(int i = 0; str[i] != '\\0'; ++i) { VideoMemory[i] = (VideoMemory[i] &amp; 0xFF00) | str[i]; }}typedef void (*constructor)();extern &quot;C&quot; constructor start_ctors;extern &quot;C&quot; constructor end_ctors;extern &quot;C&quot; void callConstructors() { for(constructor* i = &amp;start_ctors; i != &amp;end_ctors; i++) { (*i)(); }}extern &quot;C&quot; void kernelMain(void* multiboot_structure, uint32_t magicnumber) { printf(&quot;Hello World!\\n&quot;); while(1);} Memory Segments, Global Descriptor Table","link":"/2025/01/11/Write%20your%20own%20Operating%20System/Operating-System-pt-2/"},{"title":"Reading 1-Static Checking","text":"ObjectivesToday’s class has two topics: static typing the big three properties of good software Hailstone sequenceAs a running example, we’re going to explore the hailstone sequence, which is defined as follows. Starting with a number n, the next number in the sequence is n/2 if n is even, or 3n+1 if n is odd. The sequence ends when it reaches 1. Here are some examples: 1234562, 13, 10, 5, 16, 8, 4, 2, 14, 2, 12n, 2n-1 , … , 4, 2, 15, 16, 8, 4, 2, 17, 22, 11, 34, 17, 52, 26, 13, 40, …? (where does this stop?) Because of the odd-number rule, the sequence may bounce up and down before decreasing to 1. It’s conjectured that all hailstones eventually fall to the ground – i.e., the hailstone sequence reaches 1 for all starting n – but that’s still an open question. Why is it called a hailstone sequence? Because hailstones form in clouds by bouncing up and down, until they eventually build enough weight to fall to earth. Computing hailstonesHere’s some code for computing and printing the hailstone sequence for some starting n. We’ll write JavaScript and Python versions of the code side by side for comparison: 1234567891011# Pythonn = 3while n != 1: print(n) if n % 2 == 0: n = n / 2 else: n = 3 * n + 1print(n) 1234567891011// JavaScript (or TypeScript, this code works in both languages)let n = 3;while (n !== 1) { console.log(n); if (n % 2 === 0) { n = n / 2; } else { n = 3 * n + 1; }}console.log(n); The basic semantics of expressions and statements in JavaScript are very similar to Python. The while and if keywords behave the same, for example. A few points of syntax are worth noting here: JavaScript requires parentheses around the conditions of the if and while. A JavaScript statement ends with a semicolon. This is technically optional, because JavaScript has rules for automatically inserting a semicolon at the end of a line. But these rules have obscure pitfalls that can lead to unexpected behavior and bugs, so always using semicolons is a good practice. JavaScript uses curly braces around blocks, instead of indentation. But you should still always indent the block, even though JavaScript won’t pay any attention to your extra spaces. Programming is a form of communication, and you’re communicating not only to the compiler, but to human beings. Humans need that indentation. We’ll come back to this later. You may also notice that the JavaScript version uses === and !== where the Python uses == and !=. That’s because == and != in JavaScript do a variety of automatic type conversions to try to make the values on the lefthand side and righthand side comparable to each other. For example, 0 == &quot;&quot; is true in JavaScript, which is surprising and confusing. The triple-equals versions of these operators are much safer and more predictable: 0 === &quot;&quot; is false. Good JavaScript programmers will only use === and !==. This is a potential pitfall when moving from Python. TypesBut we are not using JavaScript in this class, strictly speaking. We are using TypeScript, which extends JavaScript with the ability to declare types in the program. In this case, we can specify that the variable n has type number: 1let n: number = 3; A type is a set of values, along with operations that can be performed on those values. TypeScript has several built-in types, including: number, which represents both integers and floating-point numbers boolean, which represents true or false string, which represents a sequence of characters Operations are functions that take inputs and produce outputs (and sometimes change the values themselves). The syntax for operations varies, but we still think of them as functions no matter how they’re written. Here are several different syntaxes for an operation in Python or TypeScript: As an operator. For example, a + b invokes the operation + : number × number → number.(In this notation: + is the name of the operation, number × number before the arrow gives the types of the two inputs, and number after the arrow gives the type of the output.) As a function. For example, Math.sin(theta) calls the operation sin: number → number. Here, Math is not an object. It’s the class that contains the sin function. As a method of an object. For example, str1.concat(str2) calls the operation concat: string × string → string. As a property of an object. For example, str.length calls the operation length: string → number. Note the lack of parentheses after str.length. Contrast TypeScript’s str.length with Python’s len(str). It’s the same operation in both languages – taking a string and returning its length – but it just uses different syntax. Some operations are overloaded in the sense that the same operation name is used for functions that take different types of arguments. The operator + is overloaded in TypeScript. With numbers, 5 + 3 naturally produces 8. But when + is used on strings, it does string concatenation instead, so “5” + “3” produces “53”. Overloading is not limited to operators like +; methods and functions can also be overloaded. Most programming languages have some degree of overloading. Static typingTypeScript is a statically-typed language. Variables can be assigned a type at compile time (before the program runs), and the compiler can therefore deduce the types of expressions using those variables. If a and b are declared as number, then the compiler concludes that a+b is also number. The VS Code environment does this while you’re writing the code, in fact, so you find out about many errors while you’re still typing. JavaScript and Python, by contrast, are dynamically-typed languages, because this kind of checking is deferred until runtime (while the program is running). Static typing is a particular kind of static checking, which means checking for bugs at compile time. Bugs are the bane of programming. Many of the ideas in this course are aimed at eliminating bugs from your code, and static checking is the first idea that we’ve seen for this. Static typing prevents a large class of bugs from infecting your program: to be precise, bugs caused by applying an operation to the wrong types of arguments. If you write a broken line of code like: 1&quot;5&quot; * &quot;6&quot; that tries to multiply two strings, then static typing will catch this error while you’re still programming, rather than waiting until the line is reached during execution. Static types at compile time, dynamic types at runtimeStatic type declarations are used at compile time to perform static checking. Adding static types doesn’t change the fact that the behavior of our program at runtime is driven by actual values. In the hailstone program, if we declare let n: number = 3; to specify the static type of n, the initial value at runtime is still 3, not any other number. We’ll need to keep this distinction in mind when our static type encompasses more than one possible runtime type: a variable of static type Animal (let’s imagine) might really be a Dog or a Fish or a SpottedOwl at runtime. In fact, TypeScript (like many statically-typed languages) throws away the static type information after compilation. What does the TypeScript compiler generate? JavaScript! Here is a bit of code in well-typed TypeScript, and the generated JavaScript: 12345// TypeScript to compilefunction hello(name: string): string { return 'Hi, ' + name;}let greeting: string = hello('types'); 12345// JavaScript generatedfunction hello(name) { return 'Hi, ' + name;}let greeting = hello('types'); Support for static typing in dynamically-typed languagesJust like TypeScript adds static typing to the dynamically-typed JavaScript language, Python also has extensions that support static typing. Python 3.5 and later allow you to declare type hints in the code, e.g.: 123# Python function declared with type hintsdef hello(name:str)-&gt;str: return 'Hi, ' + name The declared types can be used by a checker like Mypy to find type errors statically without having to run the code. The addition of static types to dynamically-typed languages like Python and JavaScript reflects a widespread belief among software engineers that the use of static types is essential to building and maintaining a large software system. The rest of this reading, and in fact this entire course, will show reasons for this belief. Adding static types to a dynamically-typed language enables a programming approach called gradual typing, in which some parts of the code have static type declarations and other parts omit them. Gradual typing can provide a smoother path for a small experimental prototype to grow into a large, stable, maintainable system. Static checking, dynamic checking, no checkingIt’s useful to think about three kinds of automatic checking that a language can provide: Static checking: the bug is found automatically before the program even runs. Dynamic checking: the bug is found automatically when the code is executed. No checking: the language doesn’t help you find the error at all. You have to watch for it yourself, or end up with wrong answers. Needless to say, catching a bug statically is better than catching it dynamically, and catching it dynamically is better than not catching it at all. Here are some rules of thumb for what errors you can expect to be caught at each of these times. Static checking can catch: syntax errors, like extra punctuation or spurious words. Even dynamically-typed languages like Python do this kind of static checking. If you have an indentation error in your Python program, you’ll find out before the program starts running. misspelled names, like Math.sine(2). (The correct spelling is sin.) wrong number of arguments, like Math.sin(30, 20). wrong argument types, like Math.sin(&quot;30&quot;). wrong return types, like return &quot;30&quot;; from a function that’s declared to return a number. Dynamic checking can catch, for example: specific illegal argument values. For example, the expression x/y is erroneous when y is zero, but well-defined for other values of y. So divide-by-zero is not a static error, because you can’t know until runtime whether y is actually zero or not. But divide-by-zero can be caught as a dynamic error; Python throws ZeroDivisionError when it happens. illegal conversions, i.e., when the specific value can’t be converted to or represented in the target type. For example, in Python, int(&quot;hello&quot;) throws ValueError, because the string &quot;hello&quot; cannot be parsed as a decimal integer. out-of-range indices, e.g., using a too-large index on a string or array. In Python, &quot;hello&quot;[13] throws IndexError. calling a method on a bad object reference (None in Python, or undefined or null in TypeScript). Static checking can detect errors related to the type of a variable – the set of values it is allowed to have, which is known at compile time in statically-typed languages like TypeScript – but is generally unable to find errors related to a specific value from that type. But you may have noticed that the dynamic-checking examples above mostly came from Python. What about dynamic checking in TypeScript? TypeScript does the static checking, but its runtime behavior is entirely provided by JavaScript, and JavaScript’s designers decided to do no checking for many of these cases. So, for example, when a string or array index is out of bounds, JavaScript returns the special value undefined, rather than throwing an error as Python would. When dividing by zero, JavaScript returns a special value representing infinity, rather than throwing an error. No checking makes bugs harder to find than they might otherwise be, because the special values can propagate through further computations until a failure finally occurs, much farther away from the original mistake in the code. Surprise: number is not a true numberAnother trap in TypeScript – which is shared by many other programming languages – is that its numeric type has corner cases that do not behave like the integers and real numbers we’re used to. As a result, some errors that really should be dynamically checked are not checked at all. Here are some of the traps hiding in TypeScript: Limited precision for integers. All numbers in TypeScript are floating-point numbers, which means that large-magnitude integers can only be represented approximately. Integers from -253 to 253 can be represented exactly, but beyond that range, the floating-point representation preserves only the most-significant binary digits of the number. What does that mean if you have, say, 260 and try to increment it? You get the same number back again: 2**60 + 1 === 2**60 in TypeScript. So this is an example of where what we might have hoped would be a dynamic error (because the computation we wrote can’t be represented correctly) produces the wrong answer instead. These limits on representable integers are available as the built-in constants Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER. Special values. The number type has several special values that aren’t real numbers: Number.NaN (which stands for “Not a Number”), Number.POSITIVE_INFINITY, and Number.NEGATIVE_INFINITY. So when you apply certain operations to a number that you’d expect to produce dynamic errors, like dividing by zero or taking the square root of a negative number, you will get one of these special values instead. If you keep computing with it, you’ll end up with a bad final answer. Overflow and underflow. Very large and very small numbers can’t be represented either, beyond a certain point. Number.MAX_VALUE is roughly 10308, and Number.MIN_VALUE is roughly 10-324. What happens when you do a computation whose answer is too large or too small (too close to zero) to fit in that finite range? The computation quietly overflows (becoming POSITIVE_INFINITY or NEGATIVE_INFINITY) or underflows (becoming zero). ArraysLet’s change our hailstone computation so that it stores the sequence in a data structure, instead of just printing it out. For that, we can use an array type. Arrays are variable-length sequences of another type, similar to Python lists. Here’s how we can declare an array of numbers and make an empty array value: 1let array: Array&lt;number&gt; = []; And here are some of its operations, which are very similar to Python: indexing: array[2] assignment: array[2] = 0 length: array.length add an element to the end: array.push(5) remove an element from the end: array.pop() You can see all the operations of Array in the Mozilla Developer Network (MDN) documentation; find it with a web search like “mdn array”. Get to know the MDN docs, they’re your friend. Here’s the hailstone code written with arrays: 1234567891011let array: Array&lt;number&gt; = [];let n: number = 3;while (n !== 1) { array.push(n); if (n % 2 === 0) { n = n / 2; } else { n = 3 * n + 1; }}array.push(n); IteratingA for loop steps through the elements of an array, just as in Python, though the syntax looks a little different. For example: 12345// find the maximum point of a hailstone sequence stored in arraylet max: number = 0;for (let x of array) { max = Math.max(x, max);} Be careful! Where in Python you use for ... in ..., the equivalent in TypeScript is for ... of .... TypeScript also has a for...in construct which iterates over the keys of a collection, instead of its values. In the case of an array, the keys are the indices of the array. Note the difference that one word makes: for (let x in [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]) { console.log(x); } // prints 0, 1, 2 for (let x of [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]) { console.log(x); } // prints &quot;a&quot;, &quot;b&quot;, &quot;c&quot; When you’re iterating over an array, you almost always want for...of, so you will need to untrain your Python habits here. The example above also used Math.max(), which is a handy function from the JavaScript library. The Math class is full of useful functions like this – web search “mdn math” to find its documentation in MDN. FunctionsIf we want to wrap this code into a reusable module, we can write a function: 123456789101112131415161718/** * Compute a hailstone sequence. * @param n starting number for sequence. Assumes n &gt; 0. * @returns hailstone sequence starting with n and ending with 1. */function hailstoneSequence(n: number): Array&lt;number&gt; { let array: Array&lt;number&gt; = []; while (n !== 1) { array.push(n); if (n % 2 === 0) { n = n / 2; } else { n = 3 * n + 1; } } array.push(n); return array;} Take note of the /** ... */ comment before the function, because it’s very important. This comment is a specification of the function, describing the inputs and outputs of the operation. The specification should be concise, clear, and precise. The comment provides information that is not already clear from the function types. It doesn’t say, for example, that the return value is an array of numbers, because the Array&lt;number&gt; return type declaration just below already says that. But it does say that the sequence starts with n and ends with 1, which is not captured by the type declaration but is important for the caller to know. We’ll have a lot more to say about how to write good specifications in a few classes, but you’ll have to start reading them and using them right away. Mutating values vs. reassigning variablesChange is a necessary evil. But good programmers try to avoid things that change, because they may change unexpectedly. Immutability – intentionally forbidding certain things from changing at runtime – will be a major design principle in this course. For example, an immutable type is a type whose values can never change once they have been created. The string type is immutable in both Python and TypeScript. TypeScript also allows us to declare immutable references: variables that are assigned once and never reassigned. To make a reference unreassignable, declare it with the keyword const instead of let: 1const n: number = 5; If the TypeScript compiler isn’t convinced that your const variable will only be assigned once at runtime, then it will produce a compiler error. So const gives you static checking for unreassignable references. It’s good practice to use const for as many variables as possible. Like the type of the variable, these declarations are important documentation, useful to the reader of the code and statically checked by the compiler. Documenting assumptionsWriting the type of a variable down documents an assumption about it: e.g., the variable n will always refer to a number. TypeScript actually checks this assumption at compile time, and guarantees that there’s no place in your program where you violated this assumption. Declaring a variable const is also a form of documentation, a claim that the variable will never be reassigned after its initial assignment. TypeScript checks that too, statically. We documented another assumption that TypeScript (unfortunately) doesn’t check automatically: that n must be positive. Why do we need to write down our assumptions? Because programming is full of them, and if we don’t write them down, we won’t remember them, and other people who need to read or change our programs later won’t know them. They’ll have to guess. Programs have to be written with two goals in mind: communicating with the computer. First persuading the compiler that your program is sensible – syntactically correct and type-correct. Then getting the logic right so that it gives the right results at runtime. communicating with other people. Making the program easy to understand, so that when somebody has to fix it, improve it, or adapt it in the future, they can do so. Hacking vs. engineeringWe’ve written some hacky code in this reading. Hacking is often marked by unbridled optimism: Bad: writing lots of code before testing any of it. Bad: keeping all the details in your head, assuming you’ll remember them forever, instead of writing them down in your code. Bad: assuming that bugs will be nonexistent or else easy to find and fix. But software engineering is not hacking. Engineers are pessimists: Good: write a little bit at a time, testing as you go. In a future class, we’ll talk about test-first programming. Good: document the assumptions that your code depends on. Good: defend your code against stupidity – especially your own! Static checking helps with that. The goal of 6.031Our primary goal in this course is learning how to produce software that is: Safe from bugs. Correctness (correct behavior right now) and defensiveness (correct behavior in the future) are required in any software we build. Easy to understand. The code has to communicate to future programmers who need to understand it and make changes in it (fixing bugs or adding new features). That future programmer might be you, months or years from now. You’ll be surprised how much you forget if you don’t write it down, and how much it helps your own future self to have a good design. Ready for change. Software always changes. Some designs make it easy to make changes; others require throwing away and rewriting a lot of code. There are other important properties of software (like performance, usability, security), and they may trade off against these three. But these are the Big Three that we care about in 6.031, and that software developers generally put foremost in the practice of building software. It’s worth considering every language feature, every programming practice, every design pattern that we study in this course, and understanding how they relate to the Big Three. Why we use TypeScript in this courseSince you’ve had 6.009, we’re assuming that you’re comfortable with Python. So why aren’t we using Python in this course? Why do we use TypeScript/JavaScript in 6.031? Safety is the first reason. TypeScript has static checking (primarily type checking, but other kinds of static checks too, like that your code returns values from methods declared to do so). We’re studying software engineering in this course, and safety from bugs is a key tenet of that approach. TypeScript dials safety up to a high level, which makes it a good language for learning about good software engineering practices. It’s certainly possible to write safe code in dynamic languages like Python or JavaScript, but it’s easier to understand what you need to do if you learn how in a safe, statically-checked language. Ubiquity is another reason. TypeScript compiles into pure JavaScript, which is widely used in research, education, and industry. JavaScript runs on many platforms, not just in the web browser where it originally became widespread, but now also in web servers and even in desktop applications for Windows/Mac/Linux. Compared to Java, TypeScript has a richer type system, needs less boilerplate code to write a program, and is a better choice for creating modern user interfaces and web apps. In any case, a good programmer must be multilingual. Programming languages are tools, and you have to use the right tool for the job. You will very likely have to pick up other programming languages (such as Java, C/C++, or Scheme or Ruby or Haskell) for classes, internships, or UROPs before you even finish your MIT career, so we’re getting started now by learning a second one. As a result of its ubiquity, JavaScript has a wide array of interesting and useful libraries, and excellent free tools for development (IDEs like VS Code, editors, compilers, test frameworks, profilers, code coverage, style checkers). JavaScript and Python are close competitors in the richness of their ecosystems, and TypeScript can take full advantage of JavaScript libraries. There are some reasons to regret using JavaScript. It’s large, having accumulated many features in the decades since it was originally designed. It’s weighed down by the baggage of older languages like C/C++ — the switch statement is a good example of an antiquated and unsafe language construct inherited from C. And JavaScript itself started with some poor design decisions, including type conversion rules that make 0 == “” return true and “[] + [] “somehow produce the empty string , as well as less dynamic checking than other languages. TypeScript fixes some of these warts in JavaScript, but not all. There are many parts of JavaScript that are now deprecated and avoided by programmers, because they’re risky to use. But on the whole, TypeScript is a reasonable choice of language right now to learn how to write code that is safe from bugs, easy to understand, and ready for change. And that’s our goal. Don’t get us wrong: the real skills you’ll get from this course are not language-specific, but carry over to any language that you might program in. The most important lessons from this course will survive language fads: safety, clarity, abstraction, engineering instincts. SummaryThe main idea we introduced today is static checking. Here’s how this idea relates to the goals of the course: Safe from bugs. Static checking helps with safety by catching type errors and other bugs before runtime. Easy to understand. It helps with understanding, because types are explicitly stated in the code. Ready for change. Static checking makes it easier to change your code by identifying other places that need to change in tandem.","link":"/2025/01/25/MIT6.031/Readings/01Static%20Checking/"}],"tags":[{"name":"test","slug":"test","link":"/tags/test/"},{"name":"OS","slug":"OS","link":"/tags/OS/"},{"name":"汇编","slug":"汇编","link":"/tags/%E6%B1%87%E7%BC%96/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"中文","slug":"中文","link":"/tags/%E4%B8%AD%E6%96%87/"},{"name":"Golang","slug":"Golang","link":"/tags/Golang/"},{"name":"English","slug":"English","link":"/tags/English/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"TypeScript","slug":"TypeScript","link":"/tags/TypeScript/"},{"name":"Software Construction","slug":"Software-Construction","link":"/tags/Software-Construction/"}],"categories":[{"name":"test","slug":"test","link":"/categories/test/"},{"name":"OS","slug":"OS","link":"/categories/OS/"},{"name":"Golang","slug":"Golang","link":"/categories/Golang/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"TypeScript","slug":"TypeScript","link":"/categories/TypeScript/"},{"name":"basics","slug":"Golang/basics","link":"/categories/Golang/basics/"},{"name":"basics","slug":"Java/basics","link":"/categories/Java/basics/"},{"name":"Software Construction","slug":"Software-Construction","link":"/categories/Software-Construction/"},{"name":"MIT6.031","slug":"Software-Construction/MIT6-031","link":"/categories/Software-Construction/MIT6-031/"}],"pages":[{"title":"categories","text":"","link":"/categories/index.html"}]}