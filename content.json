{"posts":[{"title":"Thinking in Java pt.1","text":"Chapter 1 Introduction to ObjectsThe progress of abstractionAlan Kay summarized five basic characteristics of Smalltalk, the first successful object-oriented language and one of the languages upon which Java is based. These characteristics represent a pure approach to object-oriented programming: Everything is an object. Think of an object as a fancy variable; it stores data, but you can “make requests” to that object, asking it to perform operations on itself. In theory, you can take any conceptual(概念性的 ) component in the problem you’re trying to solve (dogs, buildings, services, etc.) and represent it as an object in your program. A program is a bunch of objects telling each other what to do by sending messages. To make a request of an object, you “send a message” to that object. More concretely, you can think of a message as a request to call a method that belongs to a particular object. Each object has its own memory made up of other objects. Put another way, you create a new kind of object by making a package containing existing objects. Thus, you can build complexity into a program while hiding it behind the simplicity of objects. Every object has a type. Using the parlance(按照这种说法 ), each object is an instance of a class, in which “class” is synonymous with “type.” The most important distinguishing characteristic of a class is “What messages can you send to it?” All objects of a particular type can receive the same messages. This is actually a loaded statement, as you will see later. Because an object of type “circle” is also an object of type “shape,” a circle is guaranteed to accept shape messages. This means you can write code that talks to shapes and automatically handle anything that fits the description of a shape. This substitutability is one of the powerful concepts in OOP. An object has an interface","link":"/2025/01/03/Thinking-in-Java/Thinking-in-Java-pt-1/"},{"title":"goByExample pt.3","text":"InterfacesGo by Example: Interfaces 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package mainimport ( &quot;fmt&quot; &quot;math&quot;)type geometry interface { area() float64 perim() float64}type rect struct { width, height float64}type circle struct { radius float64}func (r rect) area() float64 { return r.width * r.height}func (r rect) perim() float64 { return 2*r.width + 2*r.height}func (c circle) area() float64 { return math.Pi * c.radius * c.radius}func (c circle) perim() float64 { return 2 * math.Pi * c.radius}func measure(g geometry) { fmt.Println(g) fmt.Println(g.area()) fmt.Println(g.perim())}func main() { r := rect{width: 3, height: 4} c := circle{radius: 5} measure(r) measure(c)} Interfaces are named collections of method signatures. Here’s a basic interface for geometric shapes. For our example we’ll implement this interface on rect and circle types. To implement an interface in Go, we just need to implement all the methods in the interface. Here we implement geometry on rects. The implementation for circles. If a variable has an interface type, then we can call methods that are in the named interface. Here’s a generic measure function taking advantage of this to work on any geometry. The circle and rect struct types both implement the geometry interface so we can use instances of these structs as arguments to measure. To learn more about Go’s interfaces, check out this great blog post (maybe another blog). 1234567goByExample&gt; go run .\\21.Interfaces.go{3 4}1214{5}78.5398163397448331.41592653589793 EnumsGo by Example: Enums 1234567891011121314151617181920212223242526272829303132333435363738394041424344package mainimport &quot;fmt&quot;type ServerState intconst ( StateIdle ServerState = iota StateConnected StateError StateRetrying)var stateName = map[ServerState]string{ StateIdle: &quot;idle&quot;, StateConnected: &quot;connected&quot;, StateError: &quot;error&quot;, StateRetrying: &quot;retrying&quot;,}func (ss ServerState) String() string { return stateName[ss]}func main() { ns := transition(StateIdle) fmt.Println(ns) ns2 := transition(ns) fmt.Println(ns2)}func transition(s ServerState) ServerState { switch s { case StateIdle: return StateConnected case StateConnected, StateRetrying: return StateIdle case StateError: return StateError default: panic(fmt.Errorf(&quot;unknown state: %s&quot;, s)) }} Enumerated types (enums) are a special case of sum types. An enum is a type that has a fixed number of possible values, each with a distinct name. Go doesn’t have an enum type as a distinct language feature, but enums are simple to implement using existing language idioms. Our enum type ServerState has an underlying int type. The possible values for ServerState are defined as constants. The special keyword iota generates successive (连续 ) constant values automatically; in this case 0, 1, 2 and so on. 特殊关键字 iota 自动生成连续的常量值；在本例中为 0、1、2 等等。 By implementing the fmt.Stringer interface, values of ServerState can be printed out or converted to strings. 通过实现 fmt.Stringer 接口，可以打印出 ServerState 的值或将其转换为字符串。 This can get cumbersome (繁琐 ) if there are many possible values. In such cases the [stringer tool](###stringer tool) can be used in conjunction with go:generate to automate the process. See this post(maybe another blog) for a longer explanation. 如果可能的值太多，这可能会变得很麻烦。在这种情况下，stringer 工具可以与 go:generate 结合使用来自动化该过程。 If we have a value of type int, we cannot pass it to transition - the compiler will complain about type mismatch. This provides some degree of compile-time type safety for enums. transition emulates a state transition for a server; it takes the existing state and returns a new state. Suppose we check some predicates here to determine the next state… 123goByExample&gt; go run .\\22.Enums.go connectedidle Struct EmbeddingGo by Example: Struct Embedding 123456789101112131415161718192021222324252627282930313233343536373839package mainimport &quot;fmt&quot;type base struct { num int}func (b base) describe() string { return fmt.Sprintf(&quot;base with num=%v&quot;, b.num)}type container struct { base str string}func main() { co := container{ base: base{ num: 1, }, str: &quot;some name&quot;, } fmt.Printf(&quot;co={num: %v, str: %v}\\n&quot;, co.num, co.str) fmt.Println(&quot;also num:&quot;, co.base.num) fmt.Println(&quot;describe:&quot;, co.describe()) type describer interface { describe() string } var d describer = co fmt.Println(&quot;describer:&quot;, d.describe())} Go supports embedding (嵌入 ) of structs and interfaces to express a more seamless (无缝的 ) composition of types. This is not to be confused with //go:embed which is a go directive introduced (go 指令 ) in Go version 1.16+ to embed files and folders into the application binary. A container embeds a base. An embedding looks like a field without a name. When creating structs with literals, we have to initialize the embedding explicitly; here the embedded type serves as the field name. We can access the base’s fields directly on co, e.g. co.num. Alternatively, we can spell out the full path using the embedded type name. Since container embeds base, the methods of base also become methods of a container. Here we invoke a method that was embedded from base directly on co. Embedding structs with methods may be used to bestow (赋予 ) interface implementations onto other structs. Here we see that a container now implements the describer interface because it embeds base. 12345goByExample&gt; go run '.\\23.Struct Embedding.go'co={num: 1, str: some name}also num: 1describe: base with num=1describer: base with num=1 Generics(泛型)Go by Example: Generics 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package mainimport &quot;fmt&quot;func SlicesIndex[S ~[]E, E comparable](s S, v E) int { for i := range s { if v == s[i] { return i } } return -1}type List[T any] struct { head, tail *element[T]}type element[T any] struct { next *element[T] val T}func (lst *List[T]) Push(v T) { if lst.tail == nil { lst.head = &amp;element[T]{val: v} lst.tail = lst.head } else { lst.tail.next = &amp;element[T]{val: v} lst.tail = lst.tail.next }}func (lst *List[T]) AllElements() []T { var elems []T for e := lst.head; e != nil; e = e.next { elems = append(elems, e.val) } return elems}func main() { var s = []string{&quot;foo&quot;, &quot;bar&quot;, &quot;zoo&quot;} fmt.Println(&quot;index of zoo:&quot;, SlicesIndex(s, &quot;zoo&quot;)) _ = SlicesIndex[[]string, string](s, &quot;zoo&quot;) lst := List[int]{} lst.Push(10) lst.Push(13) lst.Push(23) fmt.Println(&quot;list:&quot;, lst.AllElements())} Starting with version 1.18, Go has added support for generics, also known as type parameters. As an example of a generic function, SlicesIndex takes a slice of any comparable type and an element of that type and returns the index of the first occurrence of v in s, or -1 if not present. The comparable constraint means that we can compare values of this type with the == and != operators. For a more thorough explanation of this type signature, see this blog post (maybe another blog). Note that this function exists in the standard library as slices.Index. As an example of a generic type, List is a singly-linked list with values of any type. We can define methods on generic types just like we do on regular types, but we have to keep the type parameters in place. The type is List[T], not List. AllElements returns all the List elements as a slice. In the next example we’ll see a more idiomatic way of iterating over all elements of custom types. When invoking generic functions, we can often rely on type inference. Note that we don’t have to specify the types for S and E when calling SlicesIndex - the compiler infers them automatically. … though we could also specify them explicitly. 123goByExample&gt; go run '.\\24.generics.go' index of zoo: 2list: [10 13 23] Range over IteratorsGo by Example: Range over Iterators 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package mainimport ( &quot;fmt&quot; &quot;iter&quot; &quot;slices&quot;)type List[T any] struct { head, tail *element[T]}type element[T any] struct { next *element[T] val T}func (lst *List[T]) Push(v T) { if lst.tail == nil { lst.head = &amp;element[T]{val: v} lst.tail = lst.head } else { lst.tail.next = &amp;element[T]{val: v} lst.tail = lst.tail.next }}func (lst *List[T]) All() iter.Seq[T] { return func(yield func(T) bool) { for e := lst.head; e != nil; e = e.next { if !yield(e.val) { return } } }}func genFib() iter.Seq[int] { return func(yield func(int) bool) { a, b := 1, 1 for { if !yield(a) { return } a, b = b, a+b } }}func main() { lst := List[int]{} lst.Push(10) lst.Push(13) lst.Push(23) for e := range lst.All() { fmt.Println(e) } all := slices.Collect(lst.All()) fmt.Println(&quot;all:&quot;, all) for n := range genFib() { if n &gt;= 10 { break } fmt.Println(n) }} Starting with version 1.23, Go has added support for iterators, which lets us range over pretty much anything! Let’s look at the List type from the previous example again. In that example we had an AllElements method that returned a slice of all elements in the list. With Go iterators, we can do it better - as shown below. All returns an iterator, which in Go is a function with a special signature. The iterator function takes another function as a parameter, called yield by convention (but the name can be arbitrary). It will call yield for every element we want to iterate over, and note yield’s return value for a potential early termination. 迭代器函数将另一个函数作为参数，按照惯例称为yield（但名称可以任意）。它将为我们想要迭代的每个元素调用yield，并记录yield的返回值以防可能提前终止。 Iteration doesn’t require an underlying data structure, and doesn’t even have to be finite! Here’s a function returning an iterator over Fibonacci numbers: it keeps running as long as yield keeps returning true. 迭代不需要底层数据结构，甚至不必是有限的！这是一个返回斐波那契数列迭代器的函数：只要yield一直返回true，它就会一直运行。 Since List.All returns an iterator, we can use it in a regular range loop. Packages like slices have a number of useful functions to work with iterators. For example, Collect takes any iterator and collects all its values into a slice. Once the loop hits break or an early return, the yield function passed to the iterator will return false. 1234567891011goByExample&gt; go run '.\\25.Range over Iterators.go'101323all: [10 13 23]112358 ErrorsGo by Example: Errors 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package mainimport ( &quot;errors&quot; &quot;fmt&quot;)func f(arg int) (int, error) { if arg == 42 { return -1, errors.New(&quot;can't work with 42&quot;) } return arg + 3, nil}var ErrOutOfTea = fmt.Errorf(&quot;no more tea available&quot;)var ErrPower = fmt.Errorf(&quot;can't boil water&quot;)func makeTea(arg int) error { if arg == 2 { return ErrOutOfTea } else if arg == 4 { return fmt.Errorf(&quot;making tea: %w&quot;, ErrPower) } return nil}func main() { for _, i := range []int{7, 42} { if r, e := f(i); e != nil { fmt.Println(&quot;f failed:&quot;, e) } else { fmt.Println(&quot;f worked:&quot;, r) } } for i := range 5 { if err := makeTea(i); err != nil { if errors.Is(err, ErrOutOfTea) { fmt.Println(&quot;We should buy new tea!&quot;) } else if errors.Is(err, ErrPower) { fmt.Println(&quot;Now it is dark.&quot;) } else { fmt.Printf(&quot;unknown error: %s\\n&quot;, err) } continue } fmt.Println(&quot;Tea is ready!&quot;) }} In Go it’s idiomatic to communicate errors via an explicit, separate return value. This contrasts with the exceptions used in languages like Java and Ruby and the overloaded single result / error value sometimes used in C. Go’s approach makes it easy to see which functions return errors and to handle them using the same language constructs employed for other, non-error tasks. 扩展：fmt.Stringer官方文档：fmt.Stringer type Stringer : 123type Stringer interface { String() string} Stringer is implemented by any value that has a String method, which defines the “native” format for that value. The String method is used to print values passed as an operand to any format that accepts a string or to an unformatted printer such as Print. Example: 12345678910111213141516171819202122232425package mainimport ( &quot;fmt&quot;)// Animal has a Name and an Age to represent an animal.type Animal struct { Name string Age uint}// String makes Animal satisfy the Stringer interface.func (a Animal) String() string { return fmt.Sprintf(&quot;%v (%d)&quot;, a.Name, a.Age)}func main() { a := Animal{ Name: &quot;Gopher&quot;, Age: 2, } fmt.Println(a)} 123Output:Gopher (2) stringer toolStringer is a tool to automate the creation of methods that satisfy the fmt.Stringer interface. Given the name of a (signed or unsigned) integer type T that has constants defined, stringer will create a new self-contained Go source file implementing 1func (t T) String() string The file is created in the same package and directory as the package that defines T. It has helpful defaults designed for use with go generate. Stringer works best with constants that are consecutive values such as created using iota, but creates good code regardless. In the future it might also provide custom support for constant sets that are bit patterns. For example, given this snippet, 1234567891011package painkillertype Pill intconst ( Placebo Pill = iota Aspirin Ibuprofen Paracetamol Acetaminophen = Paracetamol) running this command 1stringer -type=Pill in the same directory will create the file pill_string.go, in package painkiller, containing a definition of 1func (Pill) String() string That method will translate the value of a Pill constant to the string representation of the respective constant name, so that the call fmt.Print(painkiller.Aspirin) will print the string “Aspirin”. Typically this process would be run using go generate, like this: 1//go:generate stringer -type=Pill If multiple constants have the same value, the lexically (词汇上 ) first matching name will be used (in the example, Acetaminophen will print as “Paracetamol”). With no arguments, it processes the package in the current directory. Otherwise, the arguments must name a single directory holding a Go package or a set of Go source files that represent a single Go package. The -type flag accepts a comma-separated list of types so a single run can generate methods for multiple types. The default output file is t_string.go, where t is the lower-cased name of the first type listed. It can be overridden with the -output flag. Types can also be declared in tests, in which case type declarations in the non-test package or its test variant are preferred over types defined in the package with suffix “_test”. The default output file for type declarations in tests is t_string_test.go with t picked as above. The -linecomment flag tells stringer to generate the text of any line comment, trimmed of leading spaces (去掉前导空格 ), instead of the constant name. For instance, if the constants above had a Pill prefix, one could write 1PillAspirin // Aspirin to suppress it in the output. slices.Indexfunc Index 1func Index[S ~[]E, E comparable](s S, v E) int Index returns the index of the first occurrence of v in s, or -1 if not present. Example: 123456789101112package mainimport ( &quot;fmt&quot; &quot;slices&quot;)func main() { numbers := []int{0, 42, 8} fmt.Println(slices.Index(numbers, 8)) fmt.Println(slices.Index(numbers, 7))} 1234Output:2-1","link":"/2024/12/24/goByExample/goByExample-pt-3/"},{"title":"goByExample pt.1","text":"Hello WorldGo by Example: hello-world 123456789package mainimport ( &quot;fmt&quot;)func main() { fmt.Println(&quot;Hello World&quot;)} To run the program, put the code in hello-world.go and use go run. Sometimes we’ll want to build our programs into binaries. We can do this using go build. We can then execute the built binary directly. Now that we can run and build basic Go programs, let’s learn more about the language. ValuesGo by Example: values 1234567891011121314151617181920212223package mainimport ( &quot;fmt&quot;)func main() { // &quot;golang&quot; fmt.Println(&quot;go&quot; + &quot;lang&quot;) // &quot;1 + 1 = 2&quot; fmt.Println(&quot;1 + 1 =&quot;, 1 + 1) // &quot;7.0 / 3.0 = 2.3333333333333335&quot; fmt.Println(&quot;7.0 / 3.0 =&quot;, 7.0 / 3.0) // false fmt.Println(true &amp;&amp; false) // true fmt.Println(true || false) // false fmt.Println(!true)} Go has various value types including strings, integers, floats, booleans, etc. Here are a few basic examples. VariablesGo by Example: Variables 1234567891011121314151617181920package mainimport &quot;fmt&quot;func main() { var a = &quot;initial&quot; fmt.Println(a) var b, c int= 1, 2 fmt.Println(b, c) var d = true fmt.Println(d) var e int fmt.Println(e) f := &quot;apple&quot; fmt.Println(f)} In Go, variables are explicitly (明确的) declared and used by the compiler to e.g. check type-correctness of function calls. var declares 1 or more variables. You can declare multiple variables at once. Go will infer the type of initialized variables. Variables declared without a corresponding initialization are zero-valued. For example, the zero value for an int is 0. The := syntax is shorthand for declaring and initializing a variable, e.g. for var f string = &quot;apple&quot; in this case. This syntax is only available inside functions. ConstantsGo by Example: Constants 123456789101112131415161718192021package mainimport ( &quot;fmt&quot; &quot;math&quot;)const s string = &quot;constant&quot;func main(){ fmt.Println(s) const n = 500000000 const d = 3e20 / n fmt.Println(d) fmt.Println(int64(d)) fmt.Println(math.Sin(n))} Go supports constants of character, string, boolean, and numeric (数学) values. const declares a constant value. A const statement can appear anywhere a var statement can. Constant expressions perform arithmetic (算数) with arbitrary precision (任意精度). A numeric constant has no type until it’s given one, such as by an explicit conversion (转换). A number can be given a type by using it in a context that requires one, such as a variable assignment or function call. For example, here math.Sin expects a float64. ForGo by Example: For 1234567891011121314151617181920212223242526272829303132package mainimport &quot;fmt&quot;func main() { i := 1 for i &lt;= 3 { fmt.Println(i) i = i + 1 } for j := 0; j &lt; 3; j++ { fmt.Println(j) } for i := range 3 { fmt.Println(&quot;range&quot;, i) } for { fmt.Println(&quot;loop&quot;) break } for n := range 6 { if n % 2 == 0 { continue } fmt.Println(n) }} for is Go’s only looping construct. Here are some basic types of for loops. 1st: The most basic type, with a single condition. 2nd: A classic initial/condition/after for loop. 3rd: Another way of accomplishing the basic “do this N times” iteration is range over an integer. 4th: for without a condition will loop repeatedly until you break out of the loop or return from the enclosing function.(the while in go) 5th: You can also continue to the next iteration of the loop. If/ElseGo by Example: If/Else 12345678910111213141516171819202122232425262728package mainimport &quot;fmt&quot;func main() { if 7%2 == 0 { fmt.Println(&quot;7 is even&quot;) } else { fmt.Println(&quot;7 is odd&quot;) } if 8%4 == 0 { fmt.Println(&quot;8 is divisible by 4&quot;) } if 8%2 == 0 || 7%2 == 0 { fmt.Println(&quot;either 8 or 7 are even&quot;) } if num := 9; num &lt; 0 { fmt.Println(num, &quot;is negative&quot;) } else if num &lt; 10 { fmt.Println(num, &quot;has 1 digit&quot;) } else { fmt.Println(num, &quot;has multiple digits&quot;) }} Branching with if and else in Go is straight-forward. You can have an if statement without an else. Logical operators like &amp;&amp; and || are often useful in conditions. A statement can precede conditionals; any variables declared in this statement are available in the current and all subsequent branches. 语句可以位于条件之前；此语句中声明的任何变量均可在当前分支和所有后续分支中使用。 Note that you don’t need parentheses (小括号) around conditions in Go, but that the braces (大括号) are required. There is no ternary if (三元运算符) in Go, so you’ll need to use a full if statement even for basic conditions. SwitchGo by Example: Switch 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package mainimport ( &quot;fmt&quot; &quot;time&quot;)func main() { i := 2 fmt.Print(&quot;Write &quot;, i, &quot; as &quot;) switch i { case 1: fmt.Println(&quot;one&quot;) case 2: fmt.Println(&quot;two&quot;) case 3: fmt.Println(&quot;three&quot;) } switch time.Now().Weekday() { case time.Saturday, time.Sunday: fmt.Println(&quot;It's the weekend&quot;) default: fmt.Println(&quot;It's a weekday&quot;) } t := time.Now() switch { case t.Hour() &lt; 12: fmt.Println(&quot;It's before noon&quot;) default: fmt.Println(&quot;It's after noon&quot;) } whatAmI := func(i interface{}) { switch t := i.(type) { case bool: fmt.Println(&quot;I'm a bool&quot;) case int: fmt.Println(&quot;I'm an int&quot;) default: fmt.Printf(&quot;Don't know type %T\\n&quot;, t) } } whatAmI(true) whatAmI(1) whatAmI(&quot;hey&quot;)} Switch statements express conditionals across many branches. You can use commas to separate multiple expressions in the same case statement. We use the optional default case in this example as well. switch without an expression is an alternate way to express if/else logic. Here we also show how the case expressions can be non-constants (case 表达式如何可以是非常量). A type switch compares types instead of values. You can use this to discover the type of an interface value. In this example, the variable t will have the type corresponding to its clause. ArraysGo by Example: Arrays 12345678910111213141516171819202122232425262728293031323334353637383940414243package mainimport &quot;fmt&quot;func main() { // a: 0 0 0 0 0 var a [5]int fmt.Println(&quot;emp:&quot;, a) // a: 0 0 0 0 100 a[4] = 100 fmt.Println(&quot;set:&quot;, a) fmt.Println(&quot;get:&quot;, a[4]) fmt.Println(&quot;len:&quot;, len(a)) // b: 1 2 3 4 5 b := [5]int{1, 2, 3, 4, 5} fmt.Println(&quot;dcl:&quot;, b) // b: 1 2 3 4 5 // len = 5 b = [...]int{1, 2, 3, 4, 5} fmt.Println(&quot;dcl:&quot;, b) b = [...]int{100, 3: 400, 500} fmt.Println(&quot;idx:&quot;, b) var twoD [2][3]int for i := 0; i &lt; 2; i++ { for j := 0; j &lt; 3; j++ { twoD[i][j] = i + j } } fmt.Println(&quot;2d: &quot;, twoD) twoD = [2][3]int{ {1, 2, 3}, {1, 2, 3}, } fmt.Println(&quot;2d: &quot;, twoD)} In Go, an array is a numbered sequence of elements of a specific length. In typical Go code, slices (the next) are much more common; arrays are useful in some special scenarios (场景). Here we create an array a that will hold exactly 5 ints. The type of elements and length are both part of the array’s type. By default an array is zero-valued, which for ints means 0s. We can set a value at an index using the array[index] = value syntax, and get a value with array[index]. The builtin len returns the length of an array. Use this syntax to declare and initialize an array in one line. You can also have the compiler count the number of elements for you with ... If you specify the index with :, the elements in between will be zeroed. 如果使用 : 指定索引，则其间的元素将被清零 b = [...]int{100, 3: 400, 500} [...]int 表示一个整数类型的数组，Go会根据初始化时的元素数量自动推断数组的大小。 100 赋值给数组的第一个位置，b[0] = 100。 3: 400 表示将数组的索引 3 设置为 400，即 b[3] = 400。这里使用了索引赋值的语法：索引:值，它将数组的特定位置初始化为给定的值。 500 会自动赋值给数组的最后一个位置，也就是 b[4] = 500。 Array types are one-dimensional, but you can compose types to build multi-dimensional data structures. You can create and initialize multi-dimensional arrays at once too. Note that arrays appear in the form [v1 v2 v3 ...] when printed with fmt.Println. SlicesGo by Example: Slices 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package mainimport ( &quot;fmt&quot; &quot;slices&quot;)func main() { var s []string fmt.Println(&quot;uninit:&quot;, s, s == nil, len(s) == 0) s = make([]string, 3) fmt.Println(&quot;emp:&quot;, s, &quot;len:&quot;, len(s), &quot;cap:&quot;, cap(s)) s[0] = &quot;a&quot; s[1] = &quot;b&quot; s[2] = &quot;c&quot; fmt.Println(&quot;set:&quot;, s) fmt.Println(&quot;get:&quot;, s[2]) fmt.Println(&quot;len:&quot;, len(s)) s = append(s, &quot;d&quot;) s = append(s, &quot;e&quot;, &quot;f&quot;) fmt.Println(&quot;apd:&quot;, s) c := make([]string, len(s)) copy(c, s) fmt.Println(&quot;cpy:&quot;, c) l := s[2:5] fmt.Println(&quot;sl1:&quot;, l) l = s[:5] fmt.Println(&quot;sl2:&quot;, l) l = s[2:] fmt.Println(&quot;sl3:&quot;, l) t := []string{&quot;g&quot;, &quot;h&quot;, &quot;i&quot;} fmt.Println(&quot;dcl:&quot;, t) t2 := []string{&quot;g&quot;, &quot;h&quot;, &quot;i&quot;} if slices.Equal(t, t2) { fmt.Println(&quot;t == t2&quot;) } twoD := make([][]int, 3) for i := 0; i &lt; 3; i++ { innerLen := i + 1 twoD[i] = make([]int, innerLen) for j := 0; j &lt; innerLen; j++ { twoD[i][j] = i + j } } fmt.Println(&quot;2d: &quot;, twoD)} Slices are an important data type in Go, giving a more powerful interface to sequences than arrays. Unlike arrays, slices are typed only by the elements they contain (not the number of elements). An uninitialized slice equals to nil and has length 0. To create an empty slice with non-zero length, use the builtin make. Here we make a slice of strings of length 3 (initially zero-valued). By default a new slice’s capacity is equal to its length; if we know the slice is going to grow ahead of time, it’s possible to pass a capacity explicitly as an additional parameter to make. We can set and get just like with arrays. len returns the length of the slice as expected. In addition to these basic operations, slices support several more that make them richer than arrays. One is the builtin append, which returns a slice containing one or more new values. Note that we need to accept a return value from append as we may get a new slice value. Slices can also be copy’d. Here we create an empty slice c of the same length as s and copy into c from s. Slices support a “slice” operator with the syntax slice[low:high]. For example, this gets a slice of the elements s[2], s[3], and s[4]. This slices up to (but excluding) s[5]. And this slices up from (and including) s[2]. We can declare and initialize a variable for slice in a single line as well. The slices package contains a number of useful utility functions for slices. Slices can be composed into multi-dimensional data structures. The length of the inner slices can vary, unlike with multi-dimensional arrays. Note that while slices are different types than arrays, they are rendered (呈现) similarly by fmt.Println. Check out this great blog post (maybe in another blog) by the Go team for more details on the design and implementation of slices in Go.Now that we’ve seen arrays and slices we’ll look at Go’s other key builtin data structure: maps. MapsGo by Example: Maps 1234567891011121314151617181920212223242526272829303132333435363738394041package mainimport ( &quot;fmt&quot; &quot;maps&quot;)func main() { m := make(map[string]int) m[&quot;k1&quot;] = 7 m[&quot;k2&quot;] = 13 fmt.Println(&quot;map:&quot;, m) v1 := m[&quot;k1&quot;] fmt.Println(&quot;v1:&quot;, v1) v3 := m[&quot;k3&quot;] fmt.Println(&quot;v3:&quot;, v3) fmt.Println(&quot;len:&quot;, len(m)) delete(m, &quot;k2&quot;) fmt.Println(&quot;map:&quot;, m) clear(m) fmt.Println(&quot;map:&quot;, m) _, prs := m[&quot;k2&quot;] fmt.Println(&quot;prs:&quot;, prs) n := map[string]int{&quot;foo&quot;: 1, &quot;bar&quot;: 2} fmt.Println(&quot;map:&quot;, n) n2 := map[string]int{&quot;foo&quot;: 1, &quot;bar&quot;: 2} if maps.Equal(n, n2) { fmt.Println(&quot;n == n2&quot;) }} Maps are Go’s built-in associative data type (内置关联数据类型) (sometimes called hashes or dicts in other languages). To create an empty map, use the builtin make: make(map[key-type]val-type). Set key/value pairs using typical name[key] = val syntax. Printing a map with e.g. fmt.Println will show all of its key/value pairs. Get a value for a key with name[key]. If the key doesn’t exist, the zero value (maybe another blog) of the value type is returned. The builtin len returns the number of key/value pairs when called on a map. The builtin delete removes key/value pairs from a map. To remove all key/value pairs from a map, use the clear builtin. The optional second return value when getting a value from a map indicates if the key was present in the map. This can be used to disambiguate between missing keys and keys with zero values like 0 or &quot;&quot;. Here we didn’t need the value itself, so we ignored it with the blank identifier _. 当从一个 map 中取值时，还有可以选择是否接收的第二个返回值，该值表明了 map 中是否存在这个键。 这可以用来消除 键不存在 和 键的值为零值 产生的歧义， 例如 0 和 &quot;&quot;。这里我们不需要值，所以用 空白标识符(blank identifier) _ 将其忽略。 You can also declare and initialize a new map in the same line with this syntax. The maps package contains a number of useful utility functions for maps. Note that maps appear in the form map[k:v k:v] when printed with fmt.Println. next part: goByExample pt.2","link":"/2024/12/21/goByExample/goByExample-pt-1/"},{"title":"goByExample pt.2","text":"FunctionsGo by Example: Functions 1234567891011121314151617181920package mainimport &quot;fmt&quot;func plus(a, b int) int { return a + b}func plusPlus(a, b, c int) int { return a + b + c}func main(){ res := plus(1, 2) fmt.Println(&quot;1 + 2 =&quot;, res) res = plusPlus(1, 2, 3) fmt.Println( &quot;1 + 2 + 3 =&quot;, res)} Functions are central (核心/中心) in Go. We’ll learn about functions with a few different examples. Here’s a function that takes two ints and returns their sum as an int. Go requires explicit returns, i.e. (即 ) it won’t automatically return the value of the last expression. When you have multiple consecutive (连续的 ) parameters of the same type, you may omit (省略 ) the type name for the like-typed (相同类型的 ) parameters up to the final parameter that declares the type. Call a function just as you’d expect, with name(args). There are several other features to Go functions. One is multiple return values, which we’ll look at next. 123goByExample&gt; go run .\\11.functions.go1 + 2 = 31 + 2 + 3 = 6 Multiple Return ValuesGo by Example: Multiple Return Values 1234567891011121314151617package mainimport &quot;fmt&quot;func vals() (int, int) { return 3, 7}func main() { a, b := vals() fmt.Println(a) fmt.Println(b) _, c := vals() fmt.Println(c)} Go has built-in support for multiple return values. This feature is used often in idiomatic Go (这个特性在 Go 语言中经常用到), for example to return both result and error values from a function. The (int, int) in this function signature shows that the function returns 2 ints. Here we use the 2 different return values from the call with multiple assignment (多赋值操作). If you only want a subset (子集 / 一部分) of the returned values, use the blank identifier _. Accepting a variable (可变的 ) number of arguments is another nice feature of Go functions; we’ll look at this next. 1234goByExample&gt; go run '.\\12.multiple return values.go'377 Variadic FunctionsGo by Example: Variadic Functions 12345678910111213141516171819202122package mainimport &quot;fmt&quot;func sum(nums ...int) { fmt.Print(nums, &quot; &quot;) total := 0 for _, num := range nums { total += num } fmt.Println(total)}func main() { sum(1, 2) sum(1, 2, 3) nums := []int{1, 2, 3, 4} sum(nums...)} Variadic functions can be called with any number of trailing (尾随 ) arguments. For example, fmt.Println is a common variadic function. Here’s a function that will take an arbitrary (随意的 ) number of ints as arguments. Within the function, the type of nums is equivalent to []int. We can call len(nums), iterate over it with range, etc. for _, num := range nums 解释： range 表达式通常返回两个值：一个是索引，另一个是值。在这段代码中 第一个值是数组 nums 中每个元素的索引。 第二个值是数组中相应位置的元素值。 Variadic functions can be called in the usual way with individual arguments. If you already have multiple args in a slice, apply them to a variadic function using func(slice...) like this. Another key aspect of functions in Go is their ability to form closures (闭包 ) , which we’ll look at next. 1234goByExample&gt; go run '.\\13.Variadic Functions.go' [1 2] 3[1 2 3] 6[1 2 3 4] 10 ClosuresGo by Example: Closures 1234567891011121314151617181920212223package mainimport &quot;fmt&quot;func intSeq() func() int { i := 0 return func() int { i++ return i }}func main() { nextInt := intSeq() fmt.Println(nextInt()) fmt.Println(nextInt()) fmt.Println(nextInt()) newInts := intSeq() fmt.Println(newInts())} Go supports anonymous functions, which can form closures. Anonymous functions are useful when you want to define a function inline without having to name it. This function intSeq returns another function, which we define anonymously in the body of intSeq. The returned function closes over the variable i to form a closure. We call intSeq, assigning the result (a function) to nextInt. This function value captures its own i value, which will be updated each time we call nextInt. See the effect of the closure by calling nextInt a few times. To confirm that the state is unique to that particular function, create and test a new one. The last feature of functions we’ll look at for now is recursion. 12345goByExample&gt; go run '.\\14.closures.go' 1231 RecursionGo by Example: Recursion 1234567891011121314151617181920212223242526package mainimport &quot;fmt&quot;func fact(n int) int { if n == 0 { return 1 } return n * fact(n-1)}func main() { fmt.Println(fact(7)) var fib func(n int) int fib = func(n int) int { if n &lt; 2 { return n } return fib(n-1) + fib(n-2) } fmt.Println(fib(7))} Go supports recursive functions. Here’s a classic example. This fact function calls itself until it reaches the base case of fact(0). Anonymous functions can also be recursive, but this requires explicitly declaring a variable with var to store the function before it’s defined. Since fib was previously declared in main, Go knows which function to call with fib here. 123goByExample&gt; go run '.\\15.recursion.go'504013 Range over Built-in TypesGo by Example: Range over Built-in Types 1234567891011121314151617181920212223242526272829303132package mainimport &quot;fmt&quot;func main() { nums := []int{2, 3, 4} sum := 0 for _, num := range nums { sum += num } fmt.Println(&quot;sum:&quot;, sum) for i, num := range nums { if num == 3 { fmt.Println(&quot;index:&quot;, i) } } kvs := map[string]string{&quot;a&quot;: &quot;apple&quot;, &quot;b&quot;: &quot;banana&quot;} for k, v := range kvs { fmt.Printf(&quot;%s -&gt; %s\\n&quot;, k, v) } for k := range kvs { fmt.Println(&quot;key:&quot;, k) } for i, c := range &quot;go&quot; { fmt.Println(i, c) }} range iterates over elements in a variety of built-in data structures. Let’s see how to use range with some of the data structures we’ve already learned. Here we use range to sum the numbers in a slice. Arrays work like this too. range on arrays and slices provides both the index and value for each entry. Above we didn’t need the index, so we ignored it with the blank identifier _. Sometimes we actually want the indexes though. range on map iterates over key/value pairs. range can also iterate over just the keys of a map. range on strings iterates over Unicode code points. The first value is the starting byte index of the rune and the second the rune itself. See [Strings and Runes](##Strings and Runes) for more details. 123456789goByExample&gt; go run '.\\16.Range over Built-in Types.go'sum: 9index: 1a -&gt; appleb -&gt; bananakey: akey: b0 1031 111 PointersGo by Example: Pointers 123456789101112131415161718192021222324package mainimport &quot;fmt&quot;func zeroval(ival int) { ival = 0}func zeroptr(iptr *int) { *iptr = 0}func main() { i := 1 fmt.Println(&quot;initial:&quot;, i) zeroval(i) fmt.Println(&quot;zeroval:&quot;, i) zeroptr(&amp;i) fmt.Println(&quot;zeroptr:&quot;, i) fmt.Println(&quot;pointer:&quot;, &amp;i)} Go supports pointers, allowing you to pass references to values and records within your program. We’ll show how pointers work in contrast to values with 2 functions: zeroval and zeroptr. zeroval has an int parameter, so arguments will be passed to it by value. zeroval will get a copy of ival distinct from the one in the calling function. zeroptr in contrast has an *int parameter, meaning that it takes an int pointer. The *iptr code in the function body then dereferences the pointer from its memory address to the current value at that address. Assigning a value to a dereferenced pointer changes the value at the referenced address. The &amp;i syntax gives the memory address of i, i.e. a pointer to i. Pointers can be printed too. zeroval doesn’t change the i in main, but zeroptr does because it has a reference to the memory address for that variable. 12345goByExample&gt; go run '.\\17.pointers.go' initial: 1zeroval: 1zeroptr: 0pointer: 0xc00000a0d8 Strings and RunesGo by Example: Strings and Runes 123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport ( &quot;fmt&quot; &quot;unicode/utf8&quot;)func main() { const s = &quot;สวัสดี&quot; fmt.Println(&quot;Len:&quot;, len(s)) for i := 0; i &lt; len(s); i++ { fmt.Printf(&quot;%x &quot;, s[i]) } fmt.Println() fmt.Println(&quot;Rune count:&quot;, utf8.RuneCountInString(s)) for idx, runeValue := range s { fmt.Printf(&quot;%#U starts at %d\\n&quot;, runeValue, idx) } fmt.Println(&quot;\\nUsing DecodeRuneInString&quot;) for i, w := 0, 0; i &lt; len(s); i += w { runeValue, width := utf8.DecodeRuneInString(s[i:]) fmt.Printf(&quot;%#U starts at %d\\n&quot;, runeValue, i) w = width examineRune(runeValue) }}func examineRune(r rune) { if r == 't' { fmt.Println(&quot;found tee&quot;) } else if r == 'ส' { fmt.Println(&quot;found so sua&quot;) }} A Go string is a read-only slice of bytes. The language and the standard library treat strings specially - as containers of text encoded in UTF-8. In other languages, strings are made of “characters”. In Go, the concept of a character is called a rune - it’s an integer that represents a Unicode code point. This Go blog post (maybe another blog) is a good introduction to the topic. s is a string assigned a literal value representing the word “hello” in the Thai language. Go string literals are UTF-8 encoded text. Since strings are equivalent to []byte, this will produce the length of the raw bytes stored within. 因为字符串等价于 []byte， 这会产生存储在其中的原始字节的长度。 Indexing into a string produces the raw byte values at each index. This loop generates the hex values of all the bytes that constitute the code points in s. To count how many runes are in a string, we can use the utf8 package. Note that the run-time of RuneCountInString depends on the size of the string, because it has to decode each UTF-8 rune sequentially. Some Thai characters are represented by UTF-8 code points that can span multiple bytes, so the result of this count may be surprising. 要计算字符串中有多少rune，我们可以使用utf8包。 注意RuneCountInString的运行时取决于字符串的大小。 因为它必须按顺序解码每个 UTF-8 rune。 一些泰语字符由多个 UTF-8 code point 表示， 所以这个计数的结果可能会令人惊讶。 A range loop handles strings specially and decodes each rune along with its offset in the string. We can achieve the same iteration by using the utf8.DecodeRuneInString function explicitly. This demonstrates passing a rune value to a function. Values enclosed in single quotes are rune literals. We can compare a rune value to a rune literal directly. 1234567891011121314151617181920goByExample&gt; go run '.\\18.Strings and Runes.go'Len: 18e0 b8 aa e0 b8 a7 e0 b8 b1 e0 b8 aa e0 b8 94 e0 b8 b5Rune count: 6U+0E2A 'ส' starts at 0U+0E27 'ว' starts at 3U+0E31 'ั' starts at 6U+0E2A 'ส' starts at 9U+0E14 'ด' starts at 12U+0E35 'ี' starts at 15Using DecodeRuneInStringU+0E2A 'ส' starts at 0found so suaU+0E27 'ว' starts at 3U+0E31 'ั' starts at 6U+0E2A 'ส' starts at 9found so suaU+0E14 'ด' starts at 12U+0E35 'ี' starts at 15 StructsGo by Example: Structs 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package mainimport &quot;fmt&quot;type person struct { name string age int}func newPerson(name string) *person { p := person{name: name} p.age = 42 return &amp;p}func main() { fmt.Println(person{&quot;Bob&quot;, 20}) fmt.Println(person{name: &quot;Alice&quot;, age: 30}) fmt.Println(person{name: &quot;Fred&quot;}) fmt.Println(&amp;person{name: &quot;Ann&quot;, age: 40}) fmt.Println(newPerson(&quot;Jon&quot;)) s := person{name: &quot;Sean&quot;, age: 50} fmt.Println(s.name) sp := &amp;s fmt.Println(sp.age) sp.age = 51 fmt.Println(sp.age) dog := struct { name string isGood bool }{ &quot;Rex&quot;, true, } fmt.Println(dog)} Go’s structs are typed collections of fields. They’re useful for grouping data together to form records. This person struct type has name and age fields. newPerson constructs a new person struct with the given name. Go is a garbage collected language; you can safely return a pointer to a local variable - it will only be cleaned up by the garbage collector when there are no active references to it. This syntax creates a new struct. You can name the fields when initializing a struct. Omitted fields will be zero-valued. An &amp; prefix yields a pointer to the struct. It’s idiomatic to encapsulate new struct creation in constructor functions 在构造函数中封装创建新的结构实例是一种习惯用法 Access struct fields with a dot. You can also use dots with struct pointers - the pointers are automatically dereferenced. Structs are mutable (可变的 ). If a struct type is only used for a single value, we don’t have to give it a name. The value can have an anonymous struct type. This technique is commonly used for table-driven tests (goByExample pt.8). 12345678910goByExample&gt; go run '.\\19.structs.go' {Bob 20}{Alice 30}{Fred 0}&amp;{Ann 40}&amp;{Jon 42}Sean5051{Rex true} MethodsGo by Example: Methods 1234567891011121314151617181920212223242526package mainimport &quot;fmt&quot;type rect struct { width, height int}func (r *rect) area() int { return r.width * r.height}func (r rect) perim() int { return 2*r.width + 2*r.height}func main() { r := rect{width: 10, height: 5} fmt.Println(&quot;area: &quot;, r.area()) fmt.Println(&quot;perim:&quot;, r.perim()) rp := &amp;r fmt.Println(&quot;area: &quot;, rp.area()) fmt.Println(&quot;perim:&quot;, rp.perim())} Go supports methods defined on struct types. This area method has a receiver type of *rect. Methods can be defined for either pointer or value receiver types. Here’s an example of a value receiver. Here we call the 2 methods defined for our struct. Go automatically handles conversion between values and pointers for method calls. You may want to use a pointer receiver type to avoid copying on method calls or to allow the method to mutate the receiving struct. Next we’ll look at Go’s mechanism (机制 ) for grouping and naming related sets of methods: interfaces. 12345goByExample&gt; go run '.\\20.Methods.go'area: 50perim: 30area: 50perim: 30","link":"/2024/12/23/goByExample/goByExample-pt-2/"},{"title":"test-pic","text":"test file for insert imgs","link":"/2024/12/21/test/test-pic/"},{"title":"Test","text":"Testit’s a test file for hexo","link":"/2024/12/21/test/Test/"},{"title":"Operating System pt.01","text":"Write your Own Operating System in 1 hour1. 准备四个文件1234kernel.cpplinker.ldloader.sMakefile 2. 编写Makefile12345678910111213141516GPPPARAMS = -m32ASPARAMS = --32LDPARAMS = -melf_i386objects = loader.o kernel.o%.o: %.cpp g++ $(GPPPARAMS) -o $@ -c $&lt;%.o: %.s as $(ASPARAMS) -o $@ $&lt;mykernel.bin: linker.ld $(objects) ld $(LDPARAMS) -T $&lt; -o $@ $(objects)install: mykernel.bin sudo cp $&lt; /boot/mykernel.bin 这段Makefile用于编译和链接一个简单的内核项目。它定义了如何从C++源文件、汇编源文件生成目标文件，并将这些目标文件链接成一个内核二进制文件。最后，它还定义了一个install目标，用于将生成的内核二进制文件复制到系统的/boot目录下。 1. 变量定义1234GPPPARAMS = -m32ASPARAMS = --32LDPARAMS = -melf_i386objects = loader.o kernel.o GPPPARAMS = -m32: 定义了一个变量GPPPARAMS，用于指定g++编译器的参数。-m32表示生成32位的代码。 ASPARAMS = --32: 定义了一个变量ASPARAMS，用于指定as汇编器的参数。--32表示生成32位的汇编代码。 LDPARAMS = -melf_i386: 定义了一个变量LDPARAMS，用于指定ld链接器的参数。-melf_i386表示生成32位的ELF格式的可执行文件。 objects = loader.o kernel.o: 定义了一个变量objects，包含了需要链接的目标文件列表。 2.编译C++源文件12%.o: %.cpp g++ $(GPPPARAMS) -o $@ -c $&lt; %.o: %.cpp: 这是一个模式规则，表示如何从.cpp文件生成对应的.o目标文件。 g++ $(GPPPARAMS) -o $@ -c $&lt;: 使用g++编译器编译.cpp文件。$(GPPPARAMS)展开为-m32，-o $@指定输出文件名为目标文件（即.o文件），-c表示只编译不链接，$&lt;表示第一个依赖文件（即.cpp文件）。 3.编译汇编源文件12%.o: %.s as $(ASPARAMS) -o $@ $&lt; %.o: %.s: 这是一个模式规则，表示如何从.s汇编文件生成对应的.o目标文件。 as $(ASPARAMS) -o $@ $&lt;: 使用as汇编器编译.s文件。$(ASPARAMS)展开为--32，-o $@指定输出文件名为目标文件（即.o文件），$&lt;表示第一个依赖文件（即.s文件）。 4.链接目标文件生成内核二进制文件 12mykernel.bin: linker.ld $(objects) ld $(LDPARAMS) -T $&lt; -o $@ $(objects) mykernel.bin: linker.ld $(objects): 定义了一个目标mykernel.bin，它依赖于linker.ld链接脚本和$(objects)中的目标文件。 ld $(LDPARAMS) -T $&lt; -o $@ $(objects): 使用ld链接器将目标文件链接成mykernel.bin。$(LDPARAMS)展开为-melf_i386，-T $&lt;指定链接脚本为linker.ld，-o $@指定输出文件名为mykernel.bin，$(objects)是要链接的目标文件列表。 安装内核二进制文件: 12install: mykernel.bin sudo cp $&lt; /boot/mykernel.bin install: mykernel.bin: 定义了一个目标install，它依赖于mykernel.bin。 sudo cp $&lt; /boot/mykernel.bin: 使用sudo权限将mykernel.bin复制到/boot目录下。$&lt;表示第一个依赖文件（即mykernel.bin）。 3.kernel.cpp12345void kernelMain(){ printf(&quot;Hello World!\\n&quot;); while(1);} 由于缺少printf函数的定义导致编译失败 4.loader.s1234567891011121314151617181920212223242526272829.set MAGIC, 0x1badb002.set FLAGS, (1&lt;&lt;0 | 1&lt;&lt;1).set CHECKSUM, -(MAGIC + FLAGS).section .multiboot .long MAGIC .long FLAGS .long CHECKSUM.section .text.extern kernelMain.global loaderloader: mov $kernel_stack, %esp push %eax push %ebx call kernelMain_stop: cli hlt jmp _stop.section .bss.space 2*1024*1024; # 2MBkernel_stack: 这段程序是一个简单的操作系统引导程序，使用了Multiboot标准来确保与兼容Multiboot的引导加载程序（如GRUB）兼容。以下是对这段程序的详细解释： 1. 定义常量123.set MAGIC, 0x1badb002.set FLAGS, (1&lt;&lt;0 | 1&lt;&lt;1).set CHECKSUM, -(MAGIC + FLAGS) MAGIC：这是一个魔数，值为 0x1badb002，用于标识这是一个Multiboot兼容的内核。引导加载程序会检查这个值来确定内核是否遵循Multiboot标准。 FLAGS：这是一个标志位，用于指定内核需要的特性。1&lt;&lt;0 表示要求引导加载程序在加载内核时提供内存布局信息，1&lt;&lt;1 表示要求提供引导设备信息。 CHECKSUM：这是一个校验和，用于验证Multiboot头的完整性。它的值是 -(MAGIC + FLAGS)，确保 MAGIC + FLAGS + CHECKSUM 的结果为0。 2. Multiboot头1234.section .multiboot .long MAGIC .long FLAGS .long CHECKSUM .section .multiboot：定义了一个名为 .multiboot 的节，用于存放Multiboot头。 .long MAGIC、.long FLAGS、.long CHECKSUM：分别将 MAGIC、FLAGS 和 CHECKSUM 的值写入Multiboot头。引导加载程序会读取这些值来验证内核的兼容性。 3. 代码段1234567891011121314.section .text.extern kernelMain.global loaderloader: mov $kernel_stack, %esp push %eax push %ebx call kernelMain_stop: cli hlt jmp _stop .section .text：定义了一个名为 .text 的节，用于存放代码。 .extern kernelMain：声明 kernelMain 是一个外部函数，通常这是操作系统内核的主函数。 .global loader：声明 loader 是一个全局符号，表示操作系统的入口点。 loader:：这是操作系统的入口点。引导加载程序在加载内核后会跳转到这个标签处执行。 mov $kernel_stack, %esp：将栈指针 esp 设置为 kernel_stack 的地址，初始化栈。 push %eax 和 push %ebx：将寄存器 eax 和 ebx 的值压入栈中。根据Multiboot标准，eax 包含魔数 0x2BADB002，ebx 包含Multiboot信息结构的地址。 call kernelMain：调用 kernelMain 函数，进入操作系统内核的主逻辑。 _stop:：这是一个无限循环，用于在 kernelMain 返回后停止CPU的执行。 cli：禁用中断。 hlt：使CPU进入休眠状态。 jmp _stop：跳转到 _stop 标签，形成一个无限循环。 4. 未初始化数据段123.section .bss.space 2*1024*1024; # 2MBkernel_stack: .section .bss：定义了一个名为 .bss 的节，用于存放未初始化的数据。 .space 2*1024*1024：在 .bss 节中分配了2MB的空间，用于内核栈。 kernel_stack:：这是内核栈的起始地址，loader 标签处的代码将栈指针 esp 设置为这个地址。 总结这段程序是一个简单的操作系统引导程序，它遵循Multiboot标准，确保与兼容Multiboot的引导加载程序（如GRUB）兼容。程序的主要功能是初始化栈，保存引导加载程序传递的参数，并跳转到操作系统内核的主函数 kernelMain。如果 kernelMain 返回，程序将进入一个无限循环，停止CPU的执行。 5. 编写自己的printf函数1234567void printf(char* str) { unsigned short* VideoMemory = (unsigned short*) 0xB8000; for(int i = 0; str[i] != '\\0'; ++i) { VideoMemory[i] = (VideoMemory[i] &amp; 0xFF00) | str[i]; }} 这段代码实现了一个简单的 printf 函数，用于在文本模式下将字符串输出到屏幕。它直接操作显存，将字符写入显存地址 0xB8000，这是x86架构中文本模式下的显存起始地址。以下是对代码的详细解释： 1. 函数定义1void printf(char* str) { 这是一个名为 printf 的函数，接受一个 char* 类型的参数 str，表示要输出的字符串。 2. 显存地址1unsigned short* VideoMemory = (unsigned short*) 0xB8000; 0xB8000 是x86架构中文本模式下的显存起始地址。在文本模式下，屏幕上的每个字符由两个字节表示： 低字节：字符的ASCII码。 高字节：字符的属性（如颜色、背景等）。 VideoMemory 是一个指向 unsigned short 类型的指针，每个 unsigned short（16位）对应屏幕上的一个字符。 将 0xB8000 强制转换为 unsigned short* 类型，表示从该地址开始，每两个字节对应屏幕上的一个字符。 3. 循环输出字符123for(int i = 0; str[i] != '\\0'; ++i) { VideoMemory[i] = (VideoMemory[i] &amp; 0xFF00) | str[i];} 这是一个 for 循环，用于遍历字符串 str 中的每个字符，直到遇到字符串结束符 \\0。 对于每个字符 str[i]： VideoMemory[i] &amp; 0xFF00：保留当前显存位置的高字节（属性部分），清除低字节（字符部分）。 | str[i]：将字符 str[i] 的ASCII码写入低字节。 最终结果是将字符 str[i] 写入显存，同时保留原有的属性（如颜色）。 4. 显存写入的细节 在文本模式下，显存的每个字符由两个字节组成： 低字节：字符的ASCII码。 高字节：字符的属性（如前景色、背景色等）。 例如，如果 VideoMemory[i] 的当前值是 0x0720： 0x07 是属性（灰色前景，黑色背景）。 0x20 是字符（空格）。 如果 str[i] 是字符 A（ASCII码为 0x41），则： VideoMemory[i] = (0x0720 &amp; 0xFF00) | 0x41 的结果是 0x0741。 屏幕上的对应位置会显示字符 A，颜色为灰色前景，黑色背景。 6.linker.ld123456789101112131415161718192021222324252627282930313233343536ENTRY(loader)OUTPUT_FORMAT(elf32-i386)OUTPUT_ARCH(i386:i386)SECTIONS{ . = 0x0100000; .text : { *(.mutiboot) *(.text*) *(.rodata) } .data : { start_ctors = .; KEEP(*( .init_array )); KEEP(*(SORT_BY_INIT_PRIORITY( .init_array*))); end_ctors = .; *(.data) } .bss : { *(.bss) } /DISCARD/ : { *(.fini_array*) *(.comment) }} 这是一个链接器脚本（Linker Script），用于定义操作系统内核的内存布局和段（Section）的组织方式。它指定了内核的入口点、输出格式、架构以及各个段（如 .text、.data、.bss 等）的加载地址和顺序。以下是对脚本的详细解释： 1. 入口点和输出格式123ENTRY(loader)OUTPUT_FORMAT(elf32-i386)OUTPUT_ARCH(i386:i386) **ENTRY(loader)**：指定程序的入口点为 loader 符号。这是操作系统内核的启动代码，通常是引导加载程序（如 GRUB）跳转到的第一个函数。 **OUTPUT_FORMAT(elf32-i386)**：指定输出文件的格式为 32 位 ELF 格式，适用于 x86 架构。 **OUTPUT_ARCH(i386:i386 )**：指定输出文件的架构为 32 位 x86（i386）。 2. 内存布局123SECTIONS{ . = 0x0100000; SECTIONS：定义内存布局的起始。 . = 0x0100000：设置当前地址为 0x0100000（1 MB）。这是内核加载的起始地址，通常用于操作系统内核的加载地址。 3. .text 段123456.text :{ *(.mutiboot) *(.text*) *(.rodata)} .text：定义代码段（.text），包含可执行代码和只读数据。 ***(.mutiboot)**：包含所有输入文件中的 .multiboot 段（Multiboot 头）。 ***(.text*)**：包含所有输入文件中的代码段（.text 及其变体）。 ***(.rodata)**：包含所有输入文件中的只读数据段（.rodata）。 4. .data 段123456789.data :{ start_ctors = .; KEEP(*( .init_array )); KEEP(*(SORT_BY_INIT_PRIORITY( .init_array*))); end_ctors = .; *(.data)} .data：定义数据段（.data），包含已初始化的全局变量和静态变量。 **start_ctors = .;**：定义一个符号 start_ctors，表示构造函数（全局对象的构造函数）的起始地址。 **KEEP(*( .init_array ))**：保留所有输入文件中的 .init_array 段，用于存放全局对象的构造函数指针。 **KEEP(*(SORT_BY_INIT_PRIORITY( .init_array* )))**：保留所有输入文件中的 .init_array* 段，并按初始化优先级排序。 **end_ctors = .;**：定义一个符号 end_ctors，表示构造函数的结束地址。 ***(.data)**：包含所有输入文件中的数据段（.data）。 5. .bss 段1234.bss :{ *(.bss)} .bss：定义未初始化数据段（.bss），包含未初始化的全局变量和静态变量。 ***(.bss)**：包含所有输入文件中的 .bss 段。 6. 丢弃的段12345/DISCARD/ : { *(.fini_array*) *(.comment)} **/DISCARD/**：定义需要丢弃的段。 ***(.fini_array*)**：丢弃所有输入文件中的 .fini_array* 段（析构函数表）。 ***(.comment)**：丢弃所有输入文件中的 .comment 段（注释信息）。 7. 总结这个链接器脚本的主要功能是： 定义内核的入口点为 loader。 指定输出文件为 32 位 ELF 格式，适用于 x86 架构。 设置内核的加载地址为 0x0100000（1 MB）。 组织代码段（.text）、数据段（.data）和未初始化数据段（.bss）的内存布局。 保留构造函数表（.init_array），丢弃析构函数表（.fini_array）和注释信息（.comment）。 8. 关键点 Multiboot 头：.multiboot 段必须位于内核的最开始，以便引导加载程序（如 GRUB）能够正确识别内核。 构造函数和析构函数：.init_array 和 .fini_array 用于全局对象的构造和析构。操作系统内核通常不需要析构函数，因此丢弃 .fini_array。 内存布局：内核的加载地址和段的组织方式对操作系统的正常运行至关重要。 9. 示例内核的加载过程 引导加载程序（如 GRUB）将内核加载到 0x0100000 地址。 跳转到 loader 入口点，开始执行内核代码。 内核的代码段、数据段和未初始化数据段按照链接器脚本的定义进行布局。 全局对象的构造函数在启动时被调用（通过 .init_array）。 通过这个链接器脚本，操作系统内核可以正确地加载到内存中，并按照预期的布局运行。 7.kernelMain函数修改12345extern &quot;C&quot; void kernelMain(void* multiboot_structure, unsigned int magicnumber) { printf(&quot;Hello World!\\n&quot;); while(1);} extern &quot;C&quot; 是 C++ 中的一个关键字，用于指定函数使用 C 语言的链接规则（linkage）。它的主要作用是防止 C++ 编译器对函数名进行名称修饰（name mangling），从而确保函数名在编译后的目标文件中保持原样，以便与 C 代码或其他外部代码正确链接。 1. C++ 的名称修饰（Name Mangling）在 C++ 中，函数名在编译时会被编译器修饰（mangled），以支持函数重载和其他 C++ 特性。例如，一个函数 void foo(int) 可能会被修饰为 _Z3fooi。这种修饰后的名称包含了函数的参数类型和返回类型信息。 然而，C 语言没有名称修饰的概念。C 编译器会直接使用函数名作为符号名。因此，如果 C++ 代码需要与 C 代码或其他外部代码（如汇编代码或操作系统引导加载程序）交互，就需要使用 extern &quot;C&quot; 来禁用名称修饰。 2. extern &quot;C&quot; 的作用extern &quot;C&quot; 的作用是告诉 C++ 编译器： 按照 C 语言的规则处理函数的链接。 不进行名称修饰，直接使用函数名作为符号名。 8. 修改grub.cfg123456### BEGIN MYKERNEL ###menuentry 'My Operating System'{ mutiboot /boot/mykernel.bin boot}### END MYKERNEL ### 这段代码是一个 GRUB 引导加载程序的配置文件片段，用于定义一个名为 “My Operating System” 的菜单项，并指定如何加载和启动你的操作系统内核（mykernel.bin）。以下是对这段配置的详细解释： 1. 配置文件的作用GRUB（Grand Unified Bootloader）是一个常用的引导加载程序，用于加载操作系统内核。GRUB 的配置文件（通常是 /boot/grub/grub.cfg 或 /boot/grub2/grub.cfg）定义了启动菜单和启动选项。 这段代码是 GRUB 配置文件的一部分，用于添加一个自定义的启动项，加载你的操作系统内核。 2. 配置内容解析123456### BEGIN MYKERNEL ###menuentry 'My Operating System'{ multiboot /boot/mykernel.bin boot}### END MYKERNEL ### (1) ### BEGIN MYKERNEL ### 和 ### END MYKERNEL ### 这是注释，用于标记配置文件的开始和结束。GRUB 会忽略这些注释。 它们的作用是帮助开发者识别和区分不同的配置块。 (2) menuentry 'My Operating System' { ... } menuentry 是 GRUB 配置中的一个关键字，用于定义一个启动菜单项。 'My Operating System' 是菜单项的名称，显示在 GRUB 启动菜单中。 { ... } 中是菜单项的具体配置。 (3) multiboot /boot/mykernel.bin multiboot 是 GRUB 的一个命令，用于加载符合 Multiboot 规范 的内核文件。 /boot/mykernel.bin 是你的操作系统内核文件的路径。GRUB 会从文件系统中加载这个文件。 /boot/ 是内核文件通常存放的目录。 mykernel.bin 是你的内核文件名。 (4) boot boot 是 GRUB 的一个命令，用于启动已加载的内核。 执行 boot 后，GRUB 会将控制权交给内核，开始操作系统的启动过程。 9.Addendum12345678typedef void (*constructor)();extern &quot;C&quot; constructor start_ctors;extern &quot;C&quot; constructor end_ctors;extern &quot;C&quot; void callConstructors() { for(constructor* i = &amp;start_ctors; i != &amp;end_ctors; i++) { (*i)(); }} 12345678910111213.section .text.extern kernelMain.extern callConstructors.global loaderloader: mov $kernel_stack, %esp call callConstructors push %eax push %ebx call kernelMain 这段代码是操作系统内核启动代码的一部分，主要用于调用全局对象的构造函数（constructors），然后跳转到内核的主函数 kernelMain。以下是对代码的详细解释： 1. 构造函数指针类型1typedef void (*constructor)(); 定义了一个函数指针类型 constructor，指向一个没有参数和返回值的函数。 这种类型的函数通常用于全局对象的构造函数。 2. 外部符号声明12extern &quot;C&quot; constructor start_ctors;extern &quot;C&quot; constructor end_ctors; start_ctors 和 end_ctors 是两个外部符号，分别表示构造函数表的起始和结束地址。 这些符号通常在链接器脚本中定义，用于标记全局构造函数表的范围。 extern &quot;C&quot; 用于禁用 C++ 的名称修饰（name mangling），确保符号名在链接时保持一致。 3. 调用构造函数12345extern &quot;C&quot; void callConstructors() { for(constructor* i = &amp;start_ctors; i != &amp;end_ctors; i++) { (*i)(); }} callConstructors 是一个函数，用于遍历构造函数表并调用每个构造函数。 start_ctors 和 end_ctors 分别指向构造函数表的起始和结束地址。 通过 for 循环遍历构造函数表，依次调用每个构造函数。 4. 汇编代码12345678910111213.section .text.extern kernelMain.extern callConstructors.global loaderloader: mov $kernel_stack, %esp call callConstructors push %eax push %ebx call kernelMain (1) .section .text 定义代码段（.text），用于存放可执行代码。 (2) .extern kernelMain 和 .extern callConstructors 声明 kernelMain 和 callConstructors 是外部符号，分别表示内核的主函数和构造函数调用函数。 (3) .global loader 声明 loader 是一个全局符号，表示操作系统的入口点。 (4) loader: 这是操作系统的入口点，引导加载程序（如 GRUB）会跳转到这个标签处执行。 (5) mov $kernel_stack, %esp 将栈指针 esp 设置为 kernel_stack 的地址，初始化栈。 kernel_stack 是一个符号，通常在链接器脚本中定义，表示内核栈的起始地址。 (6) call callConstructors 调用 callConstructors 函数，遍历并调用所有全局对象的构造函数。 (7) push %eax 和 push %ebx 将寄存器 eax 和 ebx 的值压入栈中。 根据 Multiboot 规范，eax 包含魔数 0x2BADB002，ebx 包含 Multiboot 信息结构的地址。 (8) call kernelMain 调用 kernelMain 函数，进入操作系统内核的主逻辑。 5. 链接器脚本中的构造函数表在链接器脚本中，通常会定义 start_ctors 和 end_ctors 符号，用于标记构造函数表的范围。例如： 12345678910111213141516171819202122232425SECTIONS{ . = 0x0100000; .text : { *(.multiboot) *(.text*) } .data : { start_ctors = .; KEEP(*(.init_array)); KEEP(*(SORT_BY_INIT_PRIORITY(.init_array.*))); end_ctors = .; *(.data) } .bss : { *(.bss) }} start_ctors 和 end_ctors 分别指向 .init_array 段的起始和结束地址。 .init_array 段存放全局对象的构造函数指针。 6. 总结这段代码的主要功能是： 定义构造函数指针类型 constructor。 声明外部符号 start_ctors 和 end_ctors，表示构造函数表的范围。 实现 callConstructors 函数，遍历并调用所有全局对象的构造函数。 在汇编代码中，初始化栈，调用构造函数，然后跳转到内核的主函数 kernelMain。 通过这种方式，操作系统内核可以在启动时正确初始化全局对象，然后进入主逻辑。","link":"/2025/01/10/Write%20your%20own%20Operating%20System/Operating-System-01/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"English","slug":"English","link":"/tags/English/"},{"name":"中文","slug":"中文","link":"/tags/%E4%B8%AD%E6%96%87/"},{"name":"Golang","slug":"Golang","link":"/tags/Golang/"},{"name":"test","slug":"test","link":"/tags/test/"},{"name":"img","slug":"img","link":"/tags/img/"},{"name":"OS","slug":"OS","link":"/tags/OS/"},{"name":"汇编","slug":"汇编","link":"/tags/%E6%B1%87%E7%BC%96/"},{"name":"C++","slug":"C","link":"/tags/C/"}],"categories":[{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"Golang","slug":"Golang","link":"/categories/Golang/"},{"name":"basics","slug":"Java/basics","link":"/categories/Java/basics/"},{"name":"test","slug":"test","link":"/categories/test/"},{"name":"basics","slug":"Golang/basics","link":"/categories/Golang/basics/"},{"name":"OS","slug":"OS","link":"/categories/OS/"}],"pages":[{"title":"categories","text":"","link":"/categories/index.html"}]}