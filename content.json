{"posts":[{"title":"goByExample pt.1","text":"Hello WorldGo by Example: hello-world 123456789package mainimport ( &quot;fmt&quot;)func main() { fmt.Println(&quot;Hello World&quot;)} To run the program, put the code in hello-world.go and use go run. Sometimes we’ll want to build our programs into binaries. We can do this using go build. We can then execute the built binary directly. Now that we can run and build basic Go programs, let’s learn more about the language. ValuesGo by Example: values 1234567891011121314151617181920212223package mainimport ( &quot;fmt&quot;)func main() { // &quot;golang&quot; fmt.Println(&quot;go&quot; + &quot;lang&quot;) // &quot;1 + 1 = 2&quot; fmt.Println(&quot;1 + 1 =&quot;, 1 + 1) // &quot;7.0 / 3.0 = 2.3333333333333335&quot; fmt.Println(&quot;7.0 / 3.0 =&quot;, 7.0 / 3.0) // false fmt.Println(true &amp;&amp; false) // true fmt.Println(true || false) // false fmt.Println(!true)} Go has various value types including strings, integers, floats, booleans, etc. Here are a few basic examples. VariablesGo by Example: Variables 1234567891011121314151617181920package mainimport &quot;fmt&quot;func main() { var a = &quot;initial&quot; fmt.Println(a) var b, c int= 1, 2 fmt.Println(b, c) var d = true fmt.Println(d) var e int fmt.Println(e) f := &quot;apple&quot; fmt.Println(f)} In Go, variables are explicitly (明确的) declared and used by the compiler to e.g. check type-correctness of function calls. var declares 1 or more variables. You can declare multiple variables at once. Go will infer the type of initialized variables. Variables declared without a corresponding initialization are zero-valued. For example, the zero value for an int is 0. The := syntax is shorthand for declaring and initializing a variable, e.g. for var f string = &quot;apple&quot; in this case. This syntax is only available inside functions. ConstantsGo by Example: Constants 123456789101112131415161718192021package mainimport ( &quot;fmt&quot; &quot;math&quot;)const s string = &quot;constant&quot;func main(){ fmt.Println(s) const n = 500000000 const d = 3e20 / n fmt.Println(d) fmt.Println(int64(d)) fmt.Println(math.Sin(n))} Go supports constants of character, string, boolean, and numeric (数学) values. const declares a constant value. A const statement can appear anywhere a var statement can. Constant expressions perform arithmetic (算数) with arbitrary precision (任意精度). A numeric constant has no type until it’s given one, such as by an explicit conversion (转换). A number can be given a type by using it in a context that requires one, such as a variable assignment or function call. For example, here math.Sin expects a float64. ForGo by Example: For 1234567891011121314151617181920212223242526272829303132package mainimport &quot;fmt&quot;func main() { i := 1 for i &lt;= 3 { fmt.Println(i) i = i + 1 } for j := 0; j &lt; 3; j++ { fmt.Println(j) } for i := range 3 { fmt.Println(&quot;range&quot;, i) } for { fmt.Println(&quot;loop&quot;) break } for n := range 6 { if n % 2 == 0 { continue } fmt.Println(n) }} for is Go’s only looping construct. Here are some basic types of for loops. 1st: The most basic type, with a single condition. 2nd: A classic initial/condition/after for loop. 3rd: Another way of accomplishing the basic “do this N times” iteration is range over an integer. 4th: for without a condition will loop repeatedly until you break out of the loop or return from the enclosing function.(the while in go) 5th: You can also continue to the next iteration of the loop. If/ElseGo by Example: If/Else 12345678910111213141516171819202122232425262728package mainimport &quot;fmt&quot;func main() { if 7%2 == 0 { fmt.Println(&quot;7 is even&quot;) } else { fmt.Println(&quot;7 is odd&quot;) } if 8%4 == 0 { fmt.Println(&quot;8 is divisible by 4&quot;) } if 8%2 == 0 || 7%2 == 0 { fmt.Println(&quot;either 8 or 7 are even&quot;) } if num := 9; num &lt; 0 { fmt.Println(num, &quot;is negative&quot;) } else if num &lt; 10 { fmt.Println(num, &quot;has 1 digit&quot;) } else { fmt.Println(num, &quot;has multiple digits&quot;) }} Branching with if and else in Go is straight-forward. You can have an if statement without an else. Logical operators like &amp;&amp; and || are often useful in conditions. A statement can precede conditionals; any variables declared in this statement are available in the current and all subsequent branches. 语句可以位于条件之前；此语句中声明的任何变量均可在当前分支和所有后续分支中使用。 Note that you don’t need parentheses (小括号) around conditions in Go, but that the braces (大括号) are required. There is no ternary if (三元运算符) in Go, so you’ll need to use a full if statement even for basic conditions. SwitchGo by Example: Switch 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package mainimport ( &quot;fmt&quot; &quot;time&quot;)func main() { i := 2 fmt.Print(&quot;Write &quot;, i, &quot; as &quot;) switch i { case 1: fmt.Println(&quot;one&quot;) case 2: fmt.Println(&quot;two&quot;) case 3: fmt.Println(&quot;three&quot;) } switch time.Now().Weekday() { case time.Saturday, time.Sunday: fmt.Println(&quot;It's the weekend&quot;) default: fmt.Println(&quot;It's a weekday&quot;) } t := time.Now() switch { case t.Hour() &lt; 12: fmt.Println(&quot;It's before noon&quot;) default: fmt.Println(&quot;It's after noon&quot;) } whatAmI := func(i interface{}) { switch t := i.(type) { case bool: fmt.Println(&quot;I'm a bool&quot;) case int: fmt.Println(&quot;I'm an int&quot;) default: fmt.Printf(&quot;Don't know type %T\\n&quot;, t) } } whatAmI(true) whatAmI(1) whatAmI(&quot;hey&quot;)} Switch statements express conditionals across many branches. You can use commas to separate multiple expressions in the same case statement. We use the optional default case in this example as well. switch without an expression is an alternate way to express if/else logic. Here we also show how the case expressions can be non-constants (case 表达式如何可以是非常量). A type switch compares types instead of values. You can use this to discover the type of an interface value. In this example, the variable t will have the type corresponding to its clause. ArraysGo by Example: Arrays 12345678910111213141516171819202122232425262728293031323334353637383940414243package mainimport &quot;fmt&quot;func main() { // a: 0 0 0 0 0 var a [5]int fmt.Println(&quot;emp:&quot;, a) // a: 0 0 0 0 100 a[4] = 100 fmt.Println(&quot;set:&quot;, a) fmt.Println(&quot;get:&quot;, a[4]) fmt.Println(&quot;len:&quot;, len(a)) // b: 1 2 3 4 5 b := [5]int{1, 2, 3, 4, 5} fmt.Println(&quot;dcl:&quot;, b) // b: 1 2 3 4 5 // len = 5 b = [...]int{1, 2, 3, 4, 5} fmt.Println(&quot;dcl:&quot;, b) b = [...]int{100, 3: 400, 500} fmt.Println(&quot;idx:&quot;, b) var twoD [2][3]int for i := 0; i &lt; 2; i++ { for j := 0; j &lt; 3; j++ { twoD[i][j] = i + j } } fmt.Println(&quot;2d: &quot;, twoD) twoD = [2][3]int{ {1, 2, 3}, {1, 2, 3}, } fmt.Println(&quot;2d: &quot;, twoD)} In Go, an array is a numbered sequence of elements of a specific length. In typical Go code, slices (the next) are much more common; arrays are useful in some special scenarios (场景). Here we create an array a that will hold exactly 5 ints. The type of elements and length are both part of the array’s type. By default an array is zero-valued, which for ints means 0s. We can set a value at an index using the array[index] = value syntax, and get a value with array[index]. The builtin len returns the length of an array. Use this syntax to declare and initialize an array in one line. You can also have the compiler count the number of elements for you with ... If you specify the index with :, the elements in between will be zeroed. 如果使用 : 指定索引，则其间的元素将被清零 b = [...]int{100, 3: 400, 500} [...]int 表示一个整数类型的数组，Go会根据初始化时的元素数量自动推断数组的大小。 100 赋值给数组的第一个位置，b[0] = 100。 3: 400 表示将数组的索引 3 设置为 400，即 b[3] = 400。这里使用了索引赋值的语法：索引:值，它将数组的特定位置初始化为给定的值。 500 会自动赋值给数组的最后一个位置，也就是 b[4] = 500。 Array types are one-dimensional, but you can compose types to build multi-dimensional data structures. You can create and initialize multi-dimensional arrays at once too. Note that arrays appear in the form [v1 v2 v3 ...] when printed with fmt.Println. SlicesGo by Example: Slices 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package mainimport ( &quot;fmt&quot; &quot;slices&quot;)func main() { var s []string fmt.Println(&quot;uninit:&quot;, s, s == nil, len(s) == 0) s = make([]string, 3) fmt.Println(&quot;emp:&quot;, s, &quot;len:&quot;, len(s), &quot;cap:&quot;, cap(s)) s[0] = &quot;a&quot; s[1] = &quot;b&quot; s[2] = &quot;c&quot; fmt.Println(&quot;set:&quot;, s) fmt.Println(&quot;get:&quot;, s[2]) fmt.Println(&quot;len:&quot;, len(s)) s = append(s, &quot;d&quot;) s = append(s, &quot;e&quot;, &quot;f&quot;) fmt.Println(&quot;apd:&quot;, s) c := make([]string, len(s)) copy(c, s) fmt.Println(&quot;cpy:&quot;, c) l := s[2:5] fmt.Println(&quot;sl1:&quot;, l) l = s[:5] fmt.Println(&quot;sl2:&quot;, l) l = s[2:] fmt.Println(&quot;sl3:&quot;, l) t := []string{&quot;g&quot;, &quot;h&quot;, &quot;i&quot;} fmt.Println(&quot;dcl:&quot;, t) t2 := []string{&quot;g&quot;, &quot;h&quot;, &quot;i&quot;} if slices.Equal(t, t2) { fmt.Println(&quot;t == t2&quot;) } twoD := make([][]int, 3) for i := 0; i &lt; 3; i++ { innerLen := i + 1 twoD[i] = make([]int, innerLen) for j := 0; j &lt; innerLen; j++ { twoD[i][j] = i + j } } fmt.Println(&quot;2d: &quot;, twoD)} Slices are an important data type in Go, giving a more powerful interface to sequences than arrays. Unlike arrays, slices are typed only by the elements they contain (not the number of elements). An uninitialized slice equals to nil and has length 0. To create an empty slice with non-zero length, use the builtin make. Here we make a slice of strings of length 3 (initially zero-valued). By default a new slice’s capacity is equal to its length; if we know the slice is going to grow ahead of time, it’s possible to pass a capacity explicitly as an additional parameter to make. We can set and get just like with arrays. len returns the length of the slice as expected. In addition to these basic operations, slices support several more that make them richer than arrays. One is the builtin append, which returns a slice containing one or more new values. Note that we need to accept a return value from append as we may get a new slice value. Slices can also be copy’d. Here we create an empty slice c of the same length as s and copy into c from s. Slices support a “slice” operator with the syntax slice[low:high]. For example, this gets a slice of the elements s[2], s[3], and s[4]. This slices up to (but excluding) s[5]. And this slices up from (and including) s[2]. We can declare and initialize a variable for slice in a single line as well. The slices package contains a number of useful utility functions for slices. Slices can be composed into multi-dimensional data structures. The length of the inner slices can vary, unlike with multi-dimensional arrays. Note that while slices are different types than arrays, they are rendered (呈现) similarly by fmt.Println. Check out this great blog post (maybe in another blog) by the Go team for more details on the design and implementation of slices in Go.Now that we’ve seen arrays and slices we’ll look at Go’s other key builtin data structure: maps. MapsGo by Example: Maps 1234567891011121314151617181920212223242526272829303132333435363738394041package mainimport ( &quot;fmt&quot; &quot;maps&quot;)func main() { m := make(map[string]int) m[&quot;k1&quot;] = 7 m[&quot;k2&quot;] = 13 fmt.Println(&quot;map:&quot;, m) v1 := m[&quot;k1&quot;] fmt.Println(&quot;v1:&quot;, v1) v3 := m[&quot;k3&quot;] fmt.Println(&quot;v3:&quot;, v3) fmt.Println(&quot;len:&quot;, len(m)) delete(m, &quot;k2&quot;) fmt.Println(&quot;map:&quot;, m) clear(m) fmt.Println(&quot;map:&quot;, m) _, prs := m[&quot;k2&quot;] fmt.Println(&quot;prs:&quot;, prs) n := map[string]int{&quot;foo&quot;: 1, &quot;bar&quot;: 2} fmt.Println(&quot;map:&quot;, n) n2 := map[string]int{&quot;foo&quot;: 1, &quot;bar&quot;: 2} if maps.Equal(n, n2) { fmt.Println(&quot;n == n2&quot;) }} Maps are Go’s built-in associative data type (内置关联数据类型) (sometimes called hashes or dicts in other languages). To create an empty map, use the builtin make: make(map[key-type]val-type). Set key/value pairs using typical name[key] = val syntax. Printing a map with e.g. fmt.Println will show all of its key/value pairs. Get a value for a key with name[key]. If the key doesn’t exist, the zero value (maybe another blog) of the value type is returned. The builtin len returns the number of key/value pairs when called on a map. The builtin delete removes key/value pairs from a map. To remove all key/value pairs from a map, use the clear builtin. The optional second return value when getting a value from a map indicates if the key was present in the map. This can be used to disambiguate between missing keys and keys with zero values like 0 or &quot;&quot;. Here we didn’t need the value itself, so we ignored it with the blank identifier _. 当从一个 map 中取值时，还有可以选择是否接收的第二个返回值，该值表明了 map 中是否存在这个键。 这可以用来消除 键不存在 和 键的值为零值 产生的歧义， 例如 0 和 &quot;&quot;。这里我们不需要值，所以用 空白标识符(blank identifier) _ 将其忽略。 You can also declare and initialize a new map in the same line with this syntax. The maps package contains a number of useful utility functions for maps. Note that maps appear in the form map[k:v k:v] when printed with fmt.Println. next part: goByExample pt.2","link":"/2024/12/21/goByExample%20pt.1/"},{"title":"goByExample pt.2","text":"FunctionsGo by Example: Functions 1234567891011121314151617181920package mainimport &quot;fmt&quot;func plus(a, b int) int { return a + b}func plusPlus(a, b, c int) int { return a + b + c}func main(){ res := plus(1, 2) fmt.Println(&quot;1 + 2 =&quot;, res) res = plusPlus(1, 2, 3) fmt.Println( &quot;1 + 2 + 3 =&quot;, res)} Functions are central (核心/中心) in Go. We’ll learn about functions with a few different examples. Here’s a function that takes two ints and returns their sum as an int. Go requires explicit returns, i.e. (即 ) it won’t automatically return the value of the last expression. When you have multiple consecutive (连续的 ) parameters of the same type, you may omit (省略 ) the type name for the like-typed (相同类型的 ) parameters up to the final parameter that declares the type. Call a function just as you’d expect, with name(args). There are several other features to Go functions. One is multiple return values, which we’ll look at next. 123goByExample&gt; go run .\\11.functions.go1 + 2 = 31 + 2 + 3 = 6 Multiple Return ValuesGo by Example: Multiple Return Values 1234567891011121314151617package mainimport &quot;fmt&quot;func vals() (int, int) { return 3, 7}func main() { a, b := vals() fmt.Println(a) fmt.Println(b) _, c := vals() fmt.Println(c)} Go has built-in support for multiple return values. This feature is used often in idiomatic Go (这个特性在 Go 语言中经常用到), for example to return both result and error values from a function. The (int, int) in this function signature shows that the function returns 2 ints. Here we use the 2 different return values from the call with multiple assignment (多赋值操作). If you only want a subset (子集 / 一部分) of the returned values, use the blank identifier _. Accepting a variable (可变的 ) number of arguments is another nice feature of Go functions; we’ll look at this next. 1234goByExample&gt; go run '.\\12.multiple return values.go'377 Variadic FunctionsGo by Example: Variadic Functions 12345678910111213141516171819202122package mainimport &quot;fmt&quot;func sum(nums ...int) { fmt.Print(nums, &quot; &quot;) total := 0 for _, num := range nums { total += num } fmt.Println(total)}func main() { sum(1, 2) sum(1, 2, 3) nums := []int{1, 2, 3, 4} sum(nums...)} Variadic functions can be called with any number of trailing (尾随 ) arguments. For example, fmt.Println is a common variadic function. Here’s a function that will take an arbitrary (随意的 ) number of ints as arguments. Within the function, the type of nums is equivalent to []int. We can call len(nums), iterate over it with range, etc. for _, num := range nums 解释： range 表达式通常返回两个值：一个是索引，另一个是值。在这段代码中 第一个值是数组 nums 中每个元素的索引。 第二个值是数组中相应位置的元素值。 Variadic functions can be called in the usual way with individual arguments. If you already have multiple args in a slice, apply them to a variadic function using func(slice...) like this. Another key aspect of functions in Go is their ability to form closures (闭包 ) , which we’ll look at next. 1234goByExample&gt; go run '.\\13.Variadic Functions.go' [1 2] 3[1 2 3] 6[1 2 3 4] 10 ClosuresGo by Example: Closures 1234567891011121314151617181920212223package mainimport &quot;fmt&quot;func intSeq() func() int { i := 0 return func() int { i++ return i }}func main() { nextInt := intSeq() fmt.Println(nextInt()) fmt.Println(nextInt()) fmt.Println(nextInt()) newInts := intSeq() fmt.Println(newInts())} Go supports anonymous functions, which can form closures. Anonymous functions are useful when you want to define a function inline without having to name it. This function intSeq returns another function, which we define anonymously in the body of intSeq. The returned function closes over the variable i to form a closure. We call intSeq, assigning the result (a function) to nextInt. This function value captures its own i value, which will be updated each time we call nextInt. See the effect of the closure by calling nextInt a few times. To confirm that the state is unique to that particular function, create and test a new one. The last feature of functions we’ll look at for now is recursion. 12345goByExample&gt; go run '.\\14.closures.go' 1231 RecursionGo by Example: Recursion 1234567891011121314151617181920212223242526package mainimport &quot;fmt&quot;func fact(n int) int { if n == 0 { return 1 } return n * fact(n-1)}func main() { fmt.Println(fact(7)) var fib func(n int) int fib = func(n int) int { if n &lt; 2 { return n } return fib(n-1) + fib(n-2) } fmt.Println(fib(7))} Go supports recursive functions. Here’s a classic example. This fact function calls itself until it reaches the base case of fact(0). Anonymous functions can also be recursive, but this requires explicitly declaring a variable with var to store the function before it’s defined. Since fib was previously declared in main, Go knows which function to call with fib here. 123goByExample&gt; go run '.\\15.recursion.go'504013 Range over Built-in TypesGo by Example: Range over Built-in Types 1234567891011121314151617181920212223242526272829303132package mainimport &quot;fmt&quot;func main() { nums := []int{2, 3, 4} sum := 0 for _, num := range nums { sum += num } fmt.Println(&quot;sum:&quot;, sum) for i, num := range nums { if num == 3 { fmt.Println(&quot;index:&quot;, i) } } kvs := map[string]string{&quot;a&quot;: &quot;apple&quot;, &quot;b&quot;: &quot;banana&quot;} for k, v := range kvs { fmt.Printf(&quot;%s -&gt; %s\\n&quot;, k, v) } for k := range kvs { fmt.Println(&quot;key:&quot;, k) } for i, c := range &quot;go&quot; { fmt.Println(i, c) }} range iterates over elements in a variety of built-in data structures. Let’s see how to use range with some of the data structures we’ve already learned. Here we use range to sum the numbers in a slice. Arrays work like this too. range on arrays and slices provides both the index and value for each entry. Above we didn’t need the index, so we ignored it with the blank identifier _. Sometimes we actually want the indexes though. range on map iterates over key/value pairs. range can also iterate over just the keys of a map. range on strings iterates over Unicode code points. The first value is the starting byte index of the rune and the second the rune itself. See [Strings and Runes](##Strings and Runes) for more details. 123456789goByExample&gt; go run '.\\16.Range over Built-in Types.go'sum: 9index: 1a -&gt; appleb -&gt; bananakey: akey: b0 1031 111 PointersGo by Example: Pointers 123456789101112131415161718192021222324package mainimport &quot;fmt&quot;func zeroval(ival int) { ival = 0}func zeroptr(iptr *int) { *iptr = 0}func main() { i := 1 fmt.Println(&quot;initial:&quot;, i) zeroval(i) fmt.Println(&quot;zeroval:&quot;, i) zeroptr(&amp;i) fmt.Println(&quot;zeroptr:&quot;, i) fmt.Println(&quot;pointer:&quot;, &amp;i)} Go supports pointers, allowing you to pass references to values and records within your program. We’ll show how pointers work in contrast to values with 2 functions: zeroval and zeroptr. zeroval has an int parameter, so arguments will be passed to it by value. zeroval will get a copy of ival distinct from the one in the calling function. zeroptr in contrast has an *int parameter, meaning that it takes an int pointer. The *iptr code in the function body then dereferences the pointer from its memory address to the current value at that address. Assigning a value to a dereferenced pointer changes the value at the referenced address. The &amp;i syntax gives the memory address of i, i.e. a pointer to i. Pointers can be printed too. zeroval doesn’t change the i in main, but zeroptr does because it has a reference to the memory address for that variable. 12345goByExample&gt; go run '.\\17.pointers.go' initial: 1zeroval: 1zeroptr: 0pointer: 0xc00000a0d8 Strings and RunesGo by Example: Strings and Runes 123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport ( &quot;fmt&quot; &quot;unicode/utf8&quot;)func main() { const s = &quot;สวัสดี&quot; fmt.Println(&quot;Len:&quot;, len(s)) for i := 0; i &lt; len(s); i++ { fmt.Printf(&quot;%x &quot;, s[i]) } fmt.Println() fmt.Println(&quot;Rune count:&quot;, utf8.RuneCountInString(s)) for idx, runeValue := range s { fmt.Printf(&quot;%#U starts at %d\\n&quot;, runeValue, idx) } fmt.Println(&quot;\\nUsing DecodeRuneInString&quot;) for i, w := 0, 0; i &lt; len(s); i += w { runeValue, width := utf8.DecodeRuneInString(s[i:]) fmt.Printf(&quot;%#U starts at %d\\n&quot;, runeValue, i) w = width examineRune(runeValue) }}func examineRune(r rune) { if r == 't' { fmt.Println(&quot;found tee&quot;) } else if r == 'ส' { fmt.Println(&quot;found so sua&quot;) }} A Go string is a read-only slice of bytes. The language and the standard library treat strings specially - as containers of text encoded in UTF-8. In other languages, strings are made of “characters”. In Go, the concept of a character is called a rune - it’s an integer that represents a Unicode code point. This Go blog post (maybe another blog) is a good introduction to the topic. s is a string assigned a literal value representing the word “hello” in the Thai language. Go string literals are UTF-8 encoded text. Since strings are equivalent to []byte, this will produce the length of the raw bytes stored within. 因为字符串等价于 []byte， 这会产生存储在其中的原始字节的长度。 Indexing into a string produces the raw byte values at each index. This loop generates the hex values of all the bytes that constitute the code points in s. To count how many runes are in a string, we can use the utf8 package. Note that the run-time of RuneCountInString depends on the size of the string, because it has to decode each UTF-8 rune sequentially. Some Thai characters are represented by UTF-8 code points that can span multiple bytes, so the result of this count may be surprising. 要计算字符串中有多少rune，我们可以使用utf8包。 注意RuneCountInString的运行时取决于字符串的大小。 因为它必须按顺序解码每个 UTF-8 rune。 一些泰语字符由多个 UTF-8 code point 表示， 所以这个计数的结果可能会令人惊讶。 A range loop handles strings specially and decodes each rune along with its offset in the string. We can achieve the same iteration by using the utf8.DecodeRuneInString function explicitly. This demonstrates passing a rune value to a function. Values enclosed in single quotes are rune literals. We can compare a rune value to a rune literal directly. 1234567891011121314151617181920goByExample&gt; go run '.\\18.Strings and Runes.go'Len: 18e0 b8 aa e0 b8 a7 e0 b8 b1 e0 b8 aa e0 b8 94 e0 b8 b5Rune count: 6U+0E2A 'ส' starts at 0U+0E27 'ว' starts at 3U+0E31 'ั' starts at 6U+0E2A 'ส' starts at 9U+0E14 'ด' starts at 12U+0E35 'ี' starts at 15Using DecodeRuneInStringU+0E2A 'ส' starts at 0found so suaU+0E27 'ว' starts at 3U+0E31 'ั' starts at 6U+0E2A 'ส' starts at 9found so suaU+0E14 'ด' starts at 12U+0E35 'ี' starts at 15 StructsGo by Example: Structs 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package mainimport &quot;fmt&quot;type person struct { name string age int}func newPerson(name string) *person { p := person{name: name} p.age = 42 return &amp;p}func main() { fmt.Println(person{&quot;Bob&quot;, 20}) fmt.Println(person{name: &quot;Alice&quot;, age: 30}) fmt.Println(person{name: &quot;Fred&quot;}) fmt.Println(&amp;person{name: &quot;Ann&quot;, age: 40}) fmt.Println(newPerson(&quot;Jon&quot;)) s := person{name: &quot;Sean&quot;, age: 50} fmt.Println(s.name) sp := &amp;s fmt.Println(sp.age) sp.age = 51 fmt.Println(sp.age) dog := struct { name string isGood bool }{ &quot;Rex&quot;, true, } fmt.Println(dog)} Go’s structs are typed collections of fields. They’re useful for grouping data together to form records. This person struct type has name and age fields. newPerson constructs a new person struct with the given name. Go is a garbage collected language; you can safely return a pointer to a local variable - it will only be cleaned up by the garbage collector when there are no active references to it. This syntax creates a new struct. You can name the fields when initializing a struct. Omitted fields will be zero-valued. An &amp; prefix yields a pointer to the struct. It’s idiomatic to encapsulate new struct creation in constructor functions 在构造函数中封装创建新的结构实例是一种习惯用法 Access struct fields with a dot. You can also use dots with struct pointers - the pointers are automatically dereferenced. Structs are mutable (可变的 ). If a struct type is only used for a single value, we don’t have to give it a name. The value can have an anonymous struct type. This technique is commonly used for table-driven tests (goByExample pt.8). 12345678910goByExample&gt; go run '.\\19.structs.go' {Bob 20}{Alice 30}{Fred 0}&amp;{Ann 40}&amp;{Jon 42}Sean5051{Rex true} MethodsGo by Example: Methods 1234567891011121314151617181920212223242526package mainimport &quot;fmt&quot;type rect struct { width, height int}func (r *rect) area() int { return r.width * r.height}func (r rect) perim() int { return 2*r.width + 2*r.height}func main() { r := rect{width: 10, height: 5} fmt.Println(&quot;area: &quot;, r.area()) fmt.Println(&quot;perim:&quot;, r.perim()) rp := &amp;r fmt.Println(&quot;area: &quot;, rp.area()) fmt.Println(&quot;perim:&quot;, rp.perim())} Go supports methods defined on struct types. This area method has a receiver type of *rect. Methods can be defined for either pointer or value receiver types. Here’s an example of a value receiver. Here we call the 2 methods defined for our struct. Go automatically handles conversion between values and pointers for method calls. You may want to use a pointer receiver type to avoid copying on method calls or to allow the method to mutate the receiving struct. Next we’ll look at Go’s mechanism (机制 ) for grouping and naming related sets of methods: interfaces. 12345goByExample&gt; go run '.\\20.Methods.go'area: 50perim: 30area: 50perim: 30","link":"/2024/12/23/goByExample-pt-2/"},{"title":"test-pic","text":"test file for insert imgs","link":"/2024/12/21/test-pic/"},{"title":"Test","text":"Testit’s a test file for hexo","link":"/2024/12/21/Test/"}],"tags":[{"name":"Golang","slug":"Golang","link":"/tags/Golang/"},{"name":"English","slug":"English","link":"/tags/English/"},{"name":"test","slug":"test","link":"/tags/test/"},{"name":"img","slug":"img","link":"/tags/img/"}],"categories":[{"name":"Golang","slug":"Golang","link":"/categories/Golang/"},{"name":"test","slug":"test","link":"/categories/test/"},{"name":"basics","slug":"Golang/basics","link":"/categories/Golang/basics/"}],"pages":[{"title":"categories","text":"","link":"/categories/index.html"}]}