{"posts":[{"title":"Arch Install","text":"1. 安装前的准备根据 Arch Wiki 和 ChatGPT 所给的内容安装 Arch Linux 1.1 配置控制台键盘布局和字体由于默认字体太小，本次安装使用适合 HiDPI 屏幕[^hdpi]的最大字体之一 —— ter-132b 进行安装 [^hdpi]:HiDPI（High Dots Per Inch）显示器，指的是在较小尺寸下却拥有较高分辨率的显示器。Apple 将其称作“视网膜屏幕”，这项技术主要存在于高端笔记本电脑和显示器中。 要修改控制台字体，只需运行 1# setfont ter-132b 命令即可。 1.2 切换UEFI模式安装VMware默认安装模式为 Legacy BIOS ，与Arch Wiki不符，故改为 UEFI模式 进行安装。 只需在VMware设置中修改即可。 以下内容由ChatGPT提供： 如何确认引导模式？你可以使用以下方法确认系统是以 BIOS 还是 UEFI 启动的： 方法 1：检查 /sys/firmware/efi/1ls /sys/firmware/efi 如果目录不存在，就说明是 Legacy BIOS 模式。 方法 2：使用 efivar 命令（仅适用于 UEFI）1efivar -l 如果 efivar 命令不可用，或者返回 **”No such file or directory”**，说明系统是 Legacy BIOS 模式。 方法 3：使用 dmesg 命令1dmesg | grep -i efi 如果系统是 UEFI，会输出一些 EFI 相关的日志。如果没有任何输出，则是 Legacy BIOS。 1.3 验证引导模式要验证系统目前的引导模式，请检查 UEFI 位数： 1# cat /sys/firmware/efi/fw_platform_size 如果命令结果为 64，则系统是以 UEFI 模式引导且使用 64 位 x64 UEFI。如果命令结果为 32，则系统是以 UEFI 模式引导且使用 32 位 IA32 UEFI，虽然其受支持，但引导加载程序只能使用 systemd-boot和GRUB。如果文件不存在，则系统可能是以BIOS模式（或 CSM 模式）(这两种模式通常出现在老旧的电脑或未经配置的虚拟机上）引导。如果系统没有以您想要的模式（UEFI 或 BIOS）引导启动，请您参考自己的计算机或主板说明书。 1.4 连接到互联网要在 Live 环境中配置网络连接，请遵循以下步骤： 确保系统已经列出并启用了 网络接口，用 ip-link(8) 检查： 1# ip link 对于无线局域网（Wi-Fi）和无线广域网（WWAN），请确保网卡未被 rfkill 禁用。 连接到网络： 有线以太网——连接网线。 WiFi——使用 iwctl 认证无线网络。 移动宽带调制解调器（移动网卡） - 使用 mmcli 连接到移动网络。 配置网络连接： DHCP：对于有线以太网、无线局域网（WLAN）和无线广域网（WWAN）网络接口来说，动态 IP 地址和 DNS 服务器分配（由 systemd-networkd 和 systemd-resolved 提供功能）能够开箱即用。 静态 IP 地址：按照网络配置#静态 IP 地址进行操作。 用 ping 检查网络连接： 1# ping archlinux.org 由于是通过VMware安装，网络连接已经配置好了。 1.5 更新系统时间在 Live 环境中 systemd-timesyncd 默认启用，也就是说当系统已经创建互联网连接后，系统时间将自动同步。 使用 timedatectl(1) 确保系统时间是同步的，建议提前执行 timedatectl set-timezone *地区/城市*（中国用户可以使用 timedatectl set-timezone Asia/Shanghai 以设置北京时间）： 1# timedatectl 1.6 创建硬盘分区在 Arch Linux 安装过程中，你需要先对硬盘进行分区。你可以使用 fdisk 或 cfdisk 等工具。 方法 1：使用 fdisk（推荐）fdisk 是命令行工具，适合对磁盘进行精确控制。 1. 查看磁盘先列出所有磁盘： 1lsblk 或者： 1fdisk -l 找到你的目标磁盘，例如 /dev/sda（注意：不要选错磁盘）。 2. 进入 fdisk1fdisk /dev/sda 注意： /dev/sda 是你的目标磁盘，可能需要改成 /dev/nvme0n1 或 /dev/vda，根据实际情况调整。 3. 删除现有分区（如果需要）如果磁盘上已有分区，可以输入 d 并选择要删除的分区，重复此操作直到所有旧分区删除完毕。 4. 创建新分区按照 UEFI 或 BIOS 模式进行分区： UEFI 模式（推荐） 创建 EFI 分区 （512MB，类型 1EFI System ）： 输入 n（新建分区） 选择 1 First sector：默认回车 Last sector：输入 +512M 输入 t（修改类型），然后输入 1（EFI System） 创建 Swap 分区 （可选，4GB+）： 输入 n，选择 2 First sector：默认回车 Last sector：输入 +4G（根据需要调整） 输入 t，选择 2，然后输入 19（Linux swap） 创建 根分区（剩余空间） ： 输入 n，选择 3 First sector：默认回车 Last sector：默认回车（使用剩余空间） Legacy BIOS 模式 创建 主分区（整个磁盘） ： 输入 n，选择 1 First sector：默认回车 Last sector：默认回车（使用整个磁盘） 创建 Swap 分区（可选，4GB+） ： 输入 n，选择 2 First sector：默认回车 Last sector：输入 +4G 输入 t，选择 2，然后输入 82（Linux swap） 5. 写入分区表并退出输入： 12345bashCopyEditw 这样磁盘分区就完成了！ 方法 2：使用 cfdisk（简单易用）如果你更喜欢图形界面： 1cfdisk /dev/sda 选择 分区表类型 ： UEFI 模式 选择 gpt BIOS 模式 选择 dos 选择 New 创建分区，按照上面的 UEFI 或 BIOS 分区方案进行操作。 选择 Write 并确认写入分区表。 选择 Quit 退出。 格式化分区分区完成后，需要格式化： 1234mkfs.fat -F32 /dev/sda1 # EFI 分区（UEFI 模式）mkfs.ext4 /dev/sda2 # 根分区mkswap /dev/sda3 # Swap 分区swapon /dev/sda3 # 启用 Swap 如果是 BIOS 模式： 123mkfs.ext4 /dev/sda1mkswap /dev/sda2swapon /dev/sda2 分区方案示例 已安装系统上的挂载点 分区 分区类型 建议大小 /boot1 /dev/*efi_system_partition* EFI system partition 1 GiB。 [SWAP] /dev/*swap_partition* Linux swap (交换空间) 至少 4GiB / /dev/*root_partition* Linux x86-64 根目录 (/) 设备剩余空间，至少23-32GiB 1.7 格式化分区为什么要格式化分区？ 创建文件系统：分区本身只是划分磁盘的区域，而格式化会在分区上创建具体的文件系统，使操作系统能存储和管理文件。 确保数据结构一致：不同的操作系统和用途需要不同的文件系统，比如 Linux 用 ext4，UEFI 需要 FAT32。 清除已有数据：格式化会清空原有数据，防止磁盘上的旧数据影响新系统。 各个命令的解释在 Arch Linux 安装过程中，我们会用到以下格式化命令： 1. 格式化 EFI 分区（仅适用于 UEFI 模式）1mkfs.fat -F32 /dev/sda1 解释： mkfs.fat：创建 FAT 文件系统。 -F32：指定使用 FAT32 格式，这是 UEFI 规范要求的格式。 /dev/sda1：要格式化的分区（UEFI 下 /dev/sda1 通常是 EFI 分区）。 为什么要用 FAT32？UEFI 固件只能识别 FAT 文件系统，因此 EFI 分区必须使用 FAT32，否则引导失败。 2. 格式化 Linux 根分区1mkfs.ext4 /dev/sda2 解释： mkfs.ext4：创建 ext4 文件系统（Linux 常用的文件系统）。 /dev/sda2：要格式化的分区（这里假设 /dev/sda2 是根分区）。 为什么要用 ext4？ ext4 是 Linux 默认的文件系统，稳定可靠，支持大文件和日志功能。 你也可以选择 btrfs、xfs 或 f2fs，但 ext4 兼容性最好。 3. 格式化并启用 Swap 分区12mkswap /dev/sda3swapon /dev/sda3 解释： mkswap /dev/sda3：将 /dev/sda3 分区格式化为 Swap 分区（交换空间）。 swapon /dev/sda3：启用 Swap 分区，使其生效。 为什么需要 Swap？Swap 主要用于： 内存不足时使用（比如你的物理内存 4GB，但程序需要 6GB，系统会用 Swap 临时存储数据）。 休眠（hibernate）支持（如果你的 Swap 够大，Linux 可以将内存数据写入 Swap 并休眠）。 防止 OOM（Out of Memory）（Swap 让系统在内存不足时还能继续运行，而不是直接崩溃）。 Swap 该分多大？ 无特殊需求：分配和物理内存一样大（4GB 内存 → 4GB Swap）。 想用休眠（Hibernate）：Swap 至少等于 物理内存大小。 服务器或高内存机器：可以少分甚至不分 Swap。 1.8 挂载分区挂载 UEFI 分区方案假设你的分区结构如下： /dev/sda1 → EFI 分区（FAT32，512MB） /dev/sda2 → 根分区（ext4） /dev/sda3 → Swap 分区（可选） 1. 挂载根分区（/）1mount /dev/sda2 /mnt 这会把 /dev/sda2（根分区）挂载到 /mnt，后续的 Arch Linux 安装都将在 /mnt 目录下进行。 2. 创建 /boot/efi 目录并挂载 EFI 分区12mkdir -p /mnt/boot/efimount /dev/sda1 /mnt/boot/efi mkdir -p /mnt/boot/efi：创建 EFI 挂载点。 mount /dev/sda1 /mnt/boot/efi：挂载 EFI 分区到 /mnt/boot/efi，使系统能正确安装引导程序（如 systemd-boot 或 grub）。 3. 启用 Swap 分区（如果有）1swapon /dev/sda3 这会让 Swap 分区生效，提高内存不足时的稳定性。 检查挂载情况可以用以下命令确认分区是否正确挂载： 1lsblk 你应该能看到类似的输出： 12345NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTsda 8:0 0 20G 0 disk ├─sda1 8:1 0 512M 0 part /mnt/boot/efi├─sda2 8:2 0 19G 0 part /mnt└─sda3 8:3 0 1G 0 part [SWAP] 这样，你的 UEFI 分区方案就正确挂载完成了！ 2. 开始安装系统2.1 选择镜像站系统的文件 /etc/pacman.d/mirrorlist 中定义了软件包会从哪个镜像站下载。在 LiveCD 启动的系统上，且在连接到互联网后，reflector 会通过选择 20 个最新同步的 HTTPS 镜像站并按下载速率对其进行排序来更新镜像列表（由于只考虑最新的 20 个镜像站，其结果常不佳）。 在列表中，越靠前的镜像站在下载软件包时，就会有越高的优先级。请您检查 /etc/pacman.d/mirrorlist 文件，看看列出的镜像站的顺序是否合适。如果不合适，可以手动编辑文件，将离您所处地理位置最近的镜像移到文件的头部，同时也应该考虑一些其他的评判标准。 如果 /etc/pacman.d/mirrorlist 文件中没有合适的镜像站，可以手动从 archlinux 官方网站的镜像站列表下载一份。这需要您所在的网络能够正常访问 archlinux 官方网站。例如，使用 curl(1) 下载位于中国大陆的 HTTPS 镜像站： 1# curl -L 'https://archlinux.org/mirrorlist/?country=CN&amp;protocol=https' -o /etc/pacman.d/mirrorlist 或者，也可以通过安装 pacman-mirrorlist包 来获取按国家分列的原始镜像列表。这么做的缺点是，pacman 仍然会使用当前配置中的镜像站来下载软件包数据库和 pacman-mirrorlist包，这可能会很慢。在挑选了能用的镜像之后，可以执行 1# pacman -Sy pacman-mirrorlist 再将 /etc/pacman.d/mirrorlist.pacnew 复制到 /etc/pacman.d/mirrorlist 并进行编辑。 或者，如果您记得想要使用的镜像站的 URL，那么可以手动编辑 /etc/pacman.d/mirrorlist 文件并手动输入 URL。 这个文件接下来还会被 pacstrap 拷贝到新系统里，所以请您确保设置正确。 2.2 更新密钥环过时的Live 系统内置密钥环会导致在 pacstrap 的时候无法正常安装软件包（提示为文件签名损坏）。 1# pacman -Syu archlinux-keyring 使用上面的命令更新当前 Live 系统的密钥环，也可以防止因为意外导致开发者私钥被盗用造成的安全问题。 如果您在 Live 系统里启用了中文社区仓库或其他非官方用户仓库，也不要忘了一同更新其密钥环。 参见 pacman/软件包签名。 2.3 安装必需的软件包使用 pacstrap(8) 脚本，安装 base包 软件包和 Linux 内核以及常规硬件的固件： 1# pacstrap -K /mnt base linux linux-firmware 这时候可以同时额外安装计算机的 CPU 微码包。如果计算机是 Intel 的 CPU ，使用 intel-ucode包，AMD CPU 则使用 amd-ucode包。也可以暂时都不安装，等到进入系统后再安装。 base包 软件包并没有包含 Live 环境中的全部程序。因此要获得一个功能齐全的基本系统，可能需要安装更多软件包。要安装其他软件包或软件包组（比如 base-devel包组），请将它们的名字追加到下面的 pacstrap 命令后（以空格分隔），或者也可以在 Chroot 进入新系统后使用 pacman 手动安装。特别要考虑安装： GPG 密钥环（如 archlinuxcn-keyringCNRepo，若启用了某些非官方用户仓库。） 控制台文本编辑器（如 nano、vim 和 emacs包）以便从控制台编辑配置文件（如点文件）。 访问和管理 RAID 或 LVM 分区的工具。 联网所需要的程序（例如网络管理器或 DHCP 客户端，Wi-Fi 认证软件和移动宽带连接所需的 ModemManager，以及部分 USB 无线网卡需要的 usb_modeswitch包）。 文件系统的用户工具（比如 XFS 和 Btrfs 文件系统对应的管理工具），可用于创建和管理文件系统以及 fsck。 CPU 微码更新 —— amd-ucode包 或 intel-ucode包 —— 用于硬件错误和安全修复。 未包含在 linux-firmware包 中的额外必需固件（如用于内建音频的 sof-firmware包、用于 Marvell 无线的 linux-firmware-marvell包 以及博通无线网卡的固件包)。 文件 pkglist.x86_64.txt 中包含 Live 系统安装的软件包列表。 3. 配置系统3.1 生成 fstab 文件通过以下命令生成 fstab 文件 (用 -U 或 -L 选项设置 UUID 或卷标)： 1# genfstab -U /mnt &gt; /mnt/etc/fstab 强烈建议在执行完以上命令后，检查一下生成的 /mnt/etc/fstab 文件是否正确。如果有问题，最好在现在手动修改。对于熟练者，可以自行编辑 /mnt/etc/fstab 文件。 可以手动修改 /mnt/etc/fstab 添加挂载选项（参见 mount(8) § FILESYSTEM-INDEPENDENT_MOUNT_OPTIONS 和 ext4(5) § MOUNT_OPTIONS）。例如，给固态硬盘的 ext4 文件系统添加 discard 选项以启用 TRIM。 3.2 chroot 到新安装的系统通过以下命令 chroot 到新安装的系统： 1# arch-chroot /mnt 提示：此处使用的是arch-chroot而不是直接使用chroot，注意不要输错了。 3.3 设置时区通过以下命令设置时区： 1# ln -sf /usr/share/zoneinfo/Region（地区名）/City（城市名） /etc/localtime 提示：例如，在中国大陆需要将时区设置为北京时间，那么请运行 # ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime。时区名称是上海而非北京，是因为上海是该时区内人口最多的城市（参考来源）。 然后运行 hwclock(8) 以生成 /etc/adjtime： 1# hwclock --systohc 这个命令假定已设置硬件时间为 UTC 时间。详细信息请查看系统时间#时间标准。 为了防止时钟漂移并确保时间准确，请使用 NTP（网络时间协议，Network Time Protocol）客户端（例如 systemd-timesyncd）设置时间同步。 3.4 区域和本地化设置程序和库如果需要本地化文本，都依赖区域设置，后者明确规定了地域、货币、时区日期的格式、字符排列方式和其他本地化标准。 需要设置这两个文件：locale.gen 与 locale.conf。 编辑 /etc/locale.gen，然后取消掉 en_US.UTF-8 UTF-8 和其他需要的 UTF-8 区域设置前的注释（**#**）。 接着执行 locale-gen 以生成 locale 信息： 1# locale-gen 然后创建 locale.conf(5) 文件，并编辑设定 LANG 变量，比如： 12/etc/locale.confLANG=en_US.UTF-8 另外对于中文用户： 提示： 用户可以设置自己的 locale，详情请参阅 在用户会话中覆盖系统区域设置 或 设置当前区域； 将系统 locale 设置为en_US.UTF-8，系统的日志就会用英文显示，这样更容易判断和处理问题； 也可以设置为 en_GB.UTF-8 ［英语（英国）］或 en_SG.UTF-8 ［英语（新加坡）］，附带以下特点： 进入桌面环境后以 24 小时制显示时间； LibreOffice 等办公软件的纸张尺寸会默认为 A4 而非 Letter(US)； 可尽量避免不必要且可能造成处理麻烦的英制单位。 设置的 LANG 变量需与 locale 设置一致，否则会出现以下错误： 警告：并不推荐在此设置任何中文 locale，这可能会导致 tty 上中文显示为方块（因为 TTY 下没有 CJK 字体）。如果您不经常使用 tty ，或是稍后需要安装桌面环境，则在不使用 tty 后可以设置为中文的 locale 。为了使 TTY 显示中文，也可以使用打了补丁的内核，如 linux-lilyCNRepo。 如果需要修改#控制台键盘布局和字体，可编辑 vconsole.conf(5) 使其长期生效，以德语键盘（qwertz）为例： 12/etc/vconsole.confKEYMAP=de-latin1 注意：如果键盘为标准美式键盘（中国最常见的键盘布局），请勿照抄如上设置。 3.5 网络配置创建 hostname 文件： 12/etc/hostname主机名 请接着完成新安装的环境的网络配置，配置过程中可能需要安装合适的网络管理软件。 警告：请按上述网络配置指引正确配置好网络后再重新启动，否则系统重新启动后可能无法连接网络（不过可以用 LiveCD 重新进入 arch-chroot 进行配置）。例如在虚拟机软件 VirtualBox 安装并使用桥接模式时就需要配置 DHCP 。 3.6 关于 initramfs通常不需要自己创建新的 initramfs，因为在执行 pacstrap 时已经安装 linux包，这时已经运行过 mkinitcpio 了。 如果是 LVM、系统加密或 RAID 等分区配置，请修改 mkinitcpio.conf 并用以下命令重新创建一个 Initramfs： 1# mkinitcpio -P 3.7 设置 root 密码使用以下命令设置 root 密码： 1# passwd 提示：建议为 root 用户选择一个强密码并保护其安全。 3.8 安装引导程序需要安装 Linux 引导加载程序，才能在安装后启动系统，可以使用的的引导程序已在引导加载程序中列出，请选择一个安装并配置它，GRUB 是一个比较常见且通用的选择。 警告：这是安装的最后一步也是关键的一步，请点击上述链接并按指引正确安装好引导加载程序后再重新启动。否则计算机重新启动后将无法正常进入 Arch Linux 系统。","link":"/2025/02/24/Arch%20Linux/arch-install/"},{"title":"goByExample pt.1","text":"Hello WorldGo by Example: hello-world 123456789package mainimport ( &quot;fmt&quot;)func main() { fmt.Println(&quot;Hello World&quot;)} To run the program, put the code in hello-world.go and use go run. Sometimes we’ll want to build our programs into binaries. We can do this using go build. We can then execute the built binary directly. Now that we can run and build basic Go programs, let’s learn more about the language. ValuesGo by Example: values 1234567891011121314151617181920212223package mainimport ( &quot;fmt&quot;)func main() { // &quot;golang&quot; fmt.Println(&quot;go&quot; + &quot;lang&quot;) // &quot;1 + 1 = 2&quot; fmt.Println(&quot;1 + 1 =&quot;, 1 + 1) // &quot;7.0 / 3.0 = 2.3333333333333335&quot; fmt.Println(&quot;7.0 / 3.0 =&quot;, 7.0 / 3.0) // false fmt.Println(true &amp;&amp; false) // true fmt.Println(true || false) // false fmt.Println(!true)} Go has various value types including strings, integers, floats, booleans, etc. Here are a few basic examples. VariablesGo by Example: Variables 1234567891011121314151617181920package mainimport &quot;fmt&quot;func main() { var a = &quot;initial&quot; fmt.Println(a) var b, c int= 1, 2 fmt.Println(b, c) var d = true fmt.Println(d) var e int fmt.Println(e) f := &quot;apple&quot; fmt.Println(f)} In Go, variables are explicitly (明确的) declared and used by the compiler to e.g. check type-correctness of function calls. var declares 1 or more variables. You can declare multiple variables at once. Go will infer the type of initialized variables. Variables declared without a corresponding initialization are zero-valued. For example, the zero value for an int is 0. The := syntax is shorthand for declaring and initializing a variable, e.g. for var f string = &quot;apple&quot; in this case. This syntax is only available inside functions. ConstantsGo by Example: Constants 123456789101112131415161718192021package mainimport ( &quot;fmt&quot; &quot;math&quot;)const s string = &quot;constant&quot;func main(){ fmt.Println(s) const n = 500000000 const d = 3e20 / n fmt.Println(d) fmt.Println(int64(d)) fmt.Println(math.Sin(n))} Go supports constants of character, string, boolean, and numeric (数学) values. const declares a constant value. A const statement can appear anywhere a var statement can. Constant expressions perform arithmetic (算数) with arbitrary precision (任意精度). A numeric constant has no type until it’s given one, such as by an explicit conversion (转换). A number can be given a type by using it in a context that requires one, such as a variable assignment or function call. For example, here math.Sin expects a float64. ForGo by Example: For 1234567891011121314151617181920212223242526272829303132package mainimport &quot;fmt&quot;func main() { i := 1 for i &lt;= 3 { fmt.Println(i) i = i + 1 } for j := 0; j &lt; 3; j++ { fmt.Println(j) } for i := range 3 { fmt.Println(&quot;range&quot;, i) } for { fmt.Println(&quot;loop&quot;) break } for n := range 6 { if n % 2 == 0 { continue } fmt.Println(n) }} for is Go’s only looping construct. Here are some basic types of for loops. 1st: The most basic type, with a single condition. 2nd: A classic initial/condition/after for loop. 3rd: Another way of accomplishing the basic “do this N times” iteration is range over an integer. 4th: for without a condition will loop repeatedly until you break out of the loop or return from the enclosing function.(the while in go) 5th: You can also continue to the next iteration of the loop. If/ElseGo by Example: If/Else 12345678910111213141516171819202122232425262728package mainimport &quot;fmt&quot;func main() { if 7%2 == 0 { fmt.Println(&quot;7 is even&quot;) } else { fmt.Println(&quot;7 is odd&quot;) } if 8%4 == 0 { fmt.Println(&quot;8 is divisible by 4&quot;) } if 8%2 == 0 || 7%2 == 0 { fmt.Println(&quot;either 8 or 7 are even&quot;) } if num := 9; num &lt; 0 { fmt.Println(num, &quot;is negative&quot;) } else if num &lt; 10 { fmt.Println(num, &quot;has 1 digit&quot;) } else { fmt.Println(num, &quot;has multiple digits&quot;) }} Branching with if and else in Go is straight-forward. You can have an if statement without an else. Logical operators like &amp;&amp; and || are often useful in conditions. A statement can precede conditionals; any variables declared in this statement are available in the current and all subsequent branches. 语句可以位于条件之前；此语句中声明的任何变量均可在当前分支和所有后续分支中使用。 Note that you don’t need parentheses (小括号) around conditions in Go, but that the braces (大括号) are required. There is no ternary if (三元运算符) in Go, so you’ll need to use a full if statement even for basic conditions. SwitchGo by Example: Switch 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package mainimport ( &quot;fmt&quot; &quot;time&quot;)func main() { i := 2 fmt.Print(&quot;Write &quot;, i, &quot; as &quot;) switch i { case 1: fmt.Println(&quot;one&quot;) case 2: fmt.Println(&quot;two&quot;) case 3: fmt.Println(&quot;three&quot;) } switch time.Now().Weekday() { case time.Saturday, time.Sunday: fmt.Println(&quot;It's the weekend&quot;) default: fmt.Println(&quot;It's a weekday&quot;) } t := time.Now() switch { case t.Hour() &lt; 12: fmt.Println(&quot;It's before noon&quot;) default: fmt.Println(&quot;It's after noon&quot;) } whatAmI := func(i interface{}) { switch t := i.(type) { case bool: fmt.Println(&quot;I'm a bool&quot;) case int: fmt.Println(&quot;I'm an int&quot;) default: fmt.Printf(&quot;Don't know type %T\\n&quot;, t) } } whatAmI(true) whatAmI(1) whatAmI(&quot;hey&quot;)} Switch statements express conditionals across many branches. You can use commas to separate multiple expressions in the same case statement. We use the optional default case in this example as well. switch without an expression is an alternate way to express if/else logic. Here we also show how the case expressions can be non-constants (case 表达式如何可以是非常量). A type switch compares types instead of values. You can use this to discover the type of an interface value. In this example, the variable t will have the type corresponding to its clause. ArraysGo by Example: Arrays 12345678910111213141516171819202122232425262728293031323334353637383940414243package mainimport &quot;fmt&quot;func main() { // a: 0 0 0 0 0 var a [5]int fmt.Println(&quot;emp:&quot;, a) // a: 0 0 0 0 100 a[4] = 100 fmt.Println(&quot;set:&quot;, a) fmt.Println(&quot;get:&quot;, a[4]) fmt.Println(&quot;len:&quot;, len(a)) // b: 1 2 3 4 5 b := [5]int{1, 2, 3, 4, 5} fmt.Println(&quot;dcl:&quot;, b) // b: 1 2 3 4 5 // len = 5 b = [...]int{1, 2, 3, 4, 5} fmt.Println(&quot;dcl:&quot;, b) b = [...]int{100, 3: 400, 500} fmt.Println(&quot;idx:&quot;, b) var twoD [2][3]int for i := 0; i &lt; 2; i++ { for j := 0; j &lt; 3; j++ { twoD[i][j] = i + j } } fmt.Println(&quot;2d: &quot;, twoD) twoD = [2][3]int{ {1, 2, 3}, {1, 2, 3}, } fmt.Println(&quot;2d: &quot;, twoD)} In Go, an array is a numbered sequence of elements of a specific length. In typical Go code, slices (the next) are much more common; arrays are useful in some special scenarios (场景). Here we create an array a that will hold exactly 5 ints. The type of elements and length are both part of the array’s type. By default an array is zero-valued, which for ints means 0s. We can set a value at an index using the array[index] = value syntax, and get a value with array[index]. The builtin len returns the length of an array. Use this syntax to declare and initialize an array in one line. You can also have the compiler count the number of elements for you with ... If you specify the index with :, the elements in between will be zeroed. 如果使用 : 指定索引，则其间的元素将被清零 b = [...]int{100, 3: 400, 500} [...]int 表示一个整数类型的数组，Go会根据初始化时的元素数量自动推断数组的大小。 100 赋值给数组的第一个位置，b[0] = 100。 3: 400 表示将数组的索引 3 设置为 400，即 b[3] = 400。这里使用了索引赋值的语法：索引:值，它将数组的特定位置初始化为给定的值。 500 会自动赋值给数组的最后一个位置，也就是 b[4] = 500。 Array types are one-dimensional, but you can compose types to build multi-dimensional data structures. You can create and initialize multi-dimensional arrays at once too. Note that arrays appear in the form [v1 v2 v3 ...] when printed with fmt.Println. SlicesGo by Example: Slices 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package mainimport ( &quot;fmt&quot; &quot;slices&quot;)func main() { var s []string fmt.Println(&quot;uninit:&quot;, s, s == nil, len(s) == 0) s = make([]string, 3) fmt.Println(&quot;emp:&quot;, s, &quot;len:&quot;, len(s), &quot;cap:&quot;, cap(s)) s[0] = &quot;a&quot; s[1] = &quot;b&quot; s[2] = &quot;c&quot; fmt.Println(&quot;set:&quot;, s) fmt.Println(&quot;get:&quot;, s[2]) fmt.Println(&quot;len:&quot;, len(s)) s = append(s, &quot;d&quot;) s = append(s, &quot;e&quot;, &quot;f&quot;) fmt.Println(&quot;apd:&quot;, s) c := make([]string, len(s)) copy(c, s) fmt.Println(&quot;cpy:&quot;, c) l := s[2:5] fmt.Println(&quot;sl1:&quot;, l) l = s[:5] fmt.Println(&quot;sl2:&quot;, l) l = s[2:] fmt.Println(&quot;sl3:&quot;, l) t := []string{&quot;g&quot;, &quot;h&quot;, &quot;i&quot;} fmt.Println(&quot;dcl:&quot;, t) t2 := []string{&quot;g&quot;, &quot;h&quot;, &quot;i&quot;} if slices.Equal(t, t2) { fmt.Println(&quot;t == t2&quot;) } twoD := make([][]int, 3) for i := 0; i &lt; 3; i++ { innerLen := i + 1 twoD[i] = make([]int, innerLen) for j := 0; j &lt; innerLen; j++ { twoD[i][j] = i + j } } fmt.Println(&quot;2d: &quot;, twoD)} Slices are an important data type in Go, giving a more powerful interface to sequences than arrays. Unlike arrays, slices are typed only by the elements they contain (not the number of elements). An uninitialized slice equals to nil and has length 0. To create an empty slice with non-zero length, use the builtin make. Here we make a slice of strings of length 3 (initially zero-valued). By default a new slice’s capacity is equal to its length; if we know the slice is going to grow ahead of time, it’s possible to pass a capacity explicitly as an additional parameter to make. We can set and get just like with arrays. len returns the length of the slice as expected. In addition to these basic operations, slices support several more that make them richer than arrays. One is the builtin append, which returns a slice containing one or more new values. Note that we need to accept a return value from append as we may get a new slice value. Slices can also be copy’d. Here we create an empty slice c of the same length as s and copy into c from s. Slices support a “slice” operator with the syntax slice[low:high]. For example, this gets a slice of the elements s[2], s[3], and s[4]. This slices up to (but excluding) s[5]. And this slices up from (and including) s[2]. We can declare and initialize a variable for slice in a single line as well. The slices package contains a number of useful utility functions for slices. Slices can be composed into multi-dimensional data structures. The length of the inner slices can vary, unlike with multi-dimensional arrays. Note that while slices are different types than arrays, they are rendered (呈现) similarly by fmt.Println. Check out this great blog post (maybe in another blog) by the Go team for more details on the design and implementation of slices in Go.Now that we’ve seen arrays and slices we’ll look at Go’s other key builtin data structure: maps. MapsGo by Example: Maps 1234567891011121314151617181920212223242526272829303132333435363738394041package mainimport ( &quot;fmt&quot; &quot;maps&quot;)func main() { m := make(map[string]int) m[&quot;k1&quot;] = 7 m[&quot;k2&quot;] = 13 fmt.Println(&quot;map:&quot;, m) v1 := m[&quot;k1&quot;] fmt.Println(&quot;v1:&quot;, v1) v3 := m[&quot;k3&quot;] fmt.Println(&quot;v3:&quot;, v3) fmt.Println(&quot;len:&quot;, len(m)) delete(m, &quot;k2&quot;) fmt.Println(&quot;map:&quot;, m) clear(m) fmt.Println(&quot;map:&quot;, m) _, prs := m[&quot;k2&quot;] fmt.Println(&quot;prs:&quot;, prs) n := map[string]int{&quot;foo&quot;: 1, &quot;bar&quot;: 2} fmt.Println(&quot;map:&quot;, n) n2 := map[string]int{&quot;foo&quot;: 1, &quot;bar&quot;: 2} if maps.Equal(n, n2) { fmt.Println(&quot;n == n2&quot;) }} Maps are Go’s built-in associative data type (内置关联数据类型) (sometimes called hashes or dicts in other languages). To create an empty map, use the builtin make: make(map[key-type]val-type). Set key/value pairs using typical name[key] = val syntax. Printing a map with e.g. fmt.Println will show all of its key/value pairs. Get a value for a key with name[key]. If the key doesn’t exist, the zero value (maybe another blog) of the value type is returned. The builtin len returns the number of key/value pairs when called on a map. The builtin delete removes key/value pairs from a map. To remove all key/value pairs from a map, use the clear builtin. The optional second return value when getting a value from a map indicates if the key was present in the map. This can be used to disambiguate between missing keys and keys with zero values like 0 or &quot;&quot;. Here we didn’t need the value itself, so we ignored it with the blank identifier _. 当从一个 map 中取值时，还有可以选择是否接收的第二个返回值，该值表明了 map 中是否存在这个键。 这可以用来消除 键不存在 和 键的值为零值 产生的歧义， 例如 0 和 &quot;&quot;。这里我们不需要值，所以用 空白标识符(blank identifier) _ 将其忽略。 You can also declare and initialize a new map in the same line with this syntax. The maps package contains a number of useful utility functions for maps. Note that maps appear in the form map[k:v k:v] when printed with fmt.Println. next part: goByExample pt.2","link":"/2024/12/21/goByExample/goByExample-pt-1/"},{"title":"goByExample pt.3","text":"InterfacesGo by Example: Interfaces 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package mainimport ( &quot;fmt&quot; &quot;math&quot;)type geometry interface { area() float64 perim() float64}type rect struct { width, height float64}type circle struct { radius float64}func (r rect) area() float64 { return r.width * r.height}func (r rect) perim() float64 { return 2*r.width + 2*r.height}func (c circle) area() float64 { return math.Pi * c.radius * c.radius}func (c circle) perim() float64 { return 2 * math.Pi * c.radius}func measure(g geometry) { fmt.Println(g) fmt.Println(g.area()) fmt.Println(g.perim())}func main() { r := rect{width: 3, height: 4} c := circle{radius: 5} measure(r) measure(c)} Interfaces are named collections of method signatures. Here’s a basic interface for geometric shapes. For our example we’ll implement this interface on rect and circle types. To implement an interface in Go, we just need to implement all the methods in the interface. Here we implement geometry on rects. The implementation for circles. If a variable has an interface type, then we can call methods that are in the named interface. Here’s a generic measure function taking advantage of this to work on any geometry. The circle and rect struct types both implement the geometry interface so we can use instances of these structs as arguments to measure. To learn more about Go’s interfaces, check out this great blog post (maybe another blog). 1234567goByExample&gt; go run .\\21.Interfaces.go{3 4}1214{5}78.5398163397448331.41592653589793 EnumsGo by Example: Enums 1234567891011121314151617181920212223242526272829303132333435363738394041424344package mainimport &quot;fmt&quot;type ServerState intconst ( StateIdle ServerState = iota StateConnected StateError StateRetrying)var stateName = map[ServerState]string{ StateIdle: &quot;idle&quot;, StateConnected: &quot;connected&quot;, StateError: &quot;error&quot;, StateRetrying: &quot;retrying&quot;,}func (ss ServerState) String() string { return stateName[ss]}func main() { ns := transition(StateIdle) fmt.Println(ns) ns2 := transition(ns) fmt.Println(ns2)}func transition(s ServerState) ServerState { switch s { case StateIdle: return StateConnected case StateConnected, StateRetrying: return StateIdle case StateError: return StateError default: panic(fmt.Errorf(&quot;unknown state: %s&quot;, s)) }} Enumerated types (enums) are a special case of sum types. An enum is a type that has a fixed number of possible values, each with a distinct name. Go doesn’t have an enum type as a distinct language feature, but enums are simple to implement using existing language idioms. Our enum type ServerState has an underlying int type. The possible values for ServerState are defined as constants. The special keyword iota generates successive (连续 ) constant values automatically; in this case 0, 1, 2 and so on. 特殊关键字 iota 自动生成连续的常量值；在本例中为 0、1、2 等等。 By implementing the fmt.Stringer interface, values of ServerState can be printed out or converted to strings. 通过实现 fmt.Stringer 接口，可以打印出 ServerState 的值或将其转换为字符串。 This can get cumbersome (繁琐 ) if there are many possible values. In such cases the [stringer tool](###stringer tool) can be used in conjunction with go:generate to automate the process. See this post(maybe another blog) for a longer explanation. 如果可能的值太多，这可能会变得很麻烦。在这种情况下，stringer 工具可以与 go:generate 结合使用来自动化该过程。 If we have a value of type int, we cannot pass it to transition - the compiler will complain about type mismatch. This provides some degree of compile-time type safety for enums. transition emulates a state transition for a server; it takes the existing state and returns a new state. Suppose we check some predicates here to determine the next state… 123goByExample&gt; go run .\\22.Enums.go connectedidle Struct EmbeddingGo by Example: Struct Embedding 123456789101112131415161718192021222324252627282930313233343536373839package mainimport &quot;fmt&quot;type base struct { num int}func (b base) describe() string { return fmt.Sprintf(&quot;base with num=%v&quot;, b.num)}type container struct { base str string}func main() { co := container{ base: base{ num: 1, }, str: &quot;some name&quot;, } fmt.Printf(&quot;co={num: %v, str: %v}\\n&quot;, co.num, co.str) fmt.Println(&quot;also num:&quot;, co.base.num) fmt.Println(&quot;describe:&quot;, co.describe()) type describer interface { describe() string } var d describer = co fmt.Println(&quot;describer:&quot;, d.describe())} Go supports embedding (嵌入 ) of structs and interfaces to express a more seamless (无缝的 ) composition of types. This is not to be confused with //go:embed which is a go directive introduced (go 指令 ) in Go version 1.16+ to embed files and folders into the application binary. A container embeds a base. An embedding looks like a field without a name. When creating structs with literals, we have to initialize the embedding explicitly; here the embedded type serves as the field name. We can access the base’s fields directly on co, e.g. co.num. Alternatively, we can spell out the full path using the embedded type name. Since container embeds base, the methods of base also become methods of a container. Here we invoke a method that was embedded from base directly on co. Embedding structs with methods may be used to bestow (赋予 ) interface implementations onto other structs. Here we see that a container now implements the describer interface because it embeds base. 12345goByExample&gt; go run '.\\23.Struct Embedding.go'co={num: 1, str: some name}also num: 1describe: base with num=1describer: base with num=1 Generics(泛型)Go by Example: Generics 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package mainimport &quot;fmt&quot;func SlicesIndex[S ~[]E, E comparable](s S, v E) int { for i := range s { if v == s[i] { return i } } return -1}type List[T any] struct { head, tail *element[T]}type element[T any] struct { next *element[T] val T}func (lst *List[T]) Push(v T) { if lst.tail == nil { lst.head = &amp;element[T]{val: v} lst.tail = lst.head } else { lst.tail.next = &amp;element[T]{val: v} lst.tail = lst.tail.next }}func (lst *List[T]) AllElements() []T { var elems []T for e := lst.head; e != nil; e = e.next { elems = append(elems, e.val) } return elems}func main() { var s = []string{&quot;foo&quot;, &quot;bar&quot;, &quot;zoo&quot;} fmt.Println(&quot;index of zoo:&quot;, SlicesIndex(s, &quot;zoo&quot;)) _ = SlicesIndex[[]string, string](s, &quot;zoo&quot;) lst := List[int]{} lst.Push(10) lst.Push(13) lst.Push(23) fmt.Println(&quot;list:&quot;, lst.AllElements())} Starting with version 1.18, Go has added support for generics, also known as type parameters. As an example of a generic function, SlicesIndex takes a slice of any comparable type and an element of that type and returns the index of the first occurrence of v in s, or -1 if not present. The comparable constraint means that we can compare values of this type with the == and != operators. For a more thorough explanation of this type signature, see this blog post (maybe another blog). Note that this function exists in the standard library as slices.Index. As an example of a generic type, List is a singly-linked list with values of any type. We can define methods on generic types just like we do on regular types, but we have to keep the type parameters in place. The type is List[T], not List. AllElements returns all the List elements as a slice. In the next example we’ll see a more idiomatic way of iterating over all elements of custom types. When invoking generic functions, we can often rely on type inference. Note that we don’t have to specify the types for S and E when calling SlicesIndex - the compiler infers them automatically. … though we could also specify them explicitly. 123goByExample&gt; go run '.\\24.generics.go' index of zoo: 2list: [10 13 23] Range over IteratorsGo by Example: Range over Iterators 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package mainimport ( &quot;fmt&quot; &quot;iter&quot; &quot;slices&quot;)type List[T any] struct { head, tail *element[T]}type element[T any] struct { next *element[T] val T}func (lst *List[T]) Push(v T) { if lst.tail == nil { lst.head = &amp;element[T]{val: v} lst.tail = lst.head } else { lst.tail.next = &amp;element[T]{val: v} lst.tail = lst.tail.next }}func (lst *List[T]) All() iter.Seq[T] { return func(yield func(T) bool) { for e := lst.head; e != nil; e = e.next { if !yield(e.val) { return } } }}func genFib() iter.Seq[int] { return func(yield func(int) bool) { a, b := 1, 1 for { if !yield(a) { return } a, b = b, a+b } }}func main() { lst := List[int]{} lst.Push(10) lst.Push(13) lst.Push(23) for e := range lst.All() { fmt.Println(e) } all := slices.Collect(lst.All()) fmt.Println(&quot;all:&quot;, all) for n := range genFib() { if n &gt;= 10 { break } fmt.Println(n) }} Starting with version 1.23, Go has added support for iterators, which lets us range over pretty much anything! Let’s look at the List type from the previous example again. In that example we had an AllElements method that returned a slice of all elements in the list. With Go iterators, we can do it better - as shown below. All returns an iterator, which in Go is a function with a special signature. The iterator function takes another function as a parameter, called yield by convention (but the name can be arbitrary). It will call yield for every element we want to iterate over, and note yield’s return value for a potential early termination. 迭代器函数将另一个函数作为参数，按照惯例称为yield（但名称可以任意）。它将为我们想要迭代的每个元素调用yield，并记录yield的返回值以防可能提前终止。 Iteration doesn’t require an underlying data structure, and doesn’t even have to be finite! Here’s a function returning an iterator over Fibonacci numbers: it keeps running as long as yield keeps returning true. 迭代不需要底层数据结构，甚至不必是有限的！这是一个返回斐波那契数列迭代器的函数：只要yield一直返回true，它就会一直运行。 Since List.All returns an iterator, we can use it in a regular range loop. Packages like slices have a number of useful functions to work with iterators. For example, Collect takes any iterator and collects all its values into a slice. Once the loop hits break or an early return, the yield function passed to the iterator will return false. 1234567891011goByExample&gt; go run '.\\25.Range over Iterators.go'101323all: [10 13 23]112358 ErrorsGo by Example: Errors 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package mainimport ( &quot;errors&quot; &quot;fmt&quot;)func f(arg int) (int, error) { if arg == 42 { return -1, errors.New(&quot;can't work with 42&quot;) } return arg + 3, nil}var ErrOutOfTea = fmt.Errorf(&quot;no more tea available&quot;)var ErrPower = fmt.Errorf(&quot;can't boil water&quot;)func makeTea(arg int) error { if arg == 2 { return ErrOutOfTea } else if arg == 4 { return fmt.Errorf(&quot;making tea: %w&quot;, ErrPower) } return nil}func main() { for _, i := range []int{7, 42} { if r, e := f(i); e != nil { fmt.Println(&quot;f failed:&quot;, e) } else { fmt.Println(&quot;f worked:&quot;, r) } } for i := range 5 { if err := makeTea(i); err != nil { if errors.Is(err, ErrOutOfTea) { fmt.Println(&quot;We should buy new tea!&quot;) } else if errors.Is(err, ErrPower) { fmt.Println(&quot;Now it is dark.&quot;) } else { fmt.Printf(&quot;unknown error: %s\\n&quot;, err) } continue } fmt.Println(&quot;Tea is ready!&quot;) }} In Go it’s idiomatic to communicate errors via an explicit, separate return value. This contrasts with the exceptions used in languages like Java and Ruby and the overloaded single result / error value sometimes used in C. Go’s approach makes it easy to see which functions return errors and to handle them using the same language constructs employed for other, non-error tasks. 扩展：fmt.Stringer官方文档：fmt.Stringer type Stringer : 123type Stringer interface { String() string} Stringer is implemented by any value that has a String method, which defines the “native” format for that value. The String method is used to print values passed as an operand to any format that accepts a string or to an unformatted printer such as Print. Example: 12345678910111213141516171819202122232425package mainimport ( &quot;fmt&quot;)// Animal has a Name and an Age to represent an animal.type Animal struct { Name string Age uint}// String makes Animal satisfy the Stringer interface.func (a Animal) String() string { return fmt.Sprintf(&quot;%v (%d)&quot;, a.Name, a.Age)}func main() { a := Animal{ Name: &quot;Gopher&quot;, Age: 2, } fmt.Println(a)} 123Output:Gopher (2) stringer toolStringer is a tool to automate the creation of methods that satisfy the fmt.Stringer interface. Given the name of a (signed or unsigned) integer type T that has constants defined, stringer will create a new self-contained Go source file implementing 1func (t T) String() string The file is created in the same package and directory as the package that defines T. It has helpful defaults designed for use with go generate. Stringer works best with constants that are consecutive values such as created using iota, but creates good code regardless. In the future it might also provide custom support for constant sets that are bit patterns. For example, given this snippet, 1234567891011package painkillertype Pill intconst ( Placebo Pill = iota Aspirin Ibuprofen Paracetamol Acetaminophen = Paracetamol) running this command 1stringer -type=Pill in the same directory will create the file pill_string.go, in package painkiller, containing a definition of 1func (Pill) String() string That method will translate the value of a Pill constant to the string representation of the respective constant name, so that the call fmt.Print(painkiller.Aspirin) will print the string “Aspirin”. Typically this process would be run using go generate, like this: 1//go:generate stringer -type=Pill If multiple constants have the same value, the lexically (词汇上 ) first matching name will be used (in the example, Acetaminophen will print as “Paracetamol”). With no arguments, it processes the package in the current directory. Otherwise, the arguments must name a single directory holding a Go package or a set of Go source files that represent a single Go package. The -type flag accepts a comma-separated list of types so a single run can generate methods for multiple types. The default output file is t_string.go, where t is the lower-cased name of the first type listed. It can be overridden with the -output flag. Types can also be declared in tests, in which case type declarations in the non-test package or its test variant are preferred over types defined in the package with suffix “_test”. The default output file for type declarations in tests is t_string_test.go with t picked as above. The -linecomment flag tells stringer to generate the text of any line comment, trimmed of leading spaces (去掉前导空格 ), instead of the constant name. For instance, if the constants above had a Pill prefix, one could write 1PillAspirin // Aspirin to suppress it in the output. slices.Indexfunc Index 1func Index[S ~[]E, E comparable](s S, v E) int Index returns the index of the first occurrence of v in s, or -1 if not present. Example: 123456789101112package mainimport ( &quot;fmt&quot; &quot;slices&quot;)func main() { numbers := []int{0, 42, 8} fmt.Println(slices.Index(numbers, 8)) fmt.Println(slices.Index(numbers, 7))} 1234Output:2-1","link":"/2024/12/24/goByExample/goByExample-pt-3/"},{"title":"goByExample pt.2","text":"FunctionsGo by Example: Functions 1234567891011121314151617181920package mainimport &quot;fmt&quot;func plus(a, b int) int { return a + b}func plusPlus(a, b, c int) int { return a + b + c}func main(){ res := plus(1, 2) fmt.Println(&quot;1 + 2 =&quot;, res) res = plusPlus(1, 2, 3) fmt.Println( &quot;1 + 2 + 3 =&quot;, res)} Functions are central (核心/中心) in Go. We’ll learn about functions with a few different examples. Here’s a function that takes two ints and returns their sum as an int. Go requires explicit returns, i.e. (即 ) it won’t automatically return the value of the last expression. When you have multiple consecutive (连续的 ) parameters of the same type, you may omit (省略 ) the type name for the like-typed (相同类型的 ) parameters up to the final parameter that declares the type. Call a function just as you’d expect, with name(args). There are several other features to Go functions. One is multiple return values, which we’ll look at next. 123goByExample&gt; go run .\\11.functions.go1 + 2 = 31 + 2 + 3 = 6 Multiple Return ValuesGo by Example: Multiple Return Values 1234567891011121314151617package mainimport &quot;fmt&quot;func vals() (int, int) { return 3, 7}func main() { a, b := vals() fmt.Println(a) fmt.Println(b) _, c := vals() fmt.Println(c)} Go has built-in support for multiple return values. This feature is used often in idiomatic Go (这个特性在 Go 语言中经常用到), for example to return both result and error values from a function. The (int, int) in this function signature shows that the function returns 2 ints. Here we use the 2 different return values from the call with multiple assignment (多赋值操作). If you only want a subset (子集 / 一部分) of the returned values, use the blank identifier _. Accepting a variable (可变的 ) number of arguments is another nice feature of Go functions; we’ll look at this next. 1234goByExample&gt; go run '.\\12.multiple return values.go'377 Variadic FunctionsGo by Example: Variadic Functions 12345678910111213141516171819202122package mainimport &quot;fmt&quot;func sum(nums ...int) { fmt.Print(nums, &quot; &quot;) total := 0 for _, num := range nums { total += num } fmt.Println(total)}func main() { sum(1, 2) sum(1, 2, 3) nums := []int{1, 2, 3, 4} sum(nums...)} Variadic functions can be called with any number of trailing (尾随 ) arguments. For example, fmt.Println is a common variadic function. Here’s a function that will take an arbitrary (随意的 ) number of ints as arguments. Within the function, the type of nums is equivalent to []int. We can call len(nums), iterate over it with range, etc. for _, num := range nums 解释： range 表达式通常返回两个值：一个是索引，另一个是值。在这段代码中 第一个值是数组 nums 中每个元素的索引。 第二个值是数组中相应位置的元素值。 Variadic functions can be called in the usual way with individual arguments. If you already have multiple args in a slice, apply them to a variadic function using func(slice...) like this. Another key aspect of functions in Go is their ability to form closures (闭包 ) , which we’ll look at next. 1234goByExample&gt; go run '.\\13.Variadic Functions.go' [1 2] 3[1 2 3] 6[1 2 3 4] 10 ClosuresGo by Example: Closures 1234567891011121314151617181920212223package mainimport &quot;fmt&quot;func intSeq() func() int { i := 0 return func() int { i++ return i }}func main() { nextInt := intSeq() fmt.Println(nextInt()) fmt.Println(nextInt()) fmt.Println(nextInt()) newInts := intSeq() fmt.Println(newInts())} Go supports anonymous functions, which can form closures. Anonymous functions are useful when you want to define a function inline without having to name it. This function intSeq returns another function, which we define anonymously in the body of intSeq. The returned function closes over the variable i to form a closure. We call intSeq, assigning the result (a function) to nextInt. This function value captures its own i value, which will be updated each time we call nextInt. See the effect of the closure by calling nextInt a few times. To confirm that the state is unique to that particular function, create and test a new one. The last feature of functions we’ll look at for now is recursion. 12345goByExample&gt; go run '.\\14.closures.go' 1231 RecursionGo by Example: Recursion 1234567891011121314151617181920212223242526package mainimport &quot;fmt&quot;func fact(n int) int { if n == 0 { return 1 } return n * fact(n-1)}func main() { fmt.Println(fact(7)) var fib func(n int) int fib = func(n int) int { if n &lt; 2 { return n } return fib(n-1) + fib(n-2) } fmt.Println(fib(7))} Go supports recursive functions. Here’s a classic example. This fact function calls itself until it reaches the base case of fact(0). Anonymous functions can also be recursive, but this requires explicitly declaring a variable with var to store the function before it’s defined. Since fib was previously declared in main, Go knows which function to call with fib here. 123goByExample&gt; go run '.\\15.recursion.go'504013 Range over Built-in TypesGo by Example: Range over Built-in Types 1234567891011121314151617181920212223242526272829303132package mainimport &quot;fmt&quot;func main() { nums := []int{2, 3, 4} sum := 0 for _, num := range nums { sum += num } fmt.Println(&quot;sum:&quot;, sum) for i, num := range nums { if num == 3 { fmt.Println(&quot;index:&quot;, i) } } kvs := map[string]string{&quot;a&quot;: &quot;apple&quot;, &quot;b&quot;: &quot;banana&quot;} for k, v := range kvs { fmt.Printf(&quot;%s -&gt; %s\\n&quot;, k, v) } for k := range kvs { fmt.Println(&quot;key:&quot;, k) } for i, c := range &quot;go&quot; { fmt.Println(i, c) }} range iterates over elements in a variety of built-in data structures. Let’s see how to use range with some of the data structures we’ve already learned. Here we use range to sum the numbers in a slice. Arrays work like this too. range on arrays and slices provides both the index and value for each entry. Above we didn’t need the index, so we ignored it with the blank identifier _. Sometimes we actually want the indexes though. range on map iterates over key/value pairs. range can also iterate over just the keys of a map. range on strings iterates over Unicode code points. The first value is the starting byte index of the rune and the second the rune itself. See [Strings and Runes](##Strings and Runes) for more details. 123456789goByExample&gt; go run '.\\16.Range over Built-in Types.go'sum: 9index: 1a -&gt; appleb -&gt; bananakey: akey: b0 1031 111 PointersGo by Example: Pointers 123456789101112131415161718192021222324package mainimport &quot;fmt&quot;func zeroval(ival int) { ival = 0}func zeroptr(iptr *int) { *iptr = 0}func main() { i := 1 fmt.Println(&quot;initial:&quot;, i) zeroval(i) fmt.Println(&quot;zeroval:&quot;, i) zeroptr(&amp;i) fmt.Println(&quot;zeroptr:&quot;, i) fmt.Println(&quot;pointer:&quot;, &amp;i)} Go supports pointers, allowing you to pass references to values and records within your program. We’ll show how pointers work in contrast to values with 2 functions: zeroval and zeroptr. zeroval has an int parameter, so arguments will be passed to it by value. zeroval will get a copy of ival distinct from the one in the calling function. zeroptr in contrast has an *int parameter, meaning that it takes an int pointer. The *iptr code in the function body then dereferences the pointer from its memory address to the current value at that address. Assigning a value to a dereferenced pointer changes the value at the referenced address. The &amp;i syntax gives the memory address of i, i.e. a pointer to i. Pointers can be printed too. zeroval doesn’t change the i in main, but zeroptr does because it has a reference to the memory address for that variable. 12345goByExample&gt; go run '.\\17.pointers.go' initial: 1zeroval: 1zeroptr: 0pointer: 0xc00000a0d8 Strings and RunesGo by Example: Strings and Runes 123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport ( &quot;fmt&quot; &quot;unicode/utf8&quot;)func main() { const s = &quot;สวัสดี&quot; fmt.Println(&quot;Len:&quot;, len(s)) for i := 0; i &lt; len(s); i++ { fmt.Printf(&quot;%x &quot;, s[i]) } fmt.Println() fmt.Println(&quot;Rune count:&quot;, utf8.RuneCountInString(s)) for idx, runeValue := range s { fmt.Printf(&quot;%#U starts at %d\\n&quot;, runeValue, idx) } fmt.Println(&quot;\\nUsing DecodeRuneInString&quot;) for i, w := 0, 0; i &lt; len(s); i += w { runeValue, width := utf8.DecodeRuneInString(s[i:]) fmt.Printf(&quot;%#U starts at %d\\n&quot;, runeValue, i) w = width examineRune(runeValue) }}func examineRune(r rune) { if r == 't' { fmt.Println(&quot;found tee&quot;) } else if r == 'ส' { fmt.Println(&quot;found so sua&quot;) }} A Go string is a read-only slice of bytes. The language and the standard library treat strings specially - as containers of text encoded in UTF-8. In other languages, strings are made of “characters”. In Go, the concept of a character is called a rune - it’s an integer that represents a Unicode code point. This Go blog post (maybe another blog) is a good introduction to the topic. s is a string assigned a literal value representing the word “hello” in the Thai language. Go string literals are UTF-8 encoded text. Since strings are equivalent to []byte, this will produce the length of the raw bytes stored within. 因为字符串等价于 []byte， 这会产生存储在其中的原始字节的长度。 Indexing into a string produces the raw byte values at each index. This loop generates the hex values of all the bytes that constitute the code points in s. To count how many runes are in a string, we can use the utf8 package. Note that the run-time of RuneCountInString depends on the size of the string, because it has to decode each UTF-8 rune sequentially. Some Thai characters are represented by UTF-8 code points that can span multiple bytes, so the result of this count may be surprising. 要计算字符串中有多少rune，我们可以使用utf8包。 注意RuneCountInString的运行时取决于字符串的大小。 因为它必须按顺序解码每个 UTF-8 rune。 一些泰语字符由多个 UTF-8 code point 表示， 所以这个计数的结果可能会令人惊讶。 A range loop handles strings specially and decodes each rune along with its offset in the string. We can achieve the same iteration by using the utf8.DecodeRuneInString function explicitly. This demonstrates passing a rune value to a function. Values enclosed in single quotes are rune literals. We can compare a rune value to a rune literal directly. 1234567891011121314151617181920goByExample&gt; go run '.\\18.Strings and Runes.go'Len: 18e0 b8 aa e0 b8 a7 e0 b8 b1 e0 b8 aa e0 b8 94 e0 b8 b5Rune count: 6U+0E2A 'ส' starts at 0U+0E27 'ว' starts at 3U+0E31 'ั' starts at 6U+0E2A 'ส' starts at 9U+0E14 'ด' starts at 12U+0E35 'ี' starts at 15Using DecodeRuneInStringU+0E2A 'ส' starts at 0found so suaU+0E27 'ว' starts at 3U+0E31 'ั' starts at 6U+0E2A 'ส' starts at 9found so suaU+0E14 'ด' starts at 12U+0E35 'ี' starts at 15 StructsGo by Example: Structs 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package mainimport &quot;fmt&quot;type person struct { name string age int}func newPerson(name string) *person { p := person{name: name} p.age = 42 return &amp;p}func main() { fmt.Println(person{&quot;Bob&quot;, 20}) fmt.Println(person{name: &quot;Alice&quot;, age: 30}) fmt.Println(person{name: &quot;Fred&quot;}) fmt.Println(&amp;person{name: &quot;Ann&quot;, age: 40}) fmt.Println(newPerson(&quot;Jon&quot;)) s := person{name: &quot;Sean&quot;, age: 50} fmt.Println(s.name) sp := &amp;s fmt.Println(sp.age) sp.age = 51 fmt.Println(sp.age) dog := struct { name string isGood bool }{ &quot;Rex&quot;, true, } fmt.Println(dog)} Go’s structs are typed collections of fields. They’re useful for grouping data together to form records. This person struct type has name and age fields. newPerson constructs a new person struct with the given name. Go is a garbage collected language; you can safely return a pointer to a local variable - it will only be cleaned up by the garbage collector when there are no active references to it. This syntax creates a new struct. You can name the fields when initializing a struct. Omitted fields will be zero-valued. An &amp; prefix yields a pointer to the struct. It’s idiomatic to encapsulate new struct creation in constructor functions 在构造函数中封装创建新的结构实例是一种习惯用法 Access struct fields with a dot. You can also use dots with struct pointers - the pointers are automatically dereferenced. Structs are mutable (可变的 ). If a struct type is only used for a single value, we don’t have to give it a name. The value can have an anonymous struct type. This technique is commonly used for table-driven tests (goByExample pt.8). 12345678910goByExample&gt; go run '.\\19.structs.go' {Bob 20}{Alice 30}{Fred 0}&amp;{Ann 40}&amp;{Jon 42}Sean5051{Rex true} MethodsGo by Example: Methods 1234567891011121314151617181920212223242526package mainimport &quot;fmt&quot;type rect struct { width, height int}func (r *rect) area() int { return r.width * r.height}func (r rect) perim() int { return 2*r.width + 2*r.height}func main() { r := rect{width: 10, height: 5} fmt.Println(&quot;area: &quot;, r.area()) fmt.Println(&quot;perim:&quot;, r.perim()) rp := &amp;r fmt.Println(&quot;area: &quot;, rp.area()) fmt.Println(&quot;perim:&quot;, rp.perim())} Go supports methods defined on struct types. This area method has a receiver type of *rect. Methods can be defined for either pointer or value receiver types. Here’s an example of a value receiver. Here we call the 2 methods defined for our struct. Go automatically handles conversion between values and pointers for method calls. You may want to use a pointer receiver type to avoid copying on method calls or to allow the method to mutate the receiving struct. Next we’ll look at Go’s mechanism (机制 ) for grouping and naming related sets of methods: interfaces. 12345goByExample&gt; go run '.\\20.Methods.go'area: 50perim: 30area: 50perim: 30","link":"/2024/12/23/goByExample/goByExample-pt-2/"},{"title":"test-pic","text":"test file for insert imgs","link":"/2024/12/21/test/test-pic/"},{"title":"Test","text":"Testit’s a test file for hexo","link":"/2024/12/21/test/Test/"},{"title":"Thinking in Java pt.4","text":"Chapter 4 Controlling ExecutionLike a sentient creature, a program must manipulate its world and make choices during execution. In Java you make choices with execution control statements. Java uses all of C’s execution control statements, so if you’ve programmed with C or C++, then most of what you see will be familiar. Most procedural programming languages have some kind of control statements, and there is often overlap among languages. In Java, the keywords include if-else, while, do-while, for, return, break, and a selection statement called switch. Java does not, however, support the much-maligned goto (which can still be the most expedient way to solve certain types of problems). You can still do a goto-like jump, but it is much more constrained than a typical goto. 4.1 true and falsepass 4.2 if-elsepass 4.3 Iterationpass Exercise 1Write a program that prints values from 1 to 100. 1234567public class exer_1 { public static void main(String[] args) { for (int i = 1; i &lt;= 100; i++) { System.out.println(i); } }} Exercise 2Write a program that generates 25 random int values. For each value, use an if-else statement to classify it as greater than, less than, or equal to a second randomly generated value. 1234567891011121314151617public class exer_2 { public static void main(String[] args) { Random random = new Random(); int i1 = random.nextInt(); for (int i = 1; i &lt; 25; i++) { int i2 = random.nextInt(); if (i1 &gt; i2) { System.out.println(i1 + &quot; &gt; &quot; + i2); } else if (i1 &lt; i2) { System.out.println(i1 + &quot; &lt; &quot; + i2); } else { System.out.println(i1 + &quot; = &quot; + i2); } i1 = i2; } }} Exercise 3:Modify Exercise 2 so that your code is surrounded by an “infinite” while loop. It will then run until you interrupt it from the keyboard (typically by pressing ControlC). 1234567891011121314151617public class exer_3 { public static void main(String[] args) { Random random = new Random(); int i1 = random.nextInt(); while (true) { int i2 = random.nextInt(); if (i1 &gt; i2) { System.out.println(i1 + &quot; &gt; &quot; + i2); } else if (i1 &lt; i2) { System.out.println(i1 + &quot; &lt; &quot; + i2); } else { System.out.println(i1 + &quot; = &quot; + i2); } i1 = i2; } }} Exercise 4:Write a program that uses two nested for loops and the modulus operator (%) to detect and print prime numbers (integral numbers that are not evenly divisible by any other numbers except for themselves and 1). 12345678910111213141516public class exer_4 { public static void main(String[] args) { for (int i = 0; i &lt; 10000; i++) { boolean flag = true; for (int j = 2; j &lt; i; j++) { if (i % j == 0) { flag = false; break; } } if (flag) { System.out.println(i); } } }} Exercise 5:Repeat Exercise 10 from the previous chapter, using the ternary operator and a bitwise test to display the ones and zeroes, instead of Integer.toBinaryString( ). 1pass 4.4 Foreach syntaxpass 4.5 returnpass 4.6 break and continuepass 4.7 The infamous “goto”Although goto is a reserved word in Java, it is not used in the language; Java has no goto. However, it does have something that looks a bit like a jump tied in with the break and continue keywords. It’s not a jump but rather a way to break out of an iteration statement. The reason it’s often thrown in with discussions of goto is because it uses the same mechanism: a label. A label is an identifier followed by a colon, like this: 1label1: The only place a label is useful in Java is right before an iteration statement. And that means right before—it does no good to put any other statement between the label and the iteration. And the sole reason to put a label before an iteration is if you’re going to nest another iteration or a switch (which you’ll learn about shortly) inside it. That’s because the break and continue keywords will normally interrupt only the current loop, but when used with a label, they’ll interrupt the loops up to where the label exists: 12345678910111213label1:outer-iteration { inner-iteration { //... break; // (1) //... continue; // (2) //... continue label1; // (3) //... break label1; // (4) }} In (1), the break breaks out of the inner iteration and you end up in the outer iteration. In (2), the continue moves back to the beginning of the inner iteration. But in (3), the continue label1 breaks out of the inner iteration and the outer iteration, all the way back to label1. Then it does in fact continue the iteration, but starting at the outer iteration. In (4), the break label1 also breaks all the way out to label1, but it does not reenter the iteration. It actually does break out of both iterations. Here is an example using for loops: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// For loops with &quot;labeled break&quot; and &quot;labeled continue.&quot;import static net.mindview.util.Print.*;public class LabeledFor { public static void main(String[] args) { int i = 0; outer: // Can’t have statements here for(; true ;) { // infinite loop inner: // Can’t have statements here for(; i &lt; 10; i++) { print(&quot;i = &quot; + i); if(i == 2) { print(&quot;continue&quot;); continue; } if(i == 3) { print(&quot;break&quot;); i++; // Otherwise i never // gets incremented. break; } if(i == 7) { print(&quot;continue outer&quot;); i++; // Otherwise i never // gets incremented. continue outer; } if(i == 8) { print(&quot;break outer&quot;); break outer; } for(int k = 0; k &lt; 5; k++) { if(k == 3) { print(&quot;continue inner&quot;); continue inner; } } } } // Can’t break or continue to labels here }} /* Output:i = 0continue inneri = 1continue inneri = 2continuei = 3breaki = 4continue inneri = 5continue inneri = 6continue inneri = 7continue outeri = 8break outer *///:~ The same rules hold true for while: A plain continue goes to the top of the innermost loop and continues. A labeled continue goes to the label and reenters the loop right after that label. A break “drops out of the bottom” of the loop. A labeled break drops out of the bottom of the end of the loop denoted by the label. In Dijkstra’s “Goto considered harmful” paper, what he specifically objected to was the labels, not the goto. He observed that the number of bugs seems to increase with the number of labels in a program, and that labels and gotos make programs difficult to analyze. Note that Java labels don’t suffer from this problem, since they are constrained in their placement and can’t be used to transfer control in an ad hoc manner. It’s also interesting to note that this is a case where a language feature is made more useful by restricting the power of the statement. 4.8 switchpass 4.9 SummaryThis chapter concludes the study of fundamental features that appear in most programming languages: calculation, operator precedence, type casting, and selection and iteration. Now you’re ready to begin taking steps that move you closer to the world of object-oriented programming. The next chapter will cover the important issues of initialization and cleanup of objects, followed in the subsequent chapter by the essential concept of implementation hiding.","link":"/2025/02/12/Thinking-in-Java/Thinking-in-Java-pt-4/"},{"title":"Thinking in Java pt.5","text":"Chapter 5 Initialization &amp; CleanupAs the computer revolution progresses, “unsafe” programming has become one of the major culprits that makes programming expensive. Two of these safety issues are initialization and cleanup. Many C bugs occur when the programmer forgets to initialize a variable. This is especially true with libraries when users don’t know how to initialize a library component, or even that they must. Cleanup is a special problem because it’s easy to forget about an element when you’re done with it, since it no longer concerns you. Thus, the resources used by that element are retained and you can easily end up running out of resources (most notably, memory). C++ introduced the concept of a constructor, a special method automatically called when an object is created. Java also adopted the constructor, and in addition has a garbage collector that automatically releases memory resources when they’re no longer being used. This chapter examines the issues of initialization and cleanup, and their support in Java. 5.1 Guaranteed initialization with the constructorpass 5.2 Method overloadingpass 5.3 Default constructorspass 5.4 The this keywordpass 5.4.1 Calling constructors from constructorsWhen you write several constructors for a class, there are times when you’d like to call one constructor from another to avoid duplicating code. You can make such a call by using the this keyword. Normally, when you say this, it is in the sense of “this object” or “the current object,” and by itself it produces the reference to the current object. In a constructor, the this keyword takes on a different meaning when you give it an argument list. It makes an explicit call to the constructor that matches that argument list. Thus you have a straightforward way to call other constructors: 123456789101112131415161718192021222324252627282930313233343536373839//: initialization/Flower.java// Calling constructors with &quot;this&quot;import static net.mindview.util.Print.*;public class Flower { int petalCount = 0; String s = &quot;initial value&quot;; Flower(int petals) { petalCount = petals; print(&quot;Constructor w/ int arg only, petalCount= &quot; + petalCount); } Flower(String ss) { print(&quot;Constructor w/ String arg only, s = &quot; + ss); s = ss; } Flower(String s, int petals) { this(petals); //! this(s); // Can’t call two! this.s = s; // Another use of &quot;this&quot; print(&quot;String &amp; int args&quot;); } Flower() { this(&quot;hi&quot;, 47); print(&quot;default constructor (no args)&quot;); } void printPetalCount() { //! this(11); // Not inside non-constructor! print(&quot;petalCount = &quot; + petalCount + &quot; s = &quot;+ s); } public static void main(String[] args) { Flower x = new Flower(); x.printPetalCount(); }} /* Output:Constructor w/ int arg only, petalCount= 47String &amp; int argsdefault constructor (no args)petalCount = 47 s = hi*///:~ The constructor Flower(String s, int petals) shows that, while you can call one constructor using this, you cannot call two. In addition, the constructor call must be the first thing you do, or you’ll get a compiler error message. This example also shows another way you’ll see this used. Since the name of the argument s and the name of the member data s are the same, there’s an ambiguity. You can resolve it using this.s, to say that you’re referring to the member data. You’ll often see this form used in Java code, and it’s used in numerous places in this book. In printPetalCount( ) you can see that the compiler won’t let you call a constructor from inside any method other than a constructor. 5.4.2 The meaning of staticWith the this keyword in mind, you can more fully understand what it means to make a method static. It means that there is no this for that particular method. You cannot call non-static methods from inside static methods[^1] (although the reverse is possible), and you can call a static method for the class itself, without any object. In fact, that’s primarily what a static method is for. It’s as if you’re creating the equivalent of a global method. However, global methods are not permitted in Java, and putting the static method inside a class allows it access to other static methods and to static fields. [^1]: The one case in which this is possible occurs if you pass a reference to an object into the static method (the static method could also create its own object). Then, via the reference (which is now effectively this), you can call non-static methods and access non-static fields. But typically, if you want to do something like this, you’ll just make an ordinary, non-static method. 5.5 Cleanup: finalization and garbage collectionProgrammers know about the importance of initialization, but often forget the importance of cleanup. After all, who needs to clean up an int? But with libraries, simply “letting go” of an object once you’re done with it is not always safe. Of course, Java has the garbage collector to reclaim the memory of objects that are no longer used. Now consider an unusual case: Suppose your object allocates “special” memory without using new. The garbage collector only knows how to release memory allocated with new, so it won’t know how to release the object’s “special” memory. To handle this case, Java provides a method called finalize( ) that you can define for your class. Here’s how it’s supposed to work. When the garbage collector is ready to release the storage used for your object, it will first call finalize( ), and only on the next garbage-collection pass will it reclaim the object’s memory. So if you choose to use finalize( ), it gives you the ability to perform some important cleanup at the time of garbage collection. In C++, objects always get destroyed (in a bug-free program), whereas in Java, objects do not always get garbage collected. Or, put another way: Your objects might not get garbage collected. Garbage collection is not destruction. You might find that the storage for an object never gets released because your program never nears the point of running out of storage. If your program completes and the garbage collector never gets around to releasing the storage for any of your objects, that storage will be returned to the operating system en masse as the program exits. This is a good thing, because garbage collection has some overhead, and if you never do it, you never incur that expense. 5.5.1 What is finalize() for?A third point to remember is: Garbage collection is only about memory. That is, the sole reason for the existence of the garbage collector is to recover memory that your program is no longer using. So any activity that is associated with garbage collection, most notably your finalize( ) method, must also be only about memory and its deallocation. It would seem that finalize( ) is in place because of the possibility that you’ll do something Clike by allocating memory using a mechanism other than the normal one in Java. This can happen primarily through native methods, which are a way to call non-Java code from Java. (Native methods are covered in Appendix B in the electronic 2nd edition of this book, available at www.MindView.net.) C and C++ are the only languages currently supported by native methods, but since they can call subprograms in other languages, you can effectively call anything. Inside the non-Java code, C’s malloc( ) family of functions might be called to allocate storage, and unless you call free( ), that storage will not be released, causing a memory leak. Of course, free( ) is a C and C++ function, so you’d need to call it in a native method inside your finalize( ). After reading this, you probably get the idea that you won’t use finalize( ) much.[^2] You’re correct; it is not the appropriate place for normal cleanup to occur. So where should normal cleanup be performed? [^2]:Joshua Bloch goes further in his section titled “avoid finalizers”: “Finalizers are unpredictable, often dangerous, and generally unnecessary.” Effective JavaTM Programming Language Guide, p. 20 (Addison-Wesley, 2001). 5.5.2 You must perform cleanupTo clean up an object, the user of that object must call a cleanup method at the point the cleanup is desired. This sounds pretty straightforward, but it collides a bit with the C++ concept of the destructor. In C++, all objects are destroyed. Or rather, all objects should be destroyed. If the C++ object is created as a local (i.e., on the stack—not possible in Java), then the destruction happens at the closing curly brace of the scope in which the object was created. If the object was created using new (like in Java), the destructor is called when the programmer calls the C++ operator delete (which doesn’t exist in Java). If the C++ programmer forgets to call delete, the destructor is never called, and you have a memory leak, plus the other parts of the object never get cleaned up. This kind of bug can be very difficult to track down, and is one of the compelling reasons to move from C++ to Java. In contrast, Java doesn’t allow you to create local objects—you must always use new. But in Java, there’s no “delete” for releasing the object, because the garbage collector releases the storage for you. So from a simplistic standpoint, you could say that because of garbage collection, Java has no destructor. You’ll see as this book progresses, however, that the presence of a garbage collector does not remove the need for or the utility of destructors. (And you should never call finalize( ) directly, so that’s not a solution.) If you want some kind of cleanup performed other than storage release, you must still explicitly call an appropriate method in Java, which is the equivalent of a C++ destructor without the convenience Remember that neither garbage collection nor finalization is guaranteed. If the JVM isn’t close to running out of memory, then it might not waste time recovering memory through garbage collection. 5.5.3 The termination conditionIn general, you can’t rely on finalize( ) being called, and you must create separate “cleanup” methods and call them explicitly. So it appears that finalize( ) is only useful for obscure memory cleanup that most programmers will never use. However, there is an interesting use of finalize( ) that does not rely on it being called every time. This is the verification of the termination condition[^3] of an object. [^3]: A term coined by Bill Venners (www.Artima.com) during a seminar that he and I were giving together. At the point that you’re no longer interested in an object—when it’s ready to be cleaned up— that object should be in a state whereby its memory can be safely released. For example, if the object represents an open file, that file should be closed by the programmer before the object is garbage collected. If any portions of the object are not properly cleaned up, then you have a bug in your program that can be very difficult to find. finalize( ) can be used to eventually discover this condition, even if it isn’t always called. If one of the finalizations happens to reveal the bug, then you discover the problem, which is all you really care about. Here’s a simple example of how you might use it: 12345678910111213141516171819202122232425262728293031//: initialization/TerminationCondition.java// Using finalize() to detect an object that// hasn’t been properly cleaned up.class Book { boolean checkedOut = false; Book(boolean checkOut) { checkedOut = checkOut; } void checkIn() { checkedOut = false; } protected void finalize() { if(checkedOut) System.out.println(&quot;Error: checked out&quot;); // Normally, you’ll also do this: // super.finalize(); // Call the base-class version }}public class TerminationCondition { public static void main(String[] args) { Book novel = new Book(true); // Proper cleanup: novel.checkIn(); // Drop the reference, forget to clean up: new Book(true); // Force garbage collection &amp; finalization: System.gc(); }} /* Output:Error: checked out*///:~ The termination condition is that all Book objects are supposed to be checked in before they are garbage collected, but in main( ), a programmer error doesn’t check in one of the books. Without finalize( ) to verify the termination condition, this can be a difficult bug to find. Note that System.gc( ) is used to force finalization. But even if it isn’t, it’s highly probable that the errant Book will eventually be discovered through repeated executions of the program (assuming the program allocates enough storage to cause the garbage collector to execute). You should generally assume that the base-class version of finalize( ) will also be doing something important, and call it using super, as you can see in Book.finalize( ). In this case, it is commented out because it requires exception handling, which we haven’t covered yet. 5.5.4 How a garbage collector worksIf you come from a programming language where allocating objects on the heap is expensive, you may naturally assume that Java’s scheme of allocating everything (except primitives) on the heap is also expensive. However, it turns out that the garbage collector can have a significant impact on increasing the speed of object creation. This might sound a bit odd at first—that storage release affects storage allocation—but it’s the way some JVMs work, and it means that allocating storage for heap objects in Java can be nearly as fast as creating storage on the stack in other languages. To understand garbage collection in Java, it’s helpful learn how garbage-collection schemes work in other systems. A simple but slow garbage-collection technique is called reference counting. This means that each object contains a reference counter, and every time a reference is attached to that object, the reference count is increased. Every time a reference goes out of scope or is set to null, the reference count is decreased. Thus, managing reference counts is a small but constant overhead that happens throughout the lifetime of your program. The garbage collector moves through the entire list of objects, and when it finds one with a reference count of zero it releases that storage (however, reference counting schemes often release an object as soon as the count goes to zero). The one drawback is that if objects circularly refer to each other they can have nonzero reference counts while still being garbage. Locating such self-referential groups requires significant extra work for the garbage collector. Reference counting is commonly used to explain one kind of garbage collection, but it doesn’t seem to be used in any JVM implementations. In faster schemes, garbage collection is not based on reference counting. Instead, it is based on the idea that any non-dead object must ultimately be traceable back to a reference that lives either on the stack or in static storage. The chain might go through several layers of objects. Thus, if you start in the stack and in the static storage area and walk through all the references, you’ll find all the live objects. For each reference that you find, you must trace into the object that it points to and then follow all the references in that object, tracing into the objects they point to, etc., until you’ve moved through the entire Web that originated with the reference on the stack or in static storage. Each object that you move through must still be alive. Note that there is no problem with detached self-referential groups—these are simply not found, and are therefore automatically garbage. In the approach described here, the JVM uses an adaptive garbage-collection scheme, and what it does with the live objects that it locates depends on the variant currently being used. One of these variants is stop-and-copy. This means that—for reasons that will become apparent—the program is first stopped (this is not a background collection scheme). Then, each live object is copied from one heap to another, leaving behind all the garbage. In addition, as the objects are copied into the new heap, they are packed end-to-end, thus compacting the new heap (and allowing new storage to simply be reeled off the end as previously described). Of course, when an object is moved from one place to another, all references that point at the object must be changed. The reference that goes from the heap or the static storage area to the object can be changed right away, but there can be other references pointing to this object that will be encountered later during the “walk.” These are fixed up as they are found (you could imagine a table that maps old addresses to new ones). There are two issues that make these so-called “copy collectors” inefficient. The first is the idea that you have two heaps and you slosh all the memory back and forth between these two separate heaps, maintaining twice as much memory as you actually need. Some JVMs deal with this by allocating the heap in chunks as needed and simply copying from one chunk to another. The second issue is the copying process itself. Once your program becomes stable, it might be generating little or no garbage. Despite that, a copy collector will still copy all the memory from one place to another, which is wasteful. To prevent this, some JVMs detect that no new garbage is being generated and switch to a different scheme (this is the “*adaptive*” part). This other scheme is called mark-and-sweep, and it’s what earlier versions of Sun’s JVM used all the time. For general use, mark-and-sweep is fairly slow, but when you know you’re generating little or no garbage, it’s fast. Mark-and-sweep follows the same logic of starting from the stack and static storage, and tracing through all the references to find live objects. However, each time it finds a live object, that object is marked by setting a flag in it, but the object isn’t collected yet. Only when the marking process is finished does the sweep occur. During the sweep, the dead objects are released. However, no copying happens, so if the collector chooses to compact a fragmented heap, it does so by shuffling objects around. “Stop-and-copy” refers to the idea that this type of garbage collection is not done in the background; instead, the program is stopped while the garbage collection occurs. In the Sun literature you’ll find many references to garbage collection as a low-priority background process, but it turns out that the garbage collection was not implemented that way in earlier versions of the Sun JVM. Instead, the Sun garbage collector stopped the program when memory got low. Mark-and-sweep also requires that the program be stopped. As previously mentioned, in the JVM described here memory is allocated in big blocks. If you allocate a large object, it gets its own block. Strict stop-and-copy requires copying every live object from the source heap to a new heap before you can free the old one, which translates to lots of memory. With blocks, the garbage collection can typically copy objects to dead blocks as it collects. Each block has a generation count to keep track of whether it’s alive. In the normal case, only the blocks created since the last garbage collection are compacted; all other blocks get their generation count bumped if they have been referenced from somewhere. This handles the normal case of lots of short-lived temporary objects. Periodically, a full sweep is made—large objects are still not copied (they just get their generation count bumped), and blocks containing small objects are copied and compacted. The JVM monitors the efficiency of garbage collection and if it becomes a waste of time because all objects are long-lived, then it switches to mark-andsweep. Similarly, the JVM keeps track of how successful mark-and-sweep is, and if the heap starts to become fragmented, it switches back to stop-and-copy. This is where the “adaptive” part comes in, so you end up with a mouthful: “Adaptive generational stop-and-copy mark-andsweep.” There are a number of additional speedups possible in a JVM. An especially important one involves the operation of the loader and what is called a just-in-time (JIT) compiler. A JIT compiler partially or fully converts a program into native machine code so that it doesn’t need to be interpreted by the JVM and thus runs much faster. When a class must be loaded (typically, the first time you want to create an object of that class), the .class file is located, and the bytecodes for that class are brought into memory. At this point, one approach is to simply JIT compile all the code, but this has two drawbacks: It takes a little more time, which, compounded throughout the life of the program, can add up; and it increases the size of the executable (bytecodes are significantly more compact than expanded JIT code), and this might cause paging, which definitely slows down a program. An alternative approach is lazy evaluation, which means that the code is not JIT compiled until necessary. Thus, code that never gets executed might never be JIT compiled. The Java HotSpot technologies in recent JDKs take a similar approach by increasingly optimizing a piece of code each time it is executed, so the more the code is executed, the faster it gets. 5.6 Member initializationpass 5.6.1 Specifying initializationpass 5.7 Constructor initialization5.7.1 Order of initializationWithin a class, the order of initialization is determined by the order that the variables are defined within the class. The variable definitions may be scattered throughout and in between method definitions, but the variables are initialized before any methods can be called—even the constructor. For example: 1234567891011121314151617181920212223242526272829303132//: initialization/OrderOfInitialization.java// Demonstrates initialization order.import static net.mindview.util.Print.*;// When the constructor is called to create a// Window object, you’ll see a message:class Window { Window(int marker) { print(&quot;Window(&quot; + marker + &quot;)&quot;); }}class House { Window w1 = new Window(1); // Before constructor House() { // Show that we’re in the constructor: print(&quot;House()&quot;); w3 = new Window(33); // Reinitialize w3 } Window w2 = new Window(2); // After constructor void f() { print(&quot;f()&quot;); } Window w3 = new Window(3); // At end}public class OrderOfInitialization { public static void main(String[] args) { House h = new House(); h.f(); // Shows that construction is done }} /* Output:Window(1)Window(2)Window(3)House()Window(33)f()*///:~ In House, the definitions of the Window objects are intentionally scattered about to prove that they’ll all get initialized before the constructor is entered or anything else can happen. In addition, w3 is reinitialized inside the constructor. From the output, you can see that the w3 reference gets initialized twice: once before and once during the constructor call. (The first object is dropped, so it can be garbage collected later.) This might not seem efficient at first, but it guarantees proper initialization—what would happen if an overloaded constructor were defined that did not initialize w3 and there wasn’t a “default” initialization for w3 in its definition? 5.7.2 static data initializationThere’s only a single piece of storage for a static, regardless of how many objects are created. You can’t apply the static keyword to local variables, so it only applies to fields. If a field is a static primitive and you don’t initialize it, it gets the standard initial value for its type. If it’s a reference to an object, the default initialization value is null. The order of initialization is statics first, if they haven’t already been initialized by a previous object creation, and then the non-static objects. To summarize the process of creating an object, consider a class called Dog: Even though it doesn’t explicitly use the static keyword, the constructor is actually a static method. So the first time an object of type Dog is created, or the first time a static method or static field of class Dog is accessed, the Java interpreter must locate Dog.class, which it does by searching through the classpath. As Dog.class is loaded (creating a Class object, which you’ll learn about later), all of its static initializers are run. Thus, static initialization takes place only once, as the Class object is loaded for the first time. When you create a new Dog( ), the construction process for a Dog object first allocates enough storage for a Dog object on the heap. This storage is wiped to zero, automatically setting all the primitives in that Dog object to their default values (zero for numbers and the equivalent for boolean and char) and the references to null. Any initializations that occur at the point of field definition are executed. Constructors are executed. As you shall see in the Reusing Classes chapter, this might actually involve a fair amount of activity, especially when inheritance is involved. 5.7.3 Explicit static initializationJava allows you to group other static initializations inside a special “static clause” (sometimes called a static block) in a class. It looks like this: 1234567//: initialization/Spoon.javapublic class Spoon { static int i; static { i = 47; }} ///:~ It appears to be a method, but it’s just the static keyword followed by a block of code. This code, like other static initializations, is executed only once: the first time you make an object of that class or the first time you access a static member of that class (even if you never make an object of that class). 5.7.4 Non-static instance initializationJava provides a similar syntax, called instance initialization, for initializing non-static variables for each object. 123456789101112131415161718192021222324252627282930313233343536373839404142434445//: initialization/Mugs.java// Java &quot;Instance Initialization.&quot;import static net.mindview.util.Print.*;class Mug { Mug(int marker) { print(&quot;Mug(&quot; + marker + &quot;)&quot;); } void f(int marker) { print(&quot;f(&quot; + marker + &quot;)&quot;); }}public class Mugs { Mug mug1; Mug mug2; { mug1 = new Mug(1); mug2 = new Mug(2); print(&quot;mug1 &amp; mug2 initialized&quot;); } Mugs() { print(&quot;Mugs()&quot;); } Mugs(int i) { print(&quot;Mugs(int)&quot;); } public static void main(String[] args) { print(&quot;Inside main()&quot;); new Mugs(); print(&quot;new Mugs() completed&quot;); new Mugs(1); print(&quot;new Mugs(1) completed&quot;); }} /* Output:Inside main()Mug(1)Mug(2)mug1 &amp; mug2 initializedMugs()new Mugs() completedMug(1)Mug(2)mug1 &amp; mug2 initializedMugs(int)new Mugs(1) completed*///:~ You can see that the instance initialization clause: 12345{ mug1 = new Mug(1); mug2 = new Mug(2); print(&quot;mug1 &amp; mug2 initialized&quot;);} looks exactly like the static initialization clause except for the missing static keyword. This syntax is necessary to support the initialization of anonymous inner classes (see the Inner Classes chapter), but it also allows you to guarantee that certain operations occur regardless of which explicit constructor is called. From the output, you can see that the instance initialization clause is executed before either one of the constructors. 5.8 Array initializationAn array is simply a sequence of either objects or primitives that are all the same type and are packaged together under one identifier name. Arrays are defined and used with the squarebrackets indexing operator [ ]. To define an array reference, you simply follow your type name with empty square brackets. 1234int[] a1;// You can also put the square brackets after the identifier to produce exactly the same// meaning:int a1[]; This conforms to expectations from C and C++ programmers. The former style, however, is probably a more sensible syntax, since it says that the type is “an int array.” That style will be used in this book. The compiler doesn’t allow you to tell it how big the array is. This brings us back to that issue of “references.” All that you have at this point is a reference to an array (you’ve allocated enough storage for that reference), and there’s been no space allocated for the array object itself. To create storage for the array, you must write an initialization expression. For arrays, initialization can appear anywhere in your code, but you can also use a special kind of initialization expression that must occur at the point where the array is created. This special initialization is a set of values surrounded by curly braces. The storage allocation (the equivalent of using new) is taken care of by the compiler in this case. 12345678910111213141516171819202122232425int[] a1 = { 1, 2, 3, 4, 5 };// So why would you ever define an array reference without an array?int[] a2;// Well, it’s possible to assign one array to another in Java, so you can say:a2 = a1;// What you’re really doing is copying a reference, as demonstrated here://: initialization/ArraysOfPrimitives.javaimport static net.mindview.util.Print.*; public class ArraysOfPrimitives { public static void main(String[] args) { int[] a1 = { 1, 2, 3, 4, 5 }; int[] a2; a2 = a1; for(int i = 0; i &lt; a2.length; i++) a2[i] = a2[i] + 1; for(int i = 0; i &lt; a1.length; i++) print(&quot;a1[&quot; + i + &quot;] = &quot; + a1[i]); }} /* Output:a1[0] = 2a1[1] = 3a1[2] = 4a1[3] = 5a1[4] = 6*///:~ You can see that a1 is given an initialization value but a2 is not; a2 is assigned later—in this case, to another array. Since a2 and a1 are then aliased to the same array, the changes made via a2 are seen in a1. What if you don’t know how many elements you’re going to need in your array while you’re writing the program? You simply use new to create the elements in the array. Here, new works even though it’s creating an array of primitives (new won’t create a non-array primitive): 12345678910111213141516//: initialization/ArrayNew.java// Creating arrays with new.import java.util.*;import static net.mindview.util.Print.*;public class ArrayNew { public static void main(String[] args) { int[] a; Random rand = new Random(47); a = new int[rand.nextInt(20)]; print(&quot;length of a = &quot; + a.length); print(Arrays.toString(a)); }} /* Output:length of a = 18[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]*///:~ The size of the array is chosen at random by using the Random.nextInt( ) method, which produces a value between zero and that of its argument. Because of the randomness, it’s clear that array creation is actually happening at run time. In addition, the output of this program shows that array elements of primitive types are automatically initialized to “empty” values. (For numerics and char, this is zero, and for boolean, it’s false.) The Arrays.toString( ) method, which is part of the standard java.util library, produces a printable version of a one-dimensional array. Of course, in this case the array could also have been defined and initialized in the same statement: 1int[] a = new int[rand.nextInt(20)]; 5.8.1 Variable argument listspass 5.9 Enumerated typespass 5.10 SummaryThis seemingly elaborate mechanism for initialization, the constructor, should give you a strong hint about the critical importance placed on initialization in the language. As Bjarne Stroustrup, the inventor of C++, was designing that language, one of the first observations he made about productivity in C was that improper initialization of variables causes a significant portion of programming problems. These kinds of bugs are hard to find, and similar issues apply to improper cleanup. Because constructors allow you to guarantee proper initialization and cleanup (the compiler will not allow an object to be created without the proper constructor calls), you get complete control and safety. In C++, destruction is quite important because objects created with new must be explicitly destroyed. In Java, the garbage collector automatically releases the memory for all objects, so the equivalent cleanup method in Java isn’t necessary much of the time (but when it is, you must do it yourself). In cases where you don’t need destructor-like behavior, Java’s garbage collector greatly simplifies programming and adds much-needed safety in managing memory. Some garbage collectors can even clean up other resources like graphics and file handles. However, the garbage collector does add a runtime cost, the expense of which is difficult to put into perspective because of the historical slowness of Java interpreters. Although Java has had significant performance increases over time, the speed problem has taken its toll on the adoption of the language for certain types of programming problems. Because of the guarantee that all objects will be constructed, there’s actually more to the constructor than what is shown here. In particular, when you create new classes using either composition or inheritance, the guarantee of construction also holds, and some additional syntax is necessary to support this. You’ll learn about composition, inheritance, and how they affect constructors in future chapters.","link":"/2025/02/13/Thinking-in-Java/Thinking-in-Java-pt-5/"},{"title":"Thinking in Java pt.3","text":"Chapter 3 OperatorsAt the lowest level, data in Java is manipulated using operators. If you’re familiar with C or C++ syntax, you can skim through this chapter and the next, looking for places where Java is different from those languages. 3.1 Simpler print statementsIn the previous chapter, you were introduced to the Java print statement: 1System.out.println(&quot;Rather a lot to type&quot;); The Access Control chapter introduces the concept of the static import that was added to Java SE5, and creates a tiny library to simplify writing print statements. However, you don’t need to know those details in order to begin using that library. We can rewrite the program from the last chapter using this new library: 123456789101112//: operators/HelloDate.javaimport java.util.*;import static net.mindview.util.Print.*;public class HelloDate { public static void main(String[] args) { print(&quot;Hello, it’s: &quot;); print(new Date()); }} /* Output: (55% match)Hello, it’s:Wed Oct 05 14:39:05 MDT 2005*///:~ The results are much cleaner. Notice the insertion of the static keyword in the second import statement. Although the use of net.mindview.util.Print nicely simplifies most code, it is not justifiable everywhere. If there are only a small number of print statements in a program, I forego the import and write out the full System.out.println( ). Exercise 1Write a program that uses the “short” and normal form of print statement. 123456789// short versionimport java.util.*;import static net.mindview.util.Print.*;public class exer { public static void main(String[] args) { print(&quot;Hello, it’s: &quot;); print(new Date()); }} 12345678// normal versionimport java.util.*;public class exer { public static void main(String[] args) { System.out.print(&quot;Hello, it’s: &quot;); System.out.print(new Date()); }} 3.2 Using Java operatorspass 3.3 PrecedenceOperator precedence defines how an expression evaluates when several operators are present. Java has specific rules that determine the order of evaluation. The easiest one to remember is that multiplication and division happen before addition and subtraction. Programmers often forget the other precedence rules, so you should use parentheses to make the order of evaluation explicit. 1234567891011//: operators/Precedence.javapublic class Precedence { public static void main(String[] args) { int x = 1, y = 2, z = 3; int a = x + y - 2/2 + z; // (1) int b = x + (y - 2)/(2 + z); // (2) System.out.println(&quot;a = &quot; + a + &quot; b = &quot; + b); }} /* Output:a = 5 b = 1*///:~ These statements look roughly the same, but from the output you can see that they have very different meanings which depend on the use of parentheses. Notice that the System.out.println( ) statement involves the ‘**+’ operator. In this context, ‘+’ means “string concatenation**” and, if necessary, “string conversion.” When the compiler sees a String followed by a ‘+’ followed by a non-String, it attempts to convert the nonString into a String. As you can see from the output, it successfully converts from int into String for a and b. 3.4 AssignmentWhenever you manipulate an object, what you’re manipulating is the reference, so when you assign “from one object to another,” you’re actually copying a reference from one place to another. This means that if you say c = d for objects, you end up with both c and d pointing to the object that, originally, only d pointed to. Here’s an example that demonstrates this behavior: 1234567891011121314151617181920212223242526//: operators/Assignment.java// Assignment with objects is a bit tricky.import static net.mindview.util.Print.*;class Tank { int level;}public class Assignment { public static void main(String[] args) { Tank t1 = new Tank(); Tank t2 = new Tank(); t1.level = 9; t2.level = 47; print(&quot;1: t1.level: &quot; + t1.level + &quot;, t2.level: &quot; + t2.level); t1 = t2; print(&quot;2: t1.level: &quot; + t1.level + &quot;, t2.level: &quot; + t2.level); t1.level = 27; print(&quot;3: t1.level: &quot; + t1.level + &quot;, t2.level: &quot; + t2.level); }} /* Output:1: t1.level: 9, t2.level: 472: t1.level: 47, t2.level: 473: t1.level: 27, t2.level: 27*///:~ This phenomenon is often called aliasing, and it’s a fundamental way that Java works with objects. But what if you don’t want aliasing to occur in this case? You could forego the assignment and say: 1t1.level = t2.level; This retains the two separate objects instead of discarding one and tying t1 and t2 to the same object. You’ll soon realize that manipulating the fields within objects is messy and goes against good object-oriented design principles. This is a nontrivial topic, so you should keep in mind that assignment for objects can add surprises. Exercise 2Create a class containing a float and use it to demonstrate aliasing. 1234567891011121314151617181920class Tank { float level;}public class exer_2 { public static void main(String[] args) { Tank t1 = new Tank(); Tank t2 = new Tank(); t1.level = 9; t2.level = 47; System.out.print(&quot;1: t1.level: &quot; + t1.level + &quot;, t2.level: &quot; + t2.level); t1 = t2; System.out.print(&quot;2: t1.level: &quot; + t1.level + &quot;, t2.level: &quot; + t2.level); t1.level = 27; System.out.print(&quot;3: t1.level: &quot; + t1.level + &quot;, t2.level: &quot; + t2.level); }} 3.4.1 Aliasing during method callsAliasing will also occur when you pass an object into a method: 12345678910111213141516171819202122//: operators/PassObject.java// Passing objects to methods may not be// what you’re used to.import static net.mindview.util.Print.*;class Letter { char c;}public class PassObject { static void f(Letter y) { y.c = ‘z’; } public static void main(String[] args) { Letter x = new Letter(); x.c = ‘a’; print(&quot;1: x.c: &quot; + x.c); f(x); print(&quot;2: x.c: &quot; + x.c); }} /* Output:1: x.c: a2: x.c: z*///:~ In many programming languages, the method f( ) would appear to be making a copy of its argument Letter y inside the scope of the method. But once again a reference is being passed, so the line 1y.c = ‘z’; is actually changing the object outside of f( ). Exercise 3Create a class containing a float and use it to demonstrate aliasing during method calls. pass 3.5 Mathematical operatorsThe basic mathematical operators are the same as the ones available in most programming languages: addition (+), subtraction (-), division (/), multiplication (*) and modulus (%, which produces the remainder from integer division). Integer division truncates, rather than rounds, the result. Java also uses the shorthand notation from C/C++ that performs an operation and an assignment at the same time. This is denoted by an operator followed by an equal sign, and is consistent with all the operators in the language (whenever it makes sense). For example, to add 4 to the variable x and assign the result to x, use: x += 4. The program generates a number of different types of random numbers with the Random object simply by calling the methods nextInt( ) and nextFloat( ) (you can also call nextLong( ) or nextDouble( )). The argument to nextInt( ) sets the upper bound on the generated number. The lower bound is zero, which we don’t want because of the possibility of a divide-by-zero, so the result is offset by one. Exercise 4Write a program that calculates velocity using a constant distance and a constant time. pass 3.5.1 Unary minus and plus operatorspass 3.6 Auto increment and decrementTwo of the nicer shortcuts are the increment and decrement operators (often referred to as the auto-increment and auto-decrement operators). The decrement operator is – and means “decrease by one unit.” The increment operator is ++ and means “increase by one unit.” If a is an int, for example, the expression ++a is equivalent to (a = a + 1). Increment and decrement operators not only modify the variable, but also produce the value of the variable as a result. There are two versions of each type of operator, often called the prefix and postfix versions. Preincrement means the ++ operator appears before the variable, and post-increment means the ++ operator appears after the variable. Similarly, pre-decrement means the – operator appears before the variable, and post-decrement means the – operator appears after the variable. For pre-increment and pre-decrement (i.e., ++a or –a), the operation is performed and the value is produced. For post-increment and post-decrement (i.e., a++ or a–), the value is produced, then the operation is performed. 3.7 Relational operatorsRelational operators generate a boolean result. They evaluate the relationship between the values of the operands. A relational expression produces true if the relationship is true, and false if the relationship is untrue. The relational operators are less than (&lt;), greater than (&gt;), less than or equal to (&lt;=), greater than or equal to (&gt;=), equivalent (==) and not equivalent (!=). Equivalence and nonequivalence work with all primitives, but the other comparisons won’t work with type boolean. Because boolean values can only be true or false, “greater than” and “less than” doesn’t make sense. 3.7.1 Testing object equivalenceThe relational operators == and != also work with all objects, but their meaning often confuses the first-time Java programmer. Exercise 5Create a class called Dog containing two Strings: name and says. In main( ), create two dog objects with names “spot” (who says, “Ruff!”) and “scruffy” (who says, “Wurf!”). Then display their names and what they say. pass Exercise 6Following Exercise 5, create a new Dog reference and assign it to spot’s object. Test for comparison using == and equals( ) for all references. 3.8 Logical operatorsEach of the logical operators AND (&amp;&amp;), OR (||) and NOT (!) produces a boolean value of true or false based on the logical relationship of its arguments. You can apply AND, OR, or NOT to boolean values only. You can’t use a non-boolean as if it were a boolean in a logical expression as you can in C and C++. You can see the failed attempts at doing this commented out with a ‘//!’ (this comment syntax enables automatic removal of comments to facilitate testing). The subsequent expressions, however, produce boolean values using relational comparisons, then use logical operations on the results. Exercise 7Write a program that simulates coin-flipping. 3.8.1 Short-circuitingWhen dealing with logical operators, you run into a phenomenon called “short-circuiting.” This means that the expression will be evaluated only until the truth or falsehood of the entire expression can be unambiguously determined. As a result, the latter parts of a logical expression might not be evaluated. 3.9 Literalspass Exercise 8Show that hex and octal notations work with long values. Use Long.toBinaryString( ) to display the results. pass 3.9.1 Exponential notationpass Exercise 9Display the largest and smallest numbers for both float and double exponential notation. pass 3.10 Bitwise operatorspass Exercise 10Write a program with two constant values, one with alternating binary ones and zeroes, with a zero in the least-significant digit, and the second, also alternating, with a one in the least-significant digit (hint: It’s easiest to use hexadecimal constants for this). Take these two values and combine them in all possible ways using the bitwise operators, and display the results using Integer.toBinaryString( ). 3.11 Shift operatorspass Exercise 11Start with a number that has a binary one in the most significant position (hint: Use a hexadecimal constant). Using the signed right-shift operator, right shift it all the way through all of its binary positions, each time displaying the result using Integer.toBinaryString( ). pass Exercise 12Start with a number that is all binary ones. Left shift it, then use the unsigned right-shift operator to right shift through all of its binary positions, each time displaying the result using Integer.toBinaryString( ). pass Exercise 13Write a method that displays char values in binary form. Demonstrate it using several different characters. pass 3.12 Ternary if-else operatorpass 3.13 String operator + and +=pass 3.14 Common pitfalls when using operatorspass 3.15 Casting operatorspass 3.15.1 Truncation and roundingpass 3.15.2 PromotionYou’ll discover that if you perform any mathematical or bitwise operations on primitive data types that are smaller than an int (that is, char, byte, or short), those values will be promoted to int before performing the operations, and the resulting value will be of type int. So if you want to assign back into the smaller type, you must use a cast. (And, since you’re assigning back into a smaller type, you might be losing information.) In general, the largest data type in an expression is the one that determines the size of the result of that expression; if you multiply a float and a double, the result will be double; if you add an int and a long, the result will be long. 3.16 Java has no “sizeof”pass 3.17 A compendium of operatorspass 3.18 Summarypass","link":"/2025/02/11/Thinking-in-Java/Thinking-in-Java-pt-3/"},{"title":"Thinking in Java pt.2","text":"Chapter 2 Everything Is an ObjectAlthough it is based on C++, Java is more of a “pure” object-oriented language. Both C++ and Java are hybrid languages, but in Java the designers felt that the hybridization was not as important as it was in C++. A hybrid language allows multiple programming styles; the reason C++ is hybrid is to support backward compatibility with the C language. Because C++ is a superset of the C language, it includes many of that language’s undesirable features, which can make some aspects of C++ overly complicated. The Java language assumes that you want to do only object-oriented programming. This means that before you can begin you must shift your mindset into an object-oriented world (unless it’s already there). The benefit of this initial effort is the ability to program in a language that is simpler to learn and to use than many other OOP languages. In this chapter you’ll see the basic components of a Java program and learn that (almost) everything in Java is an object. 2.1 You manipulate objects with referencesYou treat everything as an object, using a single consistent syntax. Although you treat everything as an object, the identifier you manipulate is actually a “reference” to an object[^1] You might imagine a television (the object) and a remote control (the reference). As long as you’re holding this reference, you have a connection to the television, but when someone says, “Change the channel” or “Lower the volume,” what you’re manipulating is the reference, which in turn modifies the object. If you want to move around the room and still control the television, you take the remote/reference with you, not the television. [^1]: This can be a flashpoint. There are those who say, “Clearly, it’s a pointer,” but this presumes an underlying implementation. Also, Java references are much more akin to C++ references than to pointers in their syntax. In the 1st edition of this book, I chose to invent a new term, “handle,” because C++ references and Java references have some important differences. I was coming out of C++ and did not want to confuse the C++ programmers whom I assumed would be the largest audience for Java. In the 2nd edition, I decided that “reference” was the more commonly used term, and that anyone changing from C++ would have a lot more to cope with than the terminology of references, so they might as well jump in with both feet. However, there are people who disagree even with the term “reference.” I read in one book where it was “completely wrong to say that Java supports pass by reference,” because Java object identifiers (according to that author) are actually “object references.” And (he goes on) everything is actually pass by value. So you’re not passing by reference, you’re “passing an object reference by value.” One could argue for the precision of such convoluted explanations, but I think my approach simplifies the understanding of the concept without hurting anything (well, the language lawyers may claim that I’m lying to you, but I’ll say that I’m providing an appropriate abstraction). 2.2 You must create all the objectsWhen you create a reference, you want to connect it with a new object. You do so, in general, with the new operator. The keyword new says, “Make me a new one of these objects.” 1String s = new String(&quot;asdf&quot;); Not only does this mean “Make me a new String,” but it also gives information about how to make the String by supplying an initial character string. 2.2.1 Where storage livesIt’s useful to visualize some aspects of how things are laid out while the program is running— in particular how memory is arranged. There are five different places to store data: Registers. This is the fastest storage because it exists in a place different from that of other storage: inside the processor. However, the number of registers is severely limited, so registers are allocated as they are needed. You don’t have direct control, nor do you see any evidence in your programs that registers even exist (C &amp; C++, on the other hand, allow you to suggest register allocation to the compiler). The stack. This lives in the general random-access memory (RAM) area, but has direct support from the processor via its stack pointer. The stack pointer is moved down to create new memory and moved up to release that memory. This is an extremely fast and efficient way to allocate storage, second only to registers. The Java system must know, while it is creating the program, the exact lifetime of all the items that are stored on the stack. This constraint places limits on the flexibility of your programs, so while some Java storage exists on the stack—in particular, object references—Java objects themselves are not placed on the stack. The heap. This is a general-purpose pool of memory (also in the RAM area) where all Java objects live. The nice thing about the heap is that, unlike the stack, the compiler doesn’t need to know how long that storage must stay on the heap. Thus, there’s a great deal of flexibility in using storage on the heap. Whenever you need an object, you simply write the code to create it by using new, and the storage is allocated on the heap when that code is executed. Of course there’s a price you pay for this flexibility: It may take more time to allocate and clean up heap storage than stack storage (if you even could create objects on the stack in Java, as you can in C++). Constant storage. Constant values are often placed directly in the program code, which is safe since they can never change. Sometimes constants are cordoned off by themselves so that they can be optionally placed in read-only memory (ROM), in embedded systems.[^2] [^2]: An example of this is the string pool. All literal strings and string-valued constant expressions are interned automatically and put into special static storage. Non-RAM storage. If data lives completely outside a program, it can exist while the program is not running, outside the control of the program. The two primary examples of this are streamed objects, in which objects are turned into streams of bytes, generally to be sent to another machine, and persistent objects, in which the objects are placed on disk so they will hold their state even when the program is terminated. The trick with these types of storage is turning the objects into something that can exist on the other medium, and yet can be resurrected into a regular RAMbased object when necessary. Java provides support for lightweight persistence, and mechanisms such as JDBC and Hibernate provide more sophisticated support for storing and retrieving object information in databases. 2.2.2 Special case:primitive typesOne group of types, which you’ll use quite often in your programming, gets special treatment. You can think of these as “primitive” types. The reason for the special treatment is that to create an object with new—especially a small, simple variable—isn’t very efficient, because new places objects on the heap. For these types Java falls back on the approach taken by C and C++. That is, instead of creating the variable by using new, an “automatic” variable is created that is not a reference. The variable holds the value directly, and it’s placed on the stack, so it’s much more efficient. Java determines the size of each primitive type. These sizes don’t change from one machine architecture to another as they do in most languages. This size invariance is one reason Java programs are more portable than programs in most other languages. Primitive type Size Minimum Maximum Wrapper type boolean — — — Boolean char 16 bits Unicode 0 Unicode (2^16) - 1 Character byte 8 bits -128 +127 Byte short 16 bits -2^15 +(2^15) - 1 Short int 32 bits -2^31 +(2^31) - 1 Integer long 64 bits -2^63 +(2^63) - 1 Long float 32 bits IEEE754 IEEE754 Float double 64 bits IEEE754 IEEE754 Double void — — — Void All numeric types are signed, so don’t look for unsigned types. The size of the boolean type is not explicitly specified; it is only defined to be able to take the literal values true or false. The “wrapper” classes for the primitive data types allow you to make a non-primitive object on the heap to represent that primitive type. For example: 12345678char c = ‘x’;Character ch = new Character(c);// Or you could also use:Character ch = new Character(‘x’);// Java SE5 autoboxing will automatically convert from a primitive to a wrapper type:Character ch = ‘x’; // and back:char c = ch; The reasons for wrapping primitives will be shown in a later chapter. High-precision numbersJava includes two classes for performing high-precision arithmetic: BigInteger and BigDecimal. Although these approximately fit into the same category as the “wrapper” classes, neither one has a primitive analogue. Both classes have methods that provide analogues for the operations that you perform on primitive types. That is, you can do anything with a BigInteger or BigDecimal that you can with an int or float, it’s just that you must use method calls instead of operators. Also, since there’s more involved, the operations will be slower. You’re exchanging speed for accuracy. BigInteger supports arbitrary-precision integers. This means that you can accurately represent integral values of any size without losing any information during operations. BigDecimal is for arbitrary-precision fixed-point numbers; you can use these for accurate monetary calculations, for example. Consult the JDK documentation for details about the constructors and methods you can call for these two classes. 2.2.3 Arrays in JavaOne of the primary goals of Java is safety, so many of the problems that plague programmers in C and C++ are not repeated in Java. A Java array is guaranteed to be initialized and cannot be accessed outside of its range. The range checking comes at the price of having a small amount of memory overhead on each array as well as verifying the index at run time, but the assumption is that the safety and increased productivity are worth the expense (and Java can sometimes optimize these operations). When you create an array of objects, you are really creating an array of references, and each of those references is automatically initialized to a special value with its own keyword: null. When Java sees null, it recognizes that the reference in question isn’t pointing to an object. You must assign an object to each reference before you use it, and if you try to use a reference that’s still null, the problem will be reported at run time. Thus, typical array errors are prevented in Java. You can also create an array of primitives. Again, the compiler guarantees initialization because it zeroes the memory for that array. 2.3 You never need to destroy an objectIn most programming languages, the concept of the lifetime of a variable occupies a significant portion of the programming effort. How long does the variable last? If you are supposed to destroy it, when should you? Confusion over variable lifetimes can lead to a lot of bugs, and this section shows how Java greatly simplifies the issue by doing all the cleanup work for you. 2.3.1 ScopingMost procedural languages have the concept of scope. This determines both the visibility and lifetime of the names defined within that scope. In C, C++, and Java, scope is determined by the placement of curly braces {}. So for example: 1234567891011{ int x = 12; // Only x available { int q = 96; // Both x &amp; q available } // Only x available // q is &quot;out of scope&quot;} A variable defined within a scope is available only to the end of that scope. Any text after a ‘//’ to the end of a line is a comment. Indentation makes Java code easier to read. Since Java is a free-form language, the extra spaces, tabs, and carriage returns do not affect the resulting program. You cannot do the following, even though it is legal in C and C++: 123456{ int x = 12; { int x = 96; // Illegal }} The compiler will announce that the variable x has already been defined. Thus the C and C++ ability to “hide” a variable in a larger scope is not allowed, because the Java designers thought that it led to confusing programs. 2.3.2 Scope of objectsJava objects do not have the same lifetimes as primitives. When you create a Java object using new, it hangs around past the end of the scope. Thus if you use: 123{ String s = new String(&quot;a string&quot;);} // End of scope the reference s vanishes at the end of the scope. However, the String object that s was pointing to is still occupying memory. In this bit of code, there is no way to access the object after the end of the scope, because the only reference to it is out of scope. In later chapters you’ll see how the reference to the object can be passed around and duplicated during the course of a program. It turns out that because objects created with new stay around for as long as you want them, a whole slew of C++ programming problems simply vanish in Java. In C++ you must not only make sure that the objects stay around for as long as you need them, you must also destroy the objects when you’re done with them. That brings up an interesting question. If Java leaves the objects lying around, what keeps them from filling up memory and halting your program? This is exactly the kind of problem that would occur in C++. This is where a bit of magic happens. Java has a garbage collector, which looks at all the objects that were created with new and figures out which ones are not being referenced anymore. Then it releases the memory for those objects, so the memory can be used for new objects. This means that you never need to worry about reclaiming memory yourself. You simply create objects, and when you no longer need them, they will go away by themselves. This eliminates a certain class of programming problem: the so-called “memory leak,” in which a programmer forgets to release memory. 2.4 Creating new data types: classIf everything is an object, what determines how a particular class of object looks and behaves? Put another way, what establishes the type of an object? You might expect there to be a keyword called “type,” and that certainly would have made sense. Historically, however, most objectoriented languages have used the keyword class to mean “I’m about to tell you what a new type of object looks like.” The class keyword (which is so common that it will not usually be boldfaced throughout this book) is followed by the name of the new type. For example: 123class ATypeName { /* Class body goes here */ } This introduces a new type, although the class body consists only of a comment (the stars and slashes and what is inside, which will be discussed later in this chapter), so there is not too much that you can do with it. However, you can create an object of this type using new: 1ATypeName a = new ATypeName(); But you cannot tell it to do much of anything (that is, you cannot send it any interesting messages) until you define some methods for it. 2.4.1 Fields and methodsWhen you define a class (and all you do in Java is define classes, make objects of those classes, and send messages to those objects), you can put two types of elements in your class: fields (sometimes called data members), and methods (sometimes called member functions). A field is an object of any type that you can talk to via its reference, or a primitive type. If it is a reference to an object, you must initialize that reference to connect it to an actual object (using new, as seen earlier). Each object keeps its own storage for its fields; ordinary fields are not shared among objects. Here is an example of a class with some fields: 12345class DataOnly { int i; double d; boolean b;} This class doesn’t do anything except hold data. But you can create an object like this: 1DataOnly data = new DataOnly(); You can assign values to the fields, but you must first know how to refer to a member of an object. This is accomplished by stating the name of the object reference, followed by a period (dot), followed by the name of the member inside the object: 1objectReference.member For example: 123data.i = 47;data.d = 1.1;data.b = false; It is also possible that your object might contain other objects that contain data you’d like to modify. For this, you just keep “connecting the dots.” For example: 1myPlane.leftTank.capacity = 100; The DataOnly class cannot do much of anything except hold data, because it has no methods. To understand how those work, you must first understand arguments and return values, which will be described shortly. 2.4.2 Default values for primitive membersWhen a primitive data type is a member of a class, it is guaranteed to get a default value if you do not initialize it: Primitive type Default boolean false char ‘\\u0000’ (null) byte (byte)0 short (short)0 int 0 long 0L float 0.0f double 0.0d The default values are only what Java guarantees when the variable is used as a member of a class. This ensures that member variables of primitive types will always be initialized (something C++ doesn’t do), reducing a source of bugs. However, this initial value may not be correct or even legal for the program you are writing. It’s best to always explicitly initialize your variables. This guarantee doesn’t apply to *local variables*—those that are not fields of a class. Thus, if within a method definition you have: 1int x; Then x will get some arbitrary value (as in C and C++); it will not automatically be initialized to zero. You are responsible for assigning an appropriate value before you use x. If you forget, Java definitely improves on C++: You get a compile-time error telling you the variable might not have been initialized. (Many C++ compilers will warn you about uninitialized variables, but in Java these are errors.) 2.5 Methods, arguments, and return valuesMethods in Java determine the messages an object can receive. The fundamental parts of a method are the name, the arguments, the return type, and the body. Here is the basic form: 123ReturnType methodName( /* Argument list */ ) { /* Method body */} The return type describes the value that comes back from the method after you call it. The argument list gives the types and names for the information that you want to pass into the method. The method name and argument list (which is called the signature of the method) uniquely identify that method. Methods in Java can be created only as part of a class. A method can be called only for an object[^3], and that object must be able to perform that method call. If you try to call the wrong method for an object, you’ll get an error message at compile time. You call a method for an object by naming the object followed by a period (dot), followed by the name of the method and its argument list, like this: [^3]: static methods, which you’ll learn about soon, can be called for the class, without an object. 1objectName.methodName(arg1, arg2, arg3); For example, suppose you have a method f( ) that takes no arguments and returns a value of type int. Then, if you have an object called a for which f( ) can be called, you can say this: 1int x = a.f(); The type of the return value must be compatible with the type of x. This act of calling a method is commonly referred to as sending a message to an object. In the preceding example, the message is f( ) and the object is a. Object-oriented programming is often summarized as simply “sending messages to objects.” 2.5.1 The argument listConsider a method that takes a String as its argument. Here is the definition, which must be placed within a class definition for it to be compiled: 123int storage(String s) { return s.length() * 2;} This method tells you how many bytes are required to hold the information in a particular String. (The size of each char in a String is 16 bits, or two bytes, to support Unicode characters) The argument is of type String and is called s. Once s is passed into the method, you can treat it just like any other object. (You can send messages to it.) Here, the length( ) method is called, which is one of the methods for Strings; it returns the number of characters in a string. You can also see the use of the return keyword, which does two things. First, it means “Leave the method, I’m done.” Second, if the method produces a value, that value is placed right after the return statement. In this case, the return value is produced by evaluating the expression s.length( ) * 2. You can return any type you want, but if you don’t want to return anything at all, you do so by indicating that the method returns void. Here are some examples: 1234boolean flag() { return true; }double naturalLogBase() { return 2.718; }void nothing() { return; }void nothing2() {} When the return type is void, then the return keyword is used only to exit the method, and is therefore unnecessary when you reach the end of the method. You can return from a method at any point, but if you’ve given a non-void return type, then the compiler will force you (with error messages) to return the appropriate type of value regardless of where you return. 2.6 Building a Java program2.6.1 Name visibilityTo produce an unambiguous name for a library, the Java creators want you to use your Internet domain name in reverse since domain names are guaranteed to be unique. Since my domain name is MindView.net, my utility library of foibles would be named net.mindview.utility.foibles. After your reversed domain name, the dots are intended to represent subdirectories. This mechanism means that all of your files automatically live in their own namespaces, and each class within a file must have a unique identifier—the language prevents name clashes for you. 2.6.2 Using other componentsThis is accomplished by telling the Java compiler exactly what classes you want by using the import keyword. import tells the compiler to bring in a package, which is a library of classes. (In other languages, a library could consist of functions and data as well as classes, but remember that all code in Java must be written inside a class.) Most of the time you’ll be using components from the standard Java libraries that come with your compiler. With these, you don’t need to worry about long, reversed domain names; you just say, for example: 1import java.util.ArrayList; to tell the compiler that you want to use Java’s ArrayList class. However, util contains a number of classes, and you might want to use several of them without declaring them all explicitly. This is easily accomplished by using ‘*****’ to indicate a wild card: 1import java.utils.*; It is more common to import a collection of classes in this manner than to import classes individually. 2.6.3 The static keywordThere are two situations in which this approach is not sufficient. One is if you want to have only a single piece of storage for a particular field, regardless of how many objects of that class are created, or even if no objects are created. The other is if you need a method that isn’t associated with any particular object of this class. That is, you need a method that you can call even if no objects are created. You can achieve both of these effects with the static keyword. When you say something is static, it means that particular field or method is not tied to any particular object instance of that class. So even if you’ve never created an object of that class you can call a static method or access a static field. With ordinary, non-static fields and methods, you must create an object and use that object to access the field or method, since non-static fields and methods must know the particular object they are working with[^4]. [^4]: Of course, since static methods don’t need any objects to be created before they are used, they cannot directly access non-static members or methods by simply calling those other members without referring to a named object (since nonstatic members and methods must be tied to a particular object). To make a field or method static, you simply place the keyword before the definition. For example, the following produces a static field and initializes it: 123class StaticTest { static int i = 47;} Now even if you make two StaticTest objects, there will still be only one piece of storage for StaticTest.i. Both objects will share the same i. Consider: 12StaticTest st1 = new StaticTest();StaticTest st2 = new StaticTest(); At this point, both st1.i and st2.i have the same value of 47 since they refer to the same piece of memory. There are two ways to refer to a static variable. As the preceding example indicates, you can name it via an object, by saying, for example, st2.i. You can also refer to it directly through its class name, something you cannot do with a non-static member. 1StaticTest.i++; The ++ operator adds one to the variable. At this point, both st1.i and st2.i will have the value 48. Using the class name is the preferred way to refer to a static variable. Not only does it emphasize that variable’s static nature, but in some cases it gives the compiler better opportunities for optimization. Similar logic applies to static methods. You can refer to a static method either through an object as you can with any method, or with the special additional syntax ClassName.method( ). You define a static method in a similar way: 123class Incrementable { static void increment() { StaticTest.i++; }} You can see that the Incrementable method increment( ) increments the static data i using the ++ operator. You can call increment( ) in the typical way, through an object: 12Incrementable sf = new Incrementable();sf.increment(); Or, because increment( ) is a static method, you can call it directly through its class: 1Incrementable.increment(); Although static, when applied to a field, definitely changes the way the data is created (one for each class versus the non-static one for each object), when applied to a method it’s not so dramatic. An important use of static for methods is to allow you to call that method without creating an object. This is essential, as you will see, in defining the main( ) method that is the entry point for running an application. 2.7 Your first Java programFinally, here’s the first complete program. It starts by printing a string, and then the date, using the Date class from the Java standard library. 12345678// HelloDate.javaimport java.util.*;public class HelloDate { public static void main(String[] args) { System.out.println(&quot;Hello, it’s: &quot;); System.out.println(new Date()); }} The name of the class is the same as the name of the file.When you’re creating a standalone program such as this one, one of the classes in the file must have the same name as the file. (The compiler complains if you don’t do this.) That class must contain a method called main( ) with this signature and return type: 1public static void main(String[] args) { The public keyword means that the method is available to the outside world (described in detail in the Access Control chapter). The argument to main( ) is an array of String objects. The args won’t be used in this program, but the Java compiler insists that they be there because they hold the arguments from the command line. The line that prints the date is quite interesting: 1System.out.println(new Date()); The argument is a Date object that is being created just to send its value (which is automatically converted to a String) to println( ). As soon as this statement is finished, that Date is unnecessary, and the garbage collector can come along and get it anytime. We don’t need to worry about cleaning it up. When you look at the JDK documentation from http://java.sun.com, you will see that System has many other methods that allow you to produce interesting effects (one of Java’s most powerful assets is its large set of standard libraries). For example: 12345678910//: object/ShowProperties.javapublic class ShowProperties { public static void main(String[] args) { System.getProperties().list(System.out); System.out.println(System.getProperty(&quot;user.name&quot;)); System.out.println( System.getProperty(&quot;java.library.path&quot;) ); }} ///:~ The first line in main( ) displays all of the “properties” from the system where you are running the program, so it gives you environment information. The list( ) method sends the results to its argument, System.out. You will see later in the book that you can send the results elsewhere, to a file, for example. You can also ask for a specific property—in this case, the user name and java.library.path. (The unusual comments at the beginning and end will be explained a little later.) Output(part): 123456789101112131415161718192021222324-- listing properties --java.specification.version=17sun.cpu.isalist=amd64sun.jnu.encoding=GBKjava.class.path=.java.vm.vendor=Oracle Corporationsun.arch.data.model=64java.specification.vendor=Oracle Corporationjava.version.date=2024-01-16java.home=C:\\Program Files\\Java\\jdk-17file.separator=\\java.vm.compressedOopsMode=Zero basedline.separator=sun.stdout.encoding=ms936java.vm.specification.vendor=Oracle Corporationjava.specification.name=Java Platform API Specificationuser.script=sun.management.compiler=HotSpot 64-Bit Tiered Compilersjava.vm.version=17.0.10+11-LTS-240sun.io.unicode.encoding=UnicodeLittlejava.class.version=61.0...... 2.7.1 Compiling and runningpass 2.8 Comments and embedded documentationThere are two types of comments in Java. The first is the traditional C-style comment that was inherited by C++. These comments begin with a /* and continue, possibly across many lines, until a */. Note that many programmers will begin each line of a continued comment with a *, so you’ll often see: 1234/* This is a comment * that continues * across lines */ Remember, however, that everything inside the /* and ***/** is ignored, so there’s no difference in saying: 12/* This is a comment thatcontinues across lines */ The second form of comment comes from C++. It is the single-line comment, which starts with a // and continues until the end of the line. This type of comment is convenient and commonly used because it’s easy. You don’t need to hunt on the keyboard to find / and then * (instead, you just press the same key twice), and you don’t need to close the comment. So you will often see: 1// This is a one-line comment 2.8.1 Comment documentationThe tool to extract the comments is called Javadoc, and it is part of the JDK installation. It uses some of the technology from the Java compiler to look for special comment tags that you put in your programs. It not only extracts the information marked by these tags, but it also pulls out the class name or method name that adjoins the comment. This way you can get away with the minimal amount of work to generate decent program documentation. The output of Javadoc is an HTML file that you can view with your Web browser. Thus, Javadoc allows you to create and maintain a single source file and automatically generate useful documentation. Because of Javadoc, you have a straightforward standard for creating documentation, so you can expect or even demand documentation with all Java libraries. 2.8.2 SyntaxAll of the Javadoc commands occur only within /** comments. The comments end with */ as usual. There are two primary ways to use Javadoc: Embed HTML or use “*doc tags*.” Standalone doc tags are commands that start with an @ and are placed at the beginning of a comment line. (A leading *, however, is ignored.) Inline doc tags can appear anywhere within a Javadoc comment and also start with an @ but are surrounded by curly braces. There are three “types” of comment documentation, which correspond to the element the comment precedes: class, field, or method. That is, a class comment appears right before the definition of a class, a field comment appears right in front of the definition of a field, and a method comment appears right in front of the definition of a method. As a simple example: 12345678//: object/Documentation1.java/** A class comment */public class Documentation1 { /** A field comment */ public int i; /** A method comment */ public void f() {}} ///:~ Note that Javadoc will process comment documentation for only public and protected members. Comments for private and package-access members (see the Access Control chapter) are ignored, and you’ll see no output. (However, you can use the -private flag to include private members as well.) This makes sense, since only public and protected members are available outside the file, which is the client programmer’s perspective. The output for the preceding code is an HTML file that has the same standard format as all the rest of the Java documentation, so users will be comfortable with the format and can easily navigate your classes. It’s worth entering the preceding code, sending it through Javadoc, and viewing the resulting HTML file to see the results. 2.8.3 Embedded HTMLJavadoc passes HTML commands through to the generated HTML document. This allows you full use of HTML; however, the primary motive is to let you format code, such as: 1234567//: object/Documentation2.java/*** &lt;pre&gt;* System.out.println(new Date());* &lt;/pre&gt;*////:~ You can also use HTML just as you would in any other Web document to format the regular text in your descriptions: 12345678910//: object/Documentation3.java/*** You can &lt;em&gt;even&lt;/em&gt; insert a list:* &lt;ol&gt;* &lt;li&gt; Item one* &lt;li&gt; Item two* &lt;li&gt; Item three* &lt;/ol&gt;*////:~ Note that within the documentation comment, asterisks at the beginning of a line are thrown away by Javadoc, along with leading spaces. Javadoc reformats everything so that it conforms to the standard documentation appearance. Don’t use headings such as Note that within the documentation comment, asterisks at the beginning of a line are thrown away by Javadoc, along with leading spaces. Javadoc reformats everything so that it conforms to the standard documentation appearance. Don’t use headings such as&lt;h1&gt; or &lt;hr&gt; as embedded HTML, because Javadoc inserts its own headings and yours will interfere with them. All types of comment documentation—class, field, and method—can support embedded HTML. 2.8.4 Some example tagsHere are some of the Javadoc tags available for code documentation. Before trying to do anything serious using Javadoc, you should consult the Javadoc reference in the JDK documentation to learn all the different ways that you can use Javadoc. 1. @seeThis tag allows you to refer to the documentation in other classes. Javadoc will generate HTML with the @see tags hyperlinked to the other documentation. The forms are: 123@see classname@see fully-qualified-classname@see fully-qualified-classname#method-name Each one adds a hyperlinked “See Also” entry to the generated documentation. Javadoc will not check the hyperlinks you give it to make sure they are valid. 2. {@link package.class#member label}Very similar to @see, except that it can be used inline and uses the label as the hyperlink text rather than “See Also.” 3. {@docRoot}Produces the relative path to the documentation root directory. Useful for explicit hyperlinking to pages in the documentation tree. 4. {@inheritDoc}Inherits the documentation from the nearest base class of this class into the current doc comment. 5. @versionThis is of the form: 1@version version-information in which version-information is any significant information you see fit to include. When the - version flag is placed on the Javadoc command line, the version information will be called out specially in the generated HTML documentation. 6. @authorThis is of the form: 1@author author-information in which author-information is, presumably, your name, but it could also include your email address or any other appropriate information. When the -author flag is placed on the Javadoc command line, the author information will be called out specially in the generated HTML documentation. 7. @sinceThis tag allows you to indicate the version of this code that began using a particular feature. You’ll see it appearing in the HTML Java documentation to indicate what version of the JDK is used. 8. @paramThis is used for method documentation, and is of the form: 1@param parameter-name description in which parameter-name is the identifier in the method parameter list, and description is text that can continue on subsequent lines. The description is considered finished when a new documentation tag is encountered. You can have any number of these, presumably one for each parameter. 9. @returnThis is used for method documentation, and looks like this: 1@return description in which description gives you the meaning of the return value. It can continue on subsequent lines. 10. @throwsAlthough only one exception object can emerge when you call a method, a particular method might produce any number of different types of exceptions, all of which need descriptions. So the form for the exception tag is: 1@throws fully-qualified-class-name description in which fully-qualified-class-name gives an unambiguous name of an exception class that’s defined somewhere, and description (which can continue on subsequent lines) tells you why this particular type of exception can emerge from the method call. 11. @deprecatedThis is used to indicate features that were superseded by an improved feature. The deprecated tag is a suggestion that you no longer use this particular feature, since sometime in the future it is likely to be removed. A method that is marked @deprecated causes the compiler to issue a warning if it is used. In Java SE5, the @deprecated Javadoc tag has been superseded by the @Deprecated annotation (you’ll learn about these in the Annotations chapter). 2.8.5 Documentation exampleHere is the first Java program again, this time with documentation comments added: 123456789101112131415161718192021//: object/HelloDate.javaimport java.util.*;/** The first Thinking in Java example program. * Displays a string and today’s date. * @author Bruce Eckel * @author www.MindView.net * @version 4.0*/public class HelloDate { /** Entry point to class &amp; application. * @param args array of string arguments * @throws exceptions No exceptions thrown */ public static void main(String[] args) { System.out.println(&quot;Hello, it’s: &quot;); System.out.println(new Date()); }} /* Output: (55% match)Hello, it’s:Wed Oct 05 14:39:36 MDT 2005*///:~ The first line of the file uses my own technique of putting a ‘//:’ as a special marker for the comment line containing the source file name. That line contains the path information to the file (object indicates this chapter) followed by the file name. The last line also finishes with a comment, and this one (‘///:~’) indicates the end of the source code listing, which allows it to be automatically updated into the text of this book after being checked with a compiler and executed. The /* Output: tag indicates the beginning of the output that will be generated by this file. In this form, it can be automatically tested to verify its accuracy. In this case, the (55% match) indicates to the testing system that the output will be fairly different from one run to the next so it should only expect a 55 percent correlation with the output shown here. Most examples in this book that produce output will contain the output in this commented form, so you can see the output and know that it is correct. 2.9 Coding styleThe style described in the Code Conventions for the Java Programming Language[^5] is to capitalize the first letter of a class name. If the class name consists of several words, they are run together (that is, you don’t use underscores to separate the names), and the first letter of each embedded word is capitalized, such as: [^5]: https://docs.oracle.com/javase/specs/jls/se23/html/index.html (原网站已不存在，该网站是读时添加的) To preserve space in this book and seminar presentations, not all of these guidelines could be followed, but you’ll see that the style I use here matches the Java standard as much as possible. 1class AllTheColorsOfTheRainbow { // ... This is sometimes called “camel-casing.” For almost everything else—methods, fields (member variables), and object reference names—the accepted style is just as it is for classes except that the first letter of the identifier is lowercase. For example: 1234567class AllTheColorsOfTheRainbow { int anIntegerRepresentingColors; void changeTheHueOfTheColor(int newHue) { // ... } // ...} The user must also type all these long names, so be merciful. The Java code you will see in the Sun libraries also follows the placement of open-and-close curly braces that you see used in this book. 2.10 SummaryThe goal of this chapter is just enough Java to understand how to write a simple program. You’ve also gotten an overview of the language and some of its basic ideas. However, the examples so far have all been of the form “Do this, then do that, then do something else.” The next two chapters will introduce the basic operators used in Java programming, and then show you how to control the flow of your program. 2.11 ExercisesExercise 1:Create a class containing an int and a char that are not initialized, and print their values to verify that Java performs default initialization. 12345678910public class exer_1 { public int testInt; public char testChar; public static void main(String[] args) { exer_1 obj = new exer_1(); System.out.println(obj.testInt); System.out.println(obj.testChar); }} output: 120 (null) Exercise 2:Following the HelloDate.java example in this chapter, create a “hello, world” program that simply displays that statement. You need only a single method in your class (the “main” one that gets executed when the program starts). Remember to make it static and to include the argument list, even though you don’t use the argument list. Compile the program with javac and run it using java. If you are using a different development environment than the JDK, learn how to compile and run programs in that environment. 123456public class exer_2 { public static void main(String[] args) { System.out.println(&quot;hello world&quot;); }} output: 1hello world Exercise 3:Find the code fragments involving ATypeName and turn them into a program that compiles and runs. 1234567891011public class exer_3 { int i; char c; public static void main(String[] args) { exer_3 obj = new exer_3(); System.out.println(&quot;int i : &quot; + obj.i); System.out.println(&quot;char i : &quot; + obj.c); }} output: 12int i : 0char i : Exercise 4:Turn the DataOnly code fragments into a program that compiles and runs. 12345678910111213141516171819202122232425public class exer_4 { int i; double d; boolean b; @Override public String toString() { return &quot;exer_4{&quot; + &quot;i=&quot; + i + &quot;, d=&quot; + d + &quot;, b=&quot; + b + '}'; } public static void main(String[] args) { exer_4 obj = new exer_4(); obj.i = 47; obj.d = 1.1; obj.b = false; System.out.println(&quot;exer_4:&quot; + obj); }} outputs: 1exer_4:exer_4{i=47, d=1.1, b=false} Exercise 5:Modify the previous exercise so that the values of the data in DataOnly are assigned to and printed in main( ). 同上 Exercise 6:Write a program that includes and calls the storage( ) method defined as a code fragment in this chapter. 1234567891011public class exer_6 { int storage(String s) { return s.length() * 2; } public static void main(String[] args) { exer_6 obj = new exer_6(); System.out.println(obj.storage(&quot;A&quot;)); }} outputs: 12 Exercise 7:Turn the Incrementable code fragments into a working program. 1234567891011121314class StaticTest { static int i = 47;}public class exer_7 { static void increment() { StaticTest.i++; } public static void main(String[] args) { exer_7.increment(); System.out.println(StaticTest.i); }} outputs: 148 Exercise 8:Write a program that demonstrates that, no matter how many objects you create of a particular class, there is only one instance of a particular static field in that class. pass Exercise 9:Write a program that demonstrates that autoboxing works for all the primitive types and their wrappers. pass Exercise 10:Write a program that prints three arguments taken from the command line. To do this, you’ll need to index into the command-line array of Strings. pass Exercise 11:Turn the AllTheColorsOfTheRainbow example into a program that compiles and runs. pass Exercise 12:Find the code for the second version of HelloDate.java, which is the simple comment documentation example. Execute Javadoc on the file and view the results with your Web browser. pass Exercise 13:Run Documentation1.java, Documentation2.java, and Documentation3.java through Javadoc. Verify the resulting documentation with your Web browser. pass Exercise 14:Add an HTML list of items to the documentation in the previous exercise. pass Exercise 15:Take the program in Exercise 2 and add comment documentation to it. Extract this comment documentation into an HTML file using Javadoc and view it with your Web browser. pass Exercise 16:In the Initialization &amp; Cleanup chapter, locate the Overloading.java example and add Javadoc documentation. Extract this comment documentation into an HTML file using Javadoc and view it with your Web browser. pass","link":"/2025/02/10/Thinking-in-Java/Thinking-in-Java-pt-2/"},{"title":"1.3 Hello,Cargo!","text":"使用 Cargo 创建项目12$ cargo new hello_cargo$ cd hello_cargo 第一行命令新建了名为 hello_cargo 的目录和项目。我们将项目命名为 hello_cargo，同时 Cargo 在一个同名目录中创建项目文件。 进入 hello_cargo 目录并列出文件。将会看到 Cargo 生成了两个文件和一个目录：一个 Cargo.toml 文件，一个 src 目录，以及位于 src 目录中的 main.rs 文件。 这也会在 hello_cargo 目录初始化了一个 git 仓库，以及一个 .gitignore 文件。如果在一个已经存在的 git 仓库中运行 cargo new，则这些 git 相关文件则不会生成；可以通过运行 cargo new --vcs=git 来覆盖这些行为。 初始化创建的 Cargo.toml 文件123456[package]name = &quot;hello_cargo&quot;version = &quot;0.1.0&quot;edition = &quot;2024&quot;[dependencies] 这个文件使用 TOML (Tom’s Obvious, Minimal Language) 格式，这是 Cargo 配置文件的格式。 第一行，[package]，是一个片段 section 标题，表明下面的语句用来配置一个包。随着我们在这个文件增加更多的信息，还将增加其他 section。 接下来的三行设置了 Cargo 编译程序所需的配置：项目的名称、项目的版本以及要使用的 Rust 版本。[附录 E](./22.5 E.md) 会介绍 edition 的值。 最后一行，[dependencies]，是罗列项目依赖的 section 的开始。在 Rust 中，代码包被称为 crates。这个项目并不需要其他的 crate，不过在第二章的第一个项目会用到依赖，那时会用得上这个 section。 src/main.rs123fn main() { println!(&quot;Hello, world!&quot;);} Cargo 生成了一个 “Hello, world!” 程序，正如我们之前编写的示例 1-1！目前为止，我们的项目与 Cargo 生成项目的区别是 Cargo 将代码放在 src 目录，同时项目根目录包含一个 Cargo.toml 配置文件。 Cargo 期望源文件存放在 src 目录中。项目根目录只存放 README、license 信息、配置文件和其他跟代码无关的文件。使用 Cargo 帮助你保持项目干净整洁。一切各得其所，井井有条。 如果没有使用 Cargo 开始项目，比如我们创建的 “Hello, world!” 项目，你可以将其转换为使用 Cargo 的项目。将项目代码移入 src 目录，并创建一个合适的 Cargo.toml 文件。一个简单的创建 Cargo.toml 文件的方法是运行 cargo init，它会自动为你创建该文件。 构建并运行 Cargo 项目在 hello_cargo 目录下，输入下面的命令来构建项目： 123$ cargo build Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo) Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.52s 这个命令会创建一个可执行文件 target/debug/hello_cargo （在 Windows 上是 target\\debug\\hello_cargo.exe），而不是放在目前目录下。由于默认的构建方法是调试构建（debug build），Cargo 会将可执行文件放在名为 debug 的目录中。可以通过这个命令运行可执行文件： 12$ ./target/debug/hello_cargo # 或者在 Windows 下为 .\\target\\debug\\hello_cargo.exeHello, world! 首次运行 cargo build 时，也会使 Cargo 在项目根目录创建一个新文件：Cargo.lock。这个文件记录项目依赖的实际版本。这个项目并没有依赖，所以其内容比较少。你永远也不需要手动编辑该文件；Cargo 会为你管理它。 我们刚刚使用 cargo build 构建了项目，并使用 ./target/debug/hello_cargo 运行了程序，也可以使用 cargo run 在一个命令中同时编译并运行生成的可执行文件： 1234$ cargo run Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs Running `target/debug/hello_cargo`Hello, world! 比起要记得运行 cargo build 之后再用可执行文件的完整路径来运行程序，使用 cargo run 更方便，所以大多数开发者会使用 cargo run。 注意这一次并没有出现表明 Cargo 正在编译 hello_cargo 的输出。Cargo 发现文件并没有被改变，所以它并没有重新构建，而是直接运行了二进制文件。如果修改了源文件的话，Cargo 会在运行之前重新构建项目。 Cargo 还提供了一个叫 cargo check 的命令。该命令快速检查代码确保其可以编译，但并不产生可执行文件： 123$ cargo check Checking hello_cargo v0.1.0 (file:///projects/hello_cargo) Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.11s 通常 cargo check 要比 cargo build 快得多，因为它省略了生成可执行文件的步骤。如果你在编写代码时持续的进行检查，cargo check 可以让你快速了解现在的代码能不能正常通过编译！为此很多 Rustaceans 编写代码时定期运行 cargo check 确保它们可以编译。当准备好使用可执行文件时才运行 cargo build。 回顾下已学习的 Cargo 内容： 可以使用 cargo new 创建项目。 可以使用 cargo build 构建项目。 可以使用 cargo run 一步构建并运行项目。 可以使用 cargo check 在不生成二进制文件的情况下构建项目来检查错误。 有别于将构建结果放在与源码相同的目录，Cargo 会将其放到 target/debug 目录。 使用 Cargo 的一个额外的优点是，不论你使用什么操作系统，其命令都是一样的。所以从现在开始本书将不再分别为 Linux 和 macOS 以及 Windows 提供相应的命令。 发布（ release ）构建当项目最终准备好发布时，可以使用 cargo build --release 来优化编译项目。这会在 target/release 而不是 target/debug 下生成可执行文件。这些优化可以让 Rust 代码运行的更快，不过启用这些优化也需要消耗更长的编译时间。这也就是为什么会有两种不同的配置：一种是为了开发，你需要快速且频繁地重新构建；另一种是为用户构建最终程序，它们不会经常重新构建，并且希望程序运行得越快越好。如果你在基准测试代码的运行时间，请确保运行 cargo build --release 并使用 target/release 下的可执行文件进行测试。 把 Cargo 当成习惯对于简单项目，Cargo 并不比 rustc 提供了更多的优势，但随着程序变得更复杂，其价值会逐渐显现。一旦程序壮大到由多个文件组成，亦或者是需要其他的依赖，让 Cargo 协调构建过程就会简单得多。 其实，要在任何已存在的项目上工作时，可以使用如下命令通过 Git 检出代码，移动到该项目目录并构建： 123$ git clone example.org/someproject$ cd someproject$ cargo build 关于更多 Cargo 的信息，请查阅 其文档 ( The Cargo Book )。 总结在本章中，你学习了如何： 使用 rustup 安装最新稳定版的 Rust 更新到新版的 Rust 打开本地安装的文档 直接通过 rustc 编写并运行 Hello, world! 程序 使用 Cargo 创建并运行新项目","link":"/2025/05/16/Rust/The%20Rust%20Programming%20Language/01.3%20Hello%20Cargo/"},{"title":"Write yourself a Git!","text":"1. Introduction本文尝试从底层开始解释 Git 版本控制系统，也就是从底至上逐步讲解。这听起来并不容易，而且他人已经尝试多次，但效果可能都不理想（ with questionable succes ）。但有一种简单的方法：要理解 Git 的内部原理，只需要从零开始重新实现 Git 即可。 不，别跑。（No, don’t run.） 这不是玩笑，而且真的并不复杂：如果你从头到尾阅读这篇文章并亲自编写代码（或者直接下载 ZIP 文件——但你真的应该自己写代码），最终你将得到一个名为 wyag 的程序，它将实现 Git 的所有基本功能：init、add、rm、status、commit、log…… 这些功能与 Git 本身完全兼容，兼容到（ compatible enough that ）在本教程中最后添加关于 commit 章节的提交，实际上是由 wyag 生成的，而不是 Git。而且，整个实现仅用 972 行 非常简单的 Python 代码完成。 但是，Git 对实现来说不是太复杂了吗？（ But isn’t Git too complex for that? ）在我看来，认为 Git 复杂是一种误解。没错，Git 确实是一个庞大的程序，功能众多，但它的核心其实非常简单。Git 之所以显得复杂，首先是（ stems first from ）因为它的工作方式通常非常反直觉（而那些“Git 是墨西哥卷饼”的博客文章可能并没有帮助）。但真正让 Git 变得令人困惑的，或许是它核心模型的极端简单性和强大性。 核心概念既简单又强大的组合（ The combination of core simplicity and powerful applications ），往往会让人难以理解，因为要从基本抽象的简单性跳跃性地推导出各种复杂应用，这种思维转换并不容易（比如单子（monads（函数式编程用语）），有人懂吗？）。 实现 Git 的过程将彻底揭示它的基本原理，让它的本质一览无遗。 我们可以期待去实现什么？本文将详细实现并解释 Git 核心命令的一个极简版本（如果有不清楚的地方，请反馈！）。我会保持代码简洁明了，因此 wyag 远远无法与真正的 Git 命令行相比——但缺失的部分将非常明显，并且对任何想尝试实现的人来说，都很容易补充。正如他们常说的：“将 wyag 升级为完整的 Git 库和 CLI是留给读者的一个练习。” 更具体地说，我们将实现： add(wyag source) git man page cat-file (wyag source) git man page check-ignore (wyag source) git man page checkout (wyag source) git man page commit (wyag source) git man page hash-object (wyag source) git man page init (wyag source) git man page log (wyag source) git man page ls-files (wyag source) git man page ls-tree (wyag source) git man page rev-parse (wyag source) git man page rm (wyag source) git man page show-ref (wyag source) git man page status (wyag source) git man page tag (wyag source) git man page 要跟上本文的内容，你并不需要太多前置知识：只需了解一些基本的 Git 指令（显然）、基本的 Python，以及基本的 Shell 知识即可。 首先，我只假设你对 Git 的基本命令 有一定的了解——不需要是专家级别，但如果你从未使用过 init、add、rm、commit 或 checkout，那你可能会感到困惑。 关于编程语言，wyag 将使用 Python 实现。同样，我不会使用任何花哨的特性，而且 Python 本身就很接近伪代码，因此会很容易理解。（讽刺的是，最复杂的部分可能是命令行参数解析逻辑，不过你其实并不需要完全理解它。）如果你有编程基础但从未接触过 Python，建议先在网上找个快速入门教程熟悉一下。 wyag 和 Git 都是终端程序，我默认你熟悉 Unix 终端 的基本操作。你不需要是个 l33t h4x0r（精英黑客，见[补充1](#1. l33t h4x0r)），但至少应该会使用 cd、ls、rm、tree 这些常见命令。 Warning Windows 用户注意：wyag 应该能在任何类 Unix 系统上运行，并且需要有 Python 解释器，但我完全不确定它在 Windows 上的表现。测试套件明确要求使用一个兼容 bash 的 shell，我假设 WSL（Windows Subsystem for Linux）可以提供这个功能。另外，如果你使用 WSL，确保你的 wyag 文件使用 Unix 风格的换行符（如果你用的是 VS Code，可以参考这个 StackOverflow 解决方案）。欢迎 Windows 用户提供反馈！ Note 致谢：本文得到了许多人重要的贡献，我对他们表示感谢。特别感谢以下几位：- GitHub 用户 tammoippen，他首次草拟了我忘记写的 tag_create 函数（那是 #9）。- GitHub 用户 hjlarry，在 #22 中修复了多个问题。- GitHub 用户 cutebbb，在 #32 中实现了 ls-files 的第一个版本，凭借此功能，wyag 最终实现了“暂存区”的奇妙功能！ 2. Getting started你将需要 Python 3.10 或更高版本，以及你喜欢的文本编辑器。我们不需要第三方包、虚拟环境或其他任何东西，除了常规的 Python 解释器：我们所需的一切都可以通过 Python 的标准库来实现。 我们会将代码分成两个文件： 一个可执行文件，名为 wyag； 一个 Python 库文件，名为 libwyag.py。 现在，每个软件项目开始时都会有一大堆模板代码，我们先把这些简单的部分搞定吧。 我们将从创建一个非常简短的可执行文件开始。在你的文本编辑器中创建一个新的文件，命名为 wyag，然后复制以下几行代码： 1234#!/usr/bin/env python3import libwyaglibwyag.main() 代码解释见[补充2](#2. code 1) 然后，使其变为可执行文件： 1$ chmod +x wyag 完成了！ 接下来是库文件的创建。它必须命名为 libwyag.py，并且与 wyag 可执行文件位于同一目录下。 开始时，打开空的 libwyag.py 文件，准备编写代码。 首先，我们需要导入一系列模块（可以逐个复制每个导入语句，或者将它们合并为一行）。 Git 是一个命令行应用程序，因此我们需要一些工具来解析命令行参数。Python 提供了一个很有用的模块叫做 argparse，它可以为我们完成 99% 的工作。 1import argparse Git 使用的配置文件格式基本上是 Microsoft 的 INI 格式。Python 的 configparser 模块可以用来读取和写入这些文件。 1import configparser 我们将进行一些日期/时间操作： 1from datetime import datetime 我们只需要一次，读取 Unix 上的用户/组数据库（grp 用于组，pwd 用于用户）。这是因为 Git 保存文件的数字所有者/组 ID，我们希望将其以文本形式友好地显示出来。 1import grp, pwd 为了支持 .gitignore，我们需要将文件名与诸如 *.txt 之类的模式进行匹配。文件名匹配在 fnmatch 模块中： 1from fnmatch import fnmatch Git 广泛使用 SHA-1 函数。在 Python 中，它位于 hashlib 模块中。 1import hashlib 仅需要从 math 模块中导入一个函数： 1from math import ceil os 和 os.path 提供了一些很好的文件系统抽象函数。 1import os 我们只使用了一些正则表达式： 1import re 我们还需要 sys 来访问实际的命令行参数（在 sys.argv 中）： 1import sys Git 使用 zlib 压缩所有内容。Python 也有这个模块： 1import zlib 导入完成。我们将频繁处理命令行参数。Python 提供了一个简单而功能强大的解析库 argparse。它是一个很好的库，但它的接口可能不是最直观的；如果有需要，可以参考它的文档。 1argparser = argparse.ArgumentParser(description=&quot;The stupidest content tracker&quot;) 我们需要处理子命令（如 git 中的 init、commit 等）。在 argparse 的术语中，这些被称为“子解析器”（subparsers）。此时，我们只需要声明我们的命令行界面（CLI）将使用一些子命令，并且所有调用实际上都需要一个子命令——你不能仅仅调用 git，你需要调用 git COMMAND。 12argsubparsers = argparser.add_subparsers(title=&quot;Commands&quot;, dest=&quot;command&quot;)argsubparsers.required = True dest=&quot;command&quot; 参数表示所选择的子解析器的名称将作为字符串返回，并存储在一个名为 command 的字段中。因此，我们只需要读取这个字符串，并根据它调用正确的函数。按照惯例，我将这些函数称为“桥接函数”，并在函数名前加上 cmd_ 前缀。桥接函数将解析后的参数作为唯一的参数，并负责在执行实际命令之前处理和验证这些参数。 12345678910111213141516171819def main(argv=sys.argv[1:]): args = argparser.parse_args(argv) match args.command: case &quot;add&quot; : cmd_add(args) case &quot;cat-file&quot; : cmd_cat_file(args) case &quot;check-ignore&quot; : cmd_check_ignore(args) case &quot;checkout&quot; : cmd_checkout(args) case &quot;commit&quot; : cmd_commit(args) case &quot;hash-object&quot; : cmd_hash_object(args) case &quot;init&quot; : cmd_init(args) case &quot;log&quot; : cmd_log(args) case &quot;ls-files&quot; : cmd_ls_files(args) case &quot;ls-tree&quot; : cmd_ls_tree(args) case &quot;rev-parse&quot; : cmd_rev_parse(args) case &quot;rm&quot; : cmd_rm(args) case &quot;show-ref&quot; : cmd_show_ref(args) case &quot;status&quot; : cmd_status(args) case &quot;tag&quot; : cmd_tag(args) case _ : print(&quot;Bad command.&quot;) 3. Creating repositories: init显然，按时间顺序和逻辑顺序，第一个 Git 命令是 git init，因此我们将从创建 wyag init 开始。为了实现这一点，我们首先需要一些非常基础的仓库抽象。 3.1. The Repository object显然，我们需要对仓库进行一些抽象：几乎每次运行 Git 命令时，我们都是在尝试对仓库做某些操作，创建它、读取它或修改它。 一个 Git 仓库由两部分组成：一个“工作树”，存放着要进行版本控制的文件；一个“git 目录”，Git 用来存储自己的数据。在大多数情况下，工作树是一个普通目录，git 目录是工作树的子目录，名为 .git。 Git 支持更多的情况（裸仓库、分离的 gitdir 等），但我们不需要考虑这些情况：我们将坚持使用工作树/ .git 的基本结构。我们的仓库对象将只包含两个路径：工作树路径和 git 目录路径。 要创建一个新的 Repository 对象，我们只需要进行几个检查： 必须验证目录是否存在，并且包含一个名为 .git 的子目录。 然后读取 .git/config 中的配置文件（它只是一个 INI 文件），并检查 core.repositoryformatversion 是否为 0。稍后会详细介绍这个字段。 我们的构造函数接受一个可选的 force 参数，用于禁用所有检查。这是因为稍后我们将创建的 repo_create() 函数会使用 Repository 对象来创建仓库。因此，我们需要一种方法，即使在（仍然）无效的文件系统位置，也能创建这样的对象。 123456789101112131415161718192021222324252627class GitRepository (object): &quot;&quot;&quot;A git repository&quot;&quot;&quot; worktree = None gitdir = None conf = None def __init__(self, path, force=False): self.worktree = path self.gitdir = os.path.join(path, &quot;.git&quot;) if not (force or os.path.isdir(self.gitdir)): raise Exception(f&quot;Not a Git repository {path}&quot;) # Read configuration file in .git/config self.conf = configparser.ConfigParser() cf = repo_file(self, &quot;config&quot;) if cf and os.path.exists(cf): self.conf.read([cf]) elif not force: raise Exception(&quot;Configuration file missing&quot;) if not force: vers = int(self.conf.get(&quot;core&quot;, &quot;repositoryformatversion&quot;)) if vers != 0: raise Exception(&quot;Unsupported repositoryformatversion: {vers}&quot;) 我们将处理仓库中的许多路径。我们不妨创建一些实用函数来计算这些路径，并在需要时创建缺失的目录结构。首先，创建一个通用的路径构建函数： 123def repo_path(repo, *path): &quot;&quot;&quot;Compute path under repo's gitdir.&quot;&quot;&quot; return os.path.join(repo.gitdir, *path) （关于 Python 语法的说明：*path 使得这个函数变为可变参数函数，因此可以将多个路径组件作为单独的参数传入。例如，repo_path(repo, &quot;objects&quot;, &quot;df&quot;, &quot;4ec9fc2ad990cb9da906a95a6eda6627d7b7b0&quot;) 是一个有效的调用。函数接收到的 path 是一个列表。） 接下来的两个函数，repo_file() 和 repo_dir()，分别返回并可选择性地创建文件或目录的路径。它们之间的区别在于，文件版本(repo_file())只会创建到最后一个组件的目录。 123456789101112131415161718192021222324def repo_file(repo, *path, mkdir=False): &quot;&quot;&quot;Same as repo_path, but create dirname(*path) if absent. Forexample, repo_file(r, \\&quot;refs\\&quot;, \\&quot;remotes\\&quot;, \\&quot;origin\\&quot;, \\&quot;HEAD\\&quot;) will create.git/refs/remotes/origin.&quot;&quot;&quot; if repo_dir(repo, *path[:-1], mkdir=mkdir): return repo_path(repo, *path)def repo_dir(repo, *path, mkdir=False): &quot;&quot;&quot;Same as repo_path, but mkdir *path if absent if mkdir.&quot;&quot;&quot; path = repo_path(repo, *path) if os.path.exists(path): if (os.path.isdir(path)): return path else: raise Exception(f&quot;Not a directory {path}&quot;) if mkdir: os.makedirs(path) return path else: return None （关于语法的第二个也是最后一个说明：由于 *path 使得函数成为可变参数函数，因此 mkdir 参数必须通过名称显式传递。例如，repo_file(repo, &quot;objects&quot;, mkdir=True)。） 要创建一个新的仓库，我们首先从一个目录开始（如果该目录不存在，我们会创建它），然后在其中创建 git 目录（该目录必须不存在或为空）。这个目录叫做 .git（前导的点使其在 Unix 系统中成为“隐藏”目录），并包含： .git/objects/：对象存储，我们将在下一节介绍。 .git/refs/：引用存储，稍后会讨论。它包含两个子目录，heads 和 tags。 .git/HEAD：当前 HEAD 的引用（稍后会详细讲解！）。 .git/config：仓库的配置文件。 .git/description：包含一个自由格式的仓库描述，供人类使用，且很少使用。 12345678910111213141516171819202122232425262728293031323334def repo_create(path): &quot;&quot;&quot;Create a new repository at path.&quot;&quot;&quot; repo = GitRepository(path, True) # First, we make sure the path either doesn't exist or is an # empty dir. if os.path.exists(repo.worktree): if not os.path.isdir(repo.worktree): raise Exception (f&quot;{path} is not a directory!&quot;) if os.path.exists(repo.gitdir) and os.listdir(repo.gitdir): raise Exception (f&quot;{path} is not empty!&quot;) else: os.makedirs(repo.worktree) assert repo_dir(repo, &quot;branches&quot;, mkdir=True) assert repo_dir(repo, &quot;objects&quot;, mkdir=True) assert repo_dir(repo, &quot;refs&quot;, &quot;tags&quot;, mkdir=True) assert repo_dir(repo, &quot;refs&quot;, &quot;heads&quot;, mkdir=True) # .git/description with open(repo_file(repo, &quot;description&quot;), &quot;w&quot;) as f: f.write(&quot;Unnamed repository; edit this file 'description' to name the repository.\\n&quot;) # .git/HEAD with open(repo_file(repo, &quot;HEAD&quot;), &quot;w&quot;) as f: f.write(&quot;ref: refs/heads/master\\n&quot;) with open(repo_file(repo, &quot;config&quot;), &quot;w&quot;) as f: config = repo_default_config() config.write(f) return repo 配置文件非常简单，它是一个类似 INI 的文件，包含一个部分（[core]）和三个字段： repositoryformatversion = 0：gitdir 格式的版本。0 表示初始格式，1 表示带扩展的相同格式。如果大于 1，Git 会 panic；wyag 只接受 0。 filemode = false：禁用在工作树中跟踪文件模式（权限）更改。 bare = false：指示该仓库有一个工作树。Git 支持一个可选的 worktree 键，用于指示工作树的位置（如果不是 ..）；wyag 不支持此功能。 我们使用 Python 的 configparser 库来创建这个文件： 123456789def repo_default_config(): ret = configparser.ConfigParser() ret.add_section(&quot;core&quot;) ret.set(&quot;core&quot;, &quot;repositoryformatversion&quot;, &quot;0&quot;) ret.set(&quot;core&quot;, &quot;filemode&quot;, &quot;false&quot;) ret.set(&quot;core&quot;, &quot;bare&quot;, &quot;false&quot;) return ret 3.2. The init command现在我们有了用于读取和创建仓库的代码，让我们通过创建 wyag init 命令来使这些代码可以从命令行使用。wyag init 的行为与 git init 完全相同——当然，自定义性要少得多。wyag init 的语法将是： 1wyag init [path] 我们已经有了完整的仓库创建逻辑。为了创建这个命令，我们只需要再添加两件事： 我们需要创建一个 argparse 子解析器来处理我们命令的参数。 1argsp = argsubparsers.add_parser(&quot;init&quot;, help=&quot;Initialize a new, empty repository.&quot;) 对于 init 命令，有一个单一的可选位置参数：初始化仓库的路径。默认为当前目录 : 123456argsp.add_argument(&quot;path&quot;, metavar=&quot;directory&quot;, nargs=&quot;?&quot;, default=&quot;.&quot;, help=&quot;Where to create the repository.&quot;) 我们还需要一个“桥接”函数，它将从 argparse 返回的对象中读取参数值，并使用正确的值调用实际的函数。 12def cmd_init(args): repo_create(args.path) 完成了！如果你按照这些步骤操作，你现在应该能够在任何地方使用 wyag init 创建一个 Git 仓库了： 1$ wyag init test （wyag 可执行文件通常不在你的 $PATH 中：你需要通过它的完整路径来调用它，例如 ~/projects/wyag/wyag init .。） 3.3. The repo_find() function在我们实现仓库功能时，我们需要一个函数来找到当前仓库的根目录。我们将频繁使用这个函数，因为几乎所有 Git 功能都需要在现有仓库上工作（当然，init 除外！）。有时根目录就是当前目录，但也可能是父目录：比如你的仓库根目录可能在 ~/Documents/MyProject，但你当前可能在 ~/Documents/MyProject/src/tui/frames/mainview/ 工作。我们现在将创建的 repo_find() 函数将从当前目录开始查找仓库根目录，并递归向上查找，直到根目录 /。要识别一个路径是否为仓库，它将检查该路径是否存在 .git 目录。 1234567891011121314151617181920def repo_find(path=&quot;.&quot;, required=True): path = os.path.realpath(path) if os.path.isdir(os.path.join(path, &quot;.git&quot;)): return GitRepository(path) # If we haven't returned, recurse in parent, if w parent = os.path.realpath(os.path.join(path, &quot;..&quot;)) if parent == path: # Bottom case # os.path.join(&quot;/&quot;, &quot;..&quot;) == &quot;/&quot;: # If parent==path, then path is root. if required: raise Exception(&quot;No git directory.&quot;) else: return None # Recursive case return repo_find(parent, required) 仓库部分完成了！ 4. Reading and writing objects: hash-object and cat-file4.1. What are objects?既然我们已经有了仓库，接下来就是往其中放东西。与此同时，仓库本身也很单调，编写 Git 实现不应该仅仅是写一堆 mkdir。让我们来谈谈对象，并实现 git hash-object 和 git cat-file。 也许你不太了解这两个命令——它们并不是 Git 日常工具箱的一部分，而且实际上是非常底层的命令（在 Git 术语中叫做“管道命令”）。它们的功能其实非常简单：hash-object 将一个现有的文件转换成一个 Git 对象，而 cat-file 将一个现有的 Git 对象打印到标准输出。 那么，什么是 Git 对象呢？从本质上来说，Git 是一个“内容寻址文件系统”。这意味着，与普通的文件系统不同，文件名是任意的，与文件内容无关，而 Git 存储的文件名是通过文件内容的数学计算得出的。这有一个非常重要的含义：如果一个文件的内容（例如文本文件）发生了一点变化，它的内部名称也会发生变化。简单来说，你在 Git 中不是修改文件，而是创建一个新文件并将其存储在一个不同的位置。Git 对象就是这样：在 Git 仓库中的文件，它们的路径由文件内容决定。 Warning Git 并不是真正的键值存储一些文档，包括优秀的 Pro Git ，将 Git 称为“键值存储”。这并不完全错误，但可能会引起误解。普通的文件系统实际上比 Git 更接近键值存储。因为 Git 是根据数据计算键，所以更准确的说法是，Git 应该被称为“值-值存储”。 Git 使用对象来存储许多内容：首先是它保持版本控制的实际文件——例如源代码。提交也是对象，标签也是。除了少数几个例外（稍后我们会看到！），在 Git 中，几乎所有的内容都是以对象的形式存储的。 Git 存储给定对象的路径是通过计算其内容的 SHA-1 哈希来确定的。更精确地说，Git 将哈希值转换为小写十六进制字符串，并将其拆分为两部分：前两位字符和其余部分。它使用前两位作为目录名，其余部分作为文件名（这是因为大多数文件系统不喜欢在单个目录中存储太多文件，否则会导致系统变慢。Git 的方法创建了 256 个可能的中间目录，从而将每个目录中的平均文件数量减少了 256 倍）。 Note 哈希函数是什么？SHA-1 就是我们所说的“哈希函数”。简单来说，哈希函数是一种单向数学函数：计算一个值的哈希值很容易，但无法反推出哪个值产生了该哈希值。一个非常简单的哈希函数例子是经典的 len（或 strlen）函数，它返回字符串的长度。计算一个字符串的长度非常容易，并且给定一个字符串，它的长度永远不会改变（当然，除非字符串本身改变！），但是仅凭长度是无法恢复原始字符串的。加密哈希函数是同样原理的更复杂版本，且具有额外的特性：计算一个输入值来产生给定哈希值的难度足够大，以至于实际上几乎不可能做到。（比如，要产生一个长度为 12 的字符串 i，你只需要随便输入 12 个字符。但对于像 SHA-1 这样的算法，需要的时间要长得多——足够长，以至于在实际中几乎不可能做到。[^1] [^1]: You may know that collisions have been discovered in SHA-1. Git actually doesn’t use SHA-1 anymore: it uses a hardened variant which is not SHA, but which applies the same hash to every known input but the two PDF files known to collide. 在我们开始实现对象存储系统之前，必须了解它们的确切存储格式。一个对象以一个头部开始，该头部指定其类型：blob、commit、tag 或 tree（稍后会详细讲解）。这个头部后面跟着一个 ASCII 空格（0x20），然后是对象大小的 ASCII 数字，接着是一个空字符（0x00），最后是对象的内容。在 Wyag 的仓库中，一个 commit 对象的前 48 个字节看起来像这样： 12300000000 63 6f 6d 6d 69 74 20 31 30 38 36 00 74 72 65 65 |commit 1086.tree|00000010 20 32 39 66 66 31 36 63 39 63 31 34 65 32 36 35 | 29ff16c9c14e265|00000020 32 62 32 32 66 38 62 37 38 62 62 30 38 61 35 61 |2b22f8b78bb08a5a| 在第一行中，我们可以看到类型头部，一个空格（0x20），大小的 ASCII 表示（1086）和 null 分隔符 0x00。第一行的最后四个字节是该对象内容的开头，单词“tree”——我们稍后会在讨论 commit 时进一步讲解。 这些对象（包括头部和内容）都是使用 zlib 压缩存储的。 4.2. A generic object object对象可以有多种类型，但它们都共享相同的存储/检索机制以及相同的通用头部格式。在深入了解各种类型的对象之前，我们需要对这些共同特性进行抽象。最简单的方法是创建一个通用的 GitObject 类，具有两个未实现的方法：serialize() 和 deserialize()，并提供一个默认的 init() 方法，用于在需要时创建一个新的空对象（抱歉，Python 用户，这不是非常好的设计，但它可能比使用超级构造器更容易理解）。我们的 __init__ 方法要么从提供的数据中加载对象，要么调用子类提供的 init() 方法来创建一个新的空对象。 稍后，我们将对子类化这个通用类，为每种对象格式实际实现这些函数。 1234567891011121314151617181920212223class GitObject (object): def __init__(self, data=None): if data != None: self.deserialize(data) else: self.init() def serialize(self, repo): &quot;&quot;&quot;This function MUST be implemented by subclasses.It must read the object's contents from self.data, a byte string, anddo whatever it takes to convert it into a meaningful representation.What exactly that means depend on each subclass. &quot;&quot;&quot; raise Exception(&quot;Unimplemented!&quot;) def deserialize(self, data): raise Exception(&quot;Unimplemented!&quot;) def init(self): pass # Just do nothing. This is a reasonable default! 4.3. Reading objects为了读取一个对象，我们需要知道它的 SHA-1 哈希值。然后，我们根据这个哈希值计算其路径（按照之前解释的公式：前两个字符，然后是目录分隔符“/”，然后是剩余部分），并在 gitdir 的“objects”目录中查找它。也就是说，e673d1b7eaa0aa01b5bc2442d570a765bdaae751 的路径是 .git/objects/e6/73d1b7eaa0aa01b5bc2442d570a765bdaae751。 接着，我们将该文件作为二进制文件读取，并使用 zlib 解压它。 从解压后的数据中，我们提取两个头部组件：对象类型和大小。通过类型，我们确定实际使用的类。我们将大小转换为 Python 整数，并进行匹配检查。 完成所有步骤后，我们只需调用该对象格式的正确构造函数。 123456789101112131415161718192021222324252627282930313233def object_read(repo, sha): &quot;&quot;&quot;Read object sha from Git repository repo. Return a GitObject whose exact type depends on the object.&quot;&quot;&quot; path = repo_file(repo, &quot;objects&quot;, sha[0:2], sha[2:]) if not os.path.isfile(path): return None with open (path, &quot;rb&quot;) as f: raw = zlib.decompress(f.read()) # Read object type x = raw.find(b' ') fmt = raw[0:x] # Read and validate object size y = raw.find(b'\\x00', x) size = int(raw[x:y].decode(&quot;ascii&quot;)) if size != len(raw)-y-1: raise Exception(f&quot;Malformed object {sha}: bad length&quot;) # Pick constructor match fmt: case b'commit' : c=GitCommit case b'tree' : c=GitTree case b'tag' : c=GitTag case b'blob' : c=GitBlob case _: raise Exception(f&quot;Unknown type {fmt.decode(&quot;ascii&quot;)} for object {sha}&quot;) # Call constructor and return object return c(raw[y+1:]) 4.4. Writing objects写入对象的过程实际上是读取过程的逆操作：我们先计算哈希值，接着添加头部，然后使用 zlib 压缩所有数据，并将结果写入正确的位置。这里不需要太多解释，值得注意的是哈希值是在添加头部后计算的（因此它是对象本身的哈希值，包括未压缩的头部，而不仅仅是内容的哈希）。 1234567891011121314151617def object_write(obj, repo=None): # Serialize object data data = obj.serialize() # Add header result = obj.fmt + b' ' + str(len(data)).encode() + b'\\x00' + data # Compute hash sha = hashlib.sha1(result).hexdigest() if repo: # Compute path path=repo_file(repo, &quot;objects&quot;, sha[0:2], sha[2:], mkdir=True) if not os.path.exists(path): with open(path, 'wb') as f: # Compress and write f.write(zlib.compress(result)) return sha 4.5. Working with blobs正如之前所说，类型头可以是四种之一：blob、commit、tag 和 tree — 因此 Git 有四种对象类型。 Blobs 是这四种类型中最简单的，因为它们没有实际的格式。Blobs 是用户数据：你放入 Git 中的每个文件（如 main.c、logo.png、README.md）的内容都作为一个 Blob 存储。这使得它们易于操作，因为除了基本的对象存储机制外，它们没有实际的语法或约束：它们只是未指定的数据。因此，创建一个 GitBlob 类是微不足道的，serialize 和 deserialize 函数只需存储和返回它们的输入，不做任何修改。 12345678class GitBlob(GitObject): fmt=b'blob' def serialize(self): return self.blobdata def deserialize(self, data): self.blobdata = data 4.6. The cat-file command我们现在可以创建 wyag cat-file 了。git cat-file 只是将对象的原始内容打印到标准输出，解压缩并去除 Git 头部信息。在 Wyag 的源代码仓库中，运行：git cat-file blob e0695f14a412c29e252c998c81de1dde59658e4a将会显示某个 README 文件的版本内容。 我们的简化版本只需要两个位置参数：一个类型和一个对象标识符。 1wyag cat-file TYPE OBJECT 子解析器非常简单： 1234567891011argsp = argsubparsers.add_parser(&quot;cat-file&quot;, help=&quot;Provide content of repository objects&quot;)argsp.add_argument(&quot;type&quot;, metavar=&quot;type&quot;, choices=[&quot;blob&quot;, &quot;commit&quot;, &quot;tag&quot;, &quot;tree&quot;], help=&quot;Specify the type&quot;)argsp.add_argument(&quot;object&quot;, metavar=&quot;object&quot;, help=&quot;The object to display&quot;) 我们可以实现这些函数，它们只是调用我们之前编写的现有代码： 1234567def cmd_cat_file(args): repo = repo_find() cat_file(repo, args.object, fmt=args.type.encode())def cat_file(repo, obj, fmt=None): obj = object_read(repo, object_find(repo, obj, fmt=fmt)) sys.stdout.buffer.write(obj.serialize()) 这个函数调用了一个尚未介绍的 object_find 函数。目前，它只是返回其中一个参数，像这样： 12def object_find(repo, name, fmt=None, follow=True): return name 之所以需要这个奇怪的小函数，是因为 Git 有许多方式来引用对象：完整哈希、短哈希、标签……object_find() 将作为我们的名称解析函数。我们稍后才会实现它，因此这里只是一个临时占位符。这意味着在实现真正的 object_find() 之前，我们只能通过完整哈希来引用对象。 4.7. The hash-object command我们希望能够将自己的数据存入仓库中。hash-object 基本上是 cat-file 的反向操作：它读取一个文件，将其计算为对象的哈希值，并在仓库中存储该对象（如果传递了 -w 标志），或者只是打印其哈希值。 wyag hash-object 的语法是 git hash-object 的简化版本： 1wyag hash-object [-w] [-t TYPE] FILE 这转换为： 123456789101112131415161718argsp = argsubparsers.add_parser( &quot;hash-object&quot;, help=&quot;Compute object ID and optionally creates a blob from a file&quot;)argsp.add_argument(&quot;-t&quot;, metavar=&quot;type&quot;, dest=&quot;type&quot;, choices=[&quot;blob&quot;, &quot;commit&quot;, &quot;tag&quot;, &quot;tree&quot;], default=&quot;blob&quot;, help=&quot;Specify the type&quot;)argsp.add_argument(&quot;-w&quot;, dest=&quot;write&quot;, action=&quot;store_true&quot;, help=&quot;Actually write the object into the database&quot;)argsp.add_argument(&quot;path&quot;, help=&quot;Read object from &lt;file&gt;&quot;) 实际实现非常简单。像往常一样，我们创建一个小的桥接函数： 123456789def cmd_hash_object(args): if args.write: repo = repo_find() else: repo = None with open(args.path, &quot;rb&quot;) as fd: sha = object_hash(fd, args.type.encode(), repo) print(sha) 实际实现也很简单。repo 参数是可选的，如果它是 None，对象就不会被写入（这一点在上面的 object_write() 中处理）： 12345678910111213def object_hash(fd, fmt, repo=None): &quot;&quot;&quot; Hash object, writing it to repo if provided.&quot;&quot;&quot; data = fd.read() # Choose constructor according to fmt argument match fmt: case b'commit' : obj=GitCommit(data) case b'tree' : obj=GitTree(data) case b'tag' : obj=GitTag(data) case b'blob' : obj=GitBlob(data) case _: raise Exception(f&quot;Unknown type {fmt}!&quot;) return object_write(obj, repo) 4.8. Aside: what about packfiles?我们刚刚实现的被称为“松散对象”（loose objects）。Git 还有另一种对象存储机制，称为 packfiles。Packfiles 比松散对象更高效，但也更复杂。简单来说，packfile 是松散对象的一个集合（类似于 tar 文件），但其中一些对象以增量（delta）的形式存储，即作为另一个对象的变体。Packfiles 过于复杂，wyag 无法支持它们。 Packfile 存储在 .git/objects/pack/ 目录下，扩展名为 .pack，并附带一个同名的索引文件，扩展名为 .idx。如果你想将 packfile 转换为松散对象格式（例如，在现有的仓库上使用 wyag），可以使用以下方法： 首先，将 packfile 移出 gitdir（仅仅复制是无效的）： 1mv .git/objects/pack/pack-d9ef004d4ca729287f12aaaacf36fee39baa7c9d.pack . 你可以忽略 .idx 文件。然后，在工作区中，只需使用 cat 命令输出 packfile 并通过管道传递给 git unpack-objects： 1cat pack-d9ef004d4ca729287f12aaaacf36fee39baa7c9d.pack | git unpack-objects 5. Reading commit history: log5.1. Parsing commits现在我们已经可以读取和写入对象，我们应该考虑提交对象。一个提交对象（未压缩且不含头部）看起来像这样： 12345678910111213141516171819202122tree 29ff16c9c14e2652b22f8b78bb08a5a07930c147parent 206941306e8a8af65b66eaaaea388a7ae24d49a0author Thibault Polge &lt;thibault@thb.lt&gt; 1527025023 +0200committer Thibault Polge &lt;thibault@thb.lt&gt; 1527025044 +0200gpgsig -----BEGIN PGP SIGNATURE----- iQIzBAABCAAdFiEExwXquOM8bWb4Q2zVGxM2FxoLkGQFAlsEjZQACgkQGxM2FxoL kGQdcBAAqPP+ln4nGDd2gETXjvOpOxLzIMEw4A9gU6CzWzm+oB8mEIKyaH0UFIPh rNUZ1j7/ZGFNeBDtT55LPdPIQw4KKlcf6kC8MPWP3qSu3xHqx12C5zyai2duFZUU wqOt9iCFCscFQYqKs3xsHI+ncQb+PGjVZA8+jPw7nrPIkeSXQV2aZb1E68wa2YIL 3eYgTUKz34cB6tAq9YwHnZpyPx8UJCZGkshpJmgtZ3mCbtQaO17LoihnqPn4UOMr V75R/7FjSuPLS8NaZF4wfi52btXMSxO/u7GuoJkzJscP3p4qtwe6Rl9dc1XC8P7k NIbGZ5Yg5cEPcfmhgXFOhQZkD0yxcJqBUcoFpnp2vu5XJl2E5I/quIyVxUXi6O6c /obspcvace4wy8uO0bdVhc4nJ+Rla4InVSJaUaBeiHTW8kReSFYyMmDCzLjGIu1q doU61OM3Zv1ptsLu3gUE6GU27iWYj2RWN3e3HE4Sbd89IFwLXNdSuM0ifDLZk7AQ WBhRhipCCgZhkj9g2NEk7jRVslti1NdN5zoQLaJNqSwO1MtxTmJ15Ksk3QP6kfLB Q52UWybBzpaP9HEd4XnR+HuQ4k2K0ns2KgNImsNvIyFwbpMUyUWLMPimaV1DWUXo 5SBjDB/V/W2JBFR+XKHFJeFwYhj7DD/ocsGr4ZMx/lgc8rjIBkI= =lgTX -----END PGP SIGNATURE-----Create first draft 该格式是 RFC 2822 规定的邮件消息的简化版本。它以一系列键值对开头，使用空格作为键和值的分隔符，并以提交消息结束，提交消息可能会跨多行。值可能会延续到多行，后续行以空格开头，解析器必须忽略这些空格（例如上面的 gpgsig 字段，它跨越了 16 行）。 让我们来看一下这些字段的含义： tree：指向一个树（tree）对象，我们将在接下来介绍它。树对象将 blob ID 映射到文件系统位置，并描述工作区的状态。简单来说，它代表了提交的实际内容：文件内容以及它们的位置。 parent：指向该提交的父提交。该字段可以重复，例如合并提交（merge commit）通常有多个父提交。但它也可能不存在，例如一个仓库中的第一个提交显然没有父提交。 author 和 committer：它们是分开的，因为提交的作者不一定是最终提交的人（对于 GitHub 用户来说，这可能并不明显，但许多项目是通过电子邮件进行 Git 操作的）。 gpgsig：该对象的 PGP 签名。 我们将从编写一个简单的解析器开始，代码很直观。我们即将创建的函数名 kvlm_parse() 可能会让人困惑：它不叫 commit_parse()，因为 tag 对象使用的是完全相同的格式，因此我们会将它用于这两种对象类型。我使用 KVLM 来表示“Key-Value List with Message”（键值列表加消息）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354def kvlm_parse(raw, start=0, dct=None): if not dct: dct = dict() # You CANNOT declare the argument as dct=dict() or all call to # the functions will endlessly grow the same dict. # This function is recursive: it reads a key/value pair, then call # itself back with the new position. So we first need to know # where we are: at a keyword, or already in the messageQ # We search for the next space and the next newline. spc = raw.find(b' ', start) nl = raw.find(b'\\n', start) # If space appears before newline, we have a keyword. Otherwise, # it's the final message, which we just read to the end of the file. # Base case # ========= # If newline appears first (or there's no space at all, in which # case find returns -1), we assume a blank line. A blank line # means the remainder of the data is the message. We store it in # the dictionary, with None as the key, and return. if (spc &lt; 0) or (nl &lt; spc): assert nl == start dct[None] = raw[start+1:] return dct # Recursive case # ============== # we read a key-value pair and recurse for the next. key = raw[start:spc] # Find the end of the value. Continuation lines begin with a # space, so we loop until we find a &quot;\\n&quot; not followed by a space. end = start while True: end = raw.find(b'\\n', end+1) if raw[end+1] != ord(' '): break # Grab the value # Also, drop the leading space on continuation lines value = raw[spc+1:end].replace(b'\\n ', b'\\n') # Don't overwrite existing data contents if key in dct: if type(dct[key]) == list: dct[key].append(value) else: dct[key] = [ dct[key], value ] else: dct[key]=value return kvlm_parse(raw, start=end+1, dct=dct) Note 对象标识规则我们使用 字典（HashMap） 来存储键/值关联，但我们依赖于 Python 字典的一个特性：它会保留插入顺序。这意味着当我们将对象写回时，我们会按字典中字段的添加顺序进行迭代，并以完全相同的顺序输出字段。这一点很重要，因为 Git 对对象标识有两个严格的规则：1. 相同的名称始终引用相同的对象我们之前已经看到过这个规则，它是 Git 计算对象名称的方法的直接结果 —— 对象的名称是其内容的哈希值。2. 相同的对象始终具有相同的名称这条规则稍微复杂一些：它意味着 不应该存在两个等效但名称不同的对象。例如，在 Git 中，如果我们更改提交对象中字段的顺序（比如将 tree 字段放在 parent 之后），那么提交对象的 SHA-1 哈希值 也会改变，从而创建出两个 等效但哈希不同 的提交对象。例如，在比较 tree 对象 时，Git 会假设 哈希不同的两个 tree 是不同的，这就是为什么在存储 tree 对象时，我们必须确保 其中的元素按正确顺序排序，以防止生成 等效但哈希不同的 tree。 我们还需要写类似的对象，因此让我们向工具包中添加一个 kvlm_serialize() 函数。这非常简单：我们先写所有的字段，然后是一个换行符，接着是消息内容，最后再是一个换行符。 12345678910111213141516171819def kvlm_serialize(kvlm): ret = b'' # Output fields for k in kvlm.keys(): # Skip the message itself if k == None: continue val = kvlm[k] # Normalize to a list if type(val) != list: val = [ val ] for v in val: ret += k + b' ' + (v.replace(b'\\n', b'\\n ')) + b'\\n' # Append message ret += b'\\n' + kvlm[None] return ret 5.2. The Commit object现在我们有了解析器，我们可以创建 GitCommit 类： 1234567891011class GitCommit(GitObject): fmt=b'commit' def deserialize(self, data): self.kvlm = kvlm_parse(data) def serialize(self): return kvlm_serialize(self.kvlm) def init(self): self.kvlm = dict() 5.3. The log command我们将实现一个比 Git 提供的版本简单得多的日志功能。最重要的是，我们不会处理日志的表示。相反，我们将输出 Graphviz 数据，让用户使用 dot 来渲染实际的日志。（如果你不知道如何使用 Graphviz，只需将原始输出粘贴到这个网站中。如果该链接无法访问，可以在你喜欢的搜索引擎中搜索“graphviz online”） 12345argsp = argsubparsers.add_parser(&quot;log&quot;, help=&quot;Display history of a given commit.&quot;)argsp.add_argument(&quot;commit&quot;, default=&quot;HEAD&quot;, nargs=&quot;?&quot;, help=&quot;Commit to start at.&quot;) 1234567891011121314151617181920212223242526272829303132333435363738def cmd_log(args): repo = repo_find() print(&quot;digraph wyaglog{&quot;) print(&quot; node[shape=rect]&quot;) log_graphviz(repo, object_find(repo, args.commit), set()) print(&quot;}&quot;)def log_graphviz(repo, sha, seen): if sha in seen: return seen.add(sha) commit = object_read(repo, sha) message = commit.kvlm[None].decode(&quot;utf8&quot;).strip() message = message.replace(&quot;\\\\&quot;, &quot;\\\\\\\\&quot;) message = message.replace(&quot;\\&quot;&quot;, &quot;\\\\\\&quot;&quot;) if &quot;\\n&quot; in message: # Keep only the first line message = message[:message.index(&quot;\\n&quot;)] print(f&quot; c_{sha} [label=\\&quot;{sha[0:7]}: {message}\\&quot;]&quot;) assert commit.fmt==b'commit' if not b'parent' in commit.kvlm.keys(): # Base case: the initial commit. return parents = commit.kvlm[b'parent'] if type(parents) != list: parents = [ parents ] for p in parents: p = p.decode(&quot;ascii&quot;) print (f&quot; c_{sha} -&gt; c_{p};&quot;) log_graphviz(repo, p, seen) 你现在可以像这样使用我们的 log 命令： 12wyag log e03158242ecab460f31b0d6ae1642880577ccbe8 &gt; log.dotdot -O -Tpdf log.dot 5.4. Anatomy of a commit你现在可能注意到了一些事情。 首先也是最重要的一点，我们一直在处理提交，浏览和遍历提交对象，构建提交历史的图形，而从未触及工作树中的任何文件或 Blob。我们做了很多关于提交的事情，但没有考虑它们的内容。这一点很重要：工作树的内容只是提交的一部分。但一个提交由它所包含的一切组成：它的内容、它的作者，还有它的父提交。如果你记得提交的 ID（SHA-1 哈希）是从整个提交对象计算出来的，你就会明白为什么提交是不可变的：如果你更改了作者、父提交或单个文件，你实际上创建了一个新的、不同的对象。每一个提交都与其所在的位置及其与整个仓库的关系绑定，直到第一个提交。换句话说，一个给定的提交 ID 不仅标识了一些文件内容，它还将提交与其完整的历史和整个仓库绑定在一起。 还值得注意的是，从提交的角度来看，时间似乎是倒流的：我们通常是从项目的谦逊起步开始考虑历史，最初可能是作为一种消磨时间的活动，开始时只有几行代码，一些初步的提交，随后逐渐发展到现在的状态（成千上万行代码，几十个贡献者等等）。但是每个提交完全不知未来的情况，它只与过去相连接。提交有“记忆”，但没有预感。 那么，是什么构成了一个提交呢？总结一下： 一个树对象，即工作树的内容，文件和目录； 零个、一个或多个父提交； 一个作者身份（姓名和电子邮件），以及一个时间戳； 一个提交者身份（姓名和电子邮件），以及一个时间戳； 一个可选的 PGP 签名； 一条消息； 所有这些内容哈希在一起，生成一个唯一的 SHA-1 标识符。 Note 等一下，这是否意味着 Git 是区块链？因为加密货币的原因，区块链现在非常火。确实，在某种程度上，Git 可以被视为一个区块链：它是一系列由加密手段连接在一起的区块（提交），以确保每一个元素都与整个历史关联起来。不过，不必太认真地对比这两者：我们不需要 GitCoin，真的。 6. Reading commit data: checkout虽然提交包含了比文件和目录更丰富的信息，但这并不意味着它们就很有用。现在可能是时候开始实现树对象了，这样我们才能将提交检出到工作树中。 6.1. What’s in a tree?非正式地说，树描述了工作树的内容，也就是说，它将 blobs 与路径关联起来。它是由三元组组成的数组，每个三元组包含一个文件模式、一个路径（相对于工作树）和一个 SHA-1。一个典型的树内容可能如下所示： Mode SHA-1 Path 100644 894a44cc066a027465cd26d634948d56d13af9af .gitignore 100644 94a9ed024d3859793618152ea559a168bbcbb5e2 LICENSE 100644 bab489c4f4600a38ce6dbfd652b90383a4aa3e45 README.md 100644 6d208e47659a2a10f5f8640e0155d9276a2130a9 src 040000 e7445b03aea61ec801b20d6ab62f076208b7d097 tests 040000 d5ec863f17f3a2e92aa8f6b66ac18f7b09fd1b38 main.c 模式只是文件的模式，路径是其位置。SHA-1 引用的是 blob 或另一个树对象。如果是 blob，路径是文件；如果是树，它是目录。为了在文件系统中实例化这棵树，我们将从加载与第一个路径（.gitignore）相关的对象开始，并检查它的类型。由于它是一个 blob，我们将创建一个名为 .gitignore 的文件，并填充该 blob 的内容；LICENSE 和 README.md 也按同样的方法处理。但是与 src 相关联的对象不是一个 blob，而是另一棵树：我们将创建目录 src，并在该目录中对新的树重复相同的操作。 Warning 路径是一个单一的文件系统条目路径准确地标识一个文件或目录。不是两个，也不是三个。如果你有五级嵌套的目录，即使其中四个除了下一个目录外都是空的，你也需要五个树对象，递归地相互引用。你不能通过将一个完整的路径放在单个树条目中来走捷径，比如 dir1/dir2/dir3/dir4/dir5。 6.2. Parsing trees与标签和提交不同，树对象是二进制对象，但它们的格式实际上非常简单。一个树是由以下格式的记录连接而成： 1[mode] space [path] 0x00 [sha-1] [mode] 是最多六个字节，是文件模式的八进制表示，以 ASCII 存储。例如，100644 使用字节值 49（ASCII “1”），48（ASCII “0”），48，54，52，54 来编码。前两位数字编码文件类型（文件、目录、符号链接或子模块），最后四位是权限。 它后面跟着 0x20，一个 ASCII 空格； 接下来是以 null 终止的（0x00）路径； 然后是对象的 SHA-1，以二进制编码，长度为 20 字节。 解析器将非常简单。首先，为单个记录（叶子，单个路径）创建一个小的对象封装器： 12345class GitTreeLeaf (object): def __init__(self, mode, path, sha): self.mode = mode self.path = path self.sha = sha 因为树对象只是相同基本数据结构的重复，我们将解析器写成两个函数。首先，编写一个解析单个记录的函数，返回解析的数据和它在输入数据中到达的位置： 12345678910111213141516171819202122def tree_parse_one(raw, start=0): # Find the space terminator of the mode x = raw.find(b' ', start) assert x-start == 5 or x-start==6 # Read the mode mode = raw[start:x] if len(mode) == 5: # Normalize to six bytes. mode = b&quot;0&quot; + mode # Find the NULL terminator of the path y = raw.find(b'\\x00', x) # and read the path path = raw[x+1:y] # Read the SHA… raw_sha = int.from_bytes(raw[y+1:y+21], &quot;big&quot;) # and convert it into an hex string, padded to 40 chars # with zeros if needed. sha = format(raw_sha, &quot;040x&quot;) return y+21, GitTreeLeaf(mode, path.decode(&quot;utf8&quot;), sha) 然后是“真正的”解析器，它只是循环调用前一个解析器，直到输入数据耗尽。 123456789def tree_parse(raw): pos = 0 max = len(raw) ret = list() while pos &lt; max: pos, data = tree_parse_one(raw, pos) ret.append(data) return ret 最终，我们需要一个序列化器来将树对象写回去。由于我们可能已经添加或修改了条目，因此需要对它们重新排序。保持一致的排序很重要，因为我们需要遵守 Git 的身份规则，该规则规定不能有两个等效的对象具有不同的哈希值——但是如果相同内容的树对象排序不同，它们仍然是等效的（描述相同的目录结构），但在数值上是不同的（不同的 SHA-1 标识符）。不正确排序的树对象是无效的，但 Git 并不会强制执行这一点。我在编写 wyag 时意外创建了一些无效的树对象，结果导致 Git 状态显示奇怪的错误（具体来说，git status 会报告一个实际上是干净的工作区被完全修改）。我们不希望发生这种情况。 排序函数非常简单，但有一个意想不到的细节。条目是按名称按字母顺序排序的，但目录（即树对象的条目）会在末尾添加一个 / 进行排序。这一点很重要，因为这意味着如果 whatever 是一个普通文件，它将在 whatever.c 之前排序，但如果 whatever 是一个目录，它将作为 whatever/ 排序在后。（我不确定 Git 为什么这样做。如果你感兴趣，可以查看 Git 源码中 tree.c 文件里的 base_name_compare 函数。） 12345678910# Notice this isn't a comparison function, but a conversion function.# Python's default sort doesn't accept a custom comparison function,# like in most languages, but a `key` arguments that returns a new# value, which is compared using the default rules. So we just return# the leaf name, with an extra / if it's a directory.def tree_leaf_sort_key(leaf): if leaf.mode.startswith(b&quot;10&quot;): return leaf.path else: return leaf.path + &quot;/&quot; 然后是序列化器本身。这部分非常简单：我们使用新创建的转换函数对项进行排序，然后按顺序写入。 1234567891011def tree_serialize(obj): obj.items.sort(key=tree_leaf_sort_key) ret = b'' for i in obj.items: ret += i.mode ret += b' ' ret += i.path.encode(&quot;utf8&quot;) ret += b'\\x00' sha = int(i.sha, 16) ret += sha.to_bytes(20, byteorder=&quot;big&quot;) return ret 现在，我们只需要将所有内容组合到一个类中即可。 1234567891011class GitTree(GitObject): fmt=b'tree' def deserialize(self, data): self.items = tree_parse(data) def serialize(self): return tree_serialize(self) def init(self): self.items = list() 6.3. Showing trees: ls-tree既然如此，我们顺便给 wyag 添加 ls-tree 命令吧。这么简单的功能，没有理由不加。git ls-tree [-r] TREE 只是打印树的内容，带 -r 标志时会递归打印。在递归模式下，它不会显示子树，而是仅显示最终对象及其完整路径。 123456789101112131415161718192021222324252627282930313233argsp = argsubparsers.add_parser(&quot;ls-tree&quot;, help=&quot;Pretty-print a tree object.&quot;)argsp.add_argument(&quot;-r&quot;, dest=&quot;recursive&quot;, action=&quot;store_true&quot;, help=&quot;Recurse into sub-trees&quot;)argsp.add_argument(&quot;tree&quot;, help=&quot;A tree-ish object.&quot;)def cmd_ls_tree(args): repo = repo_find() ls_tree(repo, args.tree, args.recursive)def ls_tree(repo, ref, recursive=None, prefix=&quot;&quot;): sha = object_find(repo, ref, fmt=b&quot;tree&quot;) obj = object_read(repo, sha) for item in obj.items: if len(item.mode) == 5: type = item.mode[0:1] else: type = item.mode[0:2] match type: # Determine the type. case b'04': type = &quot;tree&quot; case b'10': type = &quot;blob&quot; # A regular file. case b'12': type = &quot;blob&quot; # A symlink. Blob contents is link target. case b'16': type = &quot;commit&quot; # A submodule case _: raise Exception(f&quot;Weird tree leaf mode {item.mode}&quot;) if not (recursive and type=='tree'): # This is a leaf print(f&quot;{'0' * (6 - len(item.mode)) + item.mode.decode(&quot;ascii&quot;)} {type} {item.sha}\\t{os.path.join(prefix, item.path)}&quot;) else: # This is a branch, recurse ls_tree(repo, item.sha, recursive, os.path.join(prefix, item.path)) 6.4. The checkout commandgit checkout 只是将某个提交实例化到工作区。为了让我们的实现清晰易懂，我们将对实际的 git checkout 命令进行简化，同时添加一些安全措施。我们的 checkout 版本将按以下方式工作： 它需要两个参数：一个提交（commit）和一个目录（directory）。Git 的 checkout 命令只需要一个提交。 它会在指定目录中实例化该提交的树，但仅当该目录为空时才进行操作。Git 具有许多安全机制来防止数据丢失，而在 wyag 中尝试完全复现这些机制既复杂又不安全。由于 wyag 的目的是演示 Git，而不是提供完整的实现，这一限制是可以接受的。 让我们开始实现。如往常一样，我们需要一个子解析器（subparser）： 1234567argsp = argsubparsers.add_parser(&quot;checkout&quot;, help=&quot;Checkout a commit inside of a directory.&quot;)argsp.add_argument(&quot;commit&quot;, help=&quot;The commit or tree to checkout.&quot;)argsp.add_argument(&quot;path&quot;, help=&quot;The EMPTY directory to checkout on.&quot;) 一个包装函数（wrapper function）： 12345678910111213141516171819def cmd_checkout(args): repo = repo_find() obj = object_read(repo, object_find(repo, args.commit)) # If the object is a commit, we grab its tree if obj.fmt == b'commit': obj = object_read(repo, obj.kvlm[b'tree'].decode(&quot;ascii&quot;)) # Verify that path is an empty directory if os.path.exists(args.path): if not os.path.isdir(args.path): raise Exception(f&quot;Not a directory {args.path}!&quot;) if os.listdir(args.path): raise Exception(f&quot;Not empty {args.path}!&quot;) else: os.makedirs(args.path) tree_checkout(repo, obj, os.path.realpath(args.path)) 以及一个执行实际工作的函数： 123456789101112def tree_checkout(repo, tree, path): for item in tree.items: obj = object_read(repo, item.sha) dest = os.path.join(path, item.path) if obj.fmt == b'tree': os.mkdir(dest) tree_checkout(repo, obj, dest) elif obj.fmt == b'blob': # @TODO Support symlinks (identified by mode 12****) with open(dest, 'wb') as f: f.write(obj.blobdata) 7. Refs, tags and branches7.1. What a ref is, and the show-ref command到目前为止，我们唯一可以引用对象的方式是使用完整的十六进制标识符。然而，在 git 中，我们实际上很少看到这些标识符，除了在讨论特定提交时。通常，我们会使用 HEAD，或者某个名为 main 或 feature/more-bombs 的分支名称等。这是通过一个简单的机制——引用（references）来处理的。 Git 引用（refs）可能是 git 存储的最简单的内容。它们位于 .git/refs 的子目录中，并且是包含对象哈希值的文本文件，使用 ASCII 编码。它们实际上就是这样简单： 16071c08bcb4757d8c89a30d9755d2466cef8c1de 引用（Refs）也可以间接地引用对象，即引用另一个引用，在这种情况下，它们看起来像这样： 1ref: refs/remotes/origin/master Note 直接和间接引用从现在开始，我将把形式为 ref: path/to/other/ref 的引用称为间接引用，而把包含 SHA-1 对象 ID 的引用称为直接引用。 这一部分将描述引用（refs）的用途。目前，最重要的是： 它们是文本文件，位于 .git/refs 目录结构中； 它们保存一个对象的 SHA-1 标识符，或者引用另一个引用，最终指向一个 SHA-1（没有循环！） 为了操作引用，我们首先需要一个简单的递归解析器，它将接受一个引用名称，跟踪可能存在的递归引用（即以 ref: 开头的引用，如上所示），并返回最终的 SHA-1 标识符： 123456789101112131415161718def ref_resolve(repo, ref): path = repo_file(repo, ref) # Sometimes, an indirect reference may be broken. This is normal # in one specific case: we're looking for HEAD on a new repository # with no commits. In that case, .git/HEAD points to &quot;ref: # refs/heads/main&quot;, but .git/refs/heads/main doesn't exist yet # (since there's no commit for it to refer to). if not os.path.isfile(path): return None with open(path, 'r') as fp: data = fp.read()[:-1] # Drop final \\n ^^^^^ if data.startswith(&quot;ref: &quot;): return ref_resolve(repo, data[5:]) else: return data 让我们创建两个小函数，并实现 show-refs 命令——它仅列出仓库中的所有引用。首先，创建一个简单的递归函数来收集引用，并将它们作为字典返回： 1234567891011121314def ref_list(repo, path=None): if not path: path = repo_dir(repo, &quot;refs&quot;) ret = dict() # Git shows refs sorted. To do the same, we sort the output of # listdir for f in sorted(os.listdir(path)): can = os.path.join(path, f) if os.path.isdir(can): ret[f] = ref_list(repo, can) else: ret[f] = ref_resolve(repo, can) return ret 以及，像往常一样，一个子解析器，一个桥接函数和一个（递归）工作函数： 1234567891011121314151617argsp = argsubparsers.add_parser(&quot;show-ref&quot;, help=&quot;List references.&quot;)def cmd_show_ref(args): repo = repo_find() refs = ref_list(repo) show_ref(repo, refs, prefix=&quot;refs&quot;)def show_ref(repo, refs, with_hash=True, prefix=&quot;&quot;): if prefix: prefix = prefix + '/' for k, v in refs.items(): if type(v) == str and with_hash: print (f&quot;{v} {prefix}{k}&quot;) elif type(v) == str: print (f&quot;{prefix}{k}&quot;) else: show_ref(repo, v, with_hash=with_hash, prefix=f&quot;{prefix}{k}&quot;) 7.2. Tags as referencesrefs的最简单用途是标签。标签只是一个用户定义的对象名称，通常是一个提交。标签的一个非常常见的用途是标识软件版本：例如，您刚刚合并了程序的版本12.78.52的最后一个提交，所以您最近的提交（我们称之为6071c08）就是您的版本12.78.52。为了使这种关联显式化，您只需要这样做： 12git tag v12.78.52 6071c08# the object hash ^here^^ is optional and defaults to HEAD. 这会创建一个新的标签，叫做 v12.78.52，指向 6071c08。标签就像别名：标签为现有对象引入了一种新的引用方式。标签创建之后，v12.78.52 这个名称就指向了 6071c08。例如，下面这两个命令现在是完全等价的： 12git checkout v12.78.52git checkout 6071c08 Note 版本是标签的一个常见用途，但像 Git 中几乎所有东西一样，标签没有预定义的语义：它们的意义由你决定，并且可以指向你想指向的任何对象，甚至可以为 blobs 打标签！ 7.3. Lightweight tags and tag objects, and parsing the latter你可能已经猜到了，标签实际上就是 refs。它们位于 .git/refs/tags/ 层级。唯一需要注意的地方是，它们有两种类型：轻量标签和标签对象。 “轻量级”标签只是指向提交、树或 Blob 的常规 refs。 标签对象是指向类型为 tag 的对象的常规 refs。与轻量标签不同，标签对象具有作者、日期、可选的 PGP 签名和可选的注释。它们的格式与提交对象相同。 我们甚至不需要实现标签对象，可以重用 GitCommit 类，只需更改 fmt 字段即可。 12class GitTag(GitCommit): fmt = b'tag' 现在我们支持标签了。 7.4. The tag command让我们添加 tag 命令。在 Git 中，它做两件事：创建一个新的标签或列出现有标签（默认情况下）。所以你可以用以下方式调用它： 12345git tag # List all tagsgit tag NAME [OBJECT] # create a new *lightweight* tag NAME, pointing # at HEAD (default) or OBJECTgit tag -a NAME [OBJECT] # create a new tag *object* NAME, pointing at # HEAD (default) or OBJECT 这在 argparse 中的实现如下。请注意，我们忽略了 --list 和 [-a] name [object] 之间的互斥关系，因为对于 argparse 来说，这看起来太复杂了。 1234567891011121314151617argsp = argsubparsers.add_parser( &quot;tag&quot;, help=&quot;List and create tags&quot;)argsp.add_argument(&quot;-a&quot;, action=&quot;store_true&quot;, dest=&quot;create_tag_object&quot;, help=&quot;Whether to create a tag object&quot;)argsp.add_argument(&quot;name&quot;, nargs=&quot;?&quot;, help=&quot;The new tag's name&quot;)argsp.add_argument(&quot;object&quot;, default=&quot;HEAD&quot;, nargs=&quot;?&quot;, help=&quot;The object the new tag will point to&quot;) cmd_tag 函数将根据是否提供了 name 来分派行为（列出或创建）。 1234567891011def cmd_tag(args): repo = repo_find() if args.name: tag_create(repo, args.name, args.object, create_tag_object = args.create_tag_object) else: refs = ref_list(repo) show_ref(repo, refs[&quot;tags&quot;], with_hash=False) 我们只需要一个函数来实际创建标签： 1234567891011121314151617181920212223242526def tag_create(repo, name, ref, create_tag_object=False): # get the GitObject from the object reference sha = object_find(repo, ref) if create_tag_object: # create tag object (commit) tag = GitTag() tag.kvlm = dict() tag.kvlm[b'object'] = sha.encode() tag.kvlm[b'type'] = b'commit' tag.kvlm[b'tag'] = name.encode() # Feel free to let the user give their name! # Notice you can fix this after commit, read on! tag.kvlm[b'tagger'] = b'Wyag &lt;wyag@example.com&gt;' # …and a tag message! tag.kvlm[None] = b&quot;A tag generated by wyag, which won't let you customize the message!\\n&quot; tag_sha = object_write(tag, repo) # create reference ref_create(repo, &quot;tags/&quot; + name, tag_sha) else: # create lightweight tag (ref) ref_create(repo, &quot;tags/&quot; + name, sha)def ref_create(repo, ref_name, sha): with open(repo_file(repo, &quot;refs/&quot; + ref_name), 'w') as fp: fp.write(sha + &quot;\\n&quot;) 7.5. What’s a branch?标签已完成，现在是另一个大块内容：分支。 是时候处理问题了：像大多数 Git 用户一样，wyag 仍然没有任何关于分支的概念。它目前将一个仓库视为一堆杂乱无章的对象，其中一些是提交对象，而完全没有表示提交是如何在分支中组织的，也没有表示在任何时候都有一个提交是 HEAD，即活跃分支的头部提交（或“尖端”）。 那么，什么是分支呢？答案其实出奇地简单，但也可能让人惊讶：分支就是对某个提交的引用。你甚至可以说分支是对某个提交的别名。在这方面，分支和标签完全一样。标签是引用，存在于 .git/refs/tags 中，而分支是引用，存在于 .git/refs/heads 中。 当然，分支和标签之间是有区别的： 分支是对一个提交的引用，标签可以引用任何对象； 最重要的是，分支引用在每次提交时会被更新。这意味着每当你提交时，Git 实际上会执行以下操作： 创建一个新的提交对象，当前分支的提交 ID 作为其父提交； 提交对象被哈希并存储； 分支引用被更新，指向新提交的哈希值。 仅此而已。 但当前分支又是什么呢？实际上，它更简单。它是一个位于 refs 层级外的引用文件，存在于 .git/HEAD 中，它是一个间接引用（即它是类似 ref: path/to/other/ref 的形式，而不是简单的哈希值）。 Note 分离的 HEAD当你仅仅检出一个随机的提交时，Git 会警告你它处于“分离的 HEAD 状态”。这意味着你不再处于任何分支上。在这种情况下，.git/HEAD 是一个直接引用：它包含一个 SHA-1 值。 7.6. Referring to objects: the object_find function7.6.1. Resolving names记得我们创建的 [愚蠢的 object_find 函数](#4.6. The cat-file command) 吗？它接受四个参数，返回第二个参数不变，并忽略其他三个参数。现在是时候用一个更有用的函数来替换它了。我们将实现 Git 名称解析算法的一个小而实用的子集。新的 object_find() 将分为两步：首先，给定一个名称，它将返回一个完整的 sha-1 哈希。例如，对于 HEAD，它将返回当前分支的头部提交的哈希，等等。更精确地说，这个名称解析函数将按以下方式工作： 如果名称是 HEAD，它将解析为 .git/HEAD； 如果名称是完整的哈希，则直接返回该哈希； 如果名称看起来像是短哈希，它将收集所有完整哈希以该短哈希为前缀的对象； 最后，它将解析与名称匹配的标签和分支。 请注意，最后两步是收集值：前两步是绝对引用，因此我们可以安全地返回结果。但短哈希或分支名称可能是模糊的，我们希望列举出所有可能的含义，并在找到多个结果时抛出错误。 短哈希为了方便，Git 允许通过哈希值的前缀来引用哈希。例如，5bd254aa973646fa16f66d702a5826ea14a3eb45 可以简称为 5bd254。这被称为“短哈希”。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647def object_resolve(repo, name): &quot;&quot;&quot;Resolve name to an object hash in repo.This function is aware of: - the HEAD literal - short and long hashes - tags - branches - remote branches&quot;&quot;&quot; candidates = list() hashRE = re.compile(r&quot;^[0-9A-Fa-f]{4,40}$&quot;) # Empty string? Abort. if not name.strip(): return None # Head is nonambiguous if name == &quot;HEAD&quot;: return [ ref_resolve(repo, &quot;HEAD&quot;) ] # If it's a hex string, try for a hash. if hashRE.match(name): # This may be a hash, either small or full. 4 seems to be the # minimal length for git to consider something a short hash. # This limit is documented in man git-rev-parse name = name.lower() prefix = name[0:2] path = repo_dir(repo, &quot;objects&quot;, prefix, mkdir=False) if path: rem = name[2:] for f in os.listdir(path): if f.startswith(rem): # Notice a string startswith() itself, so this # works for full hashes. candidates.append(prefix + f) # Try for references. as_tag = ref_resolve(repo, &quot;refs/tags/&quot; + name) if as_tag: # Did we find a tag? candidates.append(as_tag) as_branch = ref_resolve(repo, &quot;refs/heads/&quot; + name) if as_branch: # Did we find a branch? candidates.append(as_branch) return candidates 第二步是，如果提供了类型参数，我们将找到的对象跟踪到所需类型的对象。这是一个非常简单的迭代过程，因为我们只需要处理简单的情况： 如果我们有一个标签，并且 fmt 不是我们期望的类型（例如 commit 或其他），则我们跟踪该标签。 如果我们有一个 commit 并且 fmt 是 tree，则返回该 commit 的树对象。 在所有其他情况下，我们中止操作：因为没有其他合理的情况需要处理。 这个过程是迭代的，因为它可能需要不确定的步骤，原因在于标签本身也可以被标记。这意味着如果一个标签指向另一个标签，我们需要继续解析，直到最终找到一个直接指向某个对象（如 commit 或 tree）的标签。这个递归过程确保我们能够跟踪所有引用，直到找到所需类型的对象。 12345678910111213141516171819202122232425262728293031323334def object_find(repo, name, fmt=None, follow=True): sha = object_resolve(repo, name) if not sha: raise Exception(f&quot;No such reference {name}.&quot;) if len(sha) &gt; 1: raise Exception(&quot;Ambiguous reference {name}: Candidates are:\\n - {'\\n - '.join(sha)}.&quot;) sha = sha[0] if not fmt: return sha while True: obj = object_read(repo, sha) # ^^^^^^^^^^^ &lt; this is a bit agressive: we're reading # the full object just to get its type. And we're doing # that in a loop, albeit normally short. Don't expect # high performance here. if obj.fmt == fmt: return sha if not follow: return None # Follow tags if obj.fmt == b'tag': sha = obj.kvlm[b'object'].decode(&quot;ascii&quot;) elif obj.fmt == b'commit' and fmt == b'tree': sha = obj.kvlm[b'tree'].decode(&quot;ascii&quot;) else: return None 通过新的 object_find() 函数，CLI wyag 变得更加易用。你现在可以执行以下操作： 123456$ wyag checkout v3.11 # A tag$ wyag checkout feature/explosions # A branch$ wyag ls-tree -r HEAD # The active branch or commit. There's also a # follow here: HEAD is actually a commit.$ wyag cat-file blob e0695f # A short hash$ wyag cat-file tree master # A branch, as a tree (another &quot;follow&quot;) 7.6.2. The rev-parse command让我们实现 wyag rev-parse。git rev-parse 命令的功能很多，但我们要克隆的用例之一是解析引用。为了进一步测试 object_find 的“跟随”功能，我们将在其接口中添加一个可选的 wyag-type 参数。 12345678910111213argsp = argsubparsers.add_parser( &quot;rev-parse&quot;, help=&quot;Parse revision (or other objects) identifiers&quot;)argsp.add_argument(&quot;--wyag-type&quot;, metavar=&quot;type&quot;, dest=&quot;type&quot;, choices=[&quot;blob&quot;, &quot;commit&quot;, &quot;tag&quot;, &quot;tree&quot;], default=None, help=&quot;Specify the expected type&quot;)argsp.add_argument(&quot;name&quot;, help=&quot;The name to parse&quot;) 桥接函数完成所有工作： 123456789def cmd_rev_parse(args): if args.type: fmt = args.type.encode() else: fmt = None repo = repo_find() print (object_find(repo, args.name, fmt, follow=True)) 并且它可以正常运行： 123456$ wyag rev-parse --wyag-type commit HEAD6c22393f5e3830d15395fd8d2f8b0cf8eb40dd58$ wyag rev-parse --wyag-type tree HEAD11d33fad71dbac72840aff1447e0d080c7484361$ wyag rev-parse --wyag-type tag HEADNone 8. Working with the staging area and the index file8.1. What’s the index file?这最后一步将带我们进入提交的过程（尽管实际创建提交的部分将在下一节进行！）。 你可能知道，在 Git 中进行提交之前，首先需要使用 git add 和 git rm 来“暂存”一些更改，然后才能执行提交。这种介于上一次提交和下一次提交之间的中间状态被称为 暂存区（staging area）。 看起来用提交对象（commit object）或树对象（tree object）来表示暂存区似乎是合乎逻辑的，但 Git 实际上使用了一种完全不同的机制，即所谓的 索引文件（index file）。 在一次提交之后，索引文件可以看作是该提交的一种副本：它存储了与对应树相同的“路径-Blob”关联信息。但除此之外，它还保存了工作区文件的额外信息，比如文件的创建/修改时间，因此 git status 通常不需要实际对比文件内容，而是仅检查文件的修改时间是否与索引文件中存储的时间相同，只有当两者不匹配时，它才会进行真正的内容比较。 因此，你可以将索引文件视为一个 三方关联表（three-way association list）：不仅包含路径与 Blob 的映射关系，还包含路径与实际文件系统条目的映射关系。 索引文件的另一个重要特点是：它可以表示不一致的状态，比如合并冲突，而树对象总是完整且明确的表示一个文件系统状态。 当你执行提交（commit）时，Git 实际上会将索引文件转换为一个新的 树对象（tree object）。总结如下： 当仓库处于“干净”状态（即没有未提交的更改）时，索引文件的内容与 HEAD 指向的提交完全相同，同时还包含关于对应文件系统条目的元数据。例如，它可能包含如下信息： 1There’s a file called src/disp.c whose contents are blob 797441c76e59e28794458b39b0f1eff4c85f4fa0. The real src/disp.c file, in the worktree, was created on 2023-07-15 15:28:29.168572151, and last modified 2023-07-15 15:28:29.1689427709. It is stored on device 65026, inode 8922881. 当你执行 git add 或 git rm 时，索引文件会相应地被修改。在上面的示例中，如果你修改了 src/disp.c 并添加你的更改，索引文件将使用新的 blob ID 进行更新（当然，blob 本身也会在此过程中被创建），并且各种文件元数据也会被更新，以便 git status 知道何时不需要比较文件内容。 当你 git commit 这些更改时，一个新的树对象将从索引文件中生成，一个新的提交对象将使用该树创建，分支将被更新，然后操作完成。 Note 关于术语的说明暂存区（staging area）和索引（index）实际上是同一回事，但“暂存区”更侧重于 Git 面向用户的功能名称（这一功能本可以通过其他方式实现），可以理解为一种抽象概念；而“索引文件”（index file）则特指 Git 实际实现该抽象功能的方式。 8.2. Parsing the index索引文件是 Git 仓库中最复杂的数据结构。其完整文档可以在 Git 源代码树的 Documentation/gitformat-index.txt 中找到，你也可以在 GitHub 镜像上浏览。索引文件由三部分组成： 一个包含格式版本号和索引中条目数量的头部； 一系列按排序存储的条目，每个条目代表一个文件，并填充至 8 字节的倍数； 一系列可选扩展，我们将在此忽略。 我们需要表示的第一个部分是一个条目。它实际上包含了很多信息，我会在注释中留下详细说明。值得注意的是，一个条目存储了与其关联的 blob 的 SHA-1 值，以及关于实际文件在实际文件系统上的大量元数据。再次强调，这是因为 git/wyag status 需要确定索引中哪些文件已经被修改：最有效的做法是先检查最后修改的时间戳，并将其与已知值进行比较，而不是直接比较文件内容。 1234567891011121314151617181920212223242526272829303132class GitIndexEntry (object): def __init__(self, ctime=None, mtime=None, dev=None, ino=None, mode_type=None, mode_perms=None, uid=None, gid=None, fsize=None, sha=None, flag_assume_valid=None, flag_stage=None, name=None): # The last time a file's metadata changed. This is a pair # (timestamp in seconds, nanoseconds) self.ctime = ctime # The last time a file's data changed. This is a pair # (timestamp in seconds, nanoseconds) self.mtime = mtime # The ID of device containing this file self.dev = dev # The file's inode number self.ino = ino # The object type, either b1000 (regular), b1010 (symlink), # b1110 (gitlink). self.mode_type = mode_type # The object permissions, an integer. self.mode_perms = mode_perms # User ID of owner self.uid = uid # Group ID of ownner self.gid = gid # Size of this object, in bytes self.fsize = fsize # The object's SHA self.sha = sha self.flag_assume_valid = flag_assume_valid self.flag_stage = flag_stage # Name of the object (full path this time!) self.name = name 索引文件是一个二进制文件，可能是出于性能原因。不过格式相对简单。它以一个包含 DIRC 魔术字节、版本号和索引文件中条目总数的头部开始。我们创建 GitIndex 类来存储这些内容： 123456789101112class GitIndex (object): version = None entries = [] # ext = None # sha = None def __init__(self, version=2, entries=None): if not entries: entries = list() self.version = version self.entries = entries 并且我们需要一个解析器，将索引文件读入这些对象。在读取完 12 字节的头部后，我们按照出现顺序解析条目。每个条目以一组固定长度的数据开头，后面跟着一个可变长度的文件名。 这段代码相当直接，但由于它在读取二进制格式，它比我们之前的代码稍显杂乱。我们频繁使用 int.from_bytes(bytes, endianness) 来将原始字节转换成整数，并且进行少量的位运算来分离共享同一字节的数据。 （这种格式可能是为了让索引文件能够直接映射到内存（mmapp()），并像 C 结构体一样直接读取，通常在大多数情况下构建索引的时间复杂度为 O(n)。这种方法在 C 中往往能产生比 Python 更优雅的代码……） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108def index_read(repo): index_file = repo_file(repo, &quot;index&quot;) # New repositories have no index! if not os.path.exists(index_file): return GitIndex() with open(index_file, 'rb') as f: raw = f.read() header = raw[:12] signature = header[:4] assert signature == b&quot;DIRC&quot; # Stands for &quot;DirCache&quot; version = int.from_bytes(header[4:8], &quot;big&quot;) assert version == 2, &quot;wyag only supports index file version 2&quot; count = int.from_bytes(header[8:12], &quot;big&quot;) entries = list() content = raw[12:] idx = 0 for i in range(0, count): # Read creation time, as a unix timestamp (seconds since # 1970-01-01 00:00:00, the &quot;epoch&quot;) ctime_s = int.from_bytes(content[idx: idx+4], &quot;big&quot;) # Read creation time, as nanoseconds after that timestamps, # for extra precision. ctime_ns = int.from_bytes(content[idx+4: idx+8], &quot;big&quot;) # Same for modification time: first seconds from epoch. mtime_s = int.from_bytes(content[idx+8: idx+12], &quot;big&quot;) # Then extra nanoseconds mtime_ns = int.from_bytes(content[idx+12: idx+16], &quot;big&quot;) # Device ID dev = int.from_bytes(content[idx+16: idx+20], &quot;big&quot;) # Inode ino = int.from_bytes(content[idx+20: idx+24], &quot;big&quot;) # Ignored. unused = int.from_bytes(content[idx+24: idx+26], &quot;big&quot;) assert 0 == unused mode = int.from_bytes(content[idx+26: idx+28], &quot;big&quot;) mode_type = mode &gt;&gt; 12 assert mode_type in [0b1000, 0b1010, 0b1110] mode_perms = mode &amp; 0b0000000111111111 # User ID uid = int.from_bytes(content[idx+28: idx+32], &quot;big&quot;) # Group ID gid = int.from_bytes(content[idx+32: idx+36], &quot;big&quot;) # Size fsize = int.from_bytes(content[idx+36: idx+40], &quot;big&quot;) # SHA (object ID). We'll store it as a lowercase hex string # for consistency. sha = format(int.from_bytes(content[idx+40: idx+60], &quot;big&quot;), &quot;040x&quot;) # Flags we're going to ignore flags = int.from_bytes(content[idx+60: idx+62], &quot;big&quot;) # Parse flags flag_assume_valid = (flags &amp; 0b1000000000000000) != 0 flag_extended = (flags &amp; 0b0100000000000000) != 0 assert not flag_extended flag_stage = flags &amp; 0b0011000000000000 # Length of the name. This is stored on 12 bits, some max # value is 0xFFF, 4095. Since names can occasionally go # beyond that length, git treats 0xFFF as meaning at least # 0xFFF, and looks for the final 0x00 to find the end of the # name --- at a small, and probably very rare, performance # cost. name_length = flags &amp; 0b0000111111111111 # We've read 62 bytes so far. idx += 62 if name_length &lt; 0xFFF: assert content[idx + name_length] == 0x00 raw_name = content[idx:idx+name_length] idx += name_length + 1 else: print(f&quot;Notice: Name is 0x{name_length:X} bytes long.&quot;) # This probably wasn't tested enough. It works with a # path of exactly 0xFFF bytes. Any extra bytes broke # something between git, my shell and my filesystem. null_idx = content.find(b'\\x00', idx + 0xFFF) raw_name = content[idx: null_idx] idx = null_idx + 1 # Just parse the name as utf8. name = raw_name.decode(&quot;utf8&quot;) # Data is padded on multiples of eight bytes for pointer # alignment, so we skip as many bytes as we need for the next # read to start at the right position. idx = 8 * ceil(idx / 8) # And we add this entry to our list. entries.append(GitIndexEntry(ctime=(ctime_s, ctime_ns), mtime=(mtime_s, mtime_ns), dev=dev, ino=ino, mode_type=mode_type, mode_perms=mode_perms, uid=uid, gid=gid, fsize=fsize, sha=sha, flag_assume_valid=flag_assume_valid, flag_stage=flag_stage, name=name)) return GitIndex(version=version, entries=entries) 8.3. The ls-files commandgit ls-files 显示暂存区中文件的名称，并且通常会有许多选项。我们的 ls-files 会简单得多，但我们会添加一个 --verbose 选项，虽然在 git 中并没有这个选项，但为了能够显示索引文件中的每一项信息，我们会加上它。 123456789101112131415161718192021argsp = argsubparsers.add_parser(&quot;ls-files&quot;, help = &quot;List all the stage files&quot;)argsp.add_argument(&quot;--verbose&quot;, action=&quot;store_true&quot;, help=&quot;Show everything.&quot;)def cmd_ls_files(args): repo = repo_find() index = index_read(repo) if args.verbose: print(f&quot;Index file format v{index.version}, containing {len(index.entries)} entries.&quot;) for e in index.entries: print(e.name) if args.verbose: entry_type = { 0b1000: &quot;regular file&quot;, 0b1010: &quot;symlink&quot;, 0b1110: &quot;git link&quot; }[e.mode_type] print(f&quot; {entry_type} with perms: {e.mode_perms:o}&quot;) print(f&quot; on blob: {e.sha}&quot;) print(f&quot; created: {datetime.fromtimestamp(e.ctime[0])}.{e.ctime[1]}, modified: {datetime.fromtimestamp(e.mtime[0])}.{e.mtime[1]}&quot;) print(f&quot; device: {e.dev}, inode: {e.ino}&quot;) print(f&quot; user: {pwd.getpwuid(e.uid).pw_name} ({e.uid}) group: {grp.getgrgid(e.gid).gr_name} ({e.gid})&quot;) print(f&quot; flags: stage={e.flag_stage} assume_valid={e.flag_assume_valid}&quot;) 如果运行 ls-files，你会注意到在一个“干净”的工作区（一个未修改的 HEAD 检出）中，它列出了 HEAD 上的所有文件。同样，索引文件并不是从 HEAD 提交的增量（即差异集），而是以不同的格式作为 HEAD 的副本开始的。 8.4. A detour: the check-ignore command我们想要实现 status 命令，但 status 需要了解忽略规则，这些规则存储在各种 .gitignore 文件中。因此，我们首先需要在 wyag 中添加一些基本的对忽略文件的支持。我们将通过 check-ignore 命令来暴露这一支持，该命令接受一组路径并返回那些应该被忽略的路径。 同样，命令解析器是非常简单的： 12argsp = argsubparsers.add_parser(&quot;check-ignore&quot;, help = &quot;Check path(s) against ignore rules.&quot;)argsp.add_argument(&quot;path&quot;, nargs=&quot;+&quot;, help=&quot;Paths to check&quot;) 而这个函数也同样简单： 123456def cmd_check_ignore(args): repo = repo_find() rules = gitignore_read(repo) for path in args.path: if check_ignore(rules, path): print(path) 当然，许多我们调用的函数在 wyag 中还不存在。我们将首先编写一个用于读取忽略文件规则的函数 gitignore_read()。这些规则的语法相当简单：忽略文件中的每一行都是一个排除模式，匹配此模式的文件会被 status、add -A 等操作忽略。然而，有三种特殊情况： 以感叹号 ! 开头的行会否定该模式（即使之前的模式已经忽略了文件，这些文件也会被包括在内）。 以井号 # 开头的行是注释，会被跳过。 行首的反斜杠 \\ 会将 ! 和 # 视为普通字符。 首先，我们需要编写一个解析单个模式的函数。这个解析器返回一个元组：模式本身，以及一个布尔值，用于指示匹配该模式的文件是应该被排除（True）还是包括（False）。换句话说，如果模式是以 ! 开头的，返回 False，否则返回 True。 1234567891011def gitignore_parse1(raw): raw = raw.strip() # Remove leading/trailing spaces if not raw or raw[0] == &quot;#&quot;: return None elif raw[0] == &quot;!&quot;: return (raw[1:], False) elif raw[0] == &quot;\\\\&quot;: return (raw[1:], True) else: return (raw, True) 解析文件就是收集文件中的所有规则。注意，这个函数并不直接解析文件，而是解析行的列表：这是因为我们不仅需要从常规文件中读取规则，还需要从 Git 的 blob 中读取规则。 123456789def gitignore_parse(lines): ret = list() for line in lines: parsed = gitignore_parse1(line) if parsed: ret.append(parsed) return ret 最后我们需要做的是收集各种忽略文件。它们有两种类型： 一些文件存在于索引中：它们是各种 gitignore 文件。强调一下复数形式；虽然通常只有一个这样的文件，位于根目录，但每个目录下都可以有一个，这个文件适用于该目录及其子目录。我将这些称为“作用域”，因为它们仅适用于其所在目录及其子目录。 另一些文件存在于索引之外。它们是全局忽略文件（通常位于 ~/.config/git/ignore）和存储在 .git/info/exclude 中的仓库特定忽略文件。我将这些称为“绝对”，因为它们适用于整个仓库，但优先级较低。 再次创建一个类来持有这些文件的信息：包括一个绝对规则的列表和一个相对规则的字典。这个字典的键是相对于工作区根目录的目录路径。 1234567class GitIgnore(object): absolute = None scoped = None def __init__(self, absolute, scoped): self.absolute = absolute self.scoped = scoped 最后，我们编写一个函数来收集仓库中所有的 gitignore 规则，并返回一个 GitIgnore 对象。需要注意的是，它从索引中读取作用域文件，而不是从工作区读取：只有已暂存的 .gitignore 文件才有意义（还要记住：HEAD 已经被暂存——暂存区是一个副本，而不是增量）。 123456789101112131415161718192021222324252627282930def gitignore_read(repo): ret = GitIgnore(absolute=list(), scoped=dict()) # Read local configuration in .git/info/exclude repo_file = os.path.join(repo.gitdir, &quot;info/exclude&quot;) if os.path.exists(repo_file): with open(repo_file, &quot;r&quot;) as f: ret.absolute.append(gitignore_parse(f.readlines())) # Global configuration if &quot;XDG_CONFIG_HOME&quot; in os.environ: config_home = os.environ[&quot;XDG_CONFIG_HOME&quot;] else: config_home = os.path.expanduser(&quot;~/.config&quot;) global_file = os.path.join(config_home, &quot;git/ignore&quot;) if os.path.exists(global_file): with open(global_file, &quot;r&quot;) as f: ret.absolute.append(gitignore_parse(f.readlines())) # .gitignore files in the index index = index_read(repo) for entry in index.entries: if entry.name == &quot;.gitignore&quot; or entry.name.endswith(&quot;/.gitignore&quot;): dir_name = os.path.dirname(entry.name) contents = object_read(repo, entry.sha) lines = contents.blobdata.decode(&quot;utf8&quot;).splitlines() ret.scoped[dir_name] = gitignore_parse(lines) return ret 我们快完成了。为了将所有内容结合在一起，我们需要一个 check_ignore 函数，它将路径与一组规则进行匹配，这些路径是相对于工作树的根目录的。这个函数的工作方式如下： 作用域规则匹配：它首先尝试将路径与作用域规则进行匹配。匹配的顺序是从路径的最深父级开始，逐级向上查找。例如，如果路径是 src/support/w32/legacy/sound.c~，它会先查找 src/support/w32/legacy/.gitignore 中的规则，然后是 src/support/w32/.gitignore，再是 src/support/.gitignore，直到根目录下的 .gitignore。 绝对规则匹配：如果作用域规则没有匹配，它将继续使用绝对规则进行匹配。 我们将编写三个小的支持函数。第一个是用来将路径与规则集进行匹配的，并返回最后一个匹配规则的结果。注意，这不是一个真正的布尔函数，因为它有三个可能的返回值：True、False 和 None。如果没有匹配，它将返回 None，这样调用者就知道应该继续尝试更一般的忽略文件（例如，向上移动一个目录级别）。 123456def check_ignore1(rules, path): result = None for (pattern, value) in rules: if fnmatch(path, pattern): result = value return result 这是一个用于匹配作用域规则字典（即各种 .gitignore 文件）的函数。它从路径所在的目录开始，逐级向上递归查找父目录，直到测试到根目录。请注意，这个函数（以及接下来的两个函数）在处理每个 .gitignore 文件时不会提前停止。即使某个规则匹配，它们会继续扫描整个文件，因为该文件中的其他规则可能会反转之前的效果（规则是按顺序处理的，因此如果你想排除 *.c 但不排除 generator.c，通用规则必须放在特定规则之前）。但是，一旦在某个文件中至少匹配到一个规则，我们就停止继续检查该文件的剩余规则，因为更一般的文件永远不会取消更具体规则的效果（这就是为什么 check_ignore1 是三值而不是布尔的原因）。 1234567891011def check_ignore_scoped(rules, path): parent = os.path.dirname(path) while True: if parent in rules: result = check_ignore1(rules[parent], path) if result != None: return result if parent == &quot;&quot;: break parent = os.path.dirname(parent) return None 这是一个用于匹配绝对规则列表的简单函数。请注意，我们将这些规则推送到列表的顺序很重要（因为我们确实先读取了仓库规则，再读取了全局规则！）。 1234567def check_ignore_absolute(rules, path): parent = os.path.dirname(path) for ruleset in rules: result = check_ignore1(ruleset, path) if result != None: return result return False # This is a reasonable default at this point. 最后，我们需要一个函数将它们全部绑定在一起。 123456789def check_ignore(rules, path): if os.path.isabs(path): raise Exception(&quot;This function requires path to be relative to the repository's root&quot;) result = check_ignore_scoped(rules.scoped, path) if result != None: return result return check_ignore_absolute(rules.absolute, path) 现在，您可以在其源代码树上调用 wyag check-ignore。 1234$ wyag check-ignore hello.el hello.elc hello.html wyag.zip wyag.tarhello.elchello.htmlwyag.zip Warning 这只是一个近似实现这并不是一个完美的重新实现。特别是，通过仅使用目录名称（例如 __pycache__）的规则排除整个目录将不起作用，因为 fnmatch 需要的模式是 __pycache__/**。如果你真的想深入了解忽略规则，这可能是一个很好的起点。 8.5. The status commandstatus 比 ls-files 更复杂，因为它需要同时比较索引（index）与 HEAD 以及实际的文件系统（worktree）。当你运行 git status 时，它会告诉你哪些文件自上次提交以来被添加、删除或修改，以及这些更改中哪些已经被暂存，并将出现在下一次提交中。因此，status 实际上是在比较 HEAD 与暂存区（staging area），以及暂存区与工作区（worktree）。它的输出格式如下： 123456789101112131415On branch masterChanges to be committed: (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage) modified: write-yourself-a-git.orgChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: write-yourself-a-git.orgUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) org-html-themes/ wl-copy 我们将实现 status 的三个部分：首先是活动分支或“分离的 HEAD”，然后是索引和工作区之间的差异（“未暂存的更改”），最后是 HEAD 和索引之间的差异（“已暂存的更改”和“未跟踪的文件”）。 公共接口非常简单，我们的 status 将不接受任何参数: 1argsp = argsubparsers.add_parser(&quot;status&quot;, help = &quot;Show the working tree status.&quot;) 桥接函数只是按顺序调用这三个组件函数： 12345678def cmd_status(_): repo = repo_find() index = index_read(repo) cmd_status_branch(repo) cmd_status_head_index(repo, index) print() cmd_status_index_worktree(repo, index) 8.5.1. Finding the active branch首先，我们需要知道当前是否位于某个分支上，如果是的话，确定是哪一个分支。我们可以通过检查 .git/HEAD 来实现这一点。该文件应该包含一个十六进制 ID（在分离的 HEAD 状态下指向某个提交），或者是一个间接引用，指向 refs/heads/ 目录中的某个分支。如果是分支，我们返回其名称；如果不是，则返回 False。 12345678def branch_get_active(repo): with open(repo_file(repo, &quot;HEAD&quot;), &quot;r&quot;) as f: head = f.read() if head.startswith(&quot;ref: refs/heads/&quot;): return(head[16:-1]) else: return False 基于此，我们可以编写 cmd_status_* 函数中的第一个，该函数由桥接函数调用。它的作用是打印当前活动分支的名称，或者在处于分离的 HEAD 状态时，打印其哈希值。 123456def cmd_status_branch(repo): branch = branch_get_active(repo) if branch: print(f&quot;On branch {branch}.&quot;) else: print(f&quot;HEAD detached at {object_find(repo, 'HEAD')}&quot;) 8.5.2. Finding changes between HEAD and index状态输出的第二块是“待提交的更改”，即暂存区与 HEAD 的差异。为此，我们将首先读取 HEAD 的树，并将其展平为一个单一的字典（哈希映射），键为完整路径，这样它就更接近于将路径与 blob 关联的（扁平化的）索引。然后，我们只需对比它们并输出差异。 首先，编写一个函数，将树（递归的，记得哦）转换为一个（扁平化的）字典。由于树是递归的，所以该函数本身也是递归的——抱歉，理解这一点需要点耐心 :) 123456789101112131415161718192021def tree_to_dict(repo, ref, prefix=&quot;&quot;): ret = dict() tree_sha = object_find(repo, ref, fmt=b&quot;tree&quot;) tree = object_read(repo, tree_sha) for leaf in tree.items: full_path = os.path.join(prefix, leaf.path) # We read the object to extract its type (this is uselessly # expensive: we could just open it as a file and read the # first few bytes) is_subtree = leaf.mode.startswith(b'04') # Depending on the type, we either store the path (if it's a # blob, so a regular file), or recurse (if it's another tree, # so a subdir) if is_subtree: ret.update(tree_to_dict(repo, leaf.sha, full_path)) else: ret[full_path] = leaf.sha return ret 以及命令本身： 12345678910111213141516def cmd_status_head_index(repo, index): print(&quot;Changes to be committed:&quot;) head = tree_to_dict(repo, &quot;HEAD&quot;) for entry in index.entries: if entry.name in head: if head[entry.name] != entry.sha: print(&quot; modified:&quot;, entry.name) del head[entry.name] # Delete the key else: print(&quot; added: &quot;, entry.name) # Keys still in HEAD are files that we haven't met in the index, # and thus have been deleted. for entry in head.keys(): print(&quot; deleted: &quot;, entry) 8.5.3. Finding changes between index and worktree1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556def cmd_status_index_worktree(repo, index): print(&quot;Changes not staged for commit:&quot;) ignore = gitignore_read(repo) gitdir_prefix = repo.gitdir + os.path.sep all_files = list() # We begin by walking the filesystem for (root, _, files) in os.walk(repo.worktree, True): if root==repo.gitdir or root.startswith(gitdir_prefix): continue for f in files: full_path = os.path.join(root, f) rel_path = os.path.relpath(full_path, repo.worktree) all_files.append(rel_path) # We now traverse the index, and compare real files with the cached # versions. for entry in index.entries: full_path = os.path.join(repo.worktree, entry.name) # That file *name* is in the index if not os.path.exists(full_path): print(&quot; deleted: &quot;, entry.name) else: stat = os.stat(full_path) # Compare metadata ctime_ns = entry.ctime[0] * 10**9 + entry.ctime[1] mtime_ns = entry.mtime[0] * 10**9 + entry.mtime[1] if (stat.st_ctime_ns != ctime_ns) or (stat.st_mtime_ns != mtime_ns): # If different, deep compare. # @FIXME This *will* crash on symlinks to dir. with open(full_path, &quot;rb&quot;) as fd: new_sha = object_hash(fd, b&quot;blob&quot;, None) # If the hashes are the same, the files are actually the same. same = entry.sha == new_sha if not same: print(&quot; modified:&quot;, entry.name) if entry.name in all_files: all_files.remove(entry.name) print() print(&quot;Untracked files:&quot;) for f in all_files: # @TODO If a full directory is untracked, we should display # its name without its contents. if not check_ignore(ignore, f): print(&quot; &quot;, f) 我们的 status 函数完成了。它应该输出类似于： 1234567891011$ wyag statusOn branch main.Changes to be committed: added: src/main.cChanges not staged for commit: modified: build.py deleted: README.orgUntracked files: src/cli.c 真正的 status 更智能：例如，它可以检测重命名，而我们的实现无法做到这一点。另一个值得提到的重要区别是，git status 实际上会在文件的元数据被修改但内容未改变时将索引文件写回。如果用我们特别的 ls-files 来查看，你可以看到这一点： 123456789101112131415$ wyag ls-files --verboseIndex file format v2, containing 1 entries.file regular file with perms: 644 on blob: f2f279981ce01b095c42ee7162aadf60185c8f67 created: 2023-07-18 18:26:15.771460869, modified: 2023-07-18 18:26:15.771460869 ...$ touch file$ git status &gt; /dev/null$ wyag ls-files --verboseIndex file format v2, containing 1 entries.file regular file with perms: 644 on blob: f2f279981ce01b095c42ee7162aadf60185c8f67 created: 2023-07-18 18:26:41.421743098, modified: 2023-07-18 18:26:41.421743098 请注意，git status 如何更新了索引文件中的两个时间戳，以反映实际文件元数据的变化。 9. Staging area and index, part 2: staging and committing好的，让我们创建提交。 我们几乎已经准备好了，但还差最后三样东西： 需要修改索引的命令，以便我们的提交不是仅仅复制其父提交。这些命令是 add 和 rm。 这些命令需要将修改后的索引写回，因为提交是基于索引进行的。 当然，我们还需要 commit 函数及其对应的 wyag commit 命令。 9.1. Writing the index我们将从写入索引开始。本质上，我们只是将所有内容序列化回二进制格式。这虽然有些繁琐，但代码应该很直观。我会在注释中详细说明具体细节，但实际上，这只是 index_read 的反向操作——如果需要，可以参考它以及 GitIndexEntry 类。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758def index_write(repo, index): with open(repo_file(repo, &quot;index&quot;), &quot;wb&quot;) as f: # HEADER # Write the magic bytes. f.write(b&quot;DIRC&quot;) # Write version number. f.write(index.version.to_bytes(4, &quot;big&quot;)) # Write the number of entries. f.write(len(index.entries).to_bytes(4, &quot;big&quot;)) # ENTRIES idx = 0 for e in index.entries: f.write(e.ctime[0].to_bytes(4, &quot;big&quot;)) f.write(e.ctime[1].to_bytes(4, &quot;big&quot;)) f.write(e.mtime[0].to_bytes(4, &quot;big&quot;)) f.write(e.mtime[1].to_bytes(4, &quot;big&quot;)) f.write(e.dev.to_bytes(4, &quot;big&quot;)) f.write(e.ino.to_bytes(4, &quot;big&quot;)) # Mode mode = (e.mode_type &lt;&lt; 12) | e.mode_perms f.write(mode.to_bytes(4, &quot;big&quot;)) f.write(e.uid.to_bytes(4, &quot;big&quot;)) f.write(e.gid.to_bytes(4, &quot;big&quot;)) f.write(e.fsize.to_bytes(4, &quot;big&quot;)) # @FIXME Convert back to int. f.write(int(e.sha, 16).to_bytes(20, &quot;big&quot;)) flag_assume_valid = 0x1 &lt;&lt; 15 if e.flag_assume_valid else 0 name_bytes = e.name.encode(&quot;utf8&quot;) bytes_len = len(name_bytes) if bytes_len &gt;= 0xFFF: name_length = 0xFFF else: name_length = bytes_len # We merge back three pieces of data (two flags and the # length of the name) on the same two bytes. f.write((flag_assume_valid | e.flag_stage | name_length).to_bytes(2, &quot;big&quot;)) # Write back the name, and a final 0x00. f.write(name_bytes) f.write((0).to_bytes(1, &quot;big&quot;)) idx += 62 + len(name_bytes) + 1 # Add padding if necessary. if idx % 8 != 0: pad = 8 - (idx % 8) f.write((0).to_bytes(pad, &quot;big&quot;)) idx += pad 9.2. The rm command对索引进行的最简单的更改就是从中删除一个条目，这意味着下一个提交将不会包含该文件。这正是 git rm 命令的作用。 Danger git rm 是一个破坏性操作，wyag rm 也是如此。该命令不仅修改索引，还会从工作区中删除文件。与 git 不同，wyag rm 不会在删除文件前检查其是否已保存。因此，请谨慎操作。 rm 接受一个参数，即要删除的路径列表： 123456argsp = argsubparsers.add_parser(&quot;rm&quot;, help=&quot;Remove files from the working tree and the index.&quot;)argsp.add_argument(&quot;path&quot;, nargs=&quot;+&quot;, help=&quot;Files to remove&quot;)def cmd_rm(args): repo = repo_find() rm(repo, args.path) rm 函数虽然有点长，但它非常简单。它接受一个仓库和一个路径列表，读取该仓库的索引，并从索引中删除与该列表匹配的条目。可选参数控制函数是否实际删除文件，以及如果某些路径在索引中不存在是否应中止（这两个参数供 add 使用，并不会在 wyag rm 命令中暴露）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445def rm(repo, paths, delete=True, skip_missing=False): # Find and read the index index = index_read(repo) worktree = repo.worktree + os.sep # Make paths absolute abspaths = set() for path in paths: abspath = os.path.abspath(path) if abspath.startswith(worktree): abspaths.add(abspath) else: raise Exception(f&quot;Cannot remove paths outside of worktree: {paths}&quot;) # The list of entries to *keep*, which we will write back to the # index. kept_entries = list() # The list of removed paths, which we'll use after index update # to physically remove the actual paths from the filesystem. remove = list() # Now iterate over the list of entries, and remove those whose # paths we find in abspaths. Preserve the others in kept_entries. for e in index.entries: full_path = os.path.join(repo.worktree, e.name) if full_path in abspaths: remove.append(full_path) abspaths.remove(full_path) else: kept_entries.append(e) # Preserve entry # If abspaths is empty, it means some paths weren't in the index. if len(abspaths) &gt; 0 and not skip_missing: raise Exception(f&quot;Cannot remove paths not in the index: {abspaths}&quot;) # Physically delete paths from filesystem. if delete: for path in remove: os.unlink(path) # Update the list of entries in the index, and write it back. index.entries = kept_entries index_write(repo, index) 现在，我们可以使用 wyag rm 来删除文件了。 9.3. The add command添加文件比删除稍微复杂一些，但我们已经掌握了所需的知识。将文件暂存（stage）到索引是一个三步操作： 先从索引中删除已有的条目（如果存在），但不删除文件本身（这也是我们在 rm 函数中添加可选参数的原因）。 计算文件的哈希值，将其存储为 blob 对象。 创建相应的索引条目，并将修改后的索引写回。 首先，我们来看命令的接口。没有什么特别之处，wyag add PATH ...，其中 PATH 是要暂存的一个或多个文件。这个桥接函数（bridge function）和之前的一样简单无趣。 123456argsp = argsubparsers.add_parser(&quot;add&quot;, help = &quot;Add files contents to the index.&quot;)argsp.add_argument(&quot;path&quot;, nargs=&quot;+&quot;, help=&quot;Files to add&quot;)def cmd_add(args): repo = repo_find() add(repo, args.path) add 与 rm 的主要区别在于，add 需要创建一个索引条目（index entry）。这并不难：我们只需对文件调用 stat()，然后将文件的元数据复制到索引的相应字段中（stat() 返回的元数据包括创建/修改时间等，这些信息会存储在索引中）。 12345678910111213141516171819202122232425262728293031323334353637383940414243def add(repo, paths, delete=True, skip_missing=False): # First remove all paths from the index, if they exist. rm (repo, paths, delete=False, skip_missing=True) worktree = repo.worktree + os.sep # Convert the paths to pairs: (absolute, relative_to_worktree). # Also delete them from the index if they're present. clean_paths = set() for path in paths: abspath = os.path.abspath(path) if not (abspath.startswith(worktree) and os.path.isfile(abspath)): raise Exception(f&quot;Not a file, or outside the worktree: {paths}&quot;) relpath = os.path.relpath(abspath, repo.worktree) clean_paths.add((abspath, relpath)) # Find and read the index. It was modified by rm. (This isn't # optimal, good enough for wyag!) # # @FIXME, though: we could just move the index through # commands instead of reading and writing it over again. index = index_read(repo) for (abspath, relpath) in clean_paths: with open(abspath, &quot;rb&quot;) as fd: sha = object_hash(fd, b&quot;blob&quot;, repo) stat = os.stat(abspath) ctime_s = int(stat.st_ctime) ctime_ns = stat.st_ctime_ns % 10**9 mtime_s = int(stat.st_mtime) mtime_ns = stat.st_mtime_ns % 10**9 entry = GitIndexEntry(ctime=(ctime_s, ctime_ns), mtime=(mtime_s, mtime_ns), dev=stat.st_dev, ino=stat.st_ino, mode_type=0b1000, mode_perms=0o644, uid=stat.st_uid, gid=stat.st_gid, fsize=stat.st_size, sha=sha, flag_assume_valid=False, flag_stage=False, name=relpath) index.entries.append(entry) # Write the index back index_write(repo, index) 9.4. The commit command现在，我们已经修改了索引并实际暂存了更改，接下来只需要将这些更改转换为一个提交（commit）。这正是 commit 命令的作用。 123456argsp = argsubparsers.add_parser(&quot;commit&quot;, help=&quot;Record changes to the repository.&quot;)argsp.add_argument(&quot;-m&quot;, metavar=&quot;message&quot;, dest=&quot;message&quot;, help=&quot;Message to associate with this commit.&quot;) 为了做到这一点，我们首先需要将索引转换为一个树对象，生成并存储相应的提交对象，并将 HEAD 分支更新为新的提交（记住：分支仅仅是对提交的引用）。 在进入有趣的细节之前，我们需要读取 Git 的配置，以获取用户的姓名，并将其用作作者和提交者的名字。我们将使用与读取仓库配置时相同的 configparser 库。 12345678910def gitconfig_read(): xdg_config_home = os.environ[&quot;XDG_CONFIG_HOME&quot;] if &quot;XDG_CONFIG_HOME&quot; in os.environ else &quot;~/.config&quot; configfiles = [ os.path.expanduser(os.path.join(xdg_config_home, &quot;git/config&quot;)), os.path.expanduser(&quot;~/.gitconfig&quot;) ] config = configparser.ConfigParser() config.read(configfiles) return config 以及一个简单的函数来获取并格式化用户身份： 12345def gitconfig_user_get(config): if &quot;user&quot; in config: if &quot;name&quot; in config[&quot;user&quot;] and &quot;email&quot; in config[&quot;user&quot;]: return f&quot;{config['user']['name']} &lt;{config['user']['email']}&gt;&quot; return None 现在是有趣的部分。我们首先需要根据索引构建一个树对象。这并不难，但需要注意的是，虽然索引是扁平的（它存储了工作区中所有文件的完整路径），而树是递归结构：它列出了文件或其他树。为了将索引“解扁平”成树，我们将按照以下步骤进行： 构建目录字典（哈希映射）：键是从工作区根目录开始的完整路径（例如 assets/sprites/monsters/），值是包含在该目录中的 GitIndexEntry 对象的列表。此时，字典仅包含文件：目录仅作为其键存在。 遍历目录列表，按照从最深的目录到根目录的顺序进行：即从最深的目录开始，逐步向上遍历。这意味着我们将按完整路径的长度对目录进行排序，从最长的路径到最短的路径（父目录的路径显然总是比子目录短）。举个例子，假设我们从 assets/sprites/monsters/ 开始： 对于 assets/sprites/monsters/，我们创建一个树对象，包含 cacodemon.png、imp.png 和 baron-of-hell.png。 我们将新创建的树写入仓库，并将该树添加到父目录中。也就是说，此时 assets/sprites/ 中将包含该树对象的 SHA-1 ID，树的名称为 monsters。 继续迭代下一个目录：比如我们到 assets/sprites/keys，在其中找到 red.png、blue.png 和 yellow.png，创建树、存储树、将树的 SHA-1 添加到 assets/sprites/ 中，依此类推。 最终，通过这个过程，我们将索引中的文件和目录重新组织成一个树结构，并能够将其保存为一个 Git 树对象。 因为树是递归的，所以我们最后构建的树，必定是根目录的树（因为它的键的长度为 0），它最终会引用所有其他的树，因此它将是我们需要的唯一一棵树。我们只需返回它的 SHA-1，就可以完成。 由于这个过程可能看起来有点复杂，让我们通过一个完整的示例来详细演示——如果你愿意，随时可以跳过。最初，我们从索引中构建的字典看起来是这样的： 12345678910111213contents[&quot;assets/sprites/monsters&quot;] = [ cacodemon.png : GitIndexEntry , imp.png : GitIndexEntry , baron-of-hell.png : GitIndexEntry ]contents[&quot;assets/sprites/keys&quot;] = [ red.png : GitIndexEntry , blue.png : GitIndexEntry , yellow.png : GitIndexEntry ]contents[&quot;assets/sprites/&quot;] = [ hero.png : GitIndexEntry ]contents[&quot;assets/&quot;] = [] # No files in herecontents[&quot;&quot;] = # Root! [ README: GitIndexEntry ] 我们按键长度降序遍历它。我们遇到的第一个键是最长的，也就是 assets/sprites/monsters。我们从它的内容构建一个新的树对象，将三个文件名（cacodemon.png、imp.png、baron-of-hell.png）与它们相应的 blob 关联起来（树叶存储的数据比索引少——只是路径、模式和 blob。因此，将条目转换成这种方式很容易）。 请注意，我们不需要关心存储这些文件的内容：wyag add 会在需要时创建相应的 blobs。我们需要将我们创建的树存储到对象库中，但可以假设 blobs 已经存在了。 假设我们新创建的树的哈希值，从直接位于 assets/sprites/monsters 中的索引条目生成，哈希值是 426f894781bc3c38f1d26f8fd2c7f38ab8d21763。我们修改字典，将这个新的树对象添加到该目录的父级，就像这样，现在剩下需要遍历的部分看起来是这样的： 12345678910contents[&quot;assets/sprites/keys&quot;] = # &lt;- unmodified. [ red.png : GitIndexEntry , blue.png : GitIndexEntry , yellow.png : GitIndexEntry ]contents[&quot;assets/sprites/&quot;] = [ hero.png : GitIndexEntry , monsters : Tree 426f894781bc3c38f1d26f8fd2c7f38ab8d21763 ] &lt;- look herecontents[&quot;assets/&quot;] = [] # emptycontents[&quot;&quot;] = # Root! [ README: GitIndexEntry ] 我们对下一个最长的键 assets/sprites/keys 做同样的操作，生成一个哈希值为 b42788e087b1e94a0e69dcb7a4a243eaab802bb2 的树，结果如下： 1234567contents[&quot;assets/sprites/&quot;] = [ hero.png : GitIndexEntry , monsters : Tree 426f894781bc3c38f1d26f8fd2c7f38ab8d21763 , keys : Tree b42788e087b1e94a0e69dcb7a4a243eaab802bb2 ]contents[&quot;assets/&quot;] = [] # emptycontents[&quot;&quot;] = # Root! [ README: GitIndexEntry ] 然后，我们从 assets/sprites 生成哈希值为 6364113557ed681d775ccbd3c90895ed276956a2 的树，该树现在包含我们的两个子树和 hero.png 文件。 1234contents[&quot;assets/&quot;] = [ sprites: Tree 6364113557ed681d775ccbd3c90895ed276956a2 ]contents[&quot;&quot;] = # Root! [ README: GitIndexEntry ] 接着，assets 变成了哈希值为 4d35513cb6d2a816bc00505be926624440ebbddd 的树，如下所示： 123contents[&quot;&quot;] = # Root! [ README: GitIndexEntry, assets: 4d35513cb6d2a816bc00505be926624440ebbddd] 我们从最后一个键（包含 README blob 和 assets 子树）创建一个树，哈希值为 9352e52ff58fa9bf5a750f090af64c09fa6a3d93。这就是我们的返回值：包含与索引内容相同的树。 这是实际的函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162def tree_from_index(repo, index): contents = dict() contents[&quot;&quot;] = list() # Enumerate entries, and turn them into a dictionary where keys # are directories, and values are lists of directory contents. for entry in index.entries: dirname = os.path.dirname(entry.name) # We create all dictonary entries up to root (&quot;&quot;). We need # them *all*, because even if a directory holds no files it # will contain at least a tree. key = dirname while key != &quot;&quot;: if not key in contents: contents[key] = list() key = os.path.dirname(key) # For now, simply store the entry in the list. contents[dirname].append(entry) # Get keys (= directories) and sort them by length, descending. # This means that we'll always encounter a given path before its # parent, which is all we need, since for each directory D we'll # need to modify its parent P to add D's tree. sorted_paths = sorted(contents.keys(), key=len, reverse=True) # This variable will store the current tree's SHA-1. After we're # done iterating over our dict, it will contain the hash for the # root tree. sha = None # We ge through the sorted list of paths (dict keys) for path in sorted_paths: # Prepare a new, empty tree object tree = GitTree() # Add each entry to our new tree, in turn for entry in contents[path]: # An entry can be a normal GitIndexEntry read from the # index, or a tree we've created. if isinstance(entry, GitIndexEntry): # Regular entry (a file) # We transcode the mode: the entry stores it as integers, # we need an octal ASCII representation for the tree. leaf_mode = f&quot;{entry.mode_type:02o}{entry.mode_perms:04o}&quot;.encode(&quot;ascii&quot;) leaf = GitTreeLeaf(mode = leaf_mode, path=os.path.basename(entry.name), sha=entry.sha) else: # Tree. We've stored it as a pair: (basename, SHA) leaf = GitTreeLeaf(mode = b&quot;040000&quot;, path=entry[0], sha=entry[1]) tree.items.append(leaf) # Write the new tree object to the store. sha = object_write(tree, repo) # Add the new tree hash to the current dictionary's parent, as # a pair (basename, SHA) parent = os.path.dirname(path) base = os.path.basename(path) # The name without the path, eg main.go for src/main.go contents[parent].append((base, sha)) return sha 这部分是最难的；希望讲解足够清楚。从这里开始，创建提交对象并更新 HEAD 就会简单得多。请记住，这个函数的作用是构建并存储尽可能多的树对象，以表示索引的状态，并返回根树的 SHA-1 哈希值。 创建提交对象的函数非常简单，它只需要几个参数：树的哈希值、父提交的哈希值、作者身份（字符串）、时间戳和时区偏移量，以及提交消息： 123456789101112131415161718192021def commit_create(repo, tree, parent, author, timestamp, message): commit = GitCommit() # Create the new commit object. commit.kvlm[b&quot;tree&quot;] = tree.encode(&quot;ascii&quot;) if parent: commit.kvlm[b&quot;parent&quot;] = parent.encode(&quot;ascii&quot;) # Trim message and add a trailing \\n message = message.strip() + &quot;\\n&quot; # Format timezone offset = int(timestamp.astimezone().utcoffset().total_seconds()) hours = offset // 3600 minutes = (offset % 3600) // 60 tz = &quot;{}{:02}{:02}&quot;.format(&quot;+&quot; if offset &gt; 0 else &quot;-&quot;, hours, minutes) author = author + timestamp.strftime(&quot; %s &quot;) + tz commit.kvlm[b&quot;author&quot;] = author.encode(&quot;utf8&quot;) commit.kvlm[b&quot;committer&quot;] = author.encode(&quot;utf8&quot;) commit.kvlm[None] = message.encode(&quot;utf8&quot;) return object_write(commit, repo) 剩下要编写的就是 cmd_commit，它是 wyag commit 命令的桥接函数： 12345678910111213141516171819202122def cmd_commit(args): repo = repo_find() index = index_read(repo) # Create trees, grab back SHA for the root tree. tree = tree_from_index(repo, index) # Create the commit object itself commit = commit_create(repo, tree, object_find(repo, &quot;HEAD&quot;), gitconfig_user_get(gitconfig_read()), datetime.now(), args.message) # Update HEAD so our commit is now the tip of the active branch. active_branch = branch_get_active(repo) if active_branch: # If we're on a branch, we update refs/heads/BRANCH with open(repo_file(repo, os.path.join(&quot;refs/heads&quot;, active_branch)), &quot;w&quot;) as fd: fd.write(commit + &quot;\\n&quot;) else: # Otherwise, we update HEAD itself. with open(repo_file(repo, &quot;HEAD&quot;), &quot;w&quot;) as fd: fd.write(&quot;\\n&quot;) And we’re done! 10. Final words10.1. Comments, feedback and issues此页面没有评论系统 :) 您可以通过电子邮件联系我：thibault@thb.lt。我也可以在 Mastodon 上找到，用户名是 @thblt@toad.social，或者在 Twitter 上 @ThbPlg，有时也会出现在 Libera 的 IRC 频道，昵称是 thblt。 本文的源码托管在 GitHub 上。欢迎通过 GitHub 直接提交问题报告和拉取请求，或者如果您愿意，也可以通过电子邮件与我联系。 10.2. License本文在创作共用 BY-NC-SA 4.0 许可协议 下发布。程序本身也根据 GNU 通用公共许可证 3.0 版，或根据您的选择，任何该许可证的后续版本进行许可。 补充1. l33t h4x0r“l33t h4x0r” 是一种 黑客文化（hacker culture） 里的 Leetspeak（精英语） 表达方式，它的原意是 **”leet hacker”**，即 elite hacker（精英黑客）。 在 Leetspeak 里： l33t = leet（elite 的变形，意为“精英”） h4x0r = hacker（haxor 是 hacker 的变体，”4” 代替 “a”，”0” 代替 “o”） 这个词通常用来形容那些技术高超的黑客（有时也带有一点戏谑或自嘲的意味），或者用来调侃那些自认为是黑客但实际上技术并不高的人。 2. code 11234#!/usr/bin/env python3import libwyaglibwyag.main() 这段代码是 wyag 可执行文件的内容。我们可以逐行解释： #!/usr/bin/env python3这一行是 shebang（或称作 hashbang），它告诉操作系统应该使用哪个解释器来运行这个文件。在这里，它指定了 python3 作为解释器，并使用 env 命令来确保使用系统中可用的 Python 3 版本。 import libwyag这行代码导入了我们之前提到的 libwyag.py 库文件，这个文件包含了实际的逻辑和功能。导入后，wyag 可以调用库中的函数和类。 libwyag.main()这一行调用了 libwyag.py 中的 main() 函数。通常，main() 函数是程序的入口点，它会处理主要的任务和逻辑。在这里，它可能会启动执行 Git 核心命令的相关功能。","link":"/2025/02/17/Write%20yourself%20a%20Git!/Write%20yourself%20a%20Git!/"},{"title":"3.1 变量与可变性","text":"变量和可变性正如第二章中提到的那样，变量默认是 **不可改变 ** 的（immutable）。这是 Rust 提供给你的众多优势之一，让你得以充分利用 Rust 提供的安全性和简单并发性来编写代码。不过，你仍然可以使用可变变量。让我们探讨一下 Rust 为何及如何鼓励你利用不可变性，以及何时你会选择禁用它。 当变量不可变时，一旦值被绑定一个名称上，你就不能改变这个值。为了对此进行说明，使用 cargo new variables 命令在 projects 目录生成一个叫做 variables 的新项目。 接着，在新建的 variables 目录，打开 src/main.rs 并将代码替换为如下代码，这些代码还不能编译，我们会首次检查到不可变错误（immutability error）： 123456fn main() { let x = 5; println!(&quot;The value of x is: {x}&quot;); x = 6; println!(&quot;The value of x is: {x}&quot;);} 保存并使用 cargo run 运行程序。应该会看到一条与不可变性有关的错误信息，如下输出所示： 123456789101112131415161718$ cargo run Compiling variables v0.1.0 (file:///projects/variables)error[E0384]: cannot assign twice to immutable variable `x` --&gt; src\\main.rs:4:5 |2 | let x = 5; | - first assignment to `x`3 | println!(&quot;The value of x is: {}&quot;, x);4 | x = 6; | ^^^^^ cannot assign twice to immutable variable |help: consider making this binding mutable |2 | let mut x = 5; | +++For more information about this error, try `rustc --explain E0384`.error: could not compile `variables` (bin &quot;variables&quot;) due to 1 previous error 这个例子展示了编译器如何帮助你找出程序中的错误。虽然编译错误令人沮丧，但那只是表示程序不能安全的完成你想让它完成的工作；并 不能 说明你不是一个好程序员！经验丰富的 Rustacean 们一样会遇到编译错误。 错误信息指出错误的原因是 不能对不可变变量 x 二次赋值（cannot assign twice to immutable variable x ），因为你尝试对不可变变量 x 赋第二个值。 不过可变性也是非常有用的，可以用来更方便地编写代码。尽管变量默认是不可变的，你仍然可以在变量名前添加 mut 来使其可变，正如在第二章所做的那样。mut 也向读者表明了其他代码将会改变这个变量值的意图。 123456fn main() { let mut x = 5; println!(&quot;The value of x is: {x}&quot;); x = 6; println!(&quot;The value of x is: {x}&quot;);} 现在运行这个程序，会出现如下内容： 123456$ cargo run Compiling variables v0.1.0 (file:///projects/variables) Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s Running `target/debug/variables`The value of x is: 5The value of x is: 6 通过 mut，允许把绑定到 x 的值从 5 改成 6。是否让变量可变的最终决定权仍然在你，取决于在某个特定情况下，你是否认为变量可变会让代码更加清晰明了。 常量类似于不可变变量，常量 (constants) 是绑定到一个名称的不允许改变的值，不过 常量与变量还是有一些区别 。 首先，不允许对常量使用 mut。常量不光默认不可变，它总是不可变。声明常量使用 const 关键字而不是 let，并且 必须 注明值的类型。在下一部分，[“数据类型”](./03.2 数据类型) 中会介绍类型和类型注解，现在无需关心这些细节，记住总是标注类型即可。 常量可以在任何作用域中声明，包括全局作用域，这在一个值需要被很多部分的代码用到时很有用。 最后一个区别是，常量只能被设置为常量表达式，而不可以是其他任何只能在运行时计算出的值。 下面是一个声明常量的例子： 1const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3; 常量的名称是 THREE_HOURS_IN_SECONDS，它的值被设置为 60（一分钟内的秒数）乘以 60（一小时内的分钟数）再乘以 3（我们在这个程序中要计算的小时数）的结果。Rust 对常量的命名约定是在单词之间使用全大写加下划线。编译器能够在编译时计算一组有限的操作，这使我们可以选择以更容易理解和验证的方式写出此值，而不是将此常量设置为值 10,800。有关声明常量时可以使用哪些操作的详细信息，请参阅 Rust Reference 的常量求值部分。 在声明它的作用域之中，常量在整个程序生命周期中都有效，此属性使得常量可以作为多处代码使用的全局范围的值，例如一个游戏中所有玩家可以获取的最高分或者光速。 将遍布于应用程序中的硬编码值声明为常量，能帮助后来的代码维护人员了解值的意图。如果将来需要修改硬编码值，也只需修改汇聚于一处的硬编码值。 遮蔽正如在猜数字游戏中所讲，我们可以定义一个与之前变量同名的新变量。Rustacean 们称之为第一个变量被第二个 遮蔽（Shadowing） 了，这意味着当您使用变量的名称时，编译器将看到第二个变量。实际上，第二个变量遮蔽了第一个变量，此时任何使用该变量名的行为中都会视为是在使用第二个变量，直到第二个变量自己也被遮蔽或第二个变量的作用域结束。可以用相同变量名称来遮蔽一个变量，以及重复使用 let 关键字来多次遮蔽，如下所示： 123456789101112fn main() { let x = 5; let x = x + 1; { let x = x * 2; println!(&quot;The value of x in the inner scope is: {x}&quot;); } println!(&quot;The value of x is: {x}&quot;);} 这个程序首先将 x 绑定到值 5 上。接着通过 let x = 创建了一个新变量 x，获取初始值并加 1，这样 x 的值就变成 6 了。然后，在使用花括号创建的 内部作用域 内，第三个 let 语句也遮蔽了 x 并创建了一个新的变量，将之前的值乘以 2，x 得到的值是 12。当该作用域结束时，内部遮蔽的作用域也结束了，x 又返回到 6。运行这个程序，它会有如下输出： 123456$ cargo run Compiling variables v0.1.0 (file:///projects/variables) Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s Running `target/debug/variables`The value of x in the inner scope is: 12The value of x is: 6 遮蔽与将变量标记为 mut 是有区别的。当不小心尝试对变量重新赋值时，如果没有使用 let 关键字，就会导致编译时错误。通过使用 let，我们可以用这个值进行一些计算，不过计算完之后变量仍然是不可变的。 mut 与遮蔽的另一个区别是，当再次使用 let 时，实际上创建了一个新变量，我们可以改变值的类型，并且复用这个名字。例如，假设程序请求用户输入空格字符来说明希望在文本之间显示多少个空格，接下来我们想将输入存储成数字（多少个空格）： 12let spaces = &quot; &quot;;let spaces = spaces.len(); 第一个 spaces 变量是字符串类型，第二个 spaces 变量是数字类型。遮蔽使我们不必使用不同的名字，如 spaces_str 和 spaces_num；相反，我们可以复用 spaces 这个更简单的名字。然而，如果尝试使用 mut，将会得到一个编译时错误，如下所示： 12let mut spaces = &quot; &quot;;spaces = spaces.len(); 这个错误说明，我们不能改变变量的类型： 123456789101112$ cargo run Compiling variables v0.1.0 (file:///projects/variables)error[E0308]: mismatched types --&gt; src/main.rs:3:14 |2 | let mut spaces = &quot; &quot;; | ----- expected due to this value3 | spaces = spaces.len(); | ^^^^^^^^^^^^ expected `&amp;str`, found `usize`For more information about this error, try `rustc --explain E0308`.error: could not compile `variables` (bin &quot;variables&quot;) due to 1 previous error 现在我们已经了解了变量如何工作，让我们看看变量可以拥有的更多数据类型。","link":"/2025/05/17/Rust/The%20Rust%20Programming%20Language/03.1%20%E5%8F%98%E9%87%8F%E4%B8%8E%E5%8F%AF%E5%8F%98%E6%80%A7/"},{"title":"Thinking in Java pt.1","text":"Chapter 1 Introduction to Objects1.1 The progress of abstractionAlan Kay summarized five basic characteristics of Smalltalk, the first successful object-oriented language and one of the languages upon which Java is based. These characteristics represent a pure approach to object-oriented programming: Everything is an object. Think of an object as a fancy variable; it stores data, but you can “make requests” to that object, asking it to perform operations on itself. In theory, you can take any conceptual(概念性的 ) component in the problem you’re trying to solve (dogs, buildings, services, etc.) and represent it as an object in your program. A program is a bunch of objects telling each other what to do by sending messages. To make a request of an object, you “send a message” to that object. More concretely, you can think of a message as a request to call a method that belongs to a particular object. Each object has its own memory made up of other objects. Put another way, you create a new kind of object by making a package containing existing objects. Thus, you can build complexity into a program while hiding it behind the simplicity of objects. Every object has a type. Using the parlance(按照这种说法 ), each object is an instance of a class, in which “class” is synonymous with “type.” The most important distinguishing characteristic of a class is “What messages can you send to it?” All objects of a particular type can receive the same messages. This is actually a loaded statement, as you will see later. Because an object of type “circle” is also an object of type “shape,” a circle is guaranteed to accept shape messages. This means you can write code that talks to shapes and automatically handle anything that fits the description of a shape. This substitutability is one of the powerful concepts in OOP. 1.2 An object has an interfaceSince a class describes a set of objects that have identical characteristics (data elements) and behaviors (functionality), a class is really a data type because a floating point number, for example, also has a set of characteristics and behaviors. The difference is that a programmer defines a class to fit a problem rather than being forced to use an existing data type that was designed to represent a unit of storage in a machine. You extend the programming language by adding new data types specific to your needs. The programming system welcomes the new classes and gives them all the care and type checking that it gives to built-in types. The object-oriented approach is not limited to building simulations. Whether or not you agree that any program is a simulation of the system you’re designing, the use of OOP techniques can easily reduce a large set of problems to a simple solution. Once a class is established, you can make as many objects of that class as you like, and then manipulate those objects as if they are the elements that exist in the problem you are trying to solve. Indeed, one of the challenges of object-oriented programming is to create a one-toone mapping between the elements in the problem space and objects in the solution space. 1.3 An object provides servicesWhile you’re trying to develop or understand a program design, one of the best ways to think about objects is as “service providers.” Your program itself will provide services to the user, and it will accomplish this by using the services offered by other objects. Your goal is to produce (or even better, locate in existing code libraries) a set of objects that provide the ideal services to solve your problem. 1.4 The hidden implementationIt is helpful to break up the playing field into class creators (those who create new data types) and client programmers (the class consumers who use the data types in their applications). The goal of the client programmer is to collect a toolbox full of classes to use for rapid application development. The goal of the class creator is to build a class that exposes only what’s necessary to the client programmer and keeps everything else hidden. Why? Because if it’s hidden, the client programmer can’t access it, which means that the class creator can change the hidden portion at will without worrying about the impact on anyone else. The hidden portion usually represents the tender insides of an object that could easily be corrupted by a careless or uninformed client programmer, so hiding the implementation reduces program bugs. Java uses three explicit keywords to set the boundaries in a class: public, private, and protected. These access specifiers determine who can use the definitions that follow. public means the following element is available to everyone. The private keyword, on the other hand, means that no one can access that element except you, the creator of the type, inside methods of that type. private is a brick wall between you and the client programmer. Someone who tries to access a private member will get a compile-time error. The protected keyword acts like private, with the exception that an inheriting class has access to protected members, but not private members. Inheritance will be introduced shortly. Java also has a “default” access, which comes into play if you don’t use one of the aforementioned specifiers. This is usually called package access because classes can access the members of other classes in the same package (library component), but outside of the package those same members appear to be private. 1.5 Reusing the implementationOnce a class has been created and tested, it should (ideally) represent a useful unit of code. It turns out that this reusability is not nearly so easy to achieve as many would hope; it takes experience and insight to produce a reusable object design. But once you have such a design, it begs to be reused. Code reuse is one of the greatest advantages that object-oriented programming languages provide. The simplest way to reuse a class is to just use an object of that class directly, but you can also place an object of that class inside a new class. We call this “creating a member object.” Your new class can be made up of any number and type of other objects, in any combination that you need to achieve the functionality desired in your new class. Because you are composing a new class from existing classes, this concept is called composition (if the composition happens dynamically, it’s usually called aggregation). Composition is often referred to as a “has-a” relationship, as in “A car has an engine.” Composition comes with a great deal of flexibility. The member objects of your new class are typically private, making them inaccessible to the client programmers who are using the class. This allows you to change those members without disturbing existing client code. You can also change the member objects at run time, to dynamically change the behavior of your program. Inheritance, which is described next, does not have this flexibility since the compiler must place compile-time restrictions on classes created with inheritance. Because inheritance is so important in object-oriented programming, it is often highly emphasized, and the new programmer can get the idea that inheritance should be used everywhere. This can result in awkward and overly complicated designs. Instead, you should first look to composition when creating new classes, since it is simpler and more flexible. If you take this approach, your designs will be cleaner. Once you’ve had some experience, it will be reasonably obvious when you need inheritance. 1.6 InheritanceA type does more than describe the constraints on a set of objects; it also has a relationship with other types. Two types can have characteristics and behaviors in common, but one type may contain more characteristics than another and may also handle more messages (or handle them differently). Inheritance expresses this similarity between types by using the concept of base types and derived types. A base type contains all of the characteristics and behaviors that are shared among the types derived from it. You create a base type to represent the core of your ideas about some objects in your system. From the base type, you derive other types to express the different ways that this core can be realized. 1.7 Interchangeable objects with polymorphismThe compiler cannot make a function call in the traditional sense. The function call generated by a non-OOP compiler causes what is called early binding, a term you may not have heard before because you’ve never thought about it any other way. It means the compiler generates a call to a specific function name, and the runtime system resolves this call to the absolute address of the code to be executed. In OOP, the program cannot determine the address of the code until run time, so some other scheme is necessary when a message is sent to a generic object. To solve the problem, object-oriented languages use the concept of late binding. When you send a message to an object, the code being called isn’t determined until run time. The compiler does ensure that the method exists and performs type checking on the arguments and return value, but it doesn’t know the exact code to execute. 1.8 The singly rooted hierarchyAll objects in a singly rooted hierarchy have an interface in common, so they are all ultimately the same fundamental type. The alternative (provided by C++) is that you don’t know that everything is the same basic type. From a backward-compatibility standpoint this fits the model of C better and can be thought of as less restrictive, but when you want to do full-on objectoriented programming you must then build your own hierarchy to provide the same convenience that’s built into other OOP languages. And in any new class library you acquire, some other incompatible interface will be used. It requires effort (and possibly multiple inheritance) to work the new interface into your design. Is the extra “flexibility” of C++ worth it? If you need it—if you have a large investment in C—it’s quite valuable. If you’re starting from scratch, other alternatives such as Java can often be more productive. All objects in a singly rooted hierarchy can be guaranteed to have certain functionality. You know you can perform certain basic operations on every object in your system. All objects can easily be created on the heap, and argument passing is greatly simplified. A singly rooted hierarchy makes it much easier to implement a garbage collector, which is one of the fundamental improvements of Java over C++. And since information about the type of an object is guaranteed to be in all objects, you’ll never end up with an object whose type you cannot determine. This is especially important with system-level operations, such as exception handling, and to allow greater flexibility in programming. 1.9 ContainersThe solution to most problems in object-oriented design seems flippant: You create another type of object. The new type of object that solves this particular problem holds references to other objects. Of course, you can do the same thing with an array, which is available in most languages. But this new object, generally called a container (also called a collection, but the Java library uses that term in a different sense so this book will use “container”), will expand itself whenever necessary to accommodate everything you place inside it. So you don’t need to know how many objects you’re going to hold in a container. Just create a container object and let it take care of the details. Fortunately, a good OOP language comes with a set of containers as part of the package. In C++, it’s part of the Standard C++ Library and is often called the Standard Template Library (STL). Smalltalk has a very complete set of containers. Java also has numerous containers in its standard library. In some libraries, one or two generic containers is considered good enough for all needs, and in others (Java, for example) the library has different types of containers for different needs: several different kinds of List classes (to hold sequences), Maps (also known as associative arrays, to associate objects with other objects), Sets (to hold one of each type of object), and more components such as queues, trees, stacks, etc. 1.9.1 Parameterized types (generics)One of the big changes in Java SE5 is the addition of parameterized types, called generics in Java. You’ll recognize the use of generics by the angle brackets with types inside; for example, an ArrayList that holds Shape can be created like this: 1ArrayList&lt;Shape&gt; shapes = new ArrayList(); There have also been changes to many of the standard library components in order to take advantage of generics. As you will see, generics have an impact on much of the code in this book. 1.10 Object creation &amp; lifetimeThe dynamic approach makes the generally logical assumption that objects tend to be complicated, so the extra overhead of finding storage and releasing that storage will not have an important impact on the creation of an object. In addition, the greater flexibility is essential to solve the general programming problem. Java uses dynamic memory allocation, exclusively.7 Every time you want to create an object, you use the new operator to build a dynamic instance of that object. Java provides a feature called a garbage collector that automatically discovers when an object is no longer in use and destroys it. A garbage collector is much more convenient because it reduces the number of issues that you must track and the code you must write. More importantly, the garbage collector provides a much higher level of insurance against the insidious problem of memory leaks, which has brought many a C++ project to its knees. With Java, the garbage collector is designed to take care of the problem of releasing the memory (although this doesn’t include other aspects of cleaning up an object). The garbage collector “knows” when an object is no longer in use, and it then automatically releases the memory for that object. This, combined with the fact that all objects are inherited from the single root class Object and that you can create objects only one way—on the heap—makes the process of programming in Java much simpler than programming in C++. You have far fewer decisions to make and hurdles to overcome. 1.11 Exception handling: dealing with errorsException handling wires error handling directly into the programming language and sometimes even the operating system. An exception is an object that is “thrown” from the site of the error and can be “caught” by an appropriate exception handler designed to handle that particular type of error. It’s as if exception handling is a different, parallel path of execution that can be taken when things go wrong. And because it uses a separate execution path, it doesn’t need to interfere with your normally executing code. This tends to make that code simpler to write because you aren’t constantly forced to check for errors. In addition, a thrown exception is unlike an error value that’s returned from a method or a flag that’s set by a method in order to indicate an error condition—these can be ignored. An exception cannot be ignored, so it’s guaranteed to be dealt with at some point. Finally, exceptions provide a way to reliably recover from a bad situation. Instead of just exiting the program, you are often able to set things right and restore execution, which produces much more robust programs. It’s worth noting that exception handling isn’t an object-oriented feature, although in objectoriented languages the exception is normally represented by an object. Exception handling existed before object-oriented languages. 1.12 Concurrent programming (并发编程)Sometimes, interrupts are necessary for handling time-critical tasks, but there’s a large class of problems in which you’re simply trying to partition the problem into separately running pieces (tasks) so that the whole program can be more responsive. Within a program, these separately running pieces are called threads, and the general concept is called concurrency. A common example of concurrency is the user interface. By using tasks, a user can press a button and get a quick response rather than being forced to wait until the program finishes its current task. All this makes concurrency sound pretty simple. There is a catch: shared resources. If you have more than one task running that’s expecting to access the same resource, you have a problem. For example, two processes can’t simultaneously send information to a printer. To solve the problem, resources that can be shared, such as the printer, must be locked while they are being used. So a task locks a resource, completes its task, and then releases the lock so that someone else can use the resource. 1.13 Java and the InternetAlthough Java is very useful for solving traditional standalone programming problems, it is also important because it solves programming problems for the World Wide Web. 1.13.1 What is the Web?1. Client/server computingThe primary idea of a client/server system is that you have a central repository of information— some kind of data, usually in a database—that you want to distribute on demand to some set of people or machines. A key to the client/server concept is that the repository of information is centrally located so that it can be changed and so that those changes will propagate out to the information consumers. Taken together, the information repository, the software that distributes the information, and the machine(s) where the information and software reside are called “*the server*.” The software that resides on the consumer machine, communicates with the server, fetches the information, processes it, and then displays it on the consumer machine is called the client. 2. The Web as a giant serverThe Web browser was a big step forward: the concept that one piece of information can be displayed on any type of computer without change. However, the original browsers were still rather primitive and rapidly bogged down by the demands placed on them. They weren’t particularly interactive, and tended to clog up both the server and the Internet because whenever you needed to do something that required programming you had to send information back to the server to be processed. It could take many seconds or minutes to find out you had misspelled something in your request. Since the browser was just a viewer it couldn’t perform even the simplest computing tasks. (On the other hand, it was safe, because it couldn’t execute any programs on your local machine that might contain bugs or viruses.) To solve this problem, different approaches have been taken. To begin with, graphics standards have been enhanced to allow better animation and video within browsers. The remainder of the problem can be solved only by incorporating the ability to run programs on the client end, under the browser. This is called client-side programming. 1.13.2 Client-side programmingMost desktop computers that run Web browsers are powerful engines capable of doing vast work, and with the original static HTML approach they are sitting there, just idly waiting for the server to dish up the next page. Client-side programming means that the Web browser is harnessed to do whatever work it can, and the result for the user is a much speedier and more interactive experience at your Web site. The problem with discussions of client-side programming is that they aren’t very different from discussions of programming in general. The parameters are almost the same, but the platform is different; a Web browser is like a limited operating system. In the end, you must still program, and this accounts for the dizzying array of problems and solutions produced by client-side programming. The rest of this section provides an overview of the issues and approaches in client-side programming. 1. Plug-insOne of the most significant steps forward in client-side programming is the development of the plug-in. This is a way for a programmer to add new functionality to the browser by downloading a piece of code that plugs itself into the appropriate spot in the browser. The value of the plug-in for client-side programming is that it allows an expert programmer to develop extensions and add those extensions to a browser without the permission of the browser manufacturer. Thus, plug-ins provide a “back door” that allows the creation of new client-side programming languages (although not all languages are implemented as plug-ins). 2. Scripting languagesScripting languages tend to be reasonably easy to understand and, because they are simply text that is part of an HTML page, they load very quickly as part of the single server hit required to procure that page. The trade-off is that your code is exposed for everyone to see (and steal). Generally, however, you aren’t doing amazingly sophisticated things with scripting languages, so this is not too much of a hardship. The scripting languages used inside Web browsers are really intended to solve specific types of problems, primarily the creation of richer and more interactive graphical user interfaces (GUIs). However, a scripting language might solve 80 percent of the problems encountered in client-side programming. Your problems might very well fit completely within that 80 percent, and since scripting languages can allow easier and faster development, you should probably consider a scripting language before looking at a more involved solution such as Java programming. 3. JavaJava is a popular solution for this. Not only is it a powerful programming language built to be secure, cross-platform, and international, but Java is being continually extended to provide language features and libraries that elegantly handle problems that are difficult in traditional programming languages, such as concurrency, database access, network programming, and distributed computing. Java allows client-side programming via the applet and with Java Web Start. An applet is a mini-program that will run only under a Web browser. The applet is downloaded automatically as part of a Web page (just as, for example, a graphic is automatically downloaded). When the applet is activated, it executes a program. This is part of its beauty—it provides you with a way to automatically distribute the client software from the server at the time the user needs the client software, and no sooner. The user gets the latest version of the client software without fail and without difficult reinstallation. Because of the way Java is designed, the programmer needs to create only a single program, and that program automatically works with all computers that have browsers with built-in Java interpreters. (This safely includes the vast majority of machines.) Since Java is a full-fledged programming language, you can do as much work as possible on the client before and after making requests of the server. For example, you won’t need to send a request form across the Internet to discover that you’ve gotten a date or some other parameter wrong, and your client computer can quickly do the work of plotting data instead of waiting for the server to make a plot and ship a graphic image back to you. Not only do you get the immediate win of speed and responsiveness, but the general network traffic and load on servers can be reduced, preventing the entire Internet from slowing down. 4. AlternativesTo be honest, Java applets have not particularly lived up to their initial fanfare. When Java first appeared, what everyone seemed most excited about was applets, because these would finally allow serious client-side programmability, to increase responsiveness and decrease bandwidth requirements for Internet-based applications. People envisioned vast possibilities. Indeed, you can find some very clever applets on the Web. But the overwhelming move to applets never happened. The biggest problem was probably that the 10 MB download necessary to install the Java Runtime Environment (JRE) was too scary for the average user. The fact that Microsoft chose not to include the JRE with Internet Explorer may have sealed its fate. In any event, Java applets didn’t happen on a large scale. 5. .NET and C#Currently, the main vulnerability and important question concerning .NET is whether Microsoft will allow it to be completely ported to other platforms. They claim there’s no problem doing this, and the Mono project (www.go-mono.com) has a partial implementation of .NET working on Linux, but until the implementation is complete and Microsoft has not decided to squash any part of it, .NET as a cross-platform solution is still a risky bet. 6. Internet vs. IntranetWhen Web technology is used for an information network that is restricted to a particular company, it is referred to as an intranet. Intranets provide much greater security than the Internet, since you can physically control access to the servers within your company. When faced with this bewildering array of solutions to the client-side programming problem, the best plan of attack is a cost-benefit analysis. Consider the constraints of your problem and what would be the shortest path to your solution. Since client-side programming is still programming, it’s always a good idea to take the fastest development approach for your particular situation. This is an aggressive stance to prepare for inevitable encounters with the problems of program development. 1.13.3 Server-side programmingA more complicated request to a server generally involves a database transaction. A common scenario involves a request for a complex database search, which the server then formats into an HTML page and sends to you as the result. (Of course, if the client has more intelligence via Java or a scripting language, the raw data can be sent and formatted at the client end, which will be faster and less load on the server.) Or you might want to register your name in a database when you join a group or place an order, which will involve changes to that database. These database requests must be processed via some code on the server side, which is generally referred to as server-side programming. Traditionally, server-side programming has been performed using Perl, Python, C++, or some other language to create CGI programs, but more sophisticated systems have since appeared. These include Java-based Web servers that allow you to perform all your server-side programming in Java by writing what are called servlets. Servlets and their offspring, JSPs, are two of the most compelling reasons that companies that develop Web sites are moving to Java, especially because they eliminate the problems of dealing with differently abled browsers. 1.14 SummaryBecause OOP adds many new concepts on top of what you find in a procedural language, your natural assumption may be that the resulting Java program will be far more complicated than the equivalent procedural program. Here, you’ll be pleasantly surprised: A well-written Java program is generally far simpler and much easier to understand than a procedural program. What you’ll see are the definitions of the objects that represent concepts in your problem space (rather than the issues of the computer representation) and messages sent to those objects to represent the activities in that space. One of the delights of objectoriented programming is that, with a well-designed program, it’s easy to understand the code by reading it. Usually, there’s a lot less code as well, because many of your problems will be solved by reusing existing library code. OOP and Java may not be for everyone. It’s important to evaluate your own needs and decide whether Java will optimally satisfy those needs, or if you might be better off with another programming system (including the one you’re currently using). If you know that your needs will be very specialized for the foreseeable future and if you have specific constraints that may not be satisfied by Java, then you owe it to yourself to investigate the alternatives (in particular, I recommend looking at Python; see www.Python.org). If you still choose Java as your language, you’ll at least understand what the options were and have a clear vision of why you took that direction.","link":"/2025/02/09/Thinking-in-Java/Thinking-in-Java-pt-1/"},{"title":"3.3 函数","text":"函数函数在 Rust 代码中非常普遍。你已经见过语言中最重要的函数之一：main 函数，它是很多程序的入口点。你也见过 fn 关键字，它用来声明新函数。 Rust 代码中的函数和变量名使用 snake case 规范风格。在 snake case 中，所有字母都是小写并使用下划线分隔单词。这是一个包含函数定义示例的程序： 123456789fn main() { println!(&quot;Hello, world!&quot;); another_function();}fn another_function() { println!(&quot;Another function.&quot;);} 我们在 Rust 中通过输入 fn 后面跟着函数名和一对圆括号来定义函数。大括号告诉编译器哪里是函数体的开始和结尾。 可以使用函数名后跟圆括号来调用我们定义过的任意函数。因为程序中已定义 another_function 函数，所以可以在 main 函数中调用它。注意，源码中 another_function 定义在 main 函数 之后；也可以定义在之前。 Rust 不关心函数定义所在的位置 ，只要函数被调用时出现在调用之处可见的作用域内就行。 main 函数中的代码会按顺序执行。首先，打印 “Hello, world!” 信息，然后调用 another_function 函数并打印它的信息。 参数我们可以定义为拥有 参数（parameters）的函数，参数是特殊变量，是函数签名的一部分。当函数拥有参数（形参）时，可以为这些参数提供具体的值（实参）。技术上讲，这些具体值被称为参数（arguments），但是在日常交流中，人们倾向于不区分使用 parameter 和 argument 来表示函数定义中的变量或调用函数时传入的具体值。 1234567fn main() { another_function(5);}fn another_function(x: i32) { println!(&quot;The value of x is: {x}&quot;);} 尝试运行程序，将会输出如下内容： 12345$ cargo run Compiling functions v0.1.0 (file:///projects/functions) Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.21s Running `target/debug/functions`The value of x is: 5 another_function 的声明中有一个命名为 x 的参数。x 的类型被指定为 i32。当我们将 5 传给 another_function 时，println! 宏会把 5 放在格式字符串中包含 x 的那对花括号的位置。 在函数签名中，必须 声明每个参数的类型。这是 Rust 设计中一个经过慎重考虑的决定：要求在函数定义中提供类型注解，意味着编译器再也不需要你在代码的其他地方注明类型来指出你的意图。而且，在知道函数需要什么类型后，编译器就能够给出更有用的错误消息。 当定义多个参数时，使用逗号分隔，像这样： 1234567fn main() { print_labeled_measurement(5, 'h');}fn print_labeled_measurement(value: i32, unit_label: char) { println!(&quot;The measurement is: {value}{unit_label}&quot;);} 这个例子创建了一个名为 print_labeled_measurement 的函数，它有两个参数。第一个参数名为 value，类型是 i32。第二个参数是 unit_label ，类型是 char。然后，该函数打印包含 value 和 unit_label 的文本。 尝试运行代码。使用上面的例子替换当前 functions 项目的 src/main.rs 文件，并用 cargo run 运行它： 12345$ cargo run Compiling functions v0.1.0 (file:///projects/functions) Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s Running `target/debug/functions`The measurement is: 5h 因为我们使用 5 作为 value 的值，h 作为 unit_label 的值来调用函数，所以程序输出包含这些值。 语句和表达式语句不返回值。因此，不能把 let 语句赋值给另一个变量，比如下面的例子尝试做的，会产生一个错误： 123fn main() { let x = (let y = 6);} let y = 6 语句并不返回值，所以没有可以绑定到 x 上的值。这与其他语言不同，例如 C 和 Ruby，它们的赋值语句会返回所赋的值。在这些语言中，可以这么写 x = y = 6，这样 x 和 y 的值都是 6；Rust 中不能这样写。 表达式会计算出一个值，并且你将编写的大部分 Rust 代码是由表达式组成的。考虑一个数学运算，比如 5 + 6，这是一个表达式并计算出值 11。表达式可以是语句的一部分：语句 let y = 6; 中的 6 是一个表达式，它计算出的值是 6。函数调用是一个表达式。宏调用是一个表达式。用大括号创建的一个新的块作用域也是一个表达式，例如： 123456789fn main() { // equals let y = 4; let y = { let x = 3; x + 1 }; println!(&quot;The value of y is: {y}&quot;);} 这个表达式： 1234{ let x = 3; x + 1} 是一个代码块，它的值是 4。这个值作为 let 语句的一部分被绑定到 y 上。注意 x + 1 这一行在结尾没有分号，与你见过的大部分代码行不同。 表达式的结尾没有分号 。如果在表达式的结尾加上分号，它就变成了语句，而语句不会返回值。在接下来探索具有返回值的函数和表达式时要谨记这一点。 具有返回值的函数函数可以向调用它的代码返回值。我们并不对返回值命名，但要在 箭头（-&gt;）后声明它的类型 。在 Rust 中，函数的返回值等同于函数体最后一个表达式的值。使用 return 关键字和指定值，可从函数中提前返回；但大部分函数隐式的返回最后的表达式。这是一个有返回值的函数的例子： 123456789fn five() -&gt; i32 { 5}fn main() { let x = five(); println!(&quot;The value of x is: {x}&quot;);} 在 five 函数中没有函数调用、宏、甚至没有 let 语句 —— 只有数字 5。这在 Rust 中是一个完全有效的函数。注意，也指定了函数返回值的类型，就是 -&gt; i32。尝试运行代码；输出应该看起来像这样： 12345$ cargo run Compiling functions v0.1.0 (file:///projects/functions) Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s Running `target/debug/functions`The value of x is: 5 five 函数的返回值是 5，所以返回值类型是 i32。让我们仔细检查一下这段代码。有两个重要的部分：首先，let x = five(); 这一行表明我们使用函数的返回值初始化一个变量。因为 five 函数返回 5，这一行与如下代码相同： 1let x = 5; 其次，five 函数没有参数并定义了返回值类型，不过函数体只有单单一个 5 也没有分号，因为这是一个表达式，我们想要返回它的值。 让我们看看另一个例子： 123456789fn main() { let x = plus_one(5); println!(&quot;The value of x is: {x}&quot;);}fn plus_one(x: i32) -&gt; i32 { x + 1} 运行代码会打印出 The value of x is: 6。但如果在包含 x + 1 的行尾加上一个分号，把它从表达式变成语句，我们将看到一个错误。 123456789fn main() { let x = plus_one(5); println!(&quot;The value of x is: {x}&quot;);}fn plus_one(x: i32) -&gt; i32 { x + 1;} 运行代码会产生一个错误，如下： 1234567891011121314$ cargo run Compiling functions v0.1.0 (file:///projects/functions)error[E0308]: mismatched types --&gt; src/main.rs:7:24 |7 | fn plus_one(x: i32) -&gt; i32 { | -------- ^^^ expected `i32`, found `()` | | | implicitly returns `()` as its body has no tail or `return` expression8 | x + 1; | - help: remove this semicolon to return this valueFor more information about this error, try `rustc --explain E0308`.error: could not compile `functions` (bin &quot;functions&quot;) due to 1 previous error 主要的错误信息，“mismatched types”（类型不匹配），揭示了代码的核心问题。函数 plus_one 的定义说明它要返回一个 i32 类型的值，不过语句并不会返回值，使用单位类型 () 表示不返回值。因为不返回值与函数定义相矛盾，从而出现一个错误。在输出中，Rust 提供了一条信息，可能有助于纠正这个错误：它建议删除分号，这会修复这个错误。","link":"/2025/05/17/Rust/The%20Rust%20Programming%20Language/03.3%20%E5%87%BD%E6%95%B0/"},{"title":"2 猜数小游戏","text":"准备项目12$ cargo new guessing_game$ cd guessing_game 处理一次猜测猜数字程序的第一部分请求和处理用户输入，并检查输入是否符合预期的格式。 首先，我们会允许玩家输入一个猜测。 123456789101112131415use std::io;fn main() { println!(&quot;Guess the number!&quot;); println!(&quot;Please input your guess.&quot;); let mut guess = String::new(); io::stdin() .read_line(&amp;mut guess) .expect(&quot;Failed to read line&quot;); println!(&quot;You guessed: {guess}&quot;);} 为了获取用户输入并打印结果作为输出，我们需要将 io 输入/输出库引入当前作用域。io 库来自于标准库，也被称为 std： 1use std::io; 默认情况下，Rust 设定了若干个会自动导入到每个程序作用域中的标准库内容，这组内容被称为 预导入（prelude） 内容。可以在标准库文档中查看预导入的所有内容。 如果需要的类型不在预导入内容中，就必须使用 use 语句显式地将其引入作用域。std::io 库提供很多有用的功能，包括接收用户输入的功能。 使用变量存储值接下来，创建一个 变量（variable）来储存用户输入： 1let mut guess = String::new(); 我们使用 let 语句来创建变量。 在 Rust 中，变量默认是 **不可变 ** 的，这意味着一旦我们给变量赋值，这个值就不可以再修改了。我们将会在第三章的 [“变量与可变性”](./03.1 变量与可变性) 部分详细讨论这个概念。在变量名前使用 mut 来使一个变量可变。 12let apples = 5; // 不可变let mut bananas = 5; // 可变 ::new 那一行的 :: 语法表明 new 是 String 类型的一个 关联函数（associated function）。关联函数是针对某个类型实现的函数，在这个例子中是 String。这个 new 函数创建了一个新的空字符串。你会发现许多类型上都有一个 new 函数，因为这是为某种类型创建新值的常用函数名。 总的来说，let mut guess = String::new(); 这一行创建了一个可变变量，当前它绑定到一个新的 String 空实例上。 接收用户输入我们在程序的第一行使用 use std::io; 从标准库中引入了输入/输出功能。现在调用 io 库中的函数 stdin，这允许我们处理用户输入： 12io::stdin() .read_line(&amp;mut guess) 如果程序的开头没有使用 use std::io; 引入 io 库，我们仍可以通过把函数调用写成 std::io::stdin 来使用该函数。stdin 函数返回一个 std::io::Stdin 的实例，这是一种代表终端标准输入句柄的类型。 接下来，代码中的 .read_line(&amp;mut guess) 调用了标准输入句柄上的 read_line 方法，以获取用户输入。我们还将 &amp;mut guess 作为参数传递给 read_line 函数，让其将用户输入储存到这个字符串中。read_line 的工作是，无论用户在标准输入中键入什么内容，都将其追加（不会覆盖其原有内容）到一个字符串中，因此它需要字符串作为参数。这个字符串参数应该是可变的，以便 read_line 将用户输入附加上去。 &amp; 表示这个参数是一个 引用（reference），它允许多处代码访问同一处数据，而无需在内存中多次拷贝。引用是一个复杂的特性，Rust 的一个主要优势就是安全而简单的操纵引用。现在，我们只需知道它像变量一样，默认是不可变的。因此，需要写成 &amp;mut guess 来使其可变，而不是 &amp;guess。（第四章会更全面地讲解引用。） 使用 Result 类型来处理潜在的错误我们还没有完全分析完这行代码。虽然我们已经讲到了第三行代码，但要注意：它仍是逻辑行（虽然换行了但仍是语句）的一部分。后一部分是这个方法（method）： 1.expect(&quot;Failed to read line&quot;); 我们也可以将代码这样写： 1io::stdin().read_line(&amp;mut guess).expect(&quot;Failed to read line&quot;); 不过，过长的代码行难以阅读，所以最好拆开来写。通常来说，当使用 .method_name() 语法调用方法时引入换行符和空格将长的代码行拆开是明智的。现在来看看这行代码干了什么。 之前提到了 read_line 会将用户输入附加到传递给它的字符串中，不过它也会返回一个类型为 Result 的值。Result 是一种枚举类型，通常也写作 enum，它可以是多种可能状态中的一个。我们把每种可能的状态称为一种 枚举成员（variant）。 第六章 将介绍枚举的更多细节。这里的 Result 类型将用来编码错误处理的信息。 Result 的成员是 Ok 和 Err，Ok 成员表示操作成功，内部包含成功时产生的值。Err 成员则意味着操作失败，并且 Err 中包含有关操作失败的原因或方式的信息。 Result 类型的值，像其他类型一样，拥有定义于其实例上的方法。Result 的实例拥有 expect 方法。如果 io::Result 实例的值是 Err，expect 会导致程序崩溃，并输出当做参数传递给 expect 的信息。所以当 read_line 方法返回 Err，则可能是来源于底层操作系统错误的结果。如果 Result 实例的值是 Ok，expect 会获取 Ok 中的值并原样返回。在本例中，这个值是用户输入到标准输入中的字节数。 如果不调用 expect，程序也能编译，不过会出现一个警告： 123456789101112131415161718$ cargo build Compiling guessing_game v0.1.0 (file:///projects/guessing_game)warning: unused `Result` that must be used --&gt; src/main.rs:10:5 |10 | io::stdin().read_line(&amp;mut guess); | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ | = note: this `Result` may be an `Err` variant, which should be handled = note: `#[warn(unused_must_use)]` on by defaulthelp: use `let _ = ...` to ignore the resulting value |10 | let _ = io::stdin().read_line(&amp;mut guess); | +++++++warning: `guessing_game` (bin &quot;guessing_game&quot;) generated 1 warning Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.59s Rust 警告我们没有使用 read_line 的返回值 Result，说明有一个可能的错误没有处理。 消除警告的正确做法是实际去编写错误处理代码，不过由于我们就是希望程序在出现问题时立即崩溃，所以直接使用 expect。第九章 会学习如何从错误中恢复。 使用 println! 占位符打印值除了位于结尾的右花括号，目前为止就只有这一行代码值得讨论一下了： 1println!(&quot;You guessed: {guess}&quot;); 这行代码现在打印了存储用户输入的字符串。{} 这对大括号是一个占位符。当打印变量的值时，变量名可以写进大括号中。当打印表达式的执行结果时，格式化字符串（format string）中大括号中留空，格式化字符串后跟逗号分隔的需要打印的表达式列表，其顺序与每一个空大括号占位符的顺序一致。在一个 println! 调用中打印变量和表达式的值看起来像这样： 1234let x = 5;let y = 10;println!(&quot;x = {x} and y + 2 = {}&quot;, y + 2); 这行代码会打印出 x = 5 and y + 2 = 12。 测试第一部分12345678$ cargo run Compiling guessing_game v0.1.0 (file:///projects/guessing_game) Finished `dev` profile [unoptimized + debuginfo] target(s) in 6.44s Running `target/debug/guessing_game`Guess the number!Please input your guess.6You guessed: 6 生成一个数字使用 crate 增加更多功能crate 是一组 Rust 源代码文件。我们正在构建的项目是一个 二进制 crate，它生成一个可执行文件。 rand crate 是一个 库 crate，库 crate 可以包含任意能被其他程序使用的代码，但是无法独立执行。 Cargo 对外部 crate 的运用是其真正的亮点所在。在我们使用 rand 编写代码之前，需要修改 Cargo.toml 文件，引入一个 rand 依赖。现在打开这个文件并将下面这一行添加到 [dependencies] section 标题之下。在当前版本下，请确保按照我们这里的方式指定 rand，否则本教程中的示例代码可能无法工作。 文件名：Cargo.toml 12[dependencies]rand = &quot;0.8.5&quot; 在 Cargo.toml 文件中，标题以及之后的内容属同一个 section，直到遇到下一个标题才开始新的 section。[dependencies] section 告诉 Cargo 本项目依赖了哪些外部 crate 及其版本。本例中，我们使用语义化版本 0.8.5 来指定 rand crate。Cargo 理解 语义化版本（Semantic Versioning）（有时也称为 SemVer），这是一种定义版本号的标准。0.8.5 事实上是 ^0.8.5 的简写，它表示任何至少是 0.8.5 但小于 0.9.0 的版本。 Cargo 认为这些版本与 0.8.5 版本的公有 API 相兼容，这样的版本指定确保了我们可以获取能使本章代码编译的最新的补丁（patch）版本。任何大于等于 0.9.0 的版本不能保证和接下来的示例采用了相同的 API。 现在，不修改任何代码，构建项目。 1234567891011121314151617181920$ cargo build Updating crates.io index Locking 15 packages to latest Rust 1.85.0 compatible versions Adding rand v0.8.5 (available: v0.9.0) Compiling proc-macro2 v1.0.93 Compiling unicode-ident v1.0.17 Compiling libc v0.2.170 Compiling cfg-if v1.0.0 Compiling byteorder v1.5.0 Compiling getrandom v0.2.15 Compiling rand_core v0.6.4 Compiling quote v1.0.38 Compiling syn v2.0.98 Compiling zerocopy-derive v0.7.35 Compiling zerocopy v0.7.35 Compiling ppv-lite86 v0.2.20 Compiling rand_chacha v0.3.1 Compiling rand v0.8.5 Compiling guessing_game v0.1.0 (file:///projects/guessing_game) Finished `dev` profile [unoptimized + debuginfo] target(s) in 2.48s 可能会出现不同的版本号（多亏了语义化版本，它们与代码是兼容的！），并且显示的行数可能会有所不同（取决于操作系统），行的顺序也可能会不同。 现在我们有了一个外部依赖，Cargo 从 registry 上获取所有包的最新版本信息，这是一份来自 Crates.io 的数据副本。Crates.io 是 Rust 生态系统中，人们发布其开源 Rust 项目的平台，供他人使用。 在更新完 registry 后，Cargo 检查 [dependencies] section 并下载列表中包含但还未下载的 crate。本例中，虽然只声明了 rand 一个依赖，然而 Cargo 还是额外获取了 rand 所需要的其他 crate，因为 rand 依赖它们来正常工作。下载完成后，Rust 编译依赖，然后使用这些依赖编译项目。 如果不做任何修改，立刻再次运行 cargo build，则不会看到任何除了 Finished 行之外的输出。Cargo 知道它已经下载并编译了依赖，同时 Cargo.toml 文件也没有变动。Cargo 还知道代码也没有任何修改，所以它不会重新编译代码。因为无事可做，它会简单地退出。 Cargo.lock 文件确保可重现构建Cargo 有一个机制，确保无论是你还是其他人在任何时候重新构建代码，都会生成相同的构建产物：Cargo 只会使用你指定的依赖版本，除非你明确指定其他版本。例如，如果下周 rand crate 的 0.8.6 版本出来了，该版本包含了一个重要的 bug 修复，但同时也引入了一个会破坏你代码的回归问题。为了解决这个问题，Rust 在你第一次运行 cargo build 时创建了 Cargo.lock 文件，我们现在可以在 guessing_game 目录找到它。 当第一次构建项目时，Cargo 计算出所有符合要求的依赖版本并写入 Cargo.lock 文件。当将来构建项目时，Cargo 会发现 Cargo.lock 已存在并使用其中指定的版本，而不是再次计算所有的版本。这使得你拥有了一个自动化的可重现构建（reproducible build）。换句话说，项目会持续使用 0.8.5 直到你显式升级，多亏有了 Cargo.lock 文件。由于 Cargo.lock 文件对于可重现构建非常重要，因此它通常会和项目中的其余代码一样提交到版本控制系统中。 更新 crate 到一个新版本当你 确实 需要升级 crate 时，Cargo 提供了这样一个命令，update，它会忽略 Cargo.lock 文件，并计算出所有符合 Cargo.toml 声明的最新版本。Cargo 接下来会把这些版本写入 Cargo.lock 文件。不过，Cargo 默认只会寻找大于 0.8.5 而小于 0.9.0 的版本。如果 rand crate 发布了两个新版本，0.8.6 和 0.9.0，在运行 cargo update 时会出现如下内容： 1234$ cargo update Updating crates.io index Locking 1 package to latest Rust 1.85.0 compatible version Updating rand v0.8.5 -&gt; v0.8.6 (available: v0.9.0) Cargo 忽略了 0.9.0 版本。这时，你也会注意到的 Cargo.lock 文件中的变化无外乎现在使用的 rand crate 版本是 0.8.6 。如果想要使用 0.9.0 版本的 rand 或是任何 0.9.x 系列的版本，必须像这样更新 Cargo.toml 文件： 12[dependencies]rand = &quot;0.9.0&quot; 下一次运行 cargo build 时，Cargo 会更新可用 crate 的 registry，并根据你指定的新版本重新评估 rand 的要求。 第十四章会讲到 Cargo 及其生态系统 的更多内容，不过目前你只需要了解这么多。通过 Cargo 复用库文件非常容易，因此 Rustacean 能够编写出由很多包组装而成的更轻巧的项目。 生成一个随机数让我们开始使用 rand 来生成一个要猜测的数字。下一步是更新 src/main.rs 。 123456789101112131415161718192021use std::io;use rand::Rng;fn main() { println!(&quot;Guess the number!&quot;); let secret_number = rand::thread_rng().gen_range(1..=100); println!(&quot;The secret number is: {secret_number}&quot;); println!(&quot;Please input your guess.&quot;); let mut guess = String::new(); io::stdin() .read_line(&amp;mut guess) .expect(&quot;Failed to read line&quot;); println!(&quot;You guessed: {guess}&quot;);} 首先，我们新增了一行 use rand::Rng;。Rng 是一个 trait，它定义了随机数生成器应实现的方法，想使用这些方法的话，此 trait 必须在作用域中。第十章会详细介绍 trait。 接下来，我们在中间还新增加了两行。第一行调用了 rand::thread_rng 函数提供实际使用的随机数生成器：它位于当前执行线程的本地环境中，并从操作系统获取 seed。接着调用随机数生成器的 gen_range 方法。这个方法由 use rand::Rng 语句引入到作用域的 Rng trait 定义。gen_range 方法获取一个范围表达式（range expression）作为参数，并生成一个在此范围之间的随机数。这里使用的这类范围表达式使用了 start..=end 这样的形式，它对上下边界均为闭区间，所以需要指定 1..=100 来请求一个 1 和 100 之间的数。 新增加的第二行代码打印出了秘密数字。这在开发程序时很有用，因为可以测试它，不过在最终版本中会删掉它。如果游戏一开始就打印出结果就没什么可玩的了！ 尝试运行程序几次： 123456789101112131415161718$ cargo run Compiling guessing_game v0.1.0 (file:///projects/guessing_game) Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.02s Running `target/debug/guessing_game`Guess the number!The secret number is: 7Please input your guess.4You guessed: 4$ cargo run Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.02s Running `target/debug/guessing_game`Guess the number!The secret number is: 83Please input your guess.5You guessed: 5 比较猜测的数字和秘密数字现在有了用户输入和一个随机数，我们可以比较它们。注意这段代码还不能通过编译，我们稍后会解释。 12345678910111213141516use std::cmp::Ordering;use std::io;use rand::Rng;fn main() { // --snip-- println!(&quot;You guessed: {guess}&quot;); match guess.cmp(&amp;secret_number) { Ordering::Less =&gt; println!(&quot;Too small!&quot;), Ordering::Greater =&gt; println!(&quot;Too big!&quot;), Ordering::Equal =&gt; println!(&quot;You win!&quot;), }} 首先我们增加了另一个 use 声明，从标准库引入了一个叫做 std::cmp::Ordering 的类型到作用域中。 Ordering 也是一个枚举，不过它的成员是 Less、Greater 和 Equal。这是比较两个值时可能出现的三种结果。 接着，底部的五行新代码使用了 Ordering 类型，cmp 方法用来比较两个值并可以在任何可比较的值上调用。它获取一个被比较值的引用：这里是把 guess 与 secret_number 做比较。然后它会返回一个刚才通过 use 引入作用域的 Ordering 枚举的成员。使用一个 [match](./06.2 match 控制流结构) 表达式，根据对 guess 和 secret_number 调用 cmp 返回的 Ordering 成员来决定接下来做什么。 一个 match 表达式由 分支（arms） 构成。一个分支包含一个 模式（pattern）和表达式开头的值与分支模式相匹配时应该执行的代码。Rust 获取提供给 match 的值并挨个检查每个分支的模式。match 结构和模式是 Rust 中强大的功能，它体现了代码可能遇到的多种情形，并确保对所有情况作出处理。这些功能将分别在第六章和第十九章详细介绍。 让我们看看使用 match 表达式的例子。假设用户猜了 50，这时随机生成的秘密数字是 38。 比较 50 与 38 时，因为 50 比 38 要大，cmp 方法会返回 Ordering::Greater。Ordering::Greater 是 match 表达式得到的值。它检查第一个分支的模式，Ordering::Less 与 Ordering::Greater并不匹配，所以它忽略了这个分支的代码并来到下一个分支。下一个分支的模式是 Ordering::Greater，正确 匹配！这个分支关联的代码被执行，在屏幕打印出 Too big!。match 表达式会在第一次成功匹配后终止，因此在这种情况下不会查看最后一个分支。 然而，代码目前并不能编译，可以尝试一下： 123456789101112131415161718192021222324$ cargo build Compiling libc v0.2.86 Compiling getrandom v0.2.2 Compiling cfg-if v1.0.0 Compiling ppv-lite86 v0.2.10 Compiling rand_core v0.6.2 Compiling rand_chacha v0.3.0 Compiling rand v0.8.5 Compiling guessing_game v0.1.0 (file:///projects/guessing_game)error[E0308]: mismatched types --&gt; src/main.rs:23:21 |23 | match guess.cmp(&amp;secret_number) { | --- ^^^^^^^^^^^^^^ expected `&amp;String`, found `&amp;{integer}` | | | arguments to this method are incorrect | = note: expected reference `&amp;String` found reference `&amp;{integer}`note: method defined here --&gt; /rustc/4eb161250e340c8f48f66e2b929ef4a5bed7c181/library/core/src/cmp.rs:964:8For more information about this error, try `rustc --explain E0308`.error: could not compile `guessing_game` (bin &quot;guessing_game&quot;) due to 1 previous error 错误的核心表明这里有 不匹配的类型（mismatched types）。Rust 有一个静态强类型系统，同时也有类型推断。当我们写出 let guess = String::new() 时，Rust 推断出 guess 应该是 String 类型，并不需要我们写出类型。另一方面，secret_number，是数字类型。几个数字类型拥有 1 到 100 之间的值：32 位数字 i32；32 位无符号数字 u32；64 位数字 i64 等等。Rust 默认使用 i32，所以它是 secret_number 的类型，除非增加类型信息，或任何能让 Rust 推断出不同数值类型的信息。这里错误的原因在于 Rust 不会比较字符串类型和数字类型。 所以我们必须把从输入中读取到的 String 转换为一个数字类型，才好与秘密数字进行比较。这可以通过在 main 函数体中增加如下代码来实现： 1234567891011121314151617// --snip--let mut guess = String::new();io::stdin() .read_line(&amp;mut guess) .expect(&quot;Failed to read line&quot;);let guess: u32 = guess.trim().parse().expect(&quot;Please type a number!&quot;);println!(&quot;You guessed: {guess}&quot;);match guess.cmp(&amp;secret_number) { Ordering::Less =&gt; println!(&quot;Too small!&quot;), Ordering::Greater =&gt; println!(&quot;Too big!&quot;), Ordering::Equal =&gt; println!(&quot;You win!&quot;),} 这行新代码是： 1let guess: u32 = guess.trim().parse().expect(&quot;Please type a number!&quot;); 这里创建了一个叫做 guess 的变量。不过等等，不是已经有了一个叫做 guess 的变量了吗？确实如此，不过 Rust 允许用一个新值来 遮蔽 （Shadowing） guess 之前的值。这个功允许我们复用 guess 变量的名字，而不是被迫创建两个不同变量，诸如 guess_str 和 guess 之类。[第三章](./03.1 变量与可变性)会介绍 shadowing 的更多细节，现在只需知道这个功能经常用于将一个类型的值转换为另一个类型的值。 我们将这个新变量绑定到 guess.trim().parse() 表达式上。表达式中的 guess 指的是包含输入的字符串类型 guess 变量。String 实例的 trim 方法会 去除字符串开头和结尾的空白字符 ，我们必须执行此方法才能将字符串与 u32 比较，因为 u32 只能包含数值型数据。用户必须输入 enter 键才能让 read_line 返回并输入他们的猜想，这将会在字符串中 增加一个换行（newline）符 。例如，用户输入 5 并按下 enter（在 Windows 上，按下 enter 键会得到一个回车符和一个换行符，\\r\\n），guess 看起来像这样：5\\n 或者 5\\r\\n。\\n 代表 “换行”，回车键；\\r 代表 “回车”，回车键。trim 方法会消除 \\n 或者 \\r\\n，结果只留下 5。 字符串的 parse 方法 将字符串转换成其他类型。这里用它来把字符串转换为数值。我们需要告诉 Rust 具体的数字类型，这里通过 let guess: u32 指定。guess 后面的冒号（:）告诉 Rust 我们指定了变量的类型。Rust 有一些内建的数字类型；u32 是一个无符号的 32 位整型。对于不大的正整数来说，它是不错的默认类型，[第三章](./03.2 数据类型)还会讲到其他数字类型。 另外，程序中的 u32 注解以及与 secret_number 的比较，意味着 Rust 会推断出 secret_number 也是 u32 类型。现在可以使用相同类型比较两个值了！ parse 方法只有在字符逻辑上可以转换为数字的时候才能工作，所以非常容易出错。例如，字符串中包含 A👍%，就无法将其转换为一个数字。因此，parse 方法返回一个 Result 类型。像之前 [“使用 Result 类型来处理潜在的错误”](# 使用 Result 类型来处理潜在的错误) 讨论的 read_line 方法那样，再次按部就班的用 expect 方法处理即可。如果 parse 不能从字符串生成一个数字，返回一个 Result 的 Err 成员时，expect 会使游戏崩溃并打印附带的信息。如果 parse 成功地将字符串转换为一个数字，它会返回 Result 的 Ok 成员，然后 expect 会返回 Ok 值中的数字。 现在让我们运行程序！ 12345678910$ cargo run Compiling guessing_game v0.1.0 (file:///projects/guessing_game) Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.26s Running `target/debug/guessing_game`Guess the number!The secret number is: 58Please input your guess. 76You guessed: 76Too big! 漂亮！即便是在猜测之前添加了空格，程序依然能判断出用户猜测了 76。多运行程序几次，输入不同的数字来检验不同的行为：猜一个正确的数字，猜一个过大的数字和猜一个过小的数字。 现在游戏已经大体上能玩了，不过用户只能猜一次。增加一个循环来改变它吧！ 使用循环来允许多次猜测loop 关键字创建了一个无限循环。我们会增加循环来给用户更多机会猜数字： 12345678910111213141516 // --snip-- println!(&quot;The secret number is: {secret_number}&quot;); loop { println!(&quot;Please input your guess.&quot;); // --snip-- match guess.cmp(&amp;secret_number) { Ordering::Less =&gt; println!(&quot;Too small!&quot;), Ordering::Greater =&gt; println!(&quot;Too big!&quot;), Ordering::Equal =&gt; println!(&quot;You win!&quot;), } }} 如上所示，我们将提示用户猜测之后的所有内容移动到了循环中。确保 loop 循环中的代码多缩进四个空格，再次运行程序。注意这里有一个新问题，程序现在会不断地要求用户输入新的猜测。用户好像无法退出啊！ 猜测正确后退出让我们增加一个 break 语句，在用户猜对时退出游戏： 123456789101112 // --snip-- match guess.cmp(&amp;secret_number) { Ordering::Less =&gt; println!(&quot;Too small!&quot;), Ordering::Greater =&gt; println!(&quot;Too big!&quot;), Ordering::Equal =&gt; { println!(&quot;You win!&quot;); break; } } }} 通过在 You win! 之后增加一行 break，用户猜对了神秘数字后会退出循环。退出循环也意味着退出程序，因为循环是 main 的最后一部分。 处理无效输入为了进一步改善游戏性，不要在用户输入非数字时崩溃，需要忽略非数字，让用户可以继续猜测。可以通过修改 guess 将 String 转化为 u32 那部分代码来实现： 1234567891011121314// --snip--io::stdin() .read_line(&amp;mut guess) .expect(&quot;Failed to read line&quot;);let guess: u32 = match guess.trim().parse() { Ok(num) =&gt; num, Err(_) =&gt; continue,};println!(&quot;You guessed: {guess}&quot;);// --snip-- 我们将 expect 调用换成 match 语句，以从遇到错误就崩溃转换为处理错误。须知 parse 返回一个 Result 类型，而 Result 是一个拥有 Ok 或 Err 成员的枚举。这里使用的 match 表达式，和之前处理 cmp 方法返回 Ordering 时用的一样。 如果 parse 能够成功地将字符串转换为一个数字，它会返回一个包含结果数字的 Ok。这个 Ok 值与 match 第一个分支的模式相匹配，该分支对应的动作返回 Ok 值中的数字 num，最后如愿变成新创建的 guess 变量。 如果 parse 不能将字符串转换为一个数字，它会返回一个包含更多错误信息的 Err。Err 值不能匹配第一个 match 分支的 Ok(num) 模式，但是会匹配第二个分支的 Err(_) 模式：_ 是一个通配符值，本例中用来匹配所有 Err 值，不管其中有何种信息。所以程序会执行第二个分支的动作，continue 意味着进入 loop 的下一次循环，请求另一个猜测。这样程序就有效的忽略了 parse 可能遇到的所有错误！ 现在程序中的一切都应该如预期般工作了。让我们试试吧： 1234567891011121314151617181920$ cargo run Compiling guessing_game v0.1.0 (file:///projects/guessing_game) Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.13s Running `target/debug/guessing_game`Guess the number!The secret number is: 61Please input your guess.10You guessed: 10Too small!Please input your guess.99You guessed: 99Too big!Please input your guess.fooPlease input your guess.61You guessed: 61You win! 太棒了！再有最后一个小的修改，就能完成猜数字游戏了：还记得程序依然会打印出秘密数字。在测试时还好，但正式发布时会毁了游戏体验。删掉打印秘密数字的 println!。 123456789101112131415161718192021222324252627282930313233343536use std::cmp::Ordering;use std::io;use rand::Rng;fn main() { println!(&quot;Guess the number!&quot;); let secret_number = rand::thread_rng().gen_range(1..=100); loop { println!(&quot;Please input your guess.&quot;); let mut guess = String::new(); io::stdin() .read_line(&amp;mut guess) .expect(&quot;Failed to read line&quot;); let guess: u32 = match guess.trim().parse() { Ok(num) =&gt; num, Err(_) =&gt; continue, }; println!(&quot;You guessed: {guess}&quot;); match guess.cmp(&amp;secret_number) { Ordering::Less =&gt; println!(&quot;Too small!&quot;), Ordering::Greater =&gt; println!(&quot;Too big!&quot;), Ordering::Equal =&gt; { println!(&quot;You win!&quot;); break; } } }} 此时此刻，你顺利完成了猜数字游戏。恭喜！ 总结本项目通过动手实践，向你介绍了 Rust 新概念：let、match、函数、使用外部 crate 等等，接下来的几章，你会继续深入学习这些概念。第三章介绍大部分编程语言都有的概念，比如变量、数据类型和函数，以及如何在 Rust 中使用它们。第四章探索所有权（ownership），这是一个 Rust 同其他语言大不相同的特性。第五章讨论结构体和方法的语法，而第六章解释枚举。","link":"/2025/05/16/Rust/The%20Rust%20Programming%20Language/02%20%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E7%8C%9C%E6%95%B0%E6%B8%B8%E6%88%8F/"},{"title":"3.4 注释","text":"注释在 Rust 中，惯用的注释样式是以两个斜杠开始注释，并持续到本行的结尾。对于超过一行的注释，需要在每一行前都加上 //，像这样： 123// So we’re doing something complicated here, long enough that we need// multiple lines of comments to do it! Whew! Hopefully, this comment will// explain what’s going on. 注释也可以放在包含代码的行的末尾： 123fn main() { let lucky_number = 7; // I'm feeling lucky today} 不过你更经常看到的是以这种格式使用它们，也就是位于它所解释的代码行的上面一行： 1234fn main() { // I'm feeling lucky today let lucky_number = 7;} Rust 还有另一种注释，称为文档注释，我们将在 14 章的 [“将 crate 发布到 Crates.io” ](./14.2 将 crate 发布到 Crates.io)部分讨论它。","link":"/2025/05/17/Rust/The%20Rust%20Programming%20Language/03.4%20%E6%B3%A8%E9%87%8A/"},{"title":"3.2 数据类型","text":"数据类型在 Rust 中，每一个值都有一个特定 数据类型（data type），这告诉 Rust 它被指定为何种数据，以便明确数据处理方式。我们将看到两类数据类型子集：标量（scalar）和复合（compound）。 记住，Rust 是 静态类型（statically typed）语言，也就是说在编译时就必须知道所有变量的类型。根据值及其使用方式，编译器通常可以推断出我们想要用的类型。当多种类型均有可能时，比如第二章使用 parse 将 String 转换为数字时，必须增加类型注解，像这样： 1let guess: u32 = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;); 如果不像上面的代码这样添加类型注解 : u32，Rust 会显示如下错误，这说明编译器需要我们提供更多信息，来了解我们想要的类型： 12345678910111213141516$ cargo build Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)error[E0284]: type annotations needed --&gt; src/main.rs:2:9 |2 | let guess = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;); | ^^^^^ ----- type must be known at this point | = note: cannot satisfy `&lt;_ as FromStr&gt;::Err == _`help: consider giving `guess` an explicit type |2 | let guess: /* Type */ = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;); | ++++++++++++For more information about this error, try `rustc --explain E0284`.error: could not compile `no_type_annotations` (bin &quot;no_type_annotations&quot;) due to 1 previous error 你会看到其它数据类型的各种类型注解。 标量类型标量（scalar）类型代表一个单独的值。Rust 有四种基本的标量类型： 整型、浮点型、布尔类型和字符类型 。你可能在其他语言中见过它们。让我们深入了解它们在 Rust 中是如何工作的。 整型整型 是一个没有小数部分的数字。我们在第二章使用过 u32 整数类型。该类型声明表明，它关联的值应该是一个占据 32 比特位的无符号整数（有符号整数类型以 i 开头而不是 u）。表格展示了 Rust 内建的整数类型。我们可以使用其中的任一个来声明一个整数值的类型。 长度 有符号 无符号 8-bit i8 u8 16-bit i16 u16 32-bit i32 u32 64-bit i64 u64 128-bit i128 u128 架构相关 isize usize 另外，isize 和 usize 类型依赖运行程序的计算机架构：64 位架构上它们是 64 位的，32 位架构上它们是 32 位的。 可以使用表格中的任何一种形式编写数字字面值。请注意可以是多种数字类型的数字字面值允许使用类型后缀，例如 57u8 来指定类型，同时也允许使用 _ 做为分隔符以方便读数，例如1_000，它的值与你指定的 1000 相同。 数字字面值 例子 Decimal (十进制) 98_222 Hex (十六进制) 0xff Octal (八进制) 0o77 Binary (二进制) 0b1111_0000 Byte (单字节字符)(仅限于u8) b'A' Rust 的默认整型默认是 i32。isize 或 usize 主要作为某些集合的索引。 整型溢出比方说有一个 u8 ，它可以存放从零到 255 的值。那么当你将其修改为 256 时就会发生 整型溢出（integer overflow ），这会导致以下两种行为之一的发生。当在 debug 模式编译时，Rust 检查这类问题并使程序 panic。panic 这个术语被 Rust 用来表明程序因错误而退出。第九章会详细介绍 panic。 使用 --release flag 在 release 模式中构建时，Rust 不会检测会导致 panic 的整型溢出。相反发生整型溢出时，Rust 会进行一种被称为二进制补码 wrapping（two’s complement wrapping）的操作。简而言之，比此类型能容纳最大值还大的值会 回绕到最小值 ，值 256 变成 0，值 257 变成 1，依此类推。程序不会 panic，不过变量可能也不会是你所期望的值。依赖整型溢出 wrapping 的行为被认为是一种错误。 为了显式地处理溢出的可能性，可以使用这几类标准库提供的原始数字类型方法： 所有模式下都可以使用 wrapping_* 方法进行 wrapping，如 wrapping_add 如果 checked_* 方法出现溢出，则返回 None值 用 overflowing_* 方法返回值和一个布尔值，表示是否出现溢出 用 saturating_* 方法在值的最小值或最大值处进行饱和处理 浮点型Rust 有两个原生的 浮点数（floating-point numbers）类型，它们是带小数点的数字。Rust 的浮点数类型是 f32 和 f64，分别占 32 位和 64 位。默认类型是 f64，因为在现代 CPU 中，它与 f32 速度几乎一样，不过精度更高。所有的浮点型都是有符号的。 12345fn main() { let x = 2.0; // f64 let y: f32 = 3.0; // f32} 浮点数采用 IEEE-754 标准表示。（f32 是单精度浮点数，f64 是双精度浮点数。） 数值运算Rust 中的所有数字类型都支持基本数学运算：加法、减法、乘法、除法和取余。整数除法会向零舍入到最接近的整数。下面的代码展示了如何在 let 语句中使用各种数值运算： 1234567891011121314151617fn main() { // addition let sum = 5 + 10; // subtraction let difference = 95.5 - 4.3; // multiplication let product = 4 * 30; // division let quotient = 56.7 / 32.2; let truncated = -5 / 3; // 结果为 -1 // remainder let remainder = 43 % 5;} 这些语句中的每个表达式使用了一个数学运算符并计算出了一个值，然后绑定给一个变量。[附录 B](./22.2 B) 包含 Rust 提供的所有运算符的列表。 布尔类型如其他大部分编程语言一样，Rust 中的布尔类型有两个可能的值：true 和 false。Rust 中的布尔类型使用 bool 表示。例如： 12345fn main() { let t = true; let f: bool = false; // with explicit type annotation} 使用布尔值的主要场景是条件表达式，例如 if 表达式。在 [“控制流”（“Control Flow”）](./03.5 控制流) 部分将介绍 if 表达式在 Rust 中如何工作。 字符类型Rust 的 char 类型是语言中最原始的字母类型。下面是一些声明 char 值的例子： 12345fn main() { let c = 'z'; let z: char = 'ℤ'; // with explicit type annotation let heart_eyed_cat = '😻';} 注意，我们用 单引号 声明 char 字面值，而与之相反的是，使用 双引号声明字符串 字面值。Rust 的 char 类型的大小为 四个字节 (four bytes)，并代表了一个 Unicode 标量值（Unicode Scalar Value），这意味着它可以比 ASCII 表示更多内容。在 Rust 中，带变音符号的字母（Accented letters），中文、日文、韩文等字符，emoji（绘文字）以及零长度的空白字符都是有效的 char 值。Unicode 标量值包含从 U+0000 到 U+D7FF 和 U+E000 到 U+10FFFF 在内的值。不过，“字符” 并不是一个 Unicode 中的概念，所以人直觉上的 “字符” 可能与 Rust 中的 char 并不符合。第八章的 [“使用字符串储存 UTF-8 编码的文本”](./08.2 使用字符串储存 UTF-8 编码的文本) 中将详细讨论这个主题。 复合类型复合类型（Compound types）可以将多个值组合成一个类型。Rust 有两个原生的复合类型：元组（tuple）和数组（array）。 元组类型元组是一个将多个不同类型的值组合进一个复合类型的主要方式。元组长度固定：一旦声明，其 长度不会增大或缩小 。 我们使用包含在圆括号中的逗号分隔的值列表来创建一个元组。元组中的每一个位置都有一个类型，而且这些不同值的类型也不必是相同的。这个例子中使用了可选的类型注解： 123fn main() { let tup: (i32, f64, u8) = (500, 6.4, 1);} tup 变量绑定到整个元组上，因为元组是一个单独的复合元素。为了从元组中获取单个值，可以使用模式匹配（pattern matching）来解构（destructure）元组值，像这样： 1234567fn main() { let tup = (500, 6.4, 1); let (x, y, z) = tup; println!(&quot;The value of y is: {y}&quot;);} 程序首先创建了一个元组并绑定到 tup 变量上。接着使用了 let 和一个模式将 tup 分成了三个不同的变量，x、y 和 z。这叫做 解构（destructuring），因为它将一个元组拆成了三个部分。最后，程序打印出了 y 的值，也就是 6.4。 我们也可以使用点号（.）后跟值的索引来直接访问所需的元组元素。例如： 123456789fn main() { let x: (i32, f64, u8) = (500, 6.4, 1); let five_hundred = x.0; let six_point_four = x.1; let one = x.2;} 这个程序创建了一个元组，x，然后使用其各自的索引访问元组中的每个元素。跟大多数编程语言一样，元组的第一个索引值是 0。 不带任何值的元组有个特殊的名称，叫做 单元（unit） 元组。这种值以及对应的类型都写作 ()，表示空值或空的返回类型。如果 表达式不返回任何其他值，则会隐式返回单元值 。 数组类型另一个包含多个值的方式是 数组（array）。与元组不同，数组中的每个元素的类型必须相同。Rust 中的数组与一些其他语言中的数组不同，Rust 中的 数组长度是固定的 。 我们将数组的值写成在方括号内，用逗号分隔的列表： 123fn main() { let a = [1, 2, 3, 4, 5];} 当你想要在栈（stack）而不是在堆（heap）上为数据分配空间（[第四章](./04.1 什么是所有权)将讨论栈与堆的更多内容），或者是想要确保总是有固定数量的元素时，数组非常有用。但是数组并不如 vector 类型灵活。vector 类型是标准库提供的一个 允许增长和缩小长度 的类似数组的集合类型。当不确定是应该使用数组还是 vector 的时候，那么很可能应该使用 vector。[第八章](./08.1 使用 Vector 储存列表)会详细讨论 vector。 然而，当你确定元素个数不会改变时，数组会更有用。例如，当你在一个程序中使用月份名字时，你更应趋向于使用数组而不是 vector，因为你确定只会有 12 个元素。 12let months = [&quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;, &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;]; 可以像这样编写数组的类型：在方括号中包含每个元素的类型，后跟分号，再后跟数组元素的数量。 1let a: [i32; 5] = [1, 2, 3, 4, 5]; 这里，i32 是每个元素的类型。分号之后，数字 5 表明该数组包含五个元素。 你还可以通过在方括号中指定初始值加分号再加元素个数的方式来创建一个每个元素都为相同值的数组： 1let a = [3; 5]; 变量名为 a 的数组将包含 5 个元素，这些元素的值最初都将被设置为 3。这种写法与 let a = [3, 3, 3, 3, 3]; 效果相同，但更简洁。 访问数组元素数组是可以在栈 (stack) 上分配的已知固定大小的单个内存块。可以使用索引来访问数组的元素，像这样： 123456fn main() { let a = [1, 2, 3, 4, 5]; let first = a[0]; let second = a[1];} 在这个例子中，叫做 first 的变量的值是 1，因为它是数组索引 [0] 的值。变量 second 将会是数组索引 [1] 的值 2。 无效的数组元素访问让我们看看如果我们访问数组结尾之后的元素会发生什么呢？比如你执行以下代码，它使用类似于第 2 章中的猜数字游戏的代码从用户那里获取数组索引： 12345678910111213141516171819202122use std::io;fn main() { let a = [1, 2, 3, 4, 5]; println!(&quot;Please enter an array index.&quot;); let mut index = String::new(); io::stdin() .read_line(&amp;mut index) .expect(&quot;Failed to read line&quot;); let index: usize = index .trim() .parse() .expect(&quot;Index entered was not a number&quot;); let element = a[index]; println!(&quot;The value of the element at index {index} is: {element}&quot;);} 此代码编译成功。如果您使用 cargo run 运行此代码并输入 0、1、2、3 或 4，程序将在数组中的索引处打印出相应的值。如果你输入一个超过数组末端的数字，如 10，你会看到这样的输出： 123thread 'main' panicked at src/main.rs:19:19:index out of bounds: the len is 5 but the index is 10note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace 程序在索引操作中使用一个无效的值时导致 运行时 错误。程序带着错误信息退出，并且没有执行最后的 println! 语句。当尝试用索引访问一个元素时，Rust 会检查指定的索引是否小于数组的长度。如果索引超出了数组长度，Rust 会 panic，这是 Rust 术语，它用于程序因为错误而退出的情况。这种检查必须在运行时进行，特别是在这种情况下，因为编译器不可能知道用户在以后运行代码时将输入什么值。","link":"/2025/05/17/Rust/The%20Rust%20Programming%20Language/03.2%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"title":"4.1 什么是所有权","text":"什么是所有权？所有权（ownership）是 Rust 用于如何管理内存的一组规则。所有程序都必须管理其运行时使用计算机内存的方式。一些语言中具有垃圾回收机制，在程序运行时有规律地寻找不再使用的内存；在另一些语言中，程序员必须亲自分配和释放内存。Rust 则选择了第三种方式： 通过所有权系统管理内存 ，编译器在编译时会根据一系列的规则进行检查。如果违反了任何这些规则，程序都不能编译。在运行时，所有权系统的任何功能都不会减慢程序的运行。 栈（Stack）与堆（Heap）在很多语言中，你并不需要经常考虑到栈与堆。不过在像 Rust 这样的系统编程语言中，值是位于栈上还是堆上在更大程度上影响了语言的行为以及为何必须做出这样的抉择。我们会在本章的稍后部分描述所有权与栈和堆相关的内容，所以这里只是一个用来预热的简要解释。 栈和堆都是代码在运行时可供使用的内存，但是它们的结构不同。栈以放入值的顺序存储值并以相反顺序取出值。这也被称作 后进先出（last in, first out）。增加数据叫做 入栈（pushing onto the stack），而移出数据叫做 出栈（popping off the stack）。栈中的所有数据都必须占用 已知且固定的大小 。在编译时大小未知或大小可能变化的数据，要改为存储在堆上。 堆是缺乏组织的：当向堆放入数据时，你要请求一定大小的空间。内存分配器（memory allocator）在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的 指针（pointer）。这个过程称作 在堆上分配内存（allocating on the heap），有时简称为 “分配”（allocating）。（将数据推入栈中并不被认为是分配）。因为指向放入堆中数据的指针是已知的并且大小是固定的，你可以将该指针存储在栈上，不过当需要实际数据时，必须访问指针。 所有权规则首先，让我们看一下所有权的规则。当我们通过举例说明时，请谨记这些规则： Rust 中的每一个值都有一个 所有者（owner）。 值在任一时刻有且只有一个所有者。 当所有者离开作用域，这个值将被丢弃。 变量作用域在所有权的第一个例子中，我们看看一些变量的 作用域（scope）。作用域是一个项（item）在程序中有效的范围。假设有这样一个变量： 1let s = &quot;hello&quot;; 变量 s 绑定到了一个字符串字面值，这个字符串值是硬编码进程序代码中的。这个变量从声明的点开始直到当前作用域结束时都是有效的。示例 4-1 中的注释标明了变量 s 在何处是有效的。 12345{ // s 在这里无效，它尚未声明 let s = &quot;hello&quot;; // 从此处起，s 是有效的 // 使用 s} // 此作用域已结束，s 不再有效 换句话说，这里有两个重要的时间点： 当 s 进入作用域时，它就是有效的。 这一直持续到它离开作用域为止。 目前为止，变量是否有效与作用域的关系跟其他编程语言是类似的。现在我们在此基础上介绍 String 类型。 String 类型为了演示所有权的规则，我们需要一个比第三章 [“数据类型”](./03.2 数据类型) 中讲到的都要复杂的数据类型。前面介绍的类型都是已知大小的，可以存储在栈中，并且当离开作用域时被移出栈，如果代码的另一部分需要在不同的作用域中使用相同的值，可以快速简单地复制它们来创建一个新的独立实例。不过我们需要寻找一个存储在 堆 上的数据来探索 Rust 是如何知道该在何时清理数据的，而 String 类型就是一个很好的例子。 我们会专注于 String 与所有权相关的部分。这些方面也同样适用于标准库提供的或你自己创建的其他复杂数据类型。在[第八章](./08.2 使用字符串储存 UTF-8 编码的文本)会更深入地讲解 String。 我们已经见过字符串字面值，即被硬编码进程序里的字符串值。字符串字面值是很方便的，不过它们并不适合使用文本的每一种场景。原因之一就是它们是不可变的。另一个原因是并非所有字符串的值都能在编写代码时就知道：例如，要是想获取用户输入并存储该怎么办呢？为此，Rust 有另一种字符串类型，String。这个类型管理被分配到堆上的数据，所以能够存储在编译时未知大小的文本。 可以使用 from 函数基于字符串字面值来创建 String ，如下： 这两个冒号 :: 是运算符，允许将特定的 from 函数置于 String 类型的命名空间（namespace）下，而不需要使用类似 string_from 这样的名字。在第五章的 [“方法语法”（“Method Syntax”）](./05.3 方法语法) 部分会着重讲解这个语法，而且在第七章的 [“路径用于引用模块树中的项”](./07.3 引用模块项目的路径) 中会讲到模块的命名空间。 12345let mut s = String::from(&quot;hello&quot;);s.push_str(&quot;, world!&quot;); // push_str() 在字符串后追加字面值println!(&quot;{s}&quot;); // 将打印 `hello, world!` 那么这里有什么区别呢？为什么 String 可变而字面值却不行呢？区别在于两个类型对内存的处理上。 内存与分配就字符串字面值来说，我们在编译时就知道其内容，所以文本被直接硬编码进最终的可执行文件中。这使得字符串字面值快速且高效。不过这些特性都只得益于字符串字面值的不可变性。不幸的是，我们不能为了每一个在编译时大小未知的文本而将一块内存放入二进制文件中，并且它的大小还可能随着程序运行而改变。 对于 String 类型，为了支持一个可变，可增长的文本片段，需要在堆上分配一块在编译时未知大小的内存来存放内容。这意味着： 必须在运行时向内存分配器（memory allocator）请求内存。 需要一个当我们处理完 String 时将内存返回给分配器的方法。 第一部分由我们完成：当调用 String::from 时，它的实现 (implementation) 请求其所需的内存。这在编程语言中是非常通用的。 然而，第二部分实现起来就各有区别了。在有 垃圾回收（garbage collector，GC）的语言中，GC 记录并清除不再使用的内存，而我们并不需要关心它。在大部分没有 GC 的语言中，识别出不再使用的内存并调用代码显式释放就是我们的责任了，跟请求内存的时候一样。从历史的角度上说正确处理内存回收曾经是一个困难的编程问题。如果忘记回收了会浪费内存。如果过早回收了，将会出现无效变量。如果重复回收，这也是个 bug。我们需要精确的为一个 allocate 配对一个 free。 Rust 采取了一个不同的策略：内存在拥有它的变量离开作用域后就被自动释放。下面是示例 4-1 中作用域例子的一个使用 String 而不是字符串字面值的版本： 123456{ let s = String::from(&quot;hello&quot;); // 从此处起，s 是有效的 // 使用 s} // 此作用域已结束， // s 不再有效 这是一个将 String 需要的内存返回给分配器的很自然的位置：当 s 离开作用域的时候。当变量离开作用域，Rust 为我们调用一个特殊的函数。这个函数叫做 drop，在这里 String 的作者可以放置释放内存的代码。Rust 在结尾的 } 处自动调用 drop。 注意：在 C++ 中，这种 item 在生命周期结束时释放资源的模式有时被称作 资源获取即初始化（*Resource Acquisition Is Initialization (RAII)*）。如果你使用过 RAII 模式的话应该对 Rust 的 drop 函数并不陌生。 这个模式对编写 Rust 代码的方式有着深远的影响。现在它看起来很简单，不过在更复杂的场景下代码的行为可能是不可预测的，比如当有多个变量使用在堆上分配的内存时。现在让我们探索一些这样的场景。 使用移动的变量与数据交互在 Rust 中，多个变量可以采取不同的方式与同一数据进行交互。让我们看看示例 4-2 中一个使用整型的例子。 12let x = 5;let y = x; 我们大致可以猜到这在干什么：“将 5 绑定到 x；接着生成一个值 x 的拷贝并绑定到 y”。现在有了两个变量，x 和 y，都等于 5。这也正是事实上发生了的，因为整数是有已知固定大小的简单值，所以这两个 5 被压入了栈中。 现在看看这个 String 版本： 12let s1 = String::from(&quot;hello&quot;);let s2 = s1; 这看起来与上面的代码非常类似，所以我们可能会假设它们的运行方式也是类似的：也就是说，第二行可能会生成一个 s1 的拷贝并绑定到 s2 上。但事实并非如此。 看看图 4-1 以了解 String 的底层会发生什么。String 由三部分组成，如图左侧所示：一个指向存放字符串内容内存的指针，一个长度，和一个容量。这一组数据存储在栈上。右侧则是堆上存放内容的内存部分。 长度表示 String 的内容当前使用了多少字节的内存。容量是 String 从分配器总共获取了多少字节的内存。长度与容量的区别是很重要的，不过在当前上下文中并不重要，所以现在可以忽略容量。 当我们将 s1 赋值给 s2，String 的数据被复制了，这意味着我们从栈上拷贝了它的指针、长度和容量。我们并没有复制指针指向的堆上数据。换句话说，内存中数据的表现如图 4-2 所示。 这个表现形式看起来并不像图 4-3 中的那样，如果 Rust 也拷贝了堆上的数据，那么内存看起来就是这样的。如果 Rust 这么做了，那么操作 s2 = s1 在堆上数据比较大的时候会对运行时性能造成非常大的影响。 之前我们提到过当变量离开作用域后，Rust 自动调用 drop 函数并清理变量的堆内存。不过图 4-2 展示了两个数据指针指向了同一位置。这就有了一个问题：当 s2 和 s1 离开作用域，它们都会尝试释放相同的内存。这是一个叫做 二次释放（double free）的错误，也是之前提到过的内存安全性 bug 之一。两次释放（相同）内存会导致内存污染，它可能会导致潜在的安全漏洞。 为了确保内存安全，在 let s2 = s1; 之后，Rust 认为 s1 不再有效，因此 Rust 不需要在 s1 离开作用域后清理任何东西。看看在 s2 被创建之后尝试使用 s1 会发生什么；这段代码不能运行： 1234let s1 = String::from(&quot;hello&quot;);let s2 = s1;println!(&quot;{s1}, world!&quot;); 你会得到一个类似如下的错误，因为 Rust 禁止你使用无效的引用。 12345678910111213141516171819202122$ cargo run Compiling ownership v0.1.0 (file:///projects/ownership)error[E0382]: borrow of moved value: `s1` --&gt; src/main.rs:5:15 |2 | let s1 = String::from(&quot;hello&quot;); | -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait3 | let s2 = s1; | -- value moved here4 |5 | println!(&quot;{s1}, world!&quot;); | ^^^^ value borrowed here after move | = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)help: consider cloning the value if the performance cost is acceptable |3 | let s2 = s1.clone(); | ++++++++For more information about this error, try `rustc --explain E0382`.error: could not compile `ownership` (bin &quot;ownership&quot;) due to 1 previous error 如果你在其他语言中听说过术语 浅拷贝（shallow copy）和 深拷贝（deep copy），那么拷贝指针、长度和容量而不拷贝数据可能听起来像浅拷贝。不过因为 Rust 同时使第一个变量无效了，这个操作被称为 移动（move），而不是叫做浅拷贝。上面的例子可以解读为 s1 被 移动 到了 s2 中。那么具体发生了什么，如图 4-4 所示。 这样就解决了我们的问题！因为只有 s2 是有效的，当其离开作用域，它就释放自己的内存，完毕。 另外，这里还隐含了一个设计选择： Rust 永远也不会自动创建数据的 “深拷贝” 。因此，任何自动的复制都可以被认为是对运行时性能影响较小的。 作用域与赋值作用域、所有权和通过 drop 函数释放内存之间的关系反过来也同样成立。当你给一个已有的变量赋一个全新的值时，Rust 将会立即调用 drop 并释放原始值的内存。例如，考虑如下代码： 1234let mut s = String::from(&quot;hello&quot;);s = String::from(&quot;ahoy&quot;);println!(&quot;{s}, world!&quot;); 起初我们声明了变量 s 并绑定为一个 &quot;hello&quot; 值的 String。接着立即创建了一个值为 &quot;ahoy&quot; 的 String 并赋值给 s。在这里，完全没有任何内容指向了原始堆上的值。 因此原始的字符串立刻就离开了作用域。Rust 会在其上运行 drop 函数同时内存会马上释放。当结尾打印其值时，将会是 &quot;ahoy, world!&quot;。 使用克隆的变量与数据交互如果我们 确实 需要深度复制 String 中堆上的数据，而不仅仅是栈上的数据，可以使用一个叫做 clone 的常用方法。第五章会讨论方法语法，不过因为方法在很多语言中是一个常见功能，所以之前你可能已经见过了。 这是一个实际使用 clone 方法的例子： 1234let s1 = String::from(&quot;hello&quot;);let s2 = s1.clone();println!(&quot;s1 = {s1}, s2 = {s2}&quot;); 这段代码能正常运行，并且明确产生图 4-3 中行为，这里堆上的数据确实被复制了。 当出现 clone 调用时，你知道一些特定的代码被执行而且这些代码可能 相当消耗资源 。你很容易察觉到一些不寻常的事情正在发生。 只在栈上的数据：拷贝这里还有一个没有提到的细节。这些代码使用了整型并且是有效的： 1234let x = 5;let y = x;println!(&quot;x = {x}, y = {y}&quot;); 但这段代码似乎与我们刚刚学到的内容相矛盾：没有调用 clone，不过 x 依然有效且没有被移动到 y 中。 原因是像整型这样的在编译时已知大小的类型被整个存储在栈上，所以拷贝其实际的值是快速的。这意味着没有理由在创建变量 y 后使 x 无效。换句话说，这里没有深浅拷贝的区别，所以这里调用 clone 并不会与通常的浅拷贝有什么不同，我们可以不用管它。 Rust 有一个叫做 Copy trait 的特殊注解，可以用在类似整型这样的存储在栈上的类型上（第十章将会详细讲解 trait）。如果一个类型实现了 Copy trait，那么一个旧的变量在将其赋值给其他变量后仍然有效。 Rust 不允许自身或其任何部分实现了 Drop trait 的类型使用 Copy trait。如果我们对其值离开作用域时需要特殊处理的类型使用 Copy 注解，将会出现一个编译时错误。要学习如何为你的类型添加 Copy 注解以实现该 trait，请阅读附录 C 中的 [“可派生的 trait”](./22.3 C)。 那么哪些类型实现了 Copy trait 呢？你可以查看给定类型的文档来确认，不过作为一个通用的规则，任何一组简单标量值的组合都可以实现 Copy，任何不需要分配内存或某种形式资源的类型都可以实现 Copy 。如下是一些 Copy 的类型： 所有整数类型，比如 u32。 布尔类型，bool，它的值是 true 和 false。 所有浮点数类型，比如 f64。 字符类型，char。 元组，当且仅当其包含的类型也都实现 Copy 的时候。比如，(i32, i32) 实现了 Copy，但 (i32, String) 就没有。 所有权与函数将值传递给函数与给变量赋值的原理相似。向函数传递值可能会移动或者复制，就像赋值语句一样。示例使用注释展示变量何时进入和离开作用域： 1234567891011121314151617181920212223fn main() { let s = String::from(&quot;hello&quot;); // s 进入作用域 takes_ownership(s); // s 的值移动到函数里 ... // ... 所以到这里不再有效 let x = 5; // x 进入作用域 makes_copy(x); // x 应该移动函数里， // 但 i32 是 Copy 的， println!(&quot;{}&quot;, x); // 所以在后面可继续使用 x} // 这里，x 先移出了作用域，然后是 s。但因为 s 的值已被移走， // 没有特殊之处fn takes_ownership(some_string: String) { // some_string 进入作用域 println!(&quot;{some_string}&quot;);} // 这里，some_string 移出作用域并调用 `drop` 方法。 // 占用的内存被释放fn makes_copy(some_integer: i32) { // some_integer 进入作用域 println!(&quot;{some_integer}&quot;);} // 这里，some_integer 移出作用域。没有特殊之处 当尝试在调用 takes_ownership 后使用 s 时，Rust 会抛出一个编译时错误。这些静态检查使我们免于犯错。试试在 main 函数中添加使用 s 和 x 的代码来看看哪里能使用它们，以及所有权规则会在哪里阻止我们这么做。 返回值与作用域返回值也可以转移所有权。示例展示了一个返回了某些值的示例。 12345678910111213141516171819202122232425fn main() { let s1 = gives_ownership(); // gives_ownership 将返回值移动给 s1 let s2 = String::from(&quot;hello&quot;); // s2 进入作用域 let s3 = takes_and_gives_back(s2); // s2 的值移动到 takes_and_gives_back 函数中， // 函数的返回值再移动给 s3} // 这里，s3 先移出作用域并被释放。s2 的值已被移走，因此没有操作。 // s1 随后移出作用域并被释放。fn gives_ownership() -&gt; String { // gives_ownership 会将返回值 // 移动给调用它的函数 let some_string = String::from(&quot;yours&quot;); // some_string 进入作用域 some_string // 返回 some_string 并移出作用域， // 给调用函数}// 该函数将传入字符串并返回该值fn takes_and_gives_back(a_string: String) -&gt; String { // a_string 进入作用域 a_string // 返回 a_string 并移出给调用的函数} 变量的所有权总是遵循相同的模式：将值赋给另一个变量时它会移动。当持有堆中数据值的变量离开作用域时，其值将通过 drop 被清理掉，除非数据被移动为另一个变量所有。 虽然这样是可以的，但是在每一个函数中都获取所有权并接着返回所有权有些啰嗦。如果我们想要函数使用一个值但不获取所有权该怎么办呢？如果我们还要接着使用它的话，每次都传进去再返回来就有点烦人了，除此之外，我们也可能想返回函数体中产生的一些数据。 我们可以使用元组来返回多个值，如示例所示。 12345678910111213fn main() { let s1 = String::from(&quot;hello&quot;); let (s2, len) = calculate_length(s1); println!(&quot;The length of '{s2}' is {len}.&quot;);}fn calculate_length(s: String) -&gt; (String, usize) { let length = s.len(); // len() 返回字符串的长度 (s, length)} 但是这未免有些形式主义，而且这种场景应该很常见。幸运的是，Rust 对此提供了一个不用获取所有权就可以使用值的功能，叫做 引用（references）。","link":"/2025/05/19/Rust/The%20Rust%20Programming%20Language/04.1%20%E4%BB%80%E4%B9%88%E6%98%AF%E6%89%80%E6%9C%89%E6%9D%83/"},{"title":"4.2 引用与借用","text":"引用与借用12345678910111213fn main() { let s1 = String::from(&quot;hello&quot;); let (s2, len) = calculate_length(s1); println!(&quot;The length of '{s2}' is {len}.&quot;);}fn calculate_length(s: String) -&gt; (String, usize) { let length = s.len(); // len() 返回字符串的长度 (s, length)} 示例中的元组代码有这样一个问题：我们必须将 String 返回给调用函数，以便在调用 calculate_length 后仍能使用 String，因为 String 被移动到了 calculate_length 内。相反我们可以提供一个 String 值的引用（reference）。引用（reference）像一个指针，因为它是一个地址，我们可以由此访问储存于该地址的属于其他变量的数据。与指针不同，引用在其生命周期内保证指向某个特定类型的有效值。 下面是如何定义并使用一个（新的）calculate_length 函数，它以一个对象的引用作为参数而不是获取值的所有权： 1234567891011fn main() { let s1 = String::from(&quot;hello&quot;); let len = calculate_length(&amp;s1); println!(&quot;The length of '{s1}' is {len}.&quot;);}fn calculate_length(s: &amp;String) -&gt; usize { s.len()} 首先，注意变量声明和函数返回值中的所有元组代码都消失了。其次，注意我们传递 &amp;s1 给 calculate_length，同时在函数定义中，我们获取 &amp;String 而不是 String。这些 &amp; 符号就是 引用，它们允许你使用值但不获取其所有权。图 4-6 展示了一张示意图。 注意：与使用 &amp; 引用相反的操作是 解引用（dereferencing），它使用解引用运算符 * 实现。我们将会在第八章遇到一些解引用运算符，并在第十五章详细讨论解引用。 仔细看看这个函数调用： 123let s1 = String::from(&quot;hello&quot;);let len = calculate_length(&amp;s1); &amp;s1 语法让我们创建一个指向值 s1 的引用，但是并不拥有它。因为并不拥有这个值，所以当引用停止使用时，它所指向的值也不会被丢弃。 同理，函数签名使用 &amp; 来表明参数 s 的类型是一个引用。让我们增加一些解释性的注释： 1234fn calculate_length(s: &amp;String) -&gt; usize { // s 是 String 的引用 s.len()} // 这里，s 离开了作用域。但因为它并不拥有引用值的所有权， // 所以什么也不会发生 变量 s 有效的作用域与函数参数的作用域一样，不过当 s 停止使用时并不丢弃引用指向的数据，因为 s 并没有所有权。当函数使用引用而不是实际值作为参数，无需返回值来交还所有权，因为就不曾拥有所有权。 我们将创建一个引用的行为称为 借用（borrowing）。正如现实生活中，如果一个人拥有某样东西，你可以从他那里借来。当你使用完后，必须还回去。因为我们并不拥有它的所有权。 那如果我们尝试修改借用的变量呢？尝试示例中的代码。剧透：这行不通！ 123456789fn main() { let s = String::from(&quot;hello&quot;); change(&amp;s);}fn change(some_string: &amp;String) { some_string.push_str(&quot;, world&quot;);} 这里是错误： 123456789101112131415$ cargo run Compiling ownership v0.1.0 (file:///projects/ownership)error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&amp;` reference --&gt; src/main.rs:8:5 |8 | some_string.push_str(&quot;, world&quot;); | ^^^^^^^^^^^ `some_string` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable |help: consider changing this to be a mutable reference |7 | fn change(some_string: &amp;mut String) { | +++For more information about this error, try `rustc --explain E0596`.error: could not compile `ownership` (bin &quot;ownership&quot;) due to 1 previous error 正如变量默认是不可变的，引用也一样。 （默认）不允许修改引用的值 。 可变引用我们通过一个小调整就能修复示例代码中的错误，允许我们修改一个借用的值，这就是 可变引用（mutable reference）： 123456789fn main() { let mut s = String::from(&quot;hello&quot;); change(&amp;mut s);}fn change(some_string: &amp;mut String) { some_string.push_str(&quot;, world&quot;);} 首先，我们必须将 s 改为 mut。然后在调用 change 函数的地方创建一个可变引用 &amp;mut s，并更新函数签名以接受一个可变引用 some_string: &amp;mut String。这就非常清楚地表明，change 函数将改变它所借用的值。 可变引用有一个很大的限制： 如果你有一个对该变量的可变引用，你就不能再创建对该变量的引用 。这些尝试创建两个 s 的可变引用的代码会失败： 123456let mut s = String::from(&quot;hello&quot;);let r1 = &amp;mut s;let r2 = &amp;mut s;println!(&quot;{}, {}&quot;, r1, r2); 错误如下： 123456789101112131415$ cargo run Compiling ownership v0.1.0 (file:///projects/ownership)error[E0499]: cannot borrow `s` as mutable more than once at a time --&gt; src/main.rs:5:14 |4 | let r1 = &amp;mut s; | ------ first mutable borrow occurs here5 | let r2 = &amp;mut s; | ^^^^^^ second mutable borrow occurs here6 |7 | println!(&quot;{}, {}&quot;, r1, r2); | -- first borrow later used hereFor more information about this error, try `rustc --explain E0499`.error: could not compile `ownership` (bin &quot;ownership&quot;) due to 1 previous error 这个报错说这段代码是无效的，因为我们不能在同一时间多次将 s 作为可变变量借用。第一个可变的借入在 r1 中，并且必须持续到在 println! 中使用它，但是在那个可变引用的创建和它的使用之间，我们又尝试在 r2 中创建另一个可变引用，该引用借用与 r1 相同的数据。 这一限制以一种非常小心谨慎的方式允许可变性，防止同一时间对同一数据存在多个可变引用。新 Rustacean 们经常难以适应这一点，因为大部分语言中变量任何时候都是可变的。这个限制的好处是 Rust 可以在编译时就避免数据竞争。数据竞争（data race）类似于竞态条件，它可由这三个行为造成： 两个或更多指针同时访问同一数据。 至少有一个指针被用来写入数据。 没有同步数据访问的机制。 数据竞争会导致未定义行为，难以在运行时追踪，并且难以诊断和修复；Rust 通过拒绝编译存在数据竞争的代码来避免此问题！ 一如既往，可以使用大括号来创建一个新的作用域，以允许拥有多个可变引用，只是不能同时拥有： 1234567let mut s = String::from(&quot;hello&quot;);{ let r1 = &amp;mut s;} // r1 在这里离开了作用域，所以我们完全可以创建一个新的引用let r2 = &amp;mut s; Rust 在同时使用可变与不可变引用时也强制采用类似的规则。这些代码会导致一个错误： 1234567let mut s = String::from(&quot;hello&quot;);let r1 = &amp;s; // 没问题let r2 = &amp;s; // 没问题let r3 = &amp;mut s; // 大问题println!(&quot;{}, {}, and {}&quot;, r1, r2, r3); 错误如下： 12345678910111213141516$ cargo run Compiling ownership v0.1.0 (file:///projects/ownership)error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable --&gt; src/main.rs:6:14 |4 | let r1 = &amp;s; // no problem | -- immutable borrow occurs here5 | let r2 = &amp;s; // no problem6 | let r3 = &amp;mut s; // BIG PROBLEM | ^^^^^^ mutable borrow occurs here7 |8 | println!(&quot;{}, {}, and {}&quot;, r1, r2, r3); | -- immutable borrow later used hereFor more information about this error, try `rustc --explain E0502`.error: could not compile `ownership` (bin &quot;ownership&quot;) due to 1 previous error 呼！我们也不能在拥有不可变引用的同时拥有可变引用。 不可变引用的借用者可不希望在借用时值会突然发生改变！然而，多个不可变引用是可以的，因为没有哪个只能读取数据的引用者能够影响其他引用者读取到的数据。 注意一个引用的作用域从声明的地方开始一直持续到最后一次使用为止。例如，因为最后一次使用不可变引用的位置在 println!，它发生在声明可变引用之前，所以如下代码是可以编译的： 123456789let mut s = String::from(&quot;hello&quot;);let r1 = &amp;s; // 没问题let r2 = &amp;s; // 没问题println!(&quot;{r1} and {r2}&quot;);// 此位置之后 r1 和 r2 不再使用let r3 = &amp;mut s; // 没问题println!(&quot;{r3}&quot;); 不可变引用 r1 和 r2 的作用域在 println! 最后一次使用之后结束，这发生在可变引用 r3 被创建之前。因为它们的作用域没有重叠，所以代码是可以编译的。编译器可以在作用域结束之前判断不再使用的引用。 尽管借用错误有时令人沮丧，但请牢记这是 Rust 编译器在提前指出一个潜在的 bug（在编译时而不是在运行时）并精准显示问题所在。这样你就不必去跟踪为何数据并不是你想象中的那样。 悬垂引用（Dangling References）在具有指针的语言中，很容易通过释放内存时保留指向它的指针而错误地生成一个悬垂指针（dangling pointer）—— 指向可能已被分配给其他用途的内存位置的指针。相比之下，在 Rust 中编译器确保引用永远也不会变成悬垂引用：当你拥有一些数据的引用，编译器确保数据不会在其引用之前离开作用域。 让我们尝试创建一个悬垂引用，看看 Rust 如何通过通过一个编译时错误来防止它： 123456789fn main() { let reference_to_nothing = dangle();}fn dangle() -&gt; &amp;String { let s = String::from(&quot;hello&quot;); &amp;s} 这里是错误： 12345678910111213141516171819202122232425262728$ cargo run Compiling ownership v0.1.0 (file:///projects/ownership)error[E0106]: missing lifetime specifier --&gt; src/main.rs:5:16 |5 | fn dangle() -&gt; &amp;String { | ^ expected named lifetime parameter | = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed fromhelp: consider using the `'static` lifetime, but this is uncommon unless you're returning a borrowed value from a `const` or a `static` |5 | fn dangle() -&gt; &amp;'static String { | +++++++help: instead, you are more likely to want to return an owned value |5 - fn dangle() -&gt; &amp;String {5 + fn dangle() -&gt; String { |error[E0515]: cannot return reference to local variable `s` --&gt; src/main.rs:8:5 |8 | &amp;s | ^^ returns a reference to data owned by the current functionSome errors have detailed explanations: E0106, E0515.For more information about an error, try `rustc --explain E0106`.error: could not compile `ownership` (bin &quot;ownership&quot;) due to 2 previous errors 错误信息引用了一个我们还未介绍的功能：生命周期（lifetimes）。第十章会详细介绍生命周期。不过，如果你不理会生命周期部分，错误信息中确实包含了为什么这段代码有问题的关键信息： 12this function's return type contains a borrowed value, but there is no valuefor it to be borrowed from 让我们仔细看看我们的 dangle 代码的每个阶段到底发生了什么： 1234567fn dangle() -&gt; &amp;String { // dangle 返回一个字符串的引用 let s = String::from(&quot;hello&quot;); // s 是一个新字符串 &amp;s // 返回字符串 s 的引用} // 这里 s 离开作用域并被丢弃。其内存被释放。 // 危险！ 因为 s 是在 dangle 函数内创建的，当 dangle 的代码执行完毕后，s 将被释放。不过我们尝试返回它的引用。这意味着这个引用会指向一个无效的 String，这可不对！Rust 不会允许我们这么做。 这里的解决方法是直接返回 String： 12345fn no_dangle() -&gt; String { let s = String::from(&quot;hello&quot;); s} 这样就没有任何错误了。所有权被移动出去，所以没有值被释放。 引用的规则让我们概括一下之前对引用的讨论： 在任意给定时间，要么只能有一个可变引用，要么只能有多个不可变引用。 引用必须总是有效的。 接下来，我们来看看另一种不同类型的引用：slice。","link":"/2025/05/20/Rust/The%20Rust%20Programming%20Language/04.2%20%E5%BC%95%E7%94%A8%E4%B8%8E%E5%80%9F%E7%94%A8/"},{"title":"5.1 结构体的定义和实例化","text":"结构体的定义和实例化结构体和我们在[“元组类型”](./03.2 数据类型)部分论过的元组类似，它们都包含多个相关的值。和元组一样，结构体的每一部分可以是不同类型。但不同于元组，结构体需要命名各部分数据以便能清楚的表明其值的意义。由于有了这些名字，结构体比元组更灵活：不需要依赖顺序来指定或访问实例中的值。 定义结构体，需要使用 struct 关键字并为整个结构体提供一个名字。结构体的名字需要描述它所组合的数据的意义。接着，在大括号中，定义每一部分数据的名字和类型，我们称为 字段（field）。例如，示例展示了一个存储用户账号信息的结构体： 123456struct User { active: bool, username: String, email: String, sign_in_count: u64,} 一旦定义了结构体后，为了使用它，通过为每个字段指定具体值来创建这个结构体的实例。创建一个实例需要以结构体的名字开头，接着在大括号中使用 key: value 键 - 值对的形式提供字段，其中 key 是字段的名字，value 是需要存储在字段中的数据值。实例中字段的顺序不需要和它们在结构体中声明的顺序一致。换句话说，结构体的定义就像一个类型的通用模板，而实例则会在这个模板中放入特定数据来创建这个类型的值。例如，可以像示例这样来声明一个特定的用户： 12345678fn main() { let user1 = User { active: true, username: String::from(&quot;someusername123&quot;), email: String::from(&quot;someone@example.com&quot;), sign_in_count: 1, };} 为了从结构体中获取某个特定的值，可以使用点号。举个例子，想要用户的邮箱地址，可以用 user1.email。如果结构体的实例是可变的，我们可以使用点号并为对应的字段赋值。示例 5-3 展示了如何改变一个可变的 User 实例中 email 字段的值： 12345678910fn main() { let mut user1 = User { active: true, username: String::from(&quot;someusername123&quot;), email: String::from(&quot;someone@example.com&quot;), sign_in_count: 1, }; user1.email = String::from(&quot;anotheremail@example.com&quot;);} 示例 5-3：改变 User 实例 email 字段的值 注意整个实例必须是可变的；Rust 并不允许只将某个字段标记为可变。另外需要注意同其他任何表达式一样，我们可以在函数体的最后一个表达式中构造一个结构体的新实例，来隐式地返回这个实例。 示例 5-4 显示了一个 build_user 函数，它返回一个带有给定的 email 和用户名的 User 结构体实例。active 字段的值为 true，并且 sign_in_count 的值为 1。 12345678fn build_user(email: String, username: String) -&gt; User { User { active: true, username: username, email: email, sign_in_count: 1, }} 示例 5-4：build_user 函数获取 email 和用户名并返回 User 实例 为函数参数起与结构体字段相同的名字是可以理解的，但是不得不重复 email 和 username 字段名称与变量有些啰嗦。如果结构体有更多字段，重复每个名称就更加烦人了。幸运的是，有一个方便的简写语法！ 使用字段初始化简写语法因为示例 5-4 中的参数名与字段名都完全相同，我们可以使用 字段初始化简写语法（field init shorthand）来重写 build_user，这样其行为与之前完全相同，不过无需重复 username 和 email 了，如示例 5-5 所示。 12345678fn build_user(email: String, username: String) -&gt; User { User { active: true, username, email, sign_in_count: 1, }} 示例 5-5：build_user 函数使用了字段初始化简写语法，因为 username 和 email 参数与结构体字段同名 这里我们创建了一个新的 User 结构体实例，它有一个叫做 email 的字段。我们想要将 email 字段的值设置为 build_user 函数 email 参数的值。因为 email 字段与 email 参数有着相同的名称，则只需编写 email 而不是 email: email。 使用结构体更新语法从其他实例创建实例使用旧实例的大部分值但改变其部分值来创建一个新的结构体实例通常是很有用的。这可以通过 结构体更新语法（struct update syntax）实现。 首先，示例 5-6 展示了不使用更新语法时，如何在 user2 中创建一个新 User 实例。我们为 email 设置了新的值，其他值则使用了实例 5-2 中创建的 user1 中的同名值： 12345678910fn main() { // --snip-- let user2 = User { active: user1.active, username: user1.username, email: String::from(&quot;another@example.com&quot;), sign_in_count: user1.sign_in_count, };} 示例 5-6：使用 user1 中的一个值创建一个新的 User 实例 使用结构体更新语法，我们可以通过更少的代码来达到相同的效果，如示例 5-7 所示。.. 语法指定了剩余未显式设置值的字段应有与给定实例对应字段相同的值。 12345678fn main() { // --snip-- let user2 = User { email: String::from(&quot;another@example.com&quot;), ..user1 };} 示例 5-7：使用结构体更新语法为一个 User 实例设置一个新的 email 值，不过其余值来自 user1 变量中实例的字段 示例 5-7 中的代码也在 user2 中创建了一个新实例，但该实例中 email 字段的值与 user1 不同，而 username、 active 和 sign_in_count 字段的值与 user1 相同。..user1 必须放在最后，以指定其余的字段应从 user1 的相应字段中获取其值，但我们可以选择以任何顺序为任意字段指定值，而不用考虑结构体定义中字段的顺序。 请注意，结构更新语法就像带有 = 的赋值，因为它移动了数据，就像我们在[“使用移动的变量与数据交互”](./04.1 什么是所有权)部分讲到的一样。在这个例子中，总体上说我们在创建 user2 后就不能再使用 user1 了，因为 user1 的 username 字段中的 String 被移到 user2 中 。如果我们给 user2 的 email 和 username 都赋予新的 String 值，从而只复用 user1 的 active 和 sign_in_count 值，那么 user1 在创建 user2 后 仍然有效 。active 和 sign_in_count 的类型是实现 Copy trait 的类型，所以我们在[“使用克隆的变量与数据交互”](./04.1 什么是所有权) 部分讨论的行为同样适用。在本例中我们也 可以继续使用 user1.email ，因为它的值并未从 user1 中移动出去。 使用没有命名字段的元组结构体来创建不同的类型也可以定义与元组类似的结构体，称为 元组结构体（tuple structs）。元组结构体有着结构体名称提供的含义，但没有具体的字段名，只有字段的类型。当你想给整个元组取一个名字，并使元组成为与其他元组不同的类型时，元组结构体是很有用的，这时像常规结构体那样为每个字段命名就显得多余和形式化了。 要定义元组结构体，以 struct 关键字和结构体名开头并后跟元组中的类型。例如，下面是两个分别叫做 Color 和 Point 元组结构体的定义和用法： 1234567struct Color(i32, i32, i32);struct Point(i32, i32, i32);fn main() { let black = Color(0, 0, 0); let origin = Point(0, 0, 0);} 注意 black 和 origin 值的类型不同，因为它们是不同的元组结构体的实例。你定义的每一个结构体有其自己的类型，即使结构体中的字段可能有着相同的类型。例如，一个获取 Color 类型参数的函数不能接受 Point 作为参数，即便这两个类型都由三个 i32 值组成。除此之外，元组结构体实例类似于元组，你可以将它们解构为单独的部分，也可以使用 . 后跟索引来访问单独的值。与元组不同的是，解构元组结构体时必须写明结构体的类型。例如，我们可以写 let Point(x, y, z) = origin;，将 origin 的值解构到名为 x、y 和 z 的变量中。 没有任何字段的类单元结构体我们也可以定义一个没有任何字段的结构体！它们被称为 类单元结构体（unit-like structs）因为它们类似于 ()，即[“元组类型”](03.2 数据类型)一节中提到的 unit 类型。类单元结构体常常在你想要在某个类型上实现 trait 但不需要在类型中存储数据的时候发挥作用。我们将在第十章介绍 trait。下面是一个声明和实例化一个名为 AlwaysEqual 的 unit 结构的示例： 12345struct AlwaysEqual;fn main() { let subject = AlwaysEqual;} 为了定义 AlwaysEqual，我们使用 struct 关键字，接着是我们想要的名称，然后是一个分号。不需要花括号或圆括号！然后，我们可以以类似的方式在 subject 变量中创建 AlwaysEqual 的实例：只需使用我们定义的名称，无需任何花括号或圆括号。设想我们稍后将为这个类型实现某种行为，使得每个 AlwaysEqual 的实例始终等于任何其它类型的实例，也许是为了获得一个已知的结果以便进行测试。我们不需要任何数据来实现这种行为！在第十章中，你会看到如何定义 trait 并在任何类型上实现它们，包括类单元结构体。 结构体数据的所有权在示例 5-1 中的 User 结构体的定义中，我们使用了自身拥有所有权的 String 类型而不是 &amp;str 字符串 slice 类型。这是一个有意而为之的选择，因为我们想要这个结构体拥有它所有的数据，为此只要整个结构体是有效的话其数据也是有效的。 可以使结构体存储被其他对象拥有的数据的引用，不过这么做的话需要用上 生命周期（lifetimes），这是一个第十章会讨论的 Rust 特性。生命周期确保结构体引用的数据有效性跟结构体本身保持一致。如果你尝试在结构体中存储一个引用而不指定生命周期将是无效的，比如这样： 123456789101112131415struct User { active: bool, username: &amp;str, email: &amp;str, sign_in_count: u64,}fn main() { let user1 = User { active: true, username: &quot;someusername123&quot;, email: &quot;someone@example.com&quot;, sign_in_count: 1, };} 编译器会抱怨它需要生命周期标识符： 12345678910111213141516171819202122232425262728293031$ cargo run Compiling structs v0.1.0 (file:///projects/structs)error[E0106]: missing lifetime specifier --&gt; src/main.rs:3:15 |3 | username: &amp;str, | ^ expected named lifetime parameter |help: consider introducing a named lifetime parameter |1 ~ struct User&lt;'a&gt; {2 | active: bool,3 ~ username: &amp;'a str, |error[E0106]: missing lifetime specifier --&gt; src/main.rs:4:12 |4 | email: &amp;str, | ^ expected named lifetime parameter |help: consider introducing a named lifetime parameter |1 ~ struct User&lt;'a&gt; {2 | active: bool,3 | username: &amp;str,4 ~ email: &amp;'a str, |For more information about this error, try `rustc --explain E0106`.error: could not compile `structs` (bin &quot;structs&quot;) due to 2 previous errors 第十章会讲到如何修复这个问题以便在结构体中存储引用，不过现在，我们会使用像 String 这类拥有所有权的类型来替代 &amp;str 这样的引用以修正这个错误。","link":"/2025/05/21/Rust/The%20Rust%20Programming%20Language/05.1%20%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%8C%96/"},{"title":"4.3 Slice 类型","text":"Slice 类型切片（slice）允许你引用集合中一段连续的元素序列，而不用引用整个集合。slice 是一种引用，所以它不拥有所有权。 这里有一个编程小习题：编写一个函数，该函数接收一个用空格分隔单词的字符串，并返回在该字符串中找到的第一个单词。如果函数在该字符串中并未找到空格，则整个字符串就是一个单词，所以应该返回整个字符串。 注意：出于介绍字符串 slice 的目的，本小节假设只使用 ASCII 字符集；一个关于 UTF-8 处理的更全面的讨论位于第八章[“使用字符串储存 UTF-8 编码的文本”](./08.2 使用字符串储存 UTF-8 编码的文本)小节。 让我们推敲下如何不用 slice 编写这个函数的签名，来理解 slice 能解决的问题： 1fn first_word(s: &amp;String) -&gt; ? first_word 函数有一个参数 &amp;String。因为我们不需要所有权，所以这没有问题。不过应该返回什么呢？我们并没有一个真正获取部分字符串的办法。不过，我们可以返回单词结尾的索引，结尾由一个空格表示。试试如示例中的代码。 1234567891011fn first_word(s: &amp;String) -&gt; usize { let bytes = s.as_bytes(); for (i, &amp;item) in bytes.iter().enumerate() { if item == b' ' { return i; } } s.len()} 因为需要逐个元素的检查 String 中的值是否为空格，需要用 as_bytes 方法将 String 转化为字节数组。 1let bytes = s.as_bytes(); 接下来，使用 iter 方法在字节数组上创建一个迭代器： 1for (i, &amp;item) in bytes.iter().enumerate() { 我们将在[第十三章](./13.2 使用迭代器处理元素序列)详细讨论迭代器。现在，只需知道 iter 方法返回集合中的每一个元素，而 enumerate 包装了 iter 的结果，将这些元素作为元组的一部分来返回。enumerate 返回的元组中，第一个元素是索引，第二个元素是集合中元素的引用。这比我们自己计算索引要方便一些。 因为 enumerate 方法返回一个元组，我们可以使用模式来解构，我们将在[第六章](./06.2 match 控制流结构)中进一步讨论有关模式的问题。所以在 for 循环中，我们指定了一个模式，其中元组中的 i 是索引而元组中的 &amp;item 是单个字节。因为我们从 .iter().enumerate() 中获取了集合元素的引用，所以模式中使用了 &amp;。 在 for 循环中，我们通过字节的字面值语法来寻找代表空格的字节。如果找到了一个空格，返回它的位置。否则，使用 s.len() 返回字符串的长度。 123456 if item == b' ' { return i; }}s.len() 现在有了一个找到字符串中第一个单词结尾索引的方法，不过这有一个问题。我们返回了一个独立的 usize，不过它只在 &amp;String 的上下文中才是一个有意义的数字。换句话说，因为它是一个与 String 相分离的值，无法保证将来它仍然有效。考虑一下示例中使用了示例中 first_word 函数的程序。 12345678910fn main() { let mut s = String::from(&quot;hello world&quot;); let word = first_word(&amp;s); // word 的值为 5 s.clear(); // 这清空了字符串，使其等于 &quot;&quot; // word 在此处的值仍然是 5， // 但是没有更多的字符串让我们可以有效地应用数值 5。word 的值现在完全无效！} 这个程序编译时没有任何错误，而且在调用 s.clear() 之后使用 word 也不会出错。因为 word 与 s 状态完全没有联系，所以 word 仍然包含值 5。可以尝试用值 5 来提取变量 s 的第一个单词，不过这是有 bug 的，因为在我们将 5 保存到 word 之后 s 的内容已经改变。 我们不得不时刻担心 word 的索引与 s 中的数据不再同步，这既繁琐又易出错！如果编写这么一个 second_word 函数的话，管理索引这件事将更加容易出问题。它的签名看起来像这样： 1fn second_word(s: &amp;String) -&gt; (usize, usize) { 现在我们要跟踪一个开始索引和一个结束索引，同时有了更多从数据的某个特定状态计算而来的值，但都完全没有与这个状态相关联。现在有三个飘忽不定的不相关变量需要保持同步。 幸运的是，Rust 为这个问题提供了一个解决方法：字符串 slice。 字符串 slice字符串 slice（string slice）是 String 中一部分值的引用，它看起来像这样： 1234let s = String::from(&quot;hello world&quot;);let hello = &amp;s[0..5];let world = &amp;s[6..11]; 不同于整个 String 的引用，hello 是一个部分 String 的引用，由一个额外的 [0..5] 部分指定。可以使用一个由中括号中的 [starting_index..ending_index] 指定的 range 创建一个 slice，其中 starting_index 是 slice 的第一个位置，ending_index 则是 slice 最后一个位置的后一个值。在其内部，slice 的数据结构存储了 slice 的开始位置和长度，长度对应于 ending_index 减去 starting_index 的值。所以对于 let world = &amp;s[6..11]; 的情况，world 将是一个包含指向 s 索引 6 的指针和长度值 5 的 slice。 图 4-7：引用了部分 String 的字符串 slice 对于 Rust 的 .. range 语法，如果想要从索引 0 开始，可以不写两个点号之前的值。换句话说，如下两个语句是相同的： 1234let s = String::from(&quot;hello&quot;);let slice = &amp;s[0..2];let slice = &amp;s[..2]; 依此类推，如果 slice 包含 String 的最后一个字节，也可以舍弃尾部的数字。这意味着如下也是相同的： 123456let s = String::from(&quot;hello&quot;);let len = s.len();let slice = &amp;s[3..len];let slice = &amp;s[3..]; 也可以同时舍弃这两个值来获取整个字符串的 slice。所以如下亦是相同的： 123456let s = String::from(&quot;hello&quot;);let len = s.len();let slice = &amp;s[0..len];let slice = &amp;s[..]; 注意：字符串 slice range 的索引必须位于有效的 UTF-8 字符边界内，如果尝试从一个多字节字符的中间位置创建字符串 slice，则程序将会因错误而退出。 在记住所有这些知识后，让我们重写 first_word 来返回一个 slice。“字符串 slice” 的类型声明写作 &amp;str： 1234567891011fn first_word(s: &amp;String) -&gt; &amp;str { let bytes = s.as_bytes(); for (i, &amp;item) in bytes.iter().enumerate() { if item == b' ' { return &amp;s[0..i]; } } &amp;s[..]} 我们使用跟示例 4-7 相同的方式获取单词结尾的索引，通过寻找第一个出现的空格。当找到一个空格，我们返回一个字符串 slice，它使用字符串的开始和空格的索引作为开始和结束的索引。 现在当调用 first_word 时，会返回与底层数据关联的单个值。这个值由一个 slice 开始位置的引用和 slice 中元素的数量组成。 second_word 函数也可以改为返回一个 slice： 1fn second_word(s: &amp;String) -&gt; &amp;str { 现在我们有了一个不易混淆且直观的 API 了，因为编译器会确保指向 String 的引用持续有效。还记得示例程序中，那个当我们获取第一个单词结尾的索引后，接着就清除了字符串导致索引就无效的 bug 吗？那些代码在逻辑上是不正确的，但却没有显示任何直接的错误。问题会在之后尝试对空字符串使用第一个单词的索引时出现。slice 就不可能出现这种 bug 并让我们更早的知道出问题了。使用 slice 版本的 first_word 会抛出一个编译时错误： 123456789fn main() { let mut s = String::from(&quot;hello world&quot;); let word = first_word(&amp;s); s.clear(); // 错误！ println!(&quot;the first word is: {word}&quot;);} 这里是编译错误： 12345678910111213141516$ cargo run Compiling ownership v0.1.0 (file:///projects/ownership)error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable --&gt; src/main.rs:18:5 |16 | let word = first_word(&amp;s); | -- immutable borrow occurs here17 |18 | s.clear(); // error! | ^^^^^^^^^ mutable borrow occurs here19 |20 | println!(&quot;the first word is: {word}&quot;); | ------ immutable borrow later used hereFor more information about this error, try `rustc --explain E0502`.error: could not compile `ownership` (bin &quot;ownership&quot;) due to 1 previous error 回忆一下借用规则，当拥有某值的不可变引用时，就不能再获取一个可变引用。因为 clear 需要清空 String，它尝试获取一个可变引用。在调用 clear 之后的 println! 使用了 word 中的引用，所以这个不可变的引用在此时必须仍然有效。Rust 不允许 clear 中的可变引用和 word 中的不可变引用同时存在，因此编译失败。Rust 不仅使得我们的 API 简单易用，也在编译时就消除了一整类的错误！ 字符串字面值就是 slice还记得我们讲到过字符串字面值被储存在二进制文件中吗？现在知道 slice 了，我们就可以正确地理解字符串字面值了： 1let s = &quot;Hello, world!&quot;; 这里 s 的类型是 &amp;str：它是一个指向二进制程序特定位置的 slice。这也就是为什么字符串字面值是不可变的；&amp;str 是一个不可变引用。 字符串 slice 作为参数在知道了能够获取字面值和 String 的 slice 后，我们对 first_word 做了改进，这是它的签名： 1fn first_word(s: &amp;String) -&gt; &amp;str { 而更有经验的 Rustacean 会编写出示例 4-9 中的签名，因为它使得可以对 &amp;String 值和 &amp;str 值使用相同的函数： 1fn first_word(s: &amp;str) -&gt; &amp;str { 示例 4-9: 通过将 s 参数的类型改为字符串 slice 来改进 first_word 函数 如果有一个字符串 slice，可以直接传递它。如果有一个 String，则可以传递整个 String 的 slice 或对 String 的引用。这种灵活性利用了 deref coercions 的优势，这个特性我们将在[“函数和方法的隐式 Deref 强制转换”](./15.2 通过 Deref trait 将智能指针当作常规引用处理)章节中介绍。定义一个获取字符串 slice 而不是 String 引用的函数使得我们的 API 更加通用并且不会丢失任何功能： 1234567891011121314151617181920fn main() { let my_string = String::from(&quot;hello world&quot;); // `first_word` 适用于 `String`（的 slice），部分或全部 let word = first_word(&amp;my_string[0..6]); let word = first_word(&amp;my_string[..]); // `first_word` 也适用于 `String` 的引用， // 这等价于整个 `String` 的 slice let word = first_word(&amp;my_string); let my_string_literal = &quot;hello world&quot;; // `first_word` 适用于字符串字面值，部分或全部 let word = first_word(&amp;my_string_literal[0..6]); let word = first_word(&amp;my_string_literal[..]); // 因为字符串字面值已经 **是** 字符串 slice 了， // 这也是适用的，无需 slice 语法！ let word = first_word(my_string_literal);} 其他类型的 slice字符串 slice，正如你想象的那样，是针对字符串的。不过也有更通用的 slice 类型。考虑一下这个数组： 1let a = [1, 2, 3, 4, 5]; 就跟我们想要获取字符串的一部分那样，我们也会想要引用数组的一部分。我们可以这样做： 12345let a = [1, 2, 3, 4, 5];let slice = &amp;a[1..3];assert_eq!(slice, &amp;[2, 3]); 这个 slice 的类型是 &amp;[i32]。它跟字符串 slice 的工作方式一样，通过存储第一个集合元素的引用和一个集合总长度。你可以对其他所有集合使用这类 slice。第八章讲到 vector 时会详细讨论这些集合。 总结所有权、借用和 slice 这些概念让 Rust 程序在编译时确保内存安全。Rust 语言提供了跟其他系统编程语言相同的方式来控制你使用的内存，但拥有数据所有者在离开作用域后自动清除其数据的功能意味着你无须额外编写和调试相关的控制代码。 所有权系统影响了 Rust 中很多其他部分的工作方式，所以我们还会继续讲到这些概念，这将贯穿本书的余下内容。让我们开始第五章，来看看如何将多份数据组合进一个 struct 中。","link":"/2025/05/21/Rust/The%20Rust%20Programming%20Language/04.3%20Slice%20%E7%B1%BB%E5%9E%8B/"},{"title":"","text":"","link":"/2025/05/19/Rust/The%20Rust%20Programming%20Language/05.3%20%E6%96%B9%E6%B3%95%E8%AF%AD%E6%B3%95/"},{"title":"3.5 控制流","text":"控制流if 表达式if 表达式允许根据条件执行不同的代码分支。你提供一个条件并表示 “如果条件满足，运行这段代码；如果条件不满足，不运行这段代码。” 123456789fn main() { let number = 3; if number &lt; 5 { println!(&quot;condition was true&quot;); } else { println!(&quot;condition was false&quot;); }} 所有的 if 表达式都以 if 关键字开头，其后跟一个条件。在这个例子中，条件检查变量 number 的值是否小于 5。在条件为 true 时希望执行的代码块位于紧跟条件之后的大括号中。if 表达式中与条件关联的代码块有时被叫做 arms，就像第二章部分中讨论到的 match 表达式中的分支一样。 也可以包含一个可选的 else 表达式来提供一个在条件为 false 时应当执行的代码块，这里我们就这么做了。如果不提供 else 表达式并且条件为 false 时，程序会直接忽略 if 代码块并继续执行下面的代码。 另外值得注意的是代码中的条件必须是 bool 值。如果条件不是 bool 值，我们将得到一个错误。 1234567fn main() { let number = 3; if number { println!(&quot;number was three&quot;); }} 这里 if 条件的值是 3，Rust 抛出了一个错误： 12345678910$ cargo run Compiling branches v0.1.0 (file:///projects/branches)error[E0308]: mismatched types --&gt; src/main.rs:4:8 |4 | if number { | ^^^^^^ expected `bool`, found integerFor more information about this error, try `rustc --explain E0308`.error: could not compile `branches` (bin &quot;branches&quot;) due to 1 previous error 这个错误表明 Rust 期望一个 bool 却得到了一个整数。不像 Ruby 或 JavaScript 这样的语言， Rust 并不会尝试自动地将非布尔值转换为布尔值 。必须总是显式地使用布尔值作为 if 的条件。例如，如果想要 if 代码块只在一个数字不等于 0 时执行，可以把 if 表达式修改成下面这样： 1234567fn main() { let number = 3; if number != 0 { println!(&quot;number was something other than zero&quot;); }} 运行代码会打印出 number was something other than zero。 使用 else if 处理多重条件可以将 else if 表达式与 if 和 else 组合来实现多重条件。 使用过多的 else if 表达式会使代码显得杂乱无章，所以如果有多于一个 else if 表达式，最好重构代码。为此，第六章会介绍一个强大的 Rust 分支结构（branching construct），叫做 match。 在 let 语句中使用 if因为 if 是一个表达式，我们可以在 let 语句的右侧使用它，例如： 123456fn main() { let condition = true; let number = if condition { 5 } else { 6 }; println!(&quot;The value of number is: {number}&quot;);} 代码块的值是其最后一个表达式的值，而数字本身就是一个表达式。在这个例子中，整个 if 表达式的值取决于哪个代码块被执行。这意味着 if 的每个分支的可能的返回值都必须是相同类型； 使用循环重复执行Rust 有三种循环：loop、while 和 for。 使用 loop 重复执行代码loop 关键字告诉 Rust 一遍又一遍地执行一段代码直到你明确要求停止。 12345fn main() { loop { println!(&quot;again!&quot;); }} 当运行这个程序时，我们会看到连续的反复打印 again!，直到我们手动停止程序。大部分终端都支持键盘快捷键 ctrl-c 来终止一个陷入无限循环的程序。 从循环返回值loop 的一个用例是重试可能会失败的操作，比如检查线程是否完成了任务。然而你可能会需要将操作的结果传递给其它的代码。要实现这一点，可以在用于停止循环的 break 表达式后添加你希望返回的值；这个值就会作为循环的返回值返回，这样你就可以使用它，如下所示： 12345678910111213fn main() { let mut counter = 0; let result = loop { counter += 1; if counter == 10 { break counter * 2; } }; println!(&quot;The result is {result}&quot;);} 在循环之前，我们声明了一个名为 counter 的变量并初始化为 0。接着声明了一个名为 result 来存放循环的返回值。在循环的每一次迭代中，我们将 counter 变量加 1，接着检查计数是否等于 10。当相等时，使用 break 关键字返回值 counter * 2。循环之后，我们通过分号结束赋值给 result 的语句。最后打印出 result 的值，也就是 20。 循环标签：在多个循环之间消除歧义如果存在嵌套循环，break 和 continue 应用于此时最内层的循环。你可以选择在一个循环上指定一个 循环标签（loop label），然后将标签与 break 或 continue 一起使用，使这些关键字应用于已标记的循环而不是最内层的循环。下面是一个包含两个嵌套循环的示例： 123456789101112131415161718192021fn main() { let mut count = 0; 'counting_up: loop { println!(&quot;count = {count}&quot;); let mut remaining = 10; loop { println!(&quot;remaining = {remaining}&quot;); if remaining == 9 { break; } if count == 2 { break 'counting_up; } remaining -= 1; } count += 1; } println!(&quot;End count = {count}&quot;);} 外层循环有一个标签 counting_up，它将从 0 数到 2。没有标签的内部循环从 10 向下数到 9。第一个没有指定标签的 break 将只退出内层循环。break 'counting_up; 语句将退出外层循环。 while 条件循环在程序中计算循环的条件也很常见。当条件为 true，执行循环。当条件不再为 true，调用 break 停止循环。这个循环类型可以通过组合 loop、if、else 和 break 来实现；如果你喜欢的话，现在就可以在程序中试试。然而，这个模式太常用了，Rust 为此内置了一个语言结构，它被称为 while 循环。 1234567891011fn main() { let mut number = 3; while number != 0 { println!(&quot;{number}!&quot;); number -= 1; } println!(&quot;LIFTOFF!!!&quot;);} 这种结构消除了很多使用 loop、if、else 和 break 时所必须的嵌套，这样更加清晰。当条件为 true 就执行，否则退出循环。 使用 for 遍历集合可以使用 while 结构来遍历集合中的元素，比如数组。 12345678910fn main() { let a = [10, 20, 30, 40, 50]; let mut index = 0; while index &lt; 5 { println!(&quot;the value is: {}&quot;, a[index]); index += 1; }} 1234567fn main() { let a = [10, 20, 30, 40, 50]; for element in a { println!(&quot;the value is: {element}&quot;); }} 下面是一个使用 for 循环来倒计时的例子，它还使用了一个我们还未讲到的方法，rev，用来反转 range。 123456fn main() { for number in (1..4).rev() { println!(&quot;{number}!&quot;); } println!(&quot;LIFTOFF!!!&quot;);} 这段代码看起来更帅气不是吗？ 总结你做到了！这是一个大章节：你学习了变量、标量和复合数据类型、函数、注释、 if 表达式和循环！ 当你准备好继续的时候，让我们讨论一个其他语言中并不常见的概念：所有权（ownership）。","link":"/2025/05/17/Rust/The%20Rust%20Programming%20Language/03.5%20%E6%8E%A7%E5%88%B6%E6%B5%81/"},{"title":"","text":"","link":"/2025/05/16/Rust/The%20Rust%20Programming%20Language/06.2%20match%20%E6%8E%A7%E5%88%B6%E6%B5%81%E7%BB%93%E6%9E%84/"},{"title":"","text":"","link":"/2025/05/19/Rust/The%20Rust%20Programming%20Language/07.3%20%E5%BC%95%E7%94%A8%E6%A8%A1%E5%9D%97%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%B7%AF%E5%BE%84/"},{"title":"","text":"","link":"/2025/05/17/Rust/The%20Rust%20Programming%20Language/08.2%20%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%82%A8%E5%AD%98%20UTF-8%20%E7%BC%96%E7%A0%81%E7%9A%84%E6%96%87%E6%9C%AC/"},{"title":"","text":"","link":"/2025/05/17/Rust/The%20Rust%20Programming%20Language/14.2%20%E5%B0%86%20crate%20%E5%8F%91%E5%B8%83%E5%88%B0%20Crates.io/"},{"title":"","text":"","link":"/2025/05/21/Rust/The%20Rust%20Programming%20Language/15.2%20%E9%80%9A%E8%BF%87%20Deref%20trait%20%E5%B0%86%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%BD%93%E4%BD%9C%E5%B8%B8%E8%A7%84%E5%BC%95%E7%94%A8%E5%A4%84%E7%90%86/"},{"title":"","text":"","link":"/2025/05/17/Rust/The%20Rust%20Programming%20Language/22.2%20B/"},{"title":"","text":"","link":"/2025/05/17/Rust/The%20Rust%20Programming%20Language/08.1%20%E4%BD%BF%E7%94%A8%20Vector%20%E5%82%A8%E5%AD%98%E5%88%97%E8%A1%A8/"},{"title":"","text":"","link":"/2025/05/19/Rust/The%20Rust%20Programming%20Language/22.3%20C/"},{"title":"","text":"","link":"/2025/05/16/Rust/The%20Rust%20Programming%20Language/22.5%20E/"},{"title":"集合 pt.2","text":"Map ( 重要 )HashMap 和 Hashtable 的区别 线程是否安全： HashMap 是 非线程安全 的， Hashtable 是 线程安全 的,因为 Hashtable 内部的方法基本都经过 synchronized 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）； 效率： 因为线程安全的问题， HashMap 要比 Hashtable 效率高 一点。另外， Hashtable 基本被淘汰，不要在代码中使用它； 对 Null key 和 Null value 的支持： HashMap 可以存储 null 的 key 和 value ，但 null 作为键只能有一个， null 作为值可以有多个； Hashtable 不允许 有 null 键和 null 值，否则会抛出 NullPointerException 。 初始容量大小和每次扩充容量大小的不同： 创建时如果不指定容量初始值， Hashtable 默认的初始大小为 11 ，之后每次扩充， 容量变为原来的 2n+1 。 HashMap 默认的初始化大小为 16 。之后每次扩充，容量变为 原来的 2 倍 。 创建时如果给定了容量初始值，那么 Hashtable 会 直接使用你给定的大小 ，而 HashMap 会 将其扩充为 2 的幂次方大小 （ HashMap 中的 tableSizeFor() 方法保证，下面给出了源代码）。也就是说 HashMap 总是使用 2 的幂作为哈希表的大小 ,后面会介绍到为什么是 2 的幂次方。 底层数据结构： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时， 将链表转化为红黑树 （将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间。 Hashtable 没有这样的机制。 哈希函数的实现： HashMap 对哈希值进行了 高位和低位的混合扰动处理 以减少冲突，而 Hashtable 直接使用键的 hashCode() 值 。 HashMap 中带有初始容量的构造函数：123456789101112131415public HashMap(int initialCapacity, float loadFactor) { if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity);} public HashMap(int initialCapacity) { this(initialCapacity, DEFAULT_LOAD_FACTOR);} 下面这个方法保证了 HashMap 总是使用 2 的幂作为哈希表的大小。 123456789101112/** * Returns a power of two size for the given target capacity. */static final int tableSizeFor(int cap) { int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;} 解析： int n = cap - 1;将输入容量减 1。这是为了处理 cap 本身已经是 2 的幂的情况。例如，若 cap = 8，不减 1 会导致结果为 16，而减 1 后最终结果仍为 8。 位运算填充所有低位为 1通过右移和按位或操作，将最高有效位之后的所有位设置为 1： 12345n |= n &gt;&gt;&gt; 1; // 将最高位的下一位设为1n |= n &gt;&gt;&gt; 2; // 将前两位后的所有低位设为1n |= n &gt;&gt;&gt; 4; // 继续填充低位n |= n &gt;&gt;&gt; 8; // 确保覆盖所有可能的位n |= n &gt;&gt;&gt; 16; // 最终n的二进制形式为全1（如0b1111） 示例：若 cap = 10（二进制 1001 ），处理后 n 变为 1111 （15） 返回结果最后对 n 进行边界检查并返回： 1234return (n &lt; 0) ? 1 : // cap=0时返回1 (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : // 超过最大值则取最大值 n + 1; // 加1得到2的幂n + 1将全1的二进制数变为2的幂（如0b1111 + 1 = 0b10000 = 16）。 边界条件处理确保结果合法。 例子： 输入 cap = 10 1tableSizeFor(10) → 返回 16 计算过程： n = 10 - 1 = 9（二进制 1001 ）。 执行位移和按位或操作： 1234n |= n &gt;&gt;&gt; 1 → 1001 | 0100 = 1101 (13)n |= n &gt;&gt;&gt; 2 → 1101 | 0011 = 1111 (15)n |= n &gt;&gt;&gt; 4 → 1111 | 0000 = 1111 (15)...后续位移无变化 n = 15 → n + 1 = 16（2⁴）。 输入 cap = 16 1tableSizeFor(16) → 返回 16 计算过程： n = 16 - 1 = 15（二进制 1111 ）。 所有位移操作后 n 仍为 15。 n + 1 = 16（2⁴），与输入相同（输入本身是 2 的幂）。 HashMap 和 HashSet 区别HashSet 底层就是基于 HashMap 实现的。（ HashSet 的源码非常非常少，因为除了 clone() 、 writeObject() 、 readObject() 是 HashSet 自己不得不实现之外，其他方法都是直接调用 HashMap 中的方法。 HashMap HashSet 实现了 Map 接口 实现 Set 接口 存储键值对 仅存储对象 调用 put()向 map 中添加元素 调用 add()方法向 Set 中添加元素 HashMap 使用键（Key）计算 hashcode HashSet 使用成员对象来计算 hashcode 值，对于两个对象来说 hashcode 可能相同，所以 equals()方法用来判断对象的相等性 HashMap 和 TreeMap 区别TreeMap 和 HashMap 都继承自 AbstractMap ，但是需要注意的是 TreeMap 它还实现了 NavigableMap 接口和 SortedMap 接口。 实现 NavigableMap 接口让 TreeMap 有了对集合内元素的搜索的能力。 NavigableMap 接口提供了丰富的方法来探索和操作键值对: 定向搜索: ceilingEntry() , floorEntry() , higherEntry() 和 lowerEntry() 等方法可以用于定位大于等于、小于等于、严格大于、严格小于给定键的最接近的键值对。 子集操作: subMap() , headMap() 和 tailMap() 方法可以高效地创建原集合的子集视图，而无需复制整个集合。 逆序视图: descendingMap() 方法返回一个逆序的 NavigableMap 视图，使得可以反向迭代整个 TreeMap 。 边界操作: firstEntry() , lastEntry() , pollFirstEntry() 和 pollLastEntry() 等方法可以方便地访问和移除元素。 这些方法都是基于 红黑树 数据结构的属性实现的，红黑树保持平衡状态，从而保证了搜索操作的时间复杂度为 O(log n) ，这让 TreeMap 成为了处理有序集合搜索问题的强大工具。 实现 SortedMap 接口让 TreeMap 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，不过我们也可以指定排序的比较器。 综上，相比于 HashMap 来说， TreeMap 主要多了 对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力 。","link":"/2025/05/17/%E5%85%AB%E8%82%A1/Java/%E9%9B%86%E5%90%88/%E9%9B%86%E5%90%88%20pt%202/"},{"title":"集合 pt.1","text":"集合概述Java 集合概述Java 集合，也叫作容器，主要是由两大接口派生而来：一个是 Collection 接口，主要用于存放单一元素；另一个是 Map 接口，主要用于存放键值对。对于 Collection 接口，下面又有三个主要的子接口： List 、 Set 、 Queue 。 注：图中只列举了主要的继承派生关系，并没有列举所有关系。比方省略了 AbstractList, NavigableSet 等抽象类以及其他的一些辅助类，如想深入了解，可自行查看源码。 List 、 Set 、 Queue 、 Map 的区别？ List: （顺序） 存储的元素是 有序的、可重复的 。 Set: （去重） 存储的元素是 不可重复的 。 Queue: （排队功能） 按特定的排队顺序确定先后顺序，存储的元素是 有序的、可重复的 。 Map: （key-value） 使用键值对存储。 key 是 无序的、不可重复的 value 是 无序的、可重复的每个键最多映射到 一个值 。 集合框架底层数据结构总结CollectionList ArrayList ： Object[] 数组。详细看：ArrayList 源码。 Vector ： Object[] 数组。 LinkedList ： 双向链表（ JDK1.6 前为循环链表， JDK 1.7 取消循环 ）。详细看：LinkedList 源码。 Set HashSet （无序、唯一） ： 基于 HashMap 实现，底层采用 HashMap 保存元素。 LinkedHashSet ： LinkedHashSet 是 HashSet 的子类，而且其内部是通过 LinkedHashMap 实现的。 TreeSet （有序、唯一） ： 红黑树（自平衡的排序二叉树）。 Queue PriorityQueue ： Object[] 数组实现 小顶堆 。详细看：PriorityQueue 源码 DelayQueue ： PriorityQueue。详细看：DelayQueue 源码 ArrryDeque ： 可扩容动态双向数组。 Map HashMap ： JDK 1.8 之前 HashMap 由 数组加链表 组成，数组是 HashMap 的主体，链表则是为了 解决哈希冲突 。 JDK 1.8 后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为 红黑树 ，以减少搜索时间。详细查看：HashMap 源码。 LinkedHashMap ： LinkedHashMap 继承自 HashMap ，所以底层仍然是 基于拉链式散列结构（即由数组和链表或红黑树） 组成。另外， LinkedHashMap 在上面的结构的基础上增加了一条双向链表，使上面的结构可以保持插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细查看：LinkedHashMap 源码。 Hashtable ： 数组+链表组成，数组是 Hashtable 的主体，链表则是为了 解决哈希冲突 。 TreeMap ： 红黑树。 如何选择集合？主要根据集合的特点。如； 需要根据键值获取到元素值时就选用 Map 接口下的集合，需要排序时选择 TreeMap ,不需要排序时就选择 HashMap ,需要保证线程安全就选用 ConcurrentHashMap 。 只需要存放元素值时，就选择实现 Collection 接口的集合，需要保证元素唯一时选择实现 Set 接口的集合比如 TreeSet 或 HashSet ，不需要就选择实现 List 接口的比如 ArrayList 或 LinkedList ，然后再根据实现这些接口的集合的特点来选用。 为什么要用集合？需要存储一组类型相同的数据时，数组是最常用且最基本的容器之一。但是，使用 数组存储对象存在不足之处 ，因为在实际开发中，存储的数据类型多种多样且数量不确定。这时，Java 集合就派上用场了。与数组相比，Java 集合提供了更灵活、更有效的方法来存储多个数据对象。Java 集合框架中的各种集合类和接口可以 存储不同类型和数量的对象 ，同时还具有 多样化的操作方式 。相较于数组，Java 集合的优势在于它们的 大小可变、支持泛型、具有内建算法等 。总的来说，Java 集合 提高了数据的存储和处理灵活性 ，可以更好地适应现代软件开发中多样化的数据需求，并支持高质量的代码编写。 ListArrayList 和 Array （数组） 的区别ArrayList 内部基于动态数组实现，比 Array 使用起来更加灵活： ArrayList 会根据实际储存的元素进行动态扩容或缩容，而 Array 被创建后就不能改变长度了。 ArrayList 允许使用泛型确保类型安全， Array 不可以。 ArrayList 中只能储存对象。 Array 可以既可以存储基本数据类型，也可以储存对象。 ArrayList 支持插入、删除、遍历等常见操作，且提供了丰富的 API 操作，如 add() 、remove() 等。 Array 只是一个固定长度的数组，只能按照下标访问其中的元素，不具备动态添加、删除元素的能力。 ArrayList 创建时不需要指定大小，而 Array 必须指定大小。 （了解） ArrayList 和 Vector 的区别 ArrayList 是 List 的主要实现类，底层使用 Object[] 存储，适合频繁的查找工作，线程不安全。 Vector 是 List 的古老实现类，底层使用 Object[] 存储，线程安全。 （了解） Vector 和 Stack 的区别 Vector 和 Stack 两者都是线程安全的，都是使用 synchronized 关键字进行同步处理。 Stack 继承自 Vector ，是一个后进先出的栈，而 Vector 是一个列表。 随着 Java 并发编程的发展， Vector 和 Stack 已经被淘汰，推荐使用并发集合类（例如 ConcurrentHashMap 、 CopyOnWriteArrayList 等）或者手动实现线程安全的方法来提供安全的多线程操作支持。 ArrayList 可以添加 null 值吗？ArrayList 中可以存储任何类型的对象，包括 null 值。但是不建议添加 null ，会让代码变的难以维护，比如忘记做判空处理就会导致空指针异常。 ArrayList 插入 / 删除的时间复杂度插入： 头部插入： 需要将所有元素后移一位，时间复杂度为 O(n) 尾部插入： ArrayList 容量未达到极限时，时间复杂度为 O(1) ，它只需要在数组末尾添加一个元素 ArrayList 容量达到极限且需要扩容时，时间复杂度为：一次 O(n) 操作将数组复制到新的更大的数组中，一次 O(1) 操作添加元素 指定位置插入： 将目标位置后的所有元素后移一位，再插入新元素，时间复杂度为 O(n) 删除 头部删除： 需要将所有元素前移一位，时间复杂度为 O(n) 尾部删除： 删除的元素位于列表末尾时，时间复杂度为 O(1) 指定位置删除： 将目标位置后的所有元素前移一位，时间复杂度为 O(n) LinkedList 插入 / 删除的时间复杂度 头部插入 / 删除： 只需修改头结点指针，时间复杂度为 O(1) 尾部插入 / 删除： 只需修改尾结点指针，时间复杂度为 O(1) 指定位置插入 / 删除： 先移动到指定位置，再修改， 时间复杂度为 O(n) LinkedList 为什么不能实现 RandomAccess 接口？RandomAccess 接口是一个标记接口，表明实现该接口的类支持随机访问（通过索引快速访问）。由于 LinkedList 底层是链表，内存地址不连续，只能通过指针定位，所以不能实现 RandomAccess 接口。 ArrayList 与 LinkedList 的区别 是否线程安全： ArrayList 和 LinkedList 都是不同步的（不保证线程安全） 底层数据结构： ArrayList 使用 Object[] ； LinkedList 使用 双向链表 插入和删除元素是否受位置影响： 见上文总结： ArrayList 受 LinkedList 头尾不受 是否支持快速随机访问： ArrayList 支持 LinkedList 不支持 内存空间占用： ArrayList 空间浪费主要体现在在 list 列表的结尾会 预留 一定的容量空间 LinkedList 空间花费则体现在它的 每一个元素 都需要消耗比 ArrayList 更多的空间 （双向链表的前驱和后继） 补充： RandomAccess 接口12public interface RandomAccess {} 查看源码发现实际上 RandomAccess 接口中什么都没有定义。所以， RandomAccess 接口不过是一个标识。标识实现这个接口的类具有随机访问功能。 在 binarySearch() 方法中，它要判断传入的 list 是否 RandomAccess 的实例，如果是，调用 indexedBinarySearch() 方法，如果不是，那么调用 iteratorBinarySearch() 方法 1234567public static &lt;T&gt;int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key) { if (list instanceof RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD) return Collections.indexedBinarySearch(list, key); else return Collections.iteratorBinarySearch(list, key);} ArrayList 的扩容机制ArrayList 源码 集合中的 fail-fast 和 fail-safe 是什么fail-fast Fail-fast systems are designed to immediately stop functioning upon encountering an unexpected condition. This immediate failure helps to catch errors early, making debugging more straightforward. 快速失败的思想即针对可能发生的异常进行提前表明故障并停止运行，通过尽早的发现和停止错误，降低故障系统级联的风险。 在 java.util 包下的大部分集合是不支持线程安全的，为了能够提前发现并发操作导致线程安全风险，提出通过维护一个 modCount 记录修改的次数，迭代期间通过比对预期修改次数 expectedModCount 和 modCount 是否一致来判断是否存在并发操作，从而实现快速失败，由此保证在避免在异常时执行非必要的复杂代码。 扩展视频：（b 站）迭代器模式 + ArrayList 源码 fail-safe Fail-safe systems take a different approach, aiming to recover and continue even in the face of unexpected conditions. This makes them particularly suited for uncertain or volatile environments. fail-safe 就是安全失败的含义，它旨在即使面对意外情况也能恢复并继续运行，这使得它特别适用于不确定或者不稳定的环境。 该思想常运用于并发容器，最经典的实现就是 CopyOnWriteArrayList 的实现，通过写时复制的思想保证在进行修改操作时复制出一份快照，基于这份快照完成添加或者删除操作后，将 CopyOnWriteArrayList 底层的数组引用指向这个新的数组空间，由此避免迭代时被并发修改所干扰所导致并发操作安全问题，当然这种做法也存缺点，即进行遍历操作时无法获得实时结果。 CopyOnWriteArrayList 实现 fail-safe 的核心代码： 123456789101112131415161718public boolean add(E e) { final ReentrantLock lock = this.lock; lock.lock(); try { //获取原有数组 Object[] elements = getArray(); int len = elements.length; //基于原有数组复制出一份内存快照 Object[] newElements = Arrays.copyOf(elements, len + 1); //进行添加操作 newElements[len] = e; //array指向新的数组 setArray(newElements); return true; } finally { lock.unlock(); } } SetComparable 和 Comparator 的区别Comparable 接口和 Comparator 接口都是 Java 中用于排序的接口，它们在实现类对象之间比较大小、排序等方面发挥了重要作用： Comparable 接口实际上是出自 java.lang 包 它有一个 compareTo(Object obj) 方法用来排序 Comparator 接口实际上是出自 java.util 包它有一个 compare(Object obj1, Object obj2) 方法用来排序 一般我们需要对一个集合使用自定义排序时，我们就要重写 compareTo() 方法或 compare() 方法，当我们需要对某一个集合实现两种排序方式，比如一个 song 对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写 compareTo() 方法和使用自制的 Comparator 方法或者以两个 Comparator 来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的 Collections.sort() 。 无序性和不可重复性的含义 无序性 不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是 根据数据的哈希值决定 的。 不可重复性是指添加的元素按照 equals() 判断时 ，返回 false ，需要同时重写 equals() 方法和 hashCode() 方法。 比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同 HashSet 、 LinkedHashSet 和 TreeSet 都是 Set 接口的实现类，都能 保证元素唯一 ，并且都 不是线程安全 的。 HashSet 、 LinkedHashSet 和 TreeSet 的主要区别在于 底层数据结构 不同。 HashSet 的底层数据结构是 哈希表（基于 HashMap 实现） 。 LinkedHashSet 的底层数据结构是 链表和哈希表 ，元素的插入和取出顺序满足 FIFO 。 TreeSet 底层数据结构是 红黑树 ，元素是 有序 的，排序的方式有自然排序和定制排序。 底层数据结构不同又导致这三者的 应用场景 不同。 HashSet 用于不需要保证元素插入和取出顺序的场景， LinkedHashSet 用于保证元素的插入和取出顺序满足 FIFO 的场景， TreeSet 用于支持对元素自定义排序规则的场景。 QueueQueue 与 Deque 的区别Queue 是 单端队列 ，只能从一端插入元素，另一端删除元素，实现上一般遵循 先进先出（FIFO） 规则。 Queue 扩展了 Collection 的接口，根据 因为容量问题而导致操作失败后处理方式的不同 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。 Queue 接口 抛出异常 返回特殊值 插入队尾 add(E e) offer(E e) 删除队首 remove() poll() 查询队首元素 element() peek() Deque 是 双端队列 ，在队列的两端均可以插入或删除元素。 Deque 扩展了 Queue 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类： Deque 接口 抛出异常 返回特殊值 插入队首 addFirst(E e) offerFirst(E e) 插入队尾 addLast(E e) offerLast(E e) 删除队首 removeFirst() pollFirst() 删除队尾 removeLast() pollLast() 查询队首元素 getFirst() peekFirst() 查询队尾元素 getLast() peekLast() 事实上，Deque 还提供有 push() 和 pop() 等其他方法，可用于模拟栈。 ArrayDeque 与 LinkedList 的区别ArrayDeque 和 LinkedList 都实现了 Deque 接口，两者都具有队列的功能，但两者有什么区别呢？ ArrayDeque 是基于 可变长的数组和双指针 来实现，而 LinkedList 则通过 链表 来实现。 ArrayDeque 不支持存储 NULL 数据 ，但 LinkedList 支持。 ArrayDeque 是在 JDK1.6 才被引入的，而 LinkedList 早在 JDK1.2 时就已经存在。 ArrayDeque 插入时可能 存在扩容过程 , 不过均摊后的插入操作依然为 O(1)。虽然 LinkedList 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。 从性能的角度上，选用 ArrayDeque 来实现队列要比 LinkedList 更好。此外， ArrayDeque 也可以用于实现栈。 说一说 PriorityQueuePriorityQueue 是在 JDK1.5 中被引入的, 其与 Queue 的区别在于元素出队顺序是 与优先级相关 的，即总是 优先级最高的元素先出队 。 PriorityQueue 利用了 二叉堆 的数据结构来实现的，底层使用 可变长的数组 来存储数据 PriorityQueue 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。 PriorityQueue 是 非线程安全 的，且 不支持存储 NULL 和 non-comparable 的对象 。 PriorityQueue 默认是小顶堆 ，但可以接收一个 Comparator 作为构造参数，从而来自定义元素优先级的先后。 什么是 BlockingQueueBlockingQueue （阻塞队列）是一个接口，继承自 Queue 。 BlockingQueue 阻塞的原因是其支持当队列 没有元素时一直阻塞 ，直到有元素；还支持 如果队列已满，一直等到队列可以放入新元素时再放入 。 BlockingQueue 常用于生产者-消费者模型中，生产者线程会向队列中添加数据，而消费者线程会从队列中取出数据进行处理。 BlockingQueue 的实现类有哪些 Java 中常用的阻塞队列实现类有以下几种： ArrayBlockingQueue ：使用数组实现的有界阻塞队列。在创建时需要指定容量大小，并支持公平和非公平两种方式的锁访问机制。 LinkedBlockingQueue ：使用单向链表实现的可选有界阻塞队列。在创建时可以指定容量大小，如果不指定则默认为 Integer.MAX_VALUE 。和 ArrayBlockingQueue 不同的是， 它仅支持非公平的锁访问机制。 PriorityBlockingQueue ：支持优先级排序的无界阻塞队列。元素必须实现 Comparable 接口或者在构造函数中传入 Comparator 对象，并且不能插入 null 元素。 SynchronousQueue ：同步队列，是一种不存储元素的阻塞队列。每个插入操作都必须等待对应的删除操作，反之删除操作也必须等待插入操作。因此， SynchronousQueue 通常用于线程之间的直接传递数据。 DelayQueue ：延迟队列，其中的元素只有到了其指定的延迟时间，才能够从队列中出队。 …… ArrayBlockingQueue 和 LinkedBlockingQueue 有什么区别ArrayBlockingQueue 和 LinkedBlockingQueue 是 Java 并发包中常用的两种阻塞队列实现，它们都是 线程安全 的。不过，不过它们之间也存在下面这些区别： 底层实现： ArrayBlockingQueue 基于 数组 实现，而 LinkedBlockingQueue 基于 链表 实现。 是否有界： ArrayBlockingQueue 是 有界队列 ，必须在创建时指定容量大小。 LinkedBlockingQueue 创建时可以不指定容量大小，默认是 Integer.MAX_VALUE ，也就是无界的。但也 可以指定队列大小，从而成为有界 的。 锁是否分离： ArrayBlockingQueue 中的锁是 没有分离 的，即生产和消费用的是同一个锁； LinkedBlockingQueue 中的锁是 分离 的，即生产用的是 putLock ，消费是 takeLock ，这样可以防止生产者和消费者线程之间的锁争夺。 内存占用： ArrayBlockingQueue 需要 提前分配数组内存 ，而 LinkedBlockingQueue 则是 动态分配链表节点内存 。这意味着， ArrayBlockingQueue 在创建时就会占用一定的内存空间，且往往申请的内存比实际所用的内存更大，而 LinkedBlockingQueue 则是根据元素的增加而逐渐占用内存空间。","link":"/2025/05/17/%E5%85%AB%E8%82%A1/Java/%E9%9B%86%E5%90%88/%E9%9B%86%E5%90%88%20pt%201/"},{"title":"","text":"","link":"/2025/05/21/Rust/The%20Rust%20Programming%20Language/13.2%20%E4%BD%BF%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%84%E7%90%86%E5%85%83%E7%B4%A0%E5%BA%8F%E5%88%97/"},{"title":"","text":"","link":"/2025/04/06/%E5%85%AB%E8%82%A1/Java/IO/IO%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/"},{"title":"","text":"","link":"/2025/04/06/%E5%85%AB%E8%82%A1/Java/IO/NIO%20%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93/"},{"title":"","text":"","link":"/2025/04/06/%E5%85%AB%E8%82%A1/Java/IO/IO%20%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"},{"title":"","text":"","link":"/2025/04/06/%E5%85%AB%E8%82%A1/Java/IO/IO%20%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/"},{"title":"JavaSE pt.2","text":"1. 面向对象基础1.1 面向对象和面向过程的区别？面向过程（ Procedural-Oriented Programming , POP ） 和面向对象 （ Object-Oriented Programming , OOP ） 是两种常见的编程范式，两者的区别主要是解决问题的不同： 面向过程 ： 将解决问题的过程拆成一个一个函数，通过函数的执行解决问题。 面向对象 ： 先抽象出对象，然后用对象执行方法的方式解决问题。 相较于 POP ， OOP 程序一般具有以下优点： 易维护 ： 由于良好的结构和封装性， OOP 程序通常更容易维护。 易复用 ： 通过继承和多态， OOP 设计使得代码更具复用性，方便扩展功能。 易扩展 ： 模块化设计使系统扩展变的更加容易和灵活。 POP 的编程方式通常更为简单和直接，适合处理一些较简单的任务。 POP 和 OOP 的性能差异主要取决于它们的运行机制，而不仅仅是编程范式本身。因此，简单比较两者性能是一个常见误区。（ 相关 issue ） 1.2 创建一个对象用什么运算符？对象实体与对象引用有何不同？new 运算符， new 对象创建对象实例（对象实例在堆内存中）， 对象引用指向对象实例（对象引用存放在栈内存中）。 1 个对象引用可以指向 0 个或 1 个对象 一个对象可以有 n 个引用指向它 1.3 对象相等和引用相等的区别？ 对象的相等一般比较的是内存中查询放的内容是否相等。 引用相等一般比较的是它们指向的内存地址是否相等。 1.4 如果一个类没有声明构造方法，该程序能正确执行吗？如果一个对象没有声明构造方法，也可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果自己添加了构造方法， Java 就不会添加默认的构造方法了。 如果重载了有参的构造方法，记得都要把无参的构造方法也写出来（无论是否用到），因为这可以帮助我们在创建对象的时候少踩坑。 1.5 构造方法有哪些特点？是否可以被 override ？特点： 名称与类名相同 ： 构造方法的名称必须与类名完全一致 没有返回值 ： 构造方法没有返回类型且不能用 void 声明 自动执行 ： 在生成类的对象时，构造方法会自动执行，无需显式调用 构造方法 不能被重写 （ override ） ， 但 可以被重载 （ overload ） 。 1.6 面向对象三大特征？1.6.1 封装封装是指将对象的状态信息 （属性） 隐藏在对象内部， 不允许外部对象直接访问。都是可以提供一些可被外界访问的方法来操作属性。 1.6.2 继承继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。 注意： 子类拥有父类对象的所有属性和方法（包括私有属性和方法），但是父类的私有属性和方法子类无法访问， 只是拥有 。 子类可以拥有自己的属性和方法。 子类可以用自己的方式实现父类的方法。 1.6.3 多态多态表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。 特点： 对象类型和引用类型之间具有继承（类） / 实现（接口） 关系 引用类型变量发出的方法调用的到底时哪个类中的方法，必须在程序运行期间才能确定 多态不能调用 “只在子类存在但父类不存在的方法” 如果子类重写了父类的方法，真正执行的是子类重写的方法，如果没有，执行的是父类的方法。 1.7 接口和抽象类的共同点和区别？共同点： 实例化 ： 接口和抽象类都不能直接实例化，只能被实现 （接口） 或继承 （抽象类） 后才能创建具体的对象。 抽象方法 ： 接口和抽象类都可以包含抽象方法，抽象方法没有方法体，必须在子类或实现类中实现。 区别： 设计目的 ：接口主要用于对类的行为进行约束，实现接口就具有对应的行为。抽象类主要用于代码复用，强调的是所属关系。 继承和实现 ：一个类只能继承一个类 （包括抽象类）一个类可以实现多个接口，一个接口也可以继承多个其他接口。 成员变量 ：接口中的成员变量只能是 public static final 类型的，不能被修改且必须有初始值。抽象类的成员变量可以有任何修饰符 （ private , protected , public ） 可以在子类中被重新定义或赋值。 方法 ： Java 8 之前，接口中的方法默认为 public abstract ， 也就是只能由方法声明。 自 Java 8 起，可以在接口中定义 default 方法和 static 方法，自 Java 9 起，接口可以包含 private 方法。 抽象类可以包含抽象方法和非抽象方法。抽象方法没有方法体，必须在子类中实现。非抽象方法有具体实现，可以直接在抽象类中使用或在子类中重写。 在 Java 8 及以上版本中，接口引入了新的方法类型： default 方法、 static 方法和 private 方法。这些方法让接口的使用更加灵活。 Java 8 引入的 default 方法用于提供接口方法的默认实现，可以在实现类中被覆盖。这样就可以在不修改实现类的情况下向现有接口添加新功能，从而增强接口的扩展性和向后兼容性。 Java 8 引入的 static 方法无法在实现类中被覆盖，只能通过接口名直接调用，类似于类中的静态方法。static 方法通常用于定义一些通用的、与接口相关的工具方法，一般很少用。 Java 9 允许在接口中使用 private 方法。 private 方法可以用于在接口内部共享代码，不对外暴露。 1.8 深拷贝和浅拷贝的区别？什么是引用拷贝？深拷贝与浅拷贝的区别： 浅拷贝 ： 浅拷贝会在堆上创建一个新的对象（区别与深拷贝的一点），不过，如果元对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，即拷贝对象和原对象共用同一个内部对象。 深拷贝 ： 深拷贝会完全复制整个对象，包括对象所包含的内部对象。 实例： 1.8.1 浅拷贝1234567891011121314151617181920212223242526public class Address implements Cloneable{ private String name; // 省略构造函数、Getter&amp;Setter方法 @Override public Address clone() { try { return (Address) super.clone(); } catch (CloneNotSupportedException e) { throw new AssertionError(); } }}public class Person implements Cloneable { private Address address; // 省略构造函数、Getter&amp;Setter方法 @Override public Person clone() { try { Person person = (Person) super.clone(); return person; } catch (CloneNotSupportedException e) { throw new AssertionError(); } }} 结果： 1234Person person1 = new Person(new Address(&quot;武汉&quot;));Person person1Copy = person1.clone();// trueSystem.out.println(person1.getAddress() == person1Copy.getAddress()); 从输出结构就可以看出， person1 的克隆对象和 person1 使用的仍然是同一个 Address 对象。 1.8.2 深拷贝12345678910@Overridepublic Person clone() { try { Person person = (Person) super.clone(); person.setAddress(person.getAddress().clone()); return person; } catch (CloneNotSupportedException e) { throw new AssertionError(); }} 结果： 1234Person person1 = new Person(new Address(&quot;武汉&quot;));Person person1Copy = person1.clone();// falseSystem.out.println(person1.getAddress() == person1Copy.getAddress()); 从输出结构可以看出，显然 person1 的克隆对象和 person1 包含的 Address 对象已经是不同的了。 1.8.3 引用拷贝引用拷贝就是两个不同的引用指向同一个对象。 2. Object2.1 Object 类的常见方法有哪些？1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。 */public final native Class&lt;?&gt; getClass()/** * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。 */public native int hashCode()/** * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。 */public boolean equals(Object obj)/** * native 方法，用于创建并返回当前对象的一份拷贝。 */protected native Object clone() throws CloneNotSupportedException/** * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。 */public String toString()/** * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。 */public final native void notify()/** * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。 */public final native void notifyAll()/** * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。 */public final native void wait(long timeout) throws InterruptedException/** * 多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。 */public final void wait(long timeout, int nanos) throws InterruptedException/** * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念 */public final void wait() throws InterruptedException/** * 实例被垃圾回收器回收的时候触发的操作 */protected void finalize() throws Throwable { } 2.2 == 和 equals() 的区别？== 对基本类型和引用类型的作用是不同的： 对基本数据类型， == 比较的是值 对引用数据类型， == 比较的是对象的内存地址 Java 只有值传递，所以对 == 来说，不管是基本数据类型还是引用数据类型，其本质都是比较值。 equals() 不能用于基本数据类型的判断。 equals() 存在于 Object 类中， 因此所有的类都有 equals() 方法。 equals() 方法存在两种使用情况： 类没有重写： 等价于通过 == 比较对象。 类重写了： 一般都重写 equals() 方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true (即认为这两个对象相等)。 String 中的 equals 方法是被重写过的，因为 Object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。 当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。 String 类 equals() 方法： 123456789101112131415161718192021public boolean equals(Object anObject) { if (this == anObject) { return true; } if (anObject instanceof String) { String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) { char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) { if (v1[i] != v2[i]) return false; i++; } return true; } } return false;} 2.3 hashcode() 有什么用？hashcode() 的作用是获取哈希值（ int 整形 ）， 也称为散列码，用于确定该对象在哈希表中的索引位置。 hashCode() 定义在 JDK 的 Object 类中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。另外需要注意的是： Object 的 hashCode() 方法是本地方法，也就是用 C 语言或 C++ 实现的。 散列表存储的是键值对( key-value )，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象） 2.4 为什么要有 hashcode() ？ 当把对象加入 HashSet 时， HashSet 会先计算对象的 hashCode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashCode 值作比较，如果没有相符的 hashCode ， HashSet 会假设对象没有重复出现。但是如果发现有相同 hashCode 值的对象，这时会调用 equals() 方法来检查 hashCode 相等的对象是否真的相同。如果两者相同， HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。—— Head First Java hashCode() 和 equals() 都是用于比较两个对象是否相等。 2.4.1 为什么 JDK 还要同时提供这两个方法呢？在一些容器（比如 HashMap 、 HashSet ）中，有了 hashCode() 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进 HashSet 的过程） 在前面也提到了添加元素进 HashSet 的过程，如果 HashSet 在对比的时候，同样的 hashCode 有多个对象，它会继续使用 equals() 来判断是否真的相同。也就是说 hashCode 帮助我们大大缩小了查找成本。 2.4.2 为什么不只提供 hashCode() 方法呢？因为两个对象的 hashCode 值相等并不代表两个对象就相等。 hashCode() 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（ 所谓哈希碰撞也就是指的是不同的对象得到相同的 hashCode )。 总结： 两个对象的 hashcode 值相等， 两个对象不一定相等。 两个对象的 hashcode 值相等且 equals() 方法返回 true ，才认为两个对象相等。 两个对象的 hashcode 不相等， 可以直接认为两个对象不相等。 2.5 为什么重写 equals() 方法时必须重写 hashcode() 方法？因为两个相等的对象的 hashCode 值必须是相等。也就是说如果 equals 方法判断两个对象是相等的，那这两个对象的 hashCode 值也要相等。 如果重写 equals() 时没有重写 hashCode() 方法的话就可能会导致 equals 方法判断是相等的两个对象， hashCode 值却不相等。 思考 ： 重写 equals() 时没有重写 hashCode() 方法的话，使用 HashMap 可能会出现什么问题。 答案： 基础： 会出现 equals 判断相同的对象由于 hashcode 不同导致 hashmap 中存在多个相同的对象。 Deepseek 优化： 当重写 equals() 而未重写 hashCode() 时，使用 HashMap 可能引发以下问题： 哈希冲突误判： HashMap 通过 hashCode() 确定键值对的存储桶位置。若两个逻辑相等的对象（ equals() 为 true ）产生不同哈希值，它们会被错误分配到不同存储桶，导致 HashMap 无法识别其等价性。 数据重复存储：本应覆盖的键值对会作为不同键被重复存储，例如 map.put(a,1) 和 map.put(b,1) 会形成两个独立条目（ 尽管 a.equals(b) == true ）。 检索数据失败：通过等价对象查询时（ 如 map.get(b) 查询已存入的 a ），由于哈希定位到错误存储桶，可能返回 null 而非预期值。 破坏契约原则：违反 Java 对象契约（ equal 对象必须有相同 hashCode ），导致所有依赖哈希机制的集合类（ HashSet 、 HashTable 等）行为异常。 总结 ： equals 方法判断两个对象是相等的，那这两个对象的 hashCode 值也要相等。 两个对象有相同的 hashCode 值，他们也不一定是相等的（哈希碰撞）。 3. String3.1 String , StringBuffer , StringBuilder 的区别？可变性： String 是不可变的。 StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串，不过没有使用 final 和 private 关键字修饰，最关键的是 AbstractStringBuilder 类还提供了很多修改字符串的方法，比如 append 方法。 12345678910111213abstract class AbstractStringBuilder implements Appendable, CharSequence { char[] value; public AbstractStringBuilder append(String str) { if (str == null) return appendNull(); int len = str.length(); ensureCapacityInternal(count + len); str.getChars(0, len, value, count); count += len; return this; } //...} 线程安全性 ： String 中的对象是不可变的，也就可以理解为常量，线程安全。 AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity 、 append 、 insert 、 indexOf 等公共方法。 StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。 StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。 性能 ： 每次对 String 类型进行改变时都会生成一个新的 String 对象，然后将指针指向新的对象。 StringBuffer 每次都会对对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10% ~ 15% 的性能提升，但却要冒多线程不安全的风险。 总结： 操作少量数据： 用 String 单线程操作字符串缓冲区下操作大量数据： StringBuilder 多线程操作字符串缓冲区下操作大量数据： StringBuffer 3.2 String 为什么不可变？String 类中使用 fianl 关键字修饰字符数组来保存字符串 1234public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence { private final char value[]; //...} 注意：被 fianl 修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象。因此， fianl 修饰的数组保存字符串并不是 String 不可变的根本原因， 因为这个数组保存的字符串是可变的（ final 修饰引用类型变量的情况）。 String 真正不可变的原因： 保存字符串的数组被 final 修饰且为私有的，并且 String 类没有提供/暴露修改这个字符串的方法。 String 类被 final 修饰导致其不能被继承，进而避免了子类破坏 String 不可变。 补充：在 Java 9 之后， String StringBuilder 与 StringBuffer 的实现被改用 byte 数组存储字符串。 12345678910public final class String implements java.io.Serializable,Comparable&lt;String&gt;, CharSequence { // @Stable 注解表示变量最多被修改一次，称为“稳定的”。 @Stable private final byte[] value;}abstract class AbstractStringBuilder implements Appendable, CharSequence { byte[] value;} Java 9 为何要将 String 的底层实现由 char[] 改成了 byte[] ?新版的 String 支持两个编码方案： Latin-1 和 UTF-16 。如果字符串中包含的汉字没有超过 Latin-1 可表示范围内的字符，那就会使用 Latin-1 。 Latin-1 编码方案下， byte 占一个字节（ 8 位 ）， char 占用 2 个字节（ 16 ）， byte 相较 char 节省一半的内存空间。 如果字符串中包含的汉字超过 Latin-1 可表示范围内的字符，byte 和 char 所占用的空间是一样的。 官方介绍 3.3 字符串拼接用 + 还是 StringBuilder ？Java 语言本身不支持运算符重载， “+”和“+=”是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的运算符。 1234String str1 = &quot;he&quot;;String str2 = &quot;llo&quot;;String str3 = &quot;world&quot;;String str4 = str1 + str2 + str3; 对应字节码： 可以看出，字符串对象通过“+”的字符串拼接方式，实际上是通过 StringBuilder 调用 append() 方法实现的，拼接完成之后调用 toString() 得到一个 String 对象 。 不过，在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：编译器不会创建单个 StringBuilder 以复用，会导致创建过多的 StringBuilder 对象。 123456String[] arr = {&quot;he&quot;, &quot;llo&quot;, &quot;world&quot;};String s = &quot;&quot;;for (int i = 0; i &lt; arr.length; i++) { s += arr[i];}System.out.println(s); StringBuilder 对象是在循环内部被创建的，这意味着每循环一次就会创建一个 StringBuilder 对象。 如果直接使用 StringBuilder 对象进行字符串拼接的话，就不会存在这个问题了。 123456String[] arr = {&quot;he&quot;, &quot;llo&quot;, &quot;world&quot;};StringBuilder s = new StringBuilder();for (String value : arr) { s.append(value);}System.out.println(s); 在 JDK 9 中，字符串相加“+”改为用动态方法 makeConcatWithConstants() 来实现，通过提前分配空间从而减少了部分临时对象的创建。然而这种优化主要针对简单的字符串拼接，如： a+b+c 。对于循环中的大量拼接操作，仍然会逐个动态分配内存（类似于两个两个 append 的概念），并不如手动使用 StringBuilder 来进行拼接效率高。 3.4 String equals() 和 Object equals() 有什么区别？String 中的 equals 方法是被重写过的，比较的是 String 字符串的值是否相等。 Object 的 equals 方法是比较的对象的内存地址。 3.5 字符串常量池的作用？字符串常量池 是 JVM 为了提升性能和减少内存消耗针对字符串（ String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。 123456// 在字符串常量池中创建字符串对象 ”ab“// 将字符串对象 ”ab“ 的引用赋值给 aaString aa = &quot;ab&quot;;// 直接返回字符串常量池中字符串对象 ”ab“，赋值给引用 bbString bb = &quot;ab&quot;;System.out.println(aa==bb); // true 3.6 String s1 = new String(“abc”);这句话创建了几个字符串对象？答案：会创建 1 或 2 个字符串对象。 字符串常量池中不存在 “abc”：会创建 2 个 字符串对象。一个在字符串常量池中，由 ldc 指令触发创建。一个在堆中，由 new String() 创建，并使用常量池中的 “abc” 进行初始化。 字符串常量池中已存在 “abc”：会创建 1 个 字符串对象。该对象在堆中，由 new String() 创建，并使用常量池中的 “abc” 进行初始化。 分析： 如果字符串常量池中不存在字符串对象 “abc”，那么它首先会在字符串常量池中创建字符串对象 “abc”，然后在堆内存中再创建其中一个字符串对象 “abc”。 字节码： 12345678910111213141516171819// 在堆内存中分配一个尚未初始化的 String 对象。// #2 是常量池中的一个符号引用，指向 java/lang/String 类。// 在类加载的解析阶段，这个符号引用会被解析成直接引用，即指向实际的 java/lang/String 类。0 new #2 &lt;java/lang/String&gt;// 复制栈顶的 String 对象引用，为后续的构造函数调用做准备。// 此时操作数栈中有两个相同的对象引用：一个用于传递给构造函数，另一个用于保持对新对象的引用，后续将其存储到局部变量表。3 dup// JVM 先检查字符串常量池中是否存在 &quot;abc&quot;。// 如果常量池中已存在 &quot;abc&quot;，则直接返回该字符串的引用；// 如果常量池中不存在 &quot;abc&quot;，则 JVM 会在常量池中创建该字符串字面量并返回它的引用。// 这个引用被压入操作数栈，用作构造函数的参数。4 ldc #3 &lt;abc&gt;// 调用构造方法，使用从常量池中加载的 &quot;abc&quot; 初始化堆中的 String 对象// 新的 String 对象将包含与常量池中的 &quot;abc&quot; 相同的内容，但它是一个独立的对象，存储于堆中。6 invokespecial #4 &lt;java/lang/String.&lt;init&gt; : (Ljava/lang/String;)V&gt;// 将堆中的 String 对象引用存储到局部变量表9 astore_1// 返回，结束方法10 return 3.7 String intern 方法有什么用？String.intern() 是一个 native 方法，用于处理字符串常量池中的对象引用。工作流程： 常量池中已有相同内容的字符串对象 ： 如果字符串常量池中已经有一个与调用 intern() 方法的字符串内容相同的对象， intern() 返回常量池中该对象的引用。 常量池中没有相同内容的字符串对象 ： intern() 方法会将当前字符串对象的引用添加到字符串常量池中，并返回该引用。 总结： intern() 方法的主要作用是确保字符串引用在常量池中的唯一性。 当调用 intern() 时，如果常量池中已经存在相同内容的字符串，则返回常量池中已有对象的引用；否则，将该字符串添加到常量池并返回其引用。 1234567891011121314// s1 指向字符串常量池中的 &quot;Java&quot; 对象String s1 = &quot;Java&quot;;// s2 也指向字符串常量池中的 &quot;Java&quot; 对象，和 s1 是同一个对象String s2 = s1.intern();// 在堆中创建一个新的 &quot;Java&quot; 对象，s3 指向它String s3 = new String(&quot;Java&quot;);// s4 指向字符串常量池中的 &quot;Java&quot; 对象，和 s1 是同一个对象String s4 = s3.intern();// s1 和 s2 指向的是同一个常量池中的对象System.out.println(s1 == s2); // true// s3 指向堆中的对象，s4 指向常量池中的对象，所以不同System.out.println(s3 == s4); // false// s1 和 s4 都指向常量池中的同一个对象System.out.println(s1 == s4); // true 3.8 String 类型的变量和常量做 “+” 运算时发生了什么？不加 final 关键词 ： 12345678String str1 = &quot;str&quot;;String str2 = &quot;ing&quot;;String str3 = &quot;str&quot; + &quot;ing&quot;;String str4 = str1 + str2;String str5 = &quot;string&quot;;System.out.println(str3 == str4);//falseSystem.out.println(str3 == str5);//trueSystem.out.println(str4 == str5);//false 注意 ：比较 String 字符串的值是否相等，可以使用 equals() 方法。 String 中的 equals 方法是被重写过的。 Object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是字符串的值是否相等。如果你使用 == 比较两个字符串是否相等的话，IDEA 还是提示你使用 equals() 方法替换。 对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。 在编译过程中，Javac 编译器（下文中统称为编译器）会进行一个叫做 常量折叠(Constant Folding) 的代码优化。 常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。 对于 String str3 = &quot;str&quot; + &quot;ing&quot;; 编译器会优化成 String str3 = &quot;string&quot;; 。 并不是所有的常量都会进行折叠，只有编译器在程序编译期就可以确定值的常量才可以： 基本数据类型( byte、boolean、short、char、int、float、long、double)以及字符串常量。 final 修饰的基本数据类型和字符串变量 字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（&lt;&lt;、&gt;&gt;、&gt;&gt;&gt; ） 引用的值在程序编译期是无法确定的，编译器无法对其进行优化。 对象引用和“+”的字符串拼接方式，实际上是通过 StringBuilder 调用 append() 方法实现的，拼接完成之后调用 toString() 得到一个 String 对象 。 1String str4 = new StringBuilder().append(str1).append(str2).toString(); 在平时写代码的时候，尽量避免多个字符串对象拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 StringBuilder 或者 StringBuffer 。 不过，字符串使用 final 关键字声明之后，可以让编译器当做常量来处理 ： 123456final String str1 = &quot;str&quot;;final String str2 = &quot;ing&quot;;// 下面两个表达式其实是等价的String c = &quot;str&quot; + &quot;ing&quot;;// 常量池中的对象String d = str1 + str2; // 常量池中的对象System.out.println(c == d);// true 被 final 关键字修饰之后的 String 会被编译器当做常量来处理，编译器在程序编译期就可以确定它的值，其效果就相当于访问常量。 NEXTJavaSE pt.3","link":"/2025/03/25/%E5%85%AB%E8%82%A1/Java/Java%E5%9F%BA%E7%A1%80/JavaSE%20pt.2/"},{"title":"JavaSE pt.1","text":"First tip：根据 JavaGuide 和 Deepseek 内容整理 1. 基础概念与常识1.1 Java 语言有哪些特点？ 简单易学（语法简单，容易上手） 面向对象（封装、继承、多态） 平台无关（Java 虚拟机） 支持多线程 可靠性（异常处理、GC） 安全性（访问权限修饰符、限制程序直接访问系统资源） 高效性（通过 JIT[^JIT] 编译器等技术优化） 支持网络编程 编译与解释并存 [^JIT]: JIT 即 “Just in Time” 拓展：“Write once, Run everywhere” ，即跨平台这一特点已经不再是 Java 的主要特点了（ Docker 等技术的出现使跨平台相当轻松）。Java 的优势转变为了其强大的生态。 1.2 JavaSE 和 JavaEE JavaSE ( Java Platform, Standard Edition )： Java 编程语言的基础，包含了支持 Java 程序开发和运行的核心类库以及 JVM 等核心组件。可以用于构建桌面应用程序或简单的服务器应用程序。 JavaEE ( Java Platform, Enterprise Edition )：建立在 JavaSE 的基础上，包含了支持企业级应用开发和部署的标准与规范（ Servlet、 JSP、 EJB、 JDBC、 JPA、 JTA 等）。可以用于构建分布式、可移植、健壮、可伸缩和安全的服务端 Java 应用程序。 简单来说，Java SE 是 Java 的基础版本，Java EE 是 Java 的高级版本。Java SE 更适合开发桌面应用程序或简单的服务器应用程序，Java EE 更适合开发复杂的企业级应用程序或 Web 应用程序。 1.3 JVM、JDK、JRE1.3.1 JVMJVM ( Java Virtual Machine ) 是运行 Java 字节码 的虚拟机。JVM 有针对不同系统的实现，目的是使用相同的字节码得到相同的结果。字节码和 JVM 是实现 Java 语言 “Write once, Run everywhere” 的关键。 JVM 不止一种，只要满足 JVM 规范，每个公司、组织或者个人都可以开发自己的专属 JVM。 我们平时接触到的 HotSpotVM 只是 JVM 规范的一种实现。 除了 HotSpotVM 外，还有 J9 VM, Zing VM, JRockit VM 等实现。 1.3.2 JDK 和 JREJDK( Java Development Kit )是 Java 开发工具包，用于创建和编译 Java 程序。它包含了 JRE ( Java Runtime Environment ) 以及编译器 Javac 和其他工具 ( javadoc, jdb（调试器）, jconsole（监控工具）, javap(反编译工具) )。 JRE 是运行已编译的 Java 程序所需的环境，包括： JVM Java 基础类库 ( Class Library )：一组标准类库，提供常用的功能和 API（如 I/O 操作、 网络通信、 数据结构 等） 简单来说，JRE 只包含运行 Java 程序所需的环境和类库，而 JDK 不仅包含 JRE ，还包括用于开发和调试的工具。 不过，从 JDK 9 开始，就不需要区分 JDK 和 JRE 的关系了，取而代之的是模块系统（ JDK 被重新组织成 94 个模块）+ jlink 工具 (随 Java 9 一起发布的新命令行工具，用于生成自定义 Java 运行时映像，该映像仅包含给定应用程序所需的模块) 。并且，从 JDK 11 开始，Oracle 不再提供单独的 JRE 下载。 可以用 jlink 根据自己的需求，创建一个更小的 runtime ，而不是都使用同样的 JRE 。 定制的、模块化的 Java 运行时映像有助于简化 Java 应用的部署和节省内存、增强安全性和可维护性。 1.4 什么是字节码？采用字节码的好处是什么？在 Java 中，能被 JVM 理解的代码（即扩展名为 .class 的文件）就是字节码，它不面向任何特定的处理器，只面向虚拟机。字节码在一定程度上解决了传统解释型语言执行效率低的问题，保留了解释型语言可移植的特点。因此 Java 程序无需重新编译便可在多种不同操作系统上运行。 .class -&gt; 机器码 这一步 JVM 类加载器 首先加载字节码文件，然后通过解释器逐行解释执行，这种方式执行速度相对较慢。而且，有些方法和代码块经常需要被调用（即热点代码），所以后来引进了 JIT ( Just In Time Compilation )编译器， 而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。这也解释了为什么经常说 Java 是编译与解释共存的语言。 HotSpot 采用了惰性评估 ( Lazy Evaluation ) 的做法，根据二八定律，消耗大部分系统资源的只有一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。 1.5 为什么说 Java 语言 “编译与解释并存” ？该问题在 上一问 已经提到过。 1.5.1 分类我们可以将高级语言按照程序的执行方式分为两类： 编译型： 编译型语言 会通过 编译器 将源代码一次性翻译成机器码。一般编译型语言执行速度较快，开发效率较低。 解释型： 解释型语言 会通过 解释器 一句一句的将代码解释（interpret）为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。 为了改善解释语言的效率而发展出的即时编译技术，已经缩小了这两种语言间的差距。这种技术混合了编译语言与解释型语言的优点，它像编译语言一样，先把程序源代码编译成字节码。到执行期时，再将字节码直译，之后执行。Java 与 LLVM 是这种技术的代表产物。 1.5.2 为什么说 Java 语言 “编译与解释并存” ？这是因为 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（.class 文件），这种字节码必须由 Java 解释器来解释执行。 1.6 AOT 有什么优点？为什么不全部使用 AOT ？JDK9 引入了新的编译模式 AOT ( Ahead Of Time Compilation ) 。 和 JIT 不同的是，这种编译模式会在程序被执行前就将其编译成机器码，属于静态编译（ C、C++、Rust、Go 等语言就是静态编译）。AOT 避免了 JIT 预热等各方面的开销，可以提高 Java 程序的启动速度，避免预热时间过长。并且， AOT 还能减少内存占用和增强 Java 程序的安全性 （ AOT 编译后的代码不容易被反编译和修改）， 特别适合云原生场景。 可以看出， AOT 的主要优势在于启动时间、内存占用和打包体积。 JIT 的主要优势在于具备更高的极限处理能力，可以降低请求的最大延迟。 1.6.1 既然 AOT 有那么多优点，为什么不全部使用 AOT ？JIT 和 AOT 各有优点， AOT 更适合云原生场景，对微服务架构的支持也比较友好。除此之外， AOT 编译无法支持 Java 的一些动态特性，如反射、动态代理、动态加载、 JNI ( Java Native Interface ) 等。然而，很多框架和库（如 Spring 、 CGLIB ）都用到了这些特性。如果只使用 AOT 编译，那就无法使用这些库和框架了，或者说需要针对性地去做适配和优化。 1.7 Oracle JDK 和 OpenJDKOracle 官方在 2012 年的博客： 问：OpenJDK 存储库中的源代码与用于构建 Oracle JDK 的代码之间有什么区别？答：非常接近 - 我们的 Oracle JDK 版本构建过程基于 OpenJDK 7 构建，只添加了几个部分，例如部署代码，其中包括 Oracle 的 Java 插件和 Java WebStart 的实现，以及一些闭源的第三方组件，如图形光栅化器，一些开源的第三方组件，如 Rhino，以及一些零碎的东西，如附加文档或第三方字体。展望未来，我们的目的是开源 Oracle JDK 的所有部分，除了我们考虑商业功能的部分。 OracleJDK 和 OpenJDK 的区别： 是否开源： OpenJDK 是一个完全开源的参考模型，而 Oracle JDK 是基于 OpenJDK 实现的，并非完全开源。OpenJDK 开源项目：Github 。 是否免费： OracleJDK 提供免费版本，但一般有时间限制。 JDK17 之后的版本可以免费分发和商用，但仅有 3 年时间， 3 年后无法免费商用。不过，JDK8u221 之前只要不升级可以无限期免费。 OpenJDK 是完全免费的。 功能性： OracleJDK 在 OpenJDK 的基础上添加了一些特有的功能和工具，比如 Java Flight Recorder ( JFR ， 一种监控工具 ) 、 Java Mission Control ( JMC ，一种监控工具 ) 等工具。不过，在 Java 11 之后， OracleJDK 和 OpenJDK 的功能基本一致，之前 OracleJDK 中的私有组件大部分也已经被捐赠给开源组织。 稳定性： OpenJDK 不提供 LTS 服务， 而 OracleJDK 大概每三年都会推出一个 LTS 版本进行长期支持。不过，很多公司都基于 OpenJDK 提供了对应的和 OracleJDK 周期相同的 LTS 版本。因此，两者的稳定性其实差不多。 协议： OracleJDK 使用 BCL/OTN 协议， 而 OpenJDK 根据 GPLv2 许可获得许可。 既然 Oracle JDK 这么好，那为什么还要有 OpenJDK？ OpenJDK 是开源的，开源意味着你可以对它根据你自己的需要进行修改、优化，比如 Alibaba 基于 OpenJDK 开发了 Dragonwell8。 OpenJDK 是商业免费的（这也是为什么通过 yum 包管理器上默认安装的 JDK 是 OpenJDK 而不是 Oracle JDK）。虽然 Oracle JDK 也是商业免费（比如 JDK 8），但并不是所有版本都是免费的。 OpenJDK 更新频率更快。Oracle JDK 一般是每 6 个月发布一个新版本，而 OpenJDK 一般是每 3 个月发布一个新版本。（现在你知道为啥 Oracle JDK 更稳定了吧，先在 OpenJDK 试试水，把大部分问题都解决掉了才在 Oracle JDK 上发布） 1.7.1 Oracle JDK 和 OpenJDK 如何选择？建议选择 OpenJDK 或者基于 OpenJDK 的发行版，比如 AWS 的 Amazon Corretto，阿里巴巴的 Alibaba Dragonwell。 1.8 C++ 和 Java 的区别？虽然 Java 和 C++ 都是面向对象的语言，但是它们有挺多不同的地方： Java 不提供指针直接访问内存，程序内存更安全。 Java 是单继承的， C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以。 Java 有自动内存管理垃圾回收机制（GC），不需要程序员手动释放无用内存。 C++ 同时支持方法重载和操作符重载， Java 只支持方法重载（操作符重载增加了复杂性）。 2. 基本语法2.1 注释有哪几种形式？ 单行注释 多行注释 文档注释 用得较多的是单行注释和文档注释，多行注释在开发中使用的相对较少。 代码的注释不是越详细越好。实际上好的代码本身就是注释，我们要尽量规范和美化自己的代码来减少不必要的注释。若编程语言足够有表达力，就不需要注释，尽量通过代码来阐述。例子：去掉下面复杂的注释，只需要创建一个与注释所言同一事物的函数即可 12// check to see if the employee is eligible for full benefitsif ((employee.flags &amp; HOURLY_FLAG) &amp;&amp; (employee.age &gt; 65)) 应替换为 1if (employee.isEligibleForFullBenefits()) 2.2 标识符和关键字的区别是什么？简单来说，标识符就是一个名字。 有一些标识符， Java 语言已经赋予其特殊的含义，只能在特定的地方使用，这些标识符就是 关键字 。 简单来说， 关键字就是被赋予特殊含义的标识符。 2.2.1 Java 语言的关键字有哪些？ 分类 关键 字 访问控制 private protected public 类、方法和变量修饰符 abstract class extends final implements interface native new static strictfp synchronized transient volatile enum 程序控制 break continue return do while if else for instanceof switch case default assert 错误处理 try catch throw throws finally 包相关 import package 基本类型 boolean byte char double float int long short 变量引用 super this void 保留字 goto const Tips: 所有的关键字都是小写的，在 IDE 中以特殊颜色显示default 这个关键字既属于程序控制，也属于类、方法和变量修饰符。 在程序控制中，当在 switch 中匹配不到任何情况时，可以使用 default 编写默认匹配的情况。 在类、方法和变量修饰符中，从 JDK8 开始引入了默认方法，可以使用 default 关键字来定义一个方法的默认实现。 在访问控制中，如果一个方法前没有任何修饰符，则默认会有一个修饰符 default ，但是这个修饰符加上就会报错。 注意： 虽然 true , false 和 null 看起来像关键字但实际上它们只是字面量，不可以作为标识符使用。 官方文档：https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html 2.3 自增自减运算符Java 提供了自增 ( ++ ) 和自减 ( -- ) 运算符来简化操作。 ++ 和 -- 运算符可以放在变量前后： 前缀： 先自增（减）变量的值，然后再使用该变量。 后缀： 先使用该变量，再自增（减）。 笔试题： 运行该代码后 a , b , c , d 和 e 分别为？ 12345678910int a = 9;// 1 --&gt; a = 9int b = a++;// 2 --&gt; a = 10 , b = 9int c = ++a;// 3 --&gt; a = 11 , b = 9 , c = 11int d = c--;// 4 --&gt; a = 11 , b = 9 , c = 10 , d = 11int e = --d;// 5 --&gt; a = 11 , b = 9 , c = 10 , d = 10 , e = 10 答案： a = 11 、b = 9 、 c = 10 、 d = 10 、 e = 10 。具体过程看注释。 2.3 移位运算符移位运算符是最基本的运算符之一，几乎每种编程语言都包含这一运算符。移位操作中，被操作的数据被视为二进制数，移位就是将其向左或向右移动若干位的运算。 移位运算符在各种框架以及 JDK 自身的源码中使用还是挺广泛的，HashMap（JDK1.8） 中的 hash 方法的源码就用到了移位运算符： 1234567static final int hash(Object key) { int h; // key.hashCode()：返回散列值也就是hashcode // ^：按位异或 // &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); } 使用移位运算符的主要原因： 高效 ： 移位运算符直接对应处理器的移位指令，这些指令通常在一个时钟周期内完成。 节省内存 ： 通过移位操作可以使一个整数存储多个布尔值或标志位。 移位运算符最常用于快速乘以或除以 2 的幂次方。除此之外，它还在以下方面发挥着重要作用： 位字段管理 ： 存储和操作多个布尔值。 哈希算法和加密算法 ： 通过移位和与、或等操作来混淆数据。 数据压缩 ： 如霍夫曼编码通过移位运算符可以快速处理和操作二进制数据，已生成紧凑的压缩格式。 数据校验 ： 如 CRC （循环冗余校验）通过移位和多项式除法生成和校验数据完整性。 内存对齐 ： 通过移位操作可以计算和调整数据的对齐地址。 Java 中有三种移位运算符： &lt;&lt; ： 左移运算符，向左移若干位，高位丢弃，低位补零，相当于乘 2^n（不溢出的情况下）。 &gt;&gt; ： 带符号右移，高位补符号位，低位丢弃。相当于除 2^n 。 &gt;&gt;&gt; ： 无符号右移，忽略符号位，空位补零。 由于 double ， float 在二进制中的表现比较特殊，因此不能来进行移位操作。 移位操作符实际上支持的类型只有 int 和 long ，编译器在对 short 、 byte 、 char 类型进行移位前，都会将其转换为 int 类型再操作。 2.3.1 如果移位的位数超过数值所占的位数会怎么样？当 int 类型左移/右移位数大于等于 32 位操作时，会先求余（%）后再进行左移/右移操作。也就是说左移/右移 32 位相当于不进行移位操作（32%32=0），左移/右移 42 位相当于左移/右移 10 位（42%32=10）。当 long 类型进行左移/右移操作时，由于 long 对应的二进制是 64 位，因此求余操作的基数也变成了 64。 也就是说： x&lt;&lt;42 等同于 x&lt;&lt;10 ， x&gt;&gt;42 等同于 x&gt;&gt;10 ， x &gt;&gt;&gt;42 等同于 x &gt;&gt;&gt; 10 。 代码示例： 123456int i = -1;System.out.println(&quot;初始数据：&quot; + i);System.out.println(&quot;初始数据对应的二进制字符串：&quot; + Integer.toBinaryString(i));i &lt;&lt;= 10;System.out.println(&quot;左移 10 位后的数据 &quot; + i);System.out.println(&quot;左移 10 位后的数据对应的二进制字符 &quot; + Integer.toBinaryString(i)); 输出： 1234初始数据：-1初始数据对应的二进制字符串：11111111111111111111111111111111左移 10 位后的数据 -1024左移 10 位后的数据对应的二进制字符 11111111111111111111110000000000 由于左移位数大于等于 32 位操作时，会先求余（%）后再进行左移操作，所以下面的代码左移 42 位相当于左移 10 位（42%32=10），输出结果和前面的代码一样。 123456int i = -1;System.out.println(&quot;初始数据：&quot; + i);System.out.println(&quot;初始数据对应的二进制字符串：&quot; + Integer.toBinaryString(i));i &lt;&lt;= 42;System.out.println(&quot;左移 10 位后的数据 &quot; + i);System.out.println(&quot;左移 10 位后的数据对应的二进制字符 &quot; + Integer.toBinaryString(i)); 右移运算符使用类似。 2.4 continue 、 break 和 return 的区别是什么？ continue ：跳出当前一次的循环，继续下一次循环。 break ： 跳出整个循环体。 return 用于跳出当前方法。一般用于： return ： 直接结束方法执行，没有返回值。 return value ： 返回一个特定值。 思考： 下列语句的结果是什么？ 12345678910111213141516171819202122232425262728293031323334public static void main(String[] args) { boolean flag = false; for (int i = 0; i &lt;= 3; i++) { if (i == 0) { // 1 --&gt; i = 0 , f = f , sout 0 System.out.println(&quot;0&quot;); // i++ sout xixi } else if (i == 1) { // 2 --&gt; i = 1 , f = f , sout 1 System.out.println(&quot;1&quot;); // i++ continue; } else if (i == 2) { // 3 --&gt; i = 2 , f = f , sout 2 System.out.println(&quot;2&quot;); flag = true; // i++ f = t sout xixi } else if (i == 3) { // 4 --&gt; i = 3 , f = t , sout 3 System.out.println(&quot;3&quot;); //break break; } else if (i == 4) { System.out.println(&quot;4&quot;); } System.out.println(&quot;xixi&quot;); } if (flag) { // 5 --&gt; sout haha System.out.println(&quot;haha&quot;); return; } System.out.println(&quot;heihei&quot;);} 结果： 12345670xixi12xixi3haha 3. 基本数据类型3.1 Java 中的几种基本数据类型？ 6 种数字类型 4 种整数型： byte , short , int , long 2 种浮点型： float , double 1 种字符型： char 1 种布尔型： boolean 基本数据类型的默认值和所占空间： 基本类型 位数 字节 默认值 取值范围 byte 8 1 0 -128 ~ 127 short 16 2 0 -2 ^ 15 ~ 2 ^ 15 - 1 int 32 4 0 -2 ^ 31 ~ 2 ^ 31 - 1 long 64 8 0L -2 ^ 63 ~ 2 ^ 63 - 1 char 16 2 ‘u0000’ 0 ~ 2 ^ 16 - 1 float 32 4 0f 1.4 E -45 ~ 3.4028235 E 38 double 64 8 0d 4.9 E -324 ~ 1.7976931348623157 E 308 boolean 1 false true , false 对于 boolean ，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。逻辑上理解是占用 1 位，但是实际中会考虑计算机高效存储因素。 Java 的每种基本类型所占存储空间的大小不会像其他大多数语言那样随机器硬件架构的变化而变化。这种所占存储空间大小的不变性是 Java 程序比用其他大多数语言编写的程序更具可移植性的原因之一。 注意： Java 里使用 long 类型的数据一定要加上 L ， 否则将作为整形解析。 Java 里使用 float 类型一定要加上 f 或 F ， 否则无法通过编译。 char = h char 单引号 String a = &quot;hello&quot; String 双引号。 这八种基本类型都有对应的包装类分别为： Byte 、 Short 、 Integer 、 Long 、 Float 、 Double 、 Character 、 Boolean 。 3.2 基本类型和包装类型的区别？ 用途 ： 除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。并且，包装类型可用于泛型，而基本类型不可以。 存储方式 ： 基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 static 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。 占用空间 ： 相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。 默认值 ： 成员变量包装类型不赋值就是 null ，而基本类型有默认值且不是 null。 比较方式 ： 对于基本数据类型来说，== 比较的是值。对于包装数据类型来说，== 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 equals() 方法。 为什么说是几乎所有对象实例都存在于堆中呢？ 这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存 注意： 基本数据类型存放在栈中是一个常见的误区！ 基本数据类型的存储位置取决于它们的作用和声明方式。如果它们是局部变量，那么它们会存放在栈中；如果它们是成员变量，那么们会存放在堆/方法区/元空间中。 12345678910111213public class Test { // 成员变量，存放在堆中 int a = 10; // 被 static 修饰的成员变量，JDK 1.7 及之前位于方法区，1.8 后存放于元空间，均不存放于堆中。 // 变量属于类，不属于对象。 static int b = 20; public void method() { // 局部变量，存放在栈中 int c = 30; static int d = 40; // 编译错误，不能在方法中使用 static 修饰局部变量 }} 3.3 包装类型的缓存机制Byte , Short , Integer , Long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据， Character 创建了数值在 [0,127] 范围的缓存数据， Boolean 直接返回 True or False 。 Integer 缓存源码： 12345678910111213public static Integer valueOf(int i) { if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);}private static class IntegerCache { static final int low = -128; static final int high; static { // high value may be configured by property int h = 127; }} Character 缓存源码： 12345678910111213141516public static Character valueOf(char c) { if (c &lt;= 127) { // must cache return CharacterCache.cache[(int)c]; } return new Character(c);}private static class CharacterCache { private CharacterCache(){} static final Character cache[] = new Character[127 + 1]; static { for (int i = 0; i &lt; cache.length; i++) cache[i] = new Character((char)i); }} Boolean 缓存源码： 123public static Boolean valueOf(boolean b) { return (b ? TRUE : FALSE);} 如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。 两种浮点数类型的包装类没有实现缓存机制。 1234567891011Integer i1 = 33;Integer i2 = 33;System.out.println(i1 == i2);// 输出 trueFloat i11 = 333f;Float i22 = 333f;System.out.println(i11 == i22);// 输出 falseDouble i3 = 1.2;Double i4 = 1.2;System.out.println(i3 == i4);// 输出 false 问题：下面的代码的输出结果是 true 还是 false ？ 123Integer i1 = 40;Integer i2 = new Integer(40);System.out.println(i1==i2); Integer i1=40 这一行代码会发生装箱，也就是说这行代码等价于 Integer i1=Integer.valueOf(40) 。因此， i1 直接使用的是缓存中的对象。而 Integer i2 = new Integer(40) 会直接创建新的对象。 因此，答案是 false 。 所有整型包装类对象之间值的比较，全部使用 equals 方法比较。 3.4 自动装箱与自动拆箱？原理？自动拆装箱？ 装箱 ： 将基本类型用对应的引用类型包装起来。 拆箱 ： 将包装类型转换为基本数据类型。 举例： 12Integer i = 10; //装箱int n = i; //拆箱 字节码： 123456789101112131415161718192021222324252627L1 LINENUMBER 8 L1 ALOAD 0 BIPUSH 10 INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer; PUTFIELD AutoBoxTest.i : Ljava/lang/Integer;L2 LINENUMBER 9 L2 ALOAD 0 ALOAD 0 GETFIELD AutoBoxTest.i : Ljava/lang/Integer; INVOKEVIRTUAL java/lang/Integer.intValue ()I PUTFIELD AutoBoxTest.n : I RETURN 从字节码中，可以发现装箱其实就是调用了包装类的 valueOf() 方法，拆箱其实就是调用了 xxxValue() 方法。 因此， Integer i = 10 等价于 Integer i = Integer.valueOf(10) int n = i 等价于 int n = i.intValue() 注意： 如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。 1234567private static long sum() { // 应该使用 long 而不是 Long Long sum = 0L; for (long i = 0; i &lt;= Integer.MAX_VALUE; i++) sum += i; return sum;} 3.5 为什么浮点数运算会有精度丢失？代码示例： 12345float a = 2.0f - 1.9f;float b = 1.8f - 1.7f;System.out.printf(&quot;%.9f&quot;,a);// 0.100000024System.out.println(b);// 0.099999905System.out.println(a == b);// false 精度丢失和计算机保存浮点数的机制有很大关系。计算机是二进制的，且计算机在保存一个数字时，宽度是有限的，无限循环的小数存储时只能被截断，所以会出现小数精度丢失的情况。 比如：十进制下的 0.2 就没办法精确转化为二进制小数： 12345678// 0.2 转换为二进制数的过程为，不断乘以 2，直到不存在小数为止，// 在这个计算过程中，得到的整数部分从上到下排列就是二进制的结果。0.2 * 2 = 0.4 -&gt; 00.4 * 2 = 0.8 -&gt; 00.8 * 2 = 1.6 -&gt; 10.6 * 2 = 1.2 -&gt; 10.2 * 2 = 0.4 -&gt; 0（发生循环）... 关于浮点数，具体看 计算机系统基础 这篇博客。 3.6 如何解决浮点数运算精度丢失？BigDecimal 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算的场景都是通过 BigDecimal 实现的。 1234567891011121314BigDecimal a = new BigDecimal(&quot;1.0&quot;);BigDecimal b = new BigDecimal(&quot;1.00&quot;);BigDecimal c = new BigDecimal(&quot;0.8&quot;);// BigDecimal 的 subtract 方法用于执行精确的减法运算。BigDecimal x = a.subtract(c);BigDecimal y = b.subtract(c);System.out.println(x); /* 0.2 */System.out.println(y); /* 0.20 */// 比较内容，不是比较值System.out.println(Objects.equals(x, y)); /* false */// 比较值相等用相等compareTo，相等返回0System.out.println(0 == x.compareTo(y)); /* true */ BigDecimal 的详细介绍在 重要知识点 里。 3.7 超过 long 整型的数据如何表示？在 Java 中，64 位 long 整型是最大的整数类型。 123long l = Long.MAX_VALUE;System.out.println(l + 1); // -9223372036854775808System.out.println(l + 1 == Long.MIN_VALUE); // true BigInteger 内部使用 int[] 数组来存储任意大小的整形数据。 注意： 相对于常规整数类型的运算来说，BigInteger 运算的效率会相对较低。 4. 变量4.1 成员变量与局部变量的区别？ 语法形式 ： 成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或参数；成员变量可以被 public , private , static 等修饰符修饰，而局部变量不能被访问控制修饰符及 static 修饰；但是成员变量和局部变量都能被 final 修饰。 存储方式 ： 如果成员变量是使用 static 修饰的，那么这个成员变量是属于类的，如果没有，这个成员变量是属于实例的。对象存储在堆内存，局部变量存储在栈内存。 生存时间 ： 成员变量是对象的一部分，随着对象的创建而存在，局部变量随方法的调用而自动生成，随方法的调用结束而消亡。 默认值 ： 成员变量如果没有被赋初值，则会自动以类型的默认值赋值（ 例外：被 fianl 修饰必须显式赋值 ），而局部变量不会自动赋值。 4.1.1 为什么成员变量有默认值？ 如果没有默认值？ –&gt; 变量存储的是内存地址对应的任意随机值，程序读取该值运行会出现意外。 默认值有两种设置方式：手动和自动，根据第一点，没有手动赋值一定要自动赋值。成员变量在运行时可借助反射等方法手动赋值，而局部变量不行。 对于编译器（ javac ）来说，局部变量没赋值很好判断，可以直接报错。而成员变量可能是运行时赋值，无法判断，误报“没默认值”又会影响用户体验，所以采用自动赋默认值。 代码示例： 123456789101112131415161718192021222324252627282930public class VariableExample { // 成员变量 private String name; private int age; // 方法中的局部变量 public void method() { int num1 = 10; // 栈中分配的局部变量 String str = &quot;Hello, world!&quot;; // 栈中分配的局部变量 System.out.println(num1); System.out.println(str); } // 带参数的方法中的局部变量 public void method2(int num2) { int sum = num2 + 10; // 栈中分配的局部变量 System.out.println(sum); } // 构造方法中的局部变量 public VariableExample(String name, int age) { this.name = name; // 对成员变量进行赋值 this.age = age; // 对成员变量进行赋值 int num3 = 20; // 栈中分配的局部变量 String str2 = &quot;Hello, &quot; + this.name + &quot;!&quot;; // 栈中分配的局部变量 System.out.println(num3); System.out.println(str2); }} 4.2 静态变量有什么用？静态变量也就是被 static 关键字修饰的变量。它可以被类的所有实例共享，无论一个类创建了多少个对象，它们都共享同一份静态变量。静态变量只会被分配一次内存，即使创建多个对象，这样可以节省内存。 通常情况下，静态变量会被 final 关键字修饰成为常量。 1234public class ConstantVariableExample { // 常量 public static final int constantVar = 0;} 4.3 字符型常量和字符串型常量的区别？ 形式 ： 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符。 含义 ： 字符常量相当于一个整型值 ( ASCII 值) ,可以参加表达式运算; 字符串常量代表一个地址值 ( 该字符串在内存中存放位置 ) 。 占内存大小 ： 字符常量只占 2 个字节; 字符串常量占若干个字节。 注意： char 在 Java 中占两个字节。 5. 方法5.1 什么是方法的返回值？ 方法有哪几种类型？方法的返回值 是指获取到的某个方法体执行后产生的结果。 可以按照方法的返回值和参数类型分类： 无参数无返回值方法 有参数无返回值的方法 有返回值无参数的方法 有返回值有参数的方法 5.2 静态方法为什么不能调用非静态成员？需要结合 JVM 的相关知识，主要原因如下： 静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。 在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。 5.3 静态方法和实例方法有何不同？ 调用方式 ：在外部调用静态方法时，可以使用 类名.方法名 的方式，也可以使用 对象.方法名 的方式，而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。不过，需要注意的是一般不建议使用 对象.方法名 的方式来调用静态方法。这种方式非常容易造成混淆，静态方法不属于类的某个对象而是属于这个类。因此，一般建议使用 类名.方法名 的方式来调用静态方法。 访问类成员是否存在限制 ：静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。 5.4 重载和重写有什么区别？ 重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，就要覆盖父类方法 5.4.1 重载发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。 综上：重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。 5.4.2 重写重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。 方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。 如果父类方法访问修饰符为 private / final / static 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。 构造方法无法被重写 5.4.3 总结综上：重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。 区别点 重载 重写 发生范围 同一个类 子类 参数列表 必须修改 一定不能改 返回类型 可修改 比父类方法返回值类型更小或相等 异常 可修改 比父类方法声明抛出的异常类更小或相等 访问修饰符 可修改 一定不能做更严格的限制（可以降低限制） 发生阶段 编译期 运行期 补充： 如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。 5.5 什么是可变长参数？从 Java5 开始，Java 支持定义可变长参数，可变长参数就是允许在调用方法时传入不定长度的参数。就比如下面这个方法就可以接受 0 个或者多个参数。 1public static void method1(String... args) { } 可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数。 1public static void method2(String arg1, String... args) { } 5.5.1 遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？会优先匹配固定参数的方法，因为固定参数的方法匹配度更高。 Java 的可变参数编译后实际会被转换成一个数组，看编译后生成的 class 文件就可以看出来了。 NEXTJavaSE pt.2","link":"/2025/03/10/%E5%85%AB%E8%82%A1/Java/Java%E5%9F%BA%E7%A1%80/JavaSE%20pt.1/"},{"title":"JavaSE pt.3","text":"1. 异常Java 异常类层次结构： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849graph LR; Throwable --&gt;Exception; Throwable --&gt;Error; Exception --&gt;CheckedException; Exception --&gt;UncheckedException; Error --&gt; Errors; subgraph CheckedException [Checked Exceptions] direction TB; IOException; ClassNotFoundException; SQLException; FileNotFoundException; ......; end CheckedException --&gt; IOException; CheckedException --&gt; ClassNotFoundException; CheckedException --&gt; SQLException; CheckedException --&gt; FileNotFoundException; subgraph UncheckedException [Unchecked Exceptions] direction TB; ArithmeticException; ClassCastException; IllegalThreadStateException; IndexOutOfBoundsException; ......; end UncheckedException --&gt; ArithmeticException; UncheckedException --&gt; ClassCastException; UncheckedException --&gt; IllegalThreadStateException; UncheckedException --&gt; IndexOutOfBoundsException; subgraph Errors [Errors] direction TB; OutOfMemoryError; VirtualMachineError; StackOverflowError; AssertionError; IOError; ......; end Errors --&gt; OutOfMemoryError; Errors --&gt; VirtualMachineError; Errors --&gt; StackOverflowError; Errors --&gt; AssertionError; Errors --&gt; IOError; 1.1 Exception 和 Error 有什么区别？在 Java 中， 所有的异常都有一个共同的祖先 ： java.lang 包下的 Throwable 类。 Throwable 类有两个重要的子类: Exception ： 程序本身可以处理的异常，通常可以通过 catch 来捕获。 Exception 又可以分为 Checked Exception （ 受检查异常， 必须处理 ） 和 Unchecked Exception （ 不受检查异常， 可以不处理 ）。 Error ： Error 属于程序无法处理的错误，不建议通过 catch 捕获。如 Java 虚拟机运行错误 （ Virtural MachineError ） 、 虚拟机内存不够错误 （ OutOfMemoryError ） 、 类定义错误 （ NoClassDefFoundError ） 等。这类异常发生时， JVM 一般会选择线程终止。 1.2 Checked Exception 和 Unchecked Exception 有什么区别？Checked Exception 即 受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 catch 或者 throws 关键字处理的话，就没办法通过编译。 除了 RuntimeException 及其子类以外，其他的 Exception 类及其子类都属于受检查异常 。常见的受检查异常有：IO 相关的异常、ClassNotFoundException、SQLException …。 Unchecked Exception 即 不受检查异常 ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。 RuntimeException 及其子类都统称为非受检查异常，常见的有： NullPointerException(空指针错误) IllegalArgumentException(参数错误比如方法入参类型错误) NumberFormatException（字符串转换为数字格式错误，IllegalArgumentException 的子类） ArrayIndexOutOfBoundsException（数组越界错误） ClassCastException（类型转换错误） ArithmeticException（算术错误） SecurityException （安全错误比如权限不够） UnsupportedOperationException (不支持的操作错误比如重复创建同一用户) …… 1.3 Throwable 类常用方法有哪些？ String getMessage() : 返回异常发生时的详细信息 String toString() : 返回异常发生时的简要描述 String getLocalizedMessage() : 返回异常对象的本地化信息。使用 Throwable 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 getMessage() 返回的结果相同 void printStackTrace() : 在控制台上打印 Throwable 对象封装的异常信息 1.4 try-catch-finally 如何使用？ try 块：用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。 catch 块：用于处理 try 捕获到的异常。 finally 块：无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。 12345678try { System.out.println(&quot;Try to do something&quot;); throw new RuntimeException(&quot;RuntimeException&quot;);} catch (Exception e) { System.out.println(&quot;Catch Exception -&gt; &quot; + e.getMessage());} finally { System.out.println(&quot;Finally&quot;);} 输出： 123Try to do somethingCatch Exception -&gt; RuntimeExceptionFinally 注意：**不要在 finally 语句块中使用 return !** 当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。这是因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。 12345678910111213public static void main(String[] args) { System.out.println(f(2));}public static int f(int value) { try { return value * value; } finally { if (value == 2) { return 0; } }} 输出： 10 1.5 finally 中的代码一定会执行吗？不一定。 如： finally 之前虚拟机被终止， finally 中的代码就不会执行。 12345678910try { System.out.println(&quot;Try to do something&quot;); throw new RuntimeException(&quot;RuntimeException&quot;);} catch (Exception e) { System.out.println(&quot;Catch Exception -&gt; &quot; + e.getMessage()); // 终止当前正在运行的Java虚拟机 System.exit(1);} finally { System.out.println(&quot;Finally&quot;);} 输出： 12Try to do somethingCatch Exception -&gt; RuntimeException 另外，在以下 2 种特殊情况下，finally 块的代码也不会被执行： 程序所在线程死亡。 关闭 CPU 。 1.6 如何使用 try-with-resources 代替 try-catch-finally？ 适用范围 （资源定义） ： 任何实现 java.lang.AutoCloseable 或者 java.io.Closeable 的对象。 关闭资源和 finally 块的执行顺序 ： 在 try-catch-resources 语句中，任何 catch 或 finally 块在声明的资源关闭后运行。 Effective Java 中指出； 面对必须要关闭的资源，我们总是应该优先使用 try-with-resources 而不是try-finally 。随之产生的代码更简短，更清晰，产生的异常对我们也更有用。 try-with-resources 语句让我们更容易编写必须要关闭的资源的代码，若采用 try-finally 则几乎做不到这点。 Java 中类似于 InputStream 、 OutputStream 、 Scanner 、 PrintWriter 等的资源都需要我们调用 close() 方法来手动关闭，一般情况下我们都是通过 try-catch-finally 语句来实现这个需求，如下： 1234567891011121314//读取文本文件的内容Scanner scanner = null;try { scanner = new Scanner(new File(&quot;D://read.txt&quot;)); while (scanner.hasNext()) { System.out.println(scanner.nextLine()); }} catch (FileNotFoundException e) { e.printStackTrace();} finally { if (scanner != null) { scanner.close(); }} 使用 Java 7 之后的 try-with-resources 语句改造上面的代码: 1234567try (Scanner scanner = new Scanner(new File(&quot;test.txt&quot;))) { while (scanner.hasNext()) { System.out.println(scanner.nextLine()); }} catch (FileNotFoundException fnfe) { fnfe.printStackTrace();} 多个资源需要关闭的时候，使用 try-with-resources 实现起来也非常简单，如果还是用 try-catch-finally 可能会带来很多问题。 通过使用分号分隔，可以在 try-with-resources 块中声明多个资源。 123456789101112try ( BufferedInputStream bin = new BufferedInputStream(new FileInputStream(new File(&quot;test.txt&quot;))); BufferedOutputStream bout = new BufferedOutputStream(new FileOutputStream(new File(&quot;out.txt&quot;))) ) { int b; while ((b = bin.read()) != -1) { bout.write(b); }}catch (IOException e) { e.printStackTrace();} 1.7 异常使用有哪些需要注意的地方？ 不要把异常定义为静态变量，因为这样会导致异常栈信息错乱。每次手动抛出异常，我们都需要手动 new 一个异常对象抛出。 抛出的异常信息一定要有意义。 建议抛出更加具体的异常，比如字符串转换为数字格式错误的时候应该抛出 NumberFormatException 而不是其父类 IllegalArgumentException。 避免重复记录日志：如果在捕获异常的地方已经记录了足够的信息（包括异常类型、错误信息和堆栈跟踪等），那么在业务代码中再次抛出这个异常时，就不应该再次记录相同的错误信息。重复记录日志会使得日志文件膨胀，并且可能会掩盖问题的实际原因，使得问题更难以追踪和解决。 …… 2. 泛型2.1 什么是泛型？有什么作用？Java 泛型 （ Generics ） 是 JDK 5 引入的新特性。使用泛型可以增强代码的可读性和稳定性。 编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。比如 ArrayList&lt;Person&gt; persons = new ArrayList&lt;Person&gt;() 这行代码就指明了该 ArrayList 对象只能传入 Person 对象，如果传入其他类型的对象就会报错。 1ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; 并且，原生 List 返回类型是 Object ，需要手动转换类型才能使用，使用泛型后编译器自动转换。 2.2 泛型的使用方式有哪几种？泛型一般有三种使用方式: 泛型类、泛型接口、泛型方法 。 泛型类 ： 1234567891011121314//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型//在实例化泛型类时，必须指定T的具体类型public class Generic&lt;T&gt;{ private T key; public Generic(T key) { this.key = key; } public T getKey(){ return key; }} 如何实例化泛型类： 1Generic&lt;Integer&gt; genericInteger = new Generic&lt;Integer&gt;(123456); 泛型接口 ： 123public interface Generator&lt;T&gt; { public T method();} 实现泛型接口，不指定类型： 123456class GeneratorImpl&lt;T&gt; implements Generator&lt;T&gt;{ @Override public T method() { return null; }} 实现泛型接口，指定类型： 123456class GeneratorImpl implements Generator&lt;String&gt; { @Override public String method() { return &quot;hello&quot;; }} 泛型方法 ： 1234567public static &lt; E &gt; void printArray( E[] inputArray ){ for ( E element : inputArray ){ System.out.printf( &quot;%s &quot;, element ); } System.out.println();} 使用： 12345// 创建不同类型数组：Integer, Double 和 CharacterInteger[] intArray = { 1, 2, 3 };String[] stringArray = { &quot;Hello&quot;, &quot;World&quot; };printArray( intArray );printArray( stringArray ); 注意: public static &lt; E &gt; void printArray( E[] inputArray ) 一般被称为静态泛型方法;在 java 中泛型只是一个占位符，必须在传递类型后才能使用。类在实例化时才能真正的传递类型参数，由于静态方法的加载先于类的实例化，也就是说类中的泛型还没有传递真正的类型参数，静态的方法的加载就已经完成了，所以静态泛型方法是没有办法使用类上声明的泛型的。只能使用自己声明的 &lt;E&gt; 2.3 项目中哪里用到了泛型？ 自定义接口通用返回结果 CommonResult&lt;T&gt; 通过参数 T 可根据具体的返回类型动态指定结果的数据类型 定义 Excel 处理类 ExcelUtil&lt;T&gt; 用于动态指定 Excel 导出的数据类型 构建集合工具类（参考 Collections 中的 sort, binarySearch 方法）。 …… 3. 反射详细解读见 其他重要知识点 3.1 什么是反射？反射之所以被称为框架的灵魂，主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。 3.2 反射的优缺点？反射可以让我们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利。 不过，反射让我们在运行时有了分析操作类的能力的同时，也增加了安全问题，比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。 相关阅读：Java Reflection: Why is it so slow? 。 3.3 反射的应用场景？像 Spring/Spring Boot、MyBatis 等等框架中都大量使用了反射机制。 这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。 比如下面是通过 JDK 实现动态代理的示例代码，其中就使用了反射类 Method 来调用指定的方法。 1234567891011121314151617public class DebugInvocationHandler implements InvocationHandler { /** * 代理类中的真实对象 */ private final Object target; public DebugInvocationHandler(Object target) { this.target = target; } public Object invoke(Object proxy, Method method, Object[] args) throws InvocationTargetException, IllegalAccessException { System.out.println(&quot;before method &quot; + method.getName()); Object result = method.invoke(target, args); System.out.println(&quot;after method &quot; + method.getName()); return result; }} 另外， 注解 的实现也用到了反射。为什么使用 Spring 的时候 ，一个 @Component 注解就声明了一个类为 Spring Bean 呢？为什么通过一个 @Value 注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？这些都是因为你可以基于反射分析类，然后获取到类/属性/方法/方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。 4. 注解4.1 注解是什么？Annotation 是 Java 5 开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类、方法或变量，提供某些信息供程序在编译或运行时使用。 注解本质时一个继承了 Annotation 的特殊接口： 123456789@Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)public @interface Override {}public interface Override extends Annotation{} JDK 提供了很多内置的注解 （ @Override , @Deprecated ），同时，我们还可以自定义注解。 4.2 注解的解析方式有几种？注解只有被解析之后才会生效，常见的解析方法有两种： 编译期直接扫描 ： 编译器在编译 Java 代码时扫描对应的注解并处理，比如某个方法使用 @Override 注解，编译器在编译时就会检测当前的方法是否重写了父类对应的方法。 运行期通过反射代理 ： 像框架中自带的注解 （如 Spring 框架的 @Value, @Component ）都是通过反射来进行处理的。 5. SPI关于 SPI 的详细解读，请看其他重要知识点 5.1 什么是 SPISPI 即 Service Provider Interface ， 字面意思就是“ 服务提供者的接口 ”， 可指：专门提供给服务提供者或者扩展框架功能的开发者去使用的一个接口。 SPI 将服务接口和具体的服务实现分离开，将服务调用方和服务实现者解耦，能提升程序的扩展性、可维护性。修改或替换服务并不需要修改调用方。 很多框架都使用了 Java 的 SPI 机制，如 Spring框架、数据库加载驱动、日志接口以及 Dubbo 的扩展实现等等。 5.2 SPI 和 API 的区别？ 一般模块之间都是通过接口进行通讯，因此在服务调用方和服务实现方（也称服务提供者）之间引入一个“接口”。 当实现方提供了接口和实现，我们可以通过调用实现方的接口从而拥有实现方给我们提供的能力，这就是 API。这种情况下，接口和实现都是放在实现方的包中。调用方通过接口调用实现方的功能，而不需要关心具体的实现细节。 当接口存在于调用方这边时，这就是 SPI 。由接口调用方确定接口规则，然后由不同的厂商根据这个规则对这个接口进行实现，从而提供服务。 例子： 公司 H 是一家科技公司，新设计了一款芯片，然后现在需要量产了，而市面上有好几家芯片制造业公司，这个时候，只要 H 公司指定好了这芯片生产的标准（定义好了接口标准），那么这些合作的芯片公司（服务提供者）就按照标准交付自家特色的芯片（提供不同方案的实现，但是给出来的结果是一样的）。 5.3 SPI 的优缺点通过 SPI 机制能够大大地提高接口设计的灵活性，但是 SPI 机制也存在一些缺点，比如： 需要遍历加载所有的实现类，不能做到按需加载，这样效率相对较低。 当多个 ServiceLoader 同时 load 时，会有并发问题。 6. 序列化和反序列化具体介绍 6.1 什么是序列化和反序列化？ 序列化 ： 将数据或对象转换成可以存储或传输的形式 （通常是二进制字节流， 也可以是 JSON 、 XML 等文本格式） 反序列化 ：将序列化过程中生成的数据转换为原始数据结构或对象的过程。 常见应用场景： 对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化； 将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化； 将对象存储到数据库（如 Redis）之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化； 将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。 6.2 序列化协议对应 TCP/IP 4层模型的哪一层？ 如上图所示，OSI 七层协议模型中，表示层做的事情主要就是对应用层的用户数据进行处理转换为二进制流。反过来的话，就是将二进制流转换成应用层的用户数据。 OSI 七层协议模型中的应用层、表示层和会话层对应的都是 TCP/IP 四层模型中的应用层，所以序列化协议属于 TCP/IP 协议应用层的一部分。 6.3 如果有些字段不想序列化怎么办？对于不想进行序列化的变量，使用 transient 关键字修饰。 transient 关键词的作用是： 阻止实例中使用此关键字的变量序列化；当对象被反序列化时，被 transient 修饰的关键字不会被持久化和恢复。 注意： transient 只能修饰变量 transient 修饰的变量，在反序列化后变量值会被设置成默认值。 static 变量因为不属于任何对象，所以无论有没有 transient 修饰都不会被序列化。 6.4 常见的序列化协议JDK 自带的序列化方法一般不用，因为序列化效率低且存在安全问题。较常用的序列化协议有 Hession , Kryo , Protobuf , protoStuff ， 这些都是基于二进制的序列化协议。 像 JSON 和 XML 这种属于文本类序列化方式。虽然可读性比较好，但是性能较差，一般不会选择。 6.5 为什么不推荐 JDK 自带的序列化？ 不支持跨语言调用 性能差 ： 相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。 存在安全问题 ： 序列化和反序列化本身并不存在问题。但当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码。 7. I/O基础设计模式模型 8. 语法糖8.1 什么是语法糖？语法糖（Syntactic sugar） 代指的是编程语言为了方便程序员开发程序而设计的一种特殊语法，这种语法对编程语言的功能并没有影响。实现相同的功能，基于语法糖写出来的代码往往更简单简洁且更易阅读。 JVM 其实并不能识别语法糖，Java 语法糖要想被正确执行，需要先通过编译器进行解糖，也就是在程序编译阶段将其转换成 JVM 认识的基本语法。这也侧面说明，Java 中真正支持语法糖的是 Java 编译器而不是 JVM。如果去看 com.sun.tools.javac.main.JavaCompiler 的源码，会发现在 compile() 中有一个步骤就是调用 desugar() ，这个方法就是负责解语法糖的实现的。 8.2 Java 中常见的语法糖详解 NEXT下一篇","link":"/2025/04/06/%E5%85%AB%E8%82%A1/Java/Java%E5%9F%BA%E7%A1%80/JavaSE%20pt.3/"},{"title":"重要知识点","text":"1. Java 值传递形参 &amp; 实参方法的定义可能会用到参数 ， 参数在程序语言中分为： 实参 （ 实际参数， Arguments ） ： 用于传递给函数 / 方法的参数， 必须有确定的值。 形参 （ 形式参数， Paraments ） ： 用于定义函数 / 方法，接收实参，不需要有确定的值。 值引用 &amp; 引用传递 值引用 ： 方法接收的是实参的拷贝，会创建副本 引用传递 ： 方法接收的是实参所引用的对象在堆中的地址，不会创建副本， 对形参的修改将影响到实参。 很多语言提供了两种参数传递的方法， 不过在 Java 中只有值传递 为什么 Java 中只有值传递例子 1： 123456789101112131415public static void main(String[] args) { int num1 = 10; int num2 = 20; swap(num1, num2); System.out.println(&quot;num1 = &quot; + num1); System.out.println(&quot;num2 = &quot; + num2);}public static void swap(int a, int b) { int temp = a; a = b; b = temp; System.out.println(&quot;a = &quot; + a); System.out.println(&quot;b = &quot; + b);} output: 1234a = 20b = 10num1 = 10num2 = 20 解析： 在 swap() 方法中，a、b 的值进行交换，并不会影响到 num1、num2。因为，a、b 的值，只是从 num1、num2 的复制过来的。也就是说，a、b 相当于 num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身 通过上面例子，可以知道了一个方法不能修改一个基本数据类型的参数。 例子 2： 1234567891011public static void main(String[] args) { int[] arr = { 1, 2, 3, 4, 5 }; System.out.println(arr[0]); change(arr); System.out.println(arr[0]);}public static void change(int[] array) { // 将数组的第一个元素变为0 array[0] = 0;} output: 1210 解析： 这里传递的还是值，不过，这个值是实参的地址。 也就是说 change 方法的参数拷贝的是 arr （实参）的地址，因此，它和 arr 指向的是同一个数组对象。这也就说明了为什么方法内部对形参的修改会影响到实参。 例子 3： 1234567891011121314151617181920public class Person { private String name; // 省略构造函数、Getter&amp;Setter方法}public static void main(String[] args) { Person xiaoZhang = new Person(&quot;小张&quot;); Person xiaoLi = new Person(&quot;小李&quot;); swap(xiaoZhang, xiaoLi); System.out.println(&quot;xiaoZhang:&quot; + xiaoZhang.getName()); System.out.println(&quot;xiaoLi:&quot; + xiaoLi.getName());}public static void swap(Person person1, Person person2) { Person temp = person1; person1 = person2; person2 = temp; System.out.println(&quot;person1:&quot; + person1.getName()); System.out.println(&quot;person2:&quot; + person2.getName());} output: 1234person1:小李person2:小张xiaoZhang:小张xiaoLi:小李 解析： swap 方法的参数 person1 和 person2 只是拷贝的实参 xiaoZhang 和 xiaoLi 的地址。因此， person1 和 person2 的互换只是拷贝的两个地址的互换罢了，并不会影响到实参 xiaoZhang 和 xiaoLi 。 引用传递是什么样的12345678910111213141516#include &lt;iostream&gt;void incr(int&amp; num){ std::cout &lt;&lt; &quot;incr before: &quot; &lt;&lt; num &lt;&lt; &quot;\\n&quot;; num++; std::cout &lt;&lt; &quot;incr after: &quot; &lt;&lt; num &lt;&lt; &quot;\\n&quot;;}int main(){ int age = 10; std::cout &lt;&lt; &quot;invoke before: &quot; &lt;&lt; age &lt;&lt; &quot;\\n&quot;; incr(age); std::cout &lt;&lt; &quot;invoke after: &quot; &lt;&lt; age &lt;&lt; &quot;\\n&quot;;} output: 1234invoke before: 10incr before: 10incr after: 11invoke after: 11 可以看到，在 incr 函数中对形参的修改，可以影响到实参的值。要注意：这里的 incr 形参的数据类型用的是 int&amp; 才为引用传递，如果是用 int 的话还是值传递！ Java 为什么不引入引用传递？ 出于安全考虑，方法内部对值进行的操作，对于调用者都是未知的（把方法定义为接口，调用方不关心具体实现）。你也想象一下，如果拿着银行卡去取钱，取的是 100，扣的是 200，是不是很可怕。 Java 之父 James Gosling 在设计之初就看到了 C、C++ 的许多弊端，所以才想着去设计一门新的语言 Java。在他设计 Java 的时候就遵循了简单易用的原则，摒弃了许多开发者一不留意就会造成问题的“特性”，语言本身的东西少了，开发者要学习的东西也少了。 值传递总结Java 中将实参传递给方法（或函数）的方式是 值传递： 如果参数是基本类型的话，很简单，传递的就是基本类型的字面量值的拷贝，会创建副本。 如果参数是引用类型，传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本。 2. Java 序列化什么是序列化与反序列化 序列化 ： 将数据或对象转换成可以存储或传输的形式 （通常是二进制字节流， 也可以是 JSON 、 XML 等文本格式） 反序列化 ：将序列化过程中生成的数据转换为原始数据结构或对象的过程。 常见应用场景： 对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化； 将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化； 将对象存储到数据库（如 Redis）之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化； 将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。 序列化协议对应 TCP/IP 4 层模型的哪一层？ 如上图所示，OSI 七层协议模型中，表示层做的事情主要就是对应用层的用户数据进行处理转换为二进制流。反过来的话，就是将二进制流转换成应用层的用户数据。 OSI 七层协议模型中的应用层、表示层和会话层对应的都是 TCP/IP 四层模型中的应用层，所以序列化协议属于 TCP/IP 协议应用层的一部分。 常见的序列化协议JDK 自带的序列化方式一般不会用 ，因为序列化效率低并且存在安全问题。比较常用的序列化协议有 Hessian、Kryo、Protobuf、ProtoStuff，这些都是基于二进制的序列化协议。 像 JSON 和 XML 这种属于文本类序列化方式。虽然可读性比较好，但是性能较差，一般不会选择。 JDK 自带的序列化JDK 自带的序列化，只需实现 java.io.Serializable 接口。 1234567891011121314@AllArgsConstructor@NoArgsConstructor@Getter@Builder@ToStringpublic class RpcRequest implements Serializable { private static final long serialVersionUID = 1905122041950251207L; private String requestId; private String interfaceName; private String methodName; private Object[] parameters; private Class&lt;?&gt;[] paramTypes; private RpcMessageTypeEnum rpcMessageTypeEnum;} serialVersionUID 有什么用序列化号 serialVersionUID 属于版本控制的作用。反序列化时，会检查 serialVersionUID 是否和当前类的 serialVersionUID 一致。如果 serialVersionUID 不一致则会抛出 InvalidClassException 异常。强烈推荐每个序列化类都手动指定其 serialVersionUID ，如果不手动指定，那么编译器会动态生成默认的 serialVersionUID 。 serialVersionUID 不是被 static 变量修饰了吗？为什么还会被“序列化”？static 修饰的变量是静态变量，属于类而非类的实例，本身是不会被序列化的。然而， serialVersionUID 是一个特例， serialVersionUID 的序列化做了特殊处理。当一个对象被序列化时， serialVersionUID 会被写入到序列化的二进制流中；在反序列化时，也会解析它并做一致性判断，以此来验证序列化对象的版本一致性。如果两者不匹配，反序列化过程将抛出 InvalidClassException ，因为这通常意味着序列化的类的定义已经发生了更改，可能不再兼容。 官方说明： A serializable class can declare its own serialVersionUID explicitly by declaring a field named “serialVersionUID“ that must be static, final, and of type long;如果想显式指定 serialVersionUID ，则需要在类中使用 static 和 final 关键字来修饰一个 long 类型的变量，变量名字必须为 “serialVersionUID“ 。 如果有些字段不想序列化怎么办？对于不想进行序列化的变量，使用 transient 关键字修饰。 transient 关键词的作用是： 阻止实例中使用此关键字的变量序列化；当对象被反序列化时，被 transient 修饰的关键字不会被持久化和恢复。 注意： transient 只能修饰变量 transient 修饰的变量，在反序列化后变量值会被设置成默认值。 static 变量因为不属于任何对象，所以无论有没有 transient 修饰都不会被序列化。 什么不推荐 JDK 自带的序列化？ 不支持跨语言调用 性能差 ： 相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。 存在安全问题 ： 序列化和反序列化本身并不存在问题。但当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码。 KryoKryo 是一个高性能的序列化/反序列化工具，由于其变长存储特性并使用了字节码生成机制，拥有较高的运行速度和较小的字节码体积。 另外，Kryo 已经是一种非常成熟的序列化实现了，已经在 Twitter、Groupon、Yahoo 以及多个著名开源项目（如 Hive、Storm）中广泛的使用。 guide-rpc-framework 就是使用的 kryo 进行序列化，序列化和反序列化相关的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Kryo serialization class, Kryo serialization efficiency is very high, but only compatible with Java language * * @author shuang.kou * @createTime 2020年05月13日 19:29:00 */@Slf4jpublic class KryoSerializer implements Serializer { /** * Because Kryo is not thread safe. So, use ThreadLocal to store Kryo objects */ private final ThreadLocal&lt;Kryo&gt; kryoThreadLocal = ThreadLocal.withInitial(() -&gt; { Kryo kryo = new Kryo(); kryo.register(RpcResponse.class); kryo.register(RpcRequest.class); return kryo; }); @Override public byte[] serialize(Object obj) { try (ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); Output output = new Output(byteArrayOutputStream)) { Kryo kryo = kryoThreadLocal.get(); // Object-&gt;byte:将对象序列化为byte数组 kryo.writeObject(output, obj); kryoThreadLocal.remove(); return output.toBytes(); } catch (Exception e) { throw new SerializeException(&quot;Serialization failed&quot;); } } @Override public &lt;T&gt; T deserialize(byte[] bytes, Class&lt;T&gt; clazz) { try (ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes); Input input = new Input(byteArrayInputStream)) { Kryo kryo = kryoThreadLocal.get(); // byte-&gt;Object:从byte数组中反序列化出对象 Object o = kryo.readObject(input, clazz); kryoThreadLocal.remove(); return clazz.cast(o); } catch (Exception e) { throw new SerializeException(&quot;Deserialization failed&quot;); } }} ProtobufProtobuf 出自 Google，性能比较优秀，也支持多种语言，同时还是跨平台的。就是在使用中过于繁琐，因为你需要自己定义 IDL 文件和生成对应的序列化代码。这样虽然不灵活，但是，另一方面导致 protobuf 没有序列化漏洞的风险。 Protobuf 包含序列化格式的定义、各种语言的库以及一个 IDL 编译器。正常情况下你需要定义 proto 文件，然后使用 IDL 编译器编译成你需要的语言 一个简单的 proto 文件如下： 123456789// protobuf的版本syntax = &quot;proto3&quot;;// SearchRequest会被编译成不同的编程语言的相应对象，比如Java中的class、Go中的structmessage Person { //string类型字段 string name = 1; // int 类型字段 int32 age = 2;} ProtoStuff由于 Protobuf 易用性较差， ProtoStuff 诞生了。 protostuff 基于 Google protobuf，但是提供了更多的功能和更简易的用法。虽然更加易用，但是不代表 ProtoStuff 性能更差。 HessianHessian 是一个轻量级的，自定义描述的二进制 RPC 协议。Hessian 是一个比较老的序列化实现了，并且同样也是跨语言的。 Dubbo2.x 默认启用的序列化方式是 Hessian2 ,但是，Dubbo 对 Hessian2 进行了修改，不过大体结构还是差不多。 序列化总结Kryo 是专门针对 Java 语言序列化方式并且性能非常好，如果应用是专门针对 Java 语言的话可以考虑使用，并且 Dubbo 官网的一篇文章中提到说推荐使用 Kryo 作为生产环境的序列化方式。 像 Protobuf、 ProtoStuff、hessian 这类都是跨语言的序列化方式，如果有跨语言需求的话可以考虑使用。 除了上面介绍到的序列化方式，还有像 Thrift，Avro 这些。 3. 泛型&amp;通配符4. 反射什么是反射反射之所以被称为框架的灵魂，主要是因为它赋予了在运行时分析类以及执行类中方法的能力。 通过反射可以获取任意一个类的所有属性和方法，还可以调用这些方法和属性。 反射的应用场景像平时大部分时候都是在写业务代码，很少会接触到直接使用反射机制的场景。 但是，这并不代表反射没有用。相反，正是因为反射，你才能这么轻松地使用各种框架。像 Spring/Spring Boot、MyBatis 等框架中都大量使用了反射机制。 这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。 例子（通过 JDK 实现动态代理）： 123456789101112131415161718public class DebugInvocationHandler implements InvocationHandler { /** * 代理类中的真实对象 */ private final Object target; public DebugInvocationHandler(Object target) { this.target = target; } public Object invoke(Object proxy, Method method, Object[] args) throws InvocationTargetException, IllegalAccessException { System.out.println(&quot;before method &quot; + method.getName()); Object result = method.invoke(target, args); System.out.println(&quot;after method &quot; + method.getName()); return result; }} 另外， Java 中的一大利器 注解 的实现也用到了反射。 为什么使用 Spring 的时候 ，一个 @Component 注解就声明了一个类为 Spring Bean 呢？为什么你通过一个 @Value 注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？ 这些都是因为你可以基于反射分析类，然后获取到类/属性/方法/方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。 反射的优缺点优点 ： 使代码更灵活、为各种框架提供开箱即用的功能提供了便利。 缺点 ： 在运行时有了操作类的能力，增加了安全问题。如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也稍差（对于框架的实际影响不大）。 反射实战获取 Class 对象的四种方式 知道具体类的情况： 1Class alunbarClass = TargetObject.class; 但是一般是不知道具体类的，基本都是通过遍历包下面的类来获取 Class 对象，通过此方法获取 Class 对象不会进行初始化。 通过 Class.forName() 传入类的全路径： 1Class alunbarClass1 = Class.forName(&quot;cn.javaguide.TargetObject&quot;); 通过对象实例 instance.getClass() 获取： 12TargetObject o = new TargetObject();Class alunbarClass2 = o.getClass(); 通过类加载器 xxxClassLoader.loadClass() 传入类路径获取： 1ClassLoader.getSystemClassLoader().loadClass(&quot;cn.javaguide.TargetObject&quot;); 通过类加载器获取 Class 对象不会进行初始化，意味着不进行包括初始化等一系列步骤，静态代码块和静态对象不会得到执行。 反射的一些基本操作 创建一个要使用反射操作的类 TargetObject。 123456789101112131415public class TargetObject { private String value; public TargetObject() { value = &quot;JavaGuide&quot;; } public void publicMethod(String s) { System.out.println(&quot;I love &quot; + s); } private void privateMethod() { System.out.println(&quot;value is &quot; + value); }} 使用反射操作这个类的方法和属性 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;public class Main { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException, NoSuchFieldException { /** * 获取 TargetObject 类的 Class 对象并且创建 TargetObject 类实例 */ Class&lt;?&gt; targetClass = Class.forName(&quot;cn.javaguide.TargetObject&quot;); TargetObject targetObject = (TargetObject) targetClass.newInstance(); /** * 获取 TargetObject 类中定义的所有方法 */ Method[] methods = targetClass.getDeclaredMethods(); for (Method method : methods) { System.out.println(method.getName()); } /** * 获取指定方法并调用 */ Method publicMethod = targetClass.getDeclaredMethod (&quot;publicMethod&quot;, String.class); publicMethod.invoke(targetObject, &quot;JavaGuide&quot;); /** * 获取指定参数并对参数进行修改 */ Field field = targetClass.getDeclaredField(&quot;value&quot;); //为了对类中的参数进行修改我们取消安全检查 field.setAccessible(true); field.set(targetObject, &quot;JavaGuide&quot;); /** * 调用 private 方法 */ Method privateMethod = targetClass.getDeclaredMethod (&quot;privateMethod&quot;); //为了调用private方法我们取消安全检查 privateMethod.setAccessible(true); privateMethod.invoke(targetObject); }} output: 1234publicMethodprivateMethodI love JavaGuidevalue is JavaGuide 5. 代理模式什么是代理模式代理模式是一种比较好理解的设计模式。简单来说就是 使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。 代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。 例子：新娘找来了自己的姨妈来代替自己处理新郎的提问，新娘收到的提问都是经过姨妈处理过滤之后的。姨妈在这里就可以看作是代理你的代理对象，代理的行为（方法）是接收和回复新郎的提问。 代理模式有静态代理和动态代理两种实现方式。 静态代理静态代理中，对目标的每个方法的增强都是手动完成的，非常不灵活（如：接口一旦新增加方法，目标对象和代理对象都要进行修改），且麻烦（需要对每个目标类都单独写一个代理类）。实际应用场景非常少，日常开发几乎看不到使用静态代理的场景。 以上是从实现和应用角度来说的，从 JVM 层面，静态代理在编译时就将接口、实现类、代理类都变成实际的 class 文件。 静态代理实现步骤： 定义一个接口及其实现类； 创建一个代理类同样实现这个接口； 将目标对象注入进代理类， 然后在代理类的对应方法调用目标类的对应方法。这样就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。 例子： 定义发送短信的接口 123public interface SmsService { String send(String message);} 实现发送短信的接口 123456public class SmsServiceImpl implements SmsService { public String send(String message) { System.out.println(&quot;send message:&quot; + message); return message; }} 创建代理类并同样实现发送短信的接口 123456789101112131415161718public class SmsProxy implements SmsService { private final SmsService smsService; public SmsProxy(SmsService smsService) { this.smsService = smsService; } @Override public String send(String message) { //调用方法之前，我们可以添加自己的操作 System.out.println(&quot;before method send()&quot;); smsService.send(message); //调用方法之后，我们同样可以添加自己的操作 System.out.println(&quot;after method send()&quot;); return null; }} 实际使用 1234567public class Main { public static void main(String[] args) { SmsService smsService = new SmsServiceImpl(); SmsProxy smsProxy = new SmsProxy(smsService); smsProxy.send(&quot;java&quot;); }} 输出： 123before method send()send message:javaafter method send() 动态代理相比于静态代理来说，动态代理更加灵活。不需要针对每个目标类都单独创建一个代理类，并且也不需要必须实现接口，可以直接代理实现类( CGLIB 动态代理机制)。 从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。 Spring AOP、RPC 框架的实现都依赖了动态代理。 动态代理在日常开发中使用相对较少，但是在框架中几乎是必用的技术。学习动态代理后，对于理解和学习各种框架的原理很有帮助。 就 Java 来说， 动态代理的实现方式有很多，如 JDK 动态代理、 GGLIB 动态代理等。 JDK 动态代理机制JDK 动态代理介绍在 Java 动态代理机制中， InvocationHandler 接口和 Proxy 类是核心。 Proxy 类中使用频率最高的方法是 newProxyInstance() ，这个方法主要用于生成一个代理对象。 1234567public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException{ ......} 这个方法一共有 3 个参数： loader ： 类加载器，用于加载代理对象。 interfaces ： 被代理类实现的接口。 h ： 实现了 InvocationHandler 接口的对象。 要实现动态代理， 还必须实现 InvocationHandler 来自定义处理逻辑。当动态代理对象调用一个方法时，这个方法的调用就会被转发到实现 InvocationHandler 接口类的 invoke 方法来调用。 12345678public interface InvocationHandler { /** * 当你使用代理对象调用方法的时候实际会调用到这个方法 */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;} invoke() 方法有三个参数： Proxy ： 动态生成的代理类 method ： 与代理类对象调用的方法相对应 args ： 当前 method 方法的参数 也就是说，通过 Proxy 类的 newProxyInstance() 创建的代理对象在调用方法时，实际会调用实现 InvocationHandler 接口的类的 invoke() 方法。可以在 invoke() 方法中自定义处理逻辑，如在方法执行前后做什么。 JDK 动态代理类使用步骤 定义一个接口及其实现类； 自定义 InvovationHandler 并重写 invoke 方法， 在 invoke 方法中调用原生方法（被代理类的方法）并自定义一些处理逻辑； 通过 Proxy.newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) 方法创建代理对象。 代码示例 定义发送短信的接口 123public interface SmsService { String send(String message);} 实现发送短信的接口 123456public class SmsServiceImpl implements SmsService { public String send(String message) { System.out.println(&quot;send message:&quot; + message); return message; }} 定义一个 JDK 动态代理类 123456789101112131415161718192021222324import java.lang.reflect.InvocationHandler;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;public class DebugInvocationHandler implements InvocationHandler { /** * 代理类中的真实对象 */ private final Object target; public DebugInvocationHandler(Object target) { this.target = target; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws InvocationTargetException, IllegalAccessException { //调用方法之前，我们可以添加自己的操作 System.out.println(&quot;before method &quot; + method.getName()); Object result = method.invoke(target, args); //调用方法之后，我们同样可以添加自己的操作 System.out.println(&quot;after method &quot; + method.getName()); return result; }} invoke() 方法: 当动态代理对象调用原生方法的时候，最终实际上调用到的 是 invoke() 方法，然后 invoke() 方法去调用了被代理对象的原生方 法。 获取代理对象的工厂类 123456789public class JdkProxyFactory { public static Object getProxy(Object target) { return Proxy.newProxyInstance( target.getClass().getClassLoader(), // 目标类的 类加载器 target.getClass().getInterfaces(), // 代理需要 实现的接口，可指定多个 new DebugInvocationHandler(target) // 代理对象 对应的自定义 InvocationHandler ); }} getProxy() ：主要通过 Proxy.newProxyInstance（） 方法获取某个类的代理对象 实际使用 12SmsService smsService = (SmsService) JdkProxyFactory.getProxy (new SmsServiceImpl());smsService.send(&quot;java&quot;); output: 123before method sendsend message:javaafter method send CGLIB 动态代理机制CGLIB 动态代理介绍JDK 动态代理有一个最致命的问题是其只能代理实现了接口的类。 为了解决这个问题，我们可以用 CGLIB 动态代理机制来避免。 CGLIB (Code Generation Library)是一个基于 ASM 的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB 通过继承方式实现代理。很多知名的开源框架都使用到了 CGLIB， 例如 Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。 在 CGLIB 动态代理机制中 MethodInterceptor 接口和 Enhancer 类是核心。 需要自定义 MethodInterceptor 并重写 intercept 方法，intercept 用于拦截增强被代理类的方法。 12345public interface MethodInterceptorextends Callback{ // 拦截被代理类中的方法 public Object intercept(Object obj, java.lang.reflect.Method method, Object[] args,MethodProxy proxy) throws Throwable;} obj : 被代理的对象（需要增强的对象） method : 被拦截的方法（需要增强的方法） args : 方法入参 proxy : 用于调用原始方法 可以通过 Enhancer 类来动态获取被代理类，当代理类调用方法的时候，实际调用的是 MethodInterceptor 中的 intercept 方法。 CGLIB 动态代理类使用步骤 定义一个类； 自定义 MethodInterceptor 并重写 intercept 方法，intercept 用于拦截增强被代理类的方法，和 JDK 动态代理中的 invoke 方法类似； 通过 Enhancer 类的 create() 创建代理类； 示例不同于 JDK 动态代理不需要额外的依赖。CGLIB(Code Generation Library) 实际是属于一个开源项目，如果你要使用它的话，需要手动添加相关依赖。 12345&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt;&lt;/dependency&gt; 实现一个使用阿里云发送短信的类 123456public class AliSmsService { public String send(String message) { System.out.println(&quot;send message:&quot; + message); return message; }} 自定义 MethodInterceptor （方法拦截器） 12345678910111213141516171819202122232425262728import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;import java.lang.reflect.Method;/** * 自定义MethodInterceptor */public class DebugMethodInterceptor implements MethodInterceptor { /** * @param o 被代理的对象（需要增强的对象） * @param method 被拦截的方法（需要增强的方法） * @param args 方法入参 * @param methodProxy 用于调用原始方法 */ @Override public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable { //调用方法之前，我们可以添加自己的操作 System.out.println(&quot;before method &quot; + method.getName()); Object object = methodProxy.invokeSuper(o, args); //调用方法之后，我们同样可以添加自己的操作 System.out.println(&quot;after method &quot; + method.getName()); return object; }} 获取代理类 1234567891011121314151617import net.sf.cglib.proxy.Enhancer;public class CglibProxyFactory { public static Object getProxy(Class&lt;?&gt; clazz) { // 创建动态代理增强类 Enhancer enhancer = new Enhancer(); // 设置类加载器 enhancer.setClassLoader(clazz.getClassLoader()); // 设置被代理类 enhancer.setSuperclass(clazz); // 设置方法拦截器 enhancer.setCallback(new DebugMethodInterceptor()); // 创建代理类 return enhancer.create(); }} 实际使用 12AliSmsService aliSmsService = (AliSmsService) CglibProxyFactory.getProxy(AliSmsService.class);aliSmsService.send(&quot;java&quot;); output 123before method sendsend message:javaafter method send JDK 动态代理和 CGLIB 动态代理对比 JDK 动态代理只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。 就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。 静态代理和动态代理的对比 灵活性：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！ JVM 层面：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。 6. BigDecimalBigDecimal 介绍BigDecimal 可以实现对小数的运算，不会造成精度丢失。 通常情况下，大部分需要小数精确运算结果的业务 （如涉及到钱的场景） 都是通过 BigDecimal 做的。 BigDecimal 常见方法创建在使用 BigDecimal 时，为了防止精度丢失，推荐使用它的 BigDecimal(String val) 构造方法或者 BigDecimal.valueOf(double val) 静态方法来创建对象。 加减乘除add 方法用于将两个 BigDecimal 对象相加， subtract 方法用于将两个 BigDecimal 对象相减。 multiply 方法用于将两个 BigDecimal 对象相乘，divide 方法用于将两个 BigDecimal 对象相除。 1234567BigDecimal a = new BigDecimal(&quot;1.0&quot;);BigDecimal b = new BigDecimal(&quot;0.9&quot;);System.out.println(a.add(b));// 1.9System.out.println(a.subtract(b));// 0.1System.out.println(a.multiply(b));// 0.90System.out.println(a.divide(b));// 无法除尽，抛出 ArithmeticException 异常System.out.println(a.divide(b, 2, RoundingMode.HALF_UP));// 1.11 需要注意的是，在使用 divide 方法的时候尽量使用 3 个参数版本，并且 RoundingMode 不要选择 UNNECESSARY ，否则很可能会遇到 ArithmeticException （无法除尽出现无限循环小数的时候），其中 scale 表示要保留几位小数，roundingMode 代表保留规则。 123public BigDecimal divide(BigDecimal divisor, int scale, RoundingMode roundingMode) { return divide(divisor, scale, roundingMode.oldMode);} 保留规则非常多，这里列举几种: 123456789101112131415161718public enum RoundingMode { // 2.5 -&gt; 3 , 1.6 -&gt; 2 // -1.6 -&gt; -2 , -2.5 -&gt; -3 UP(BigDecimal.ROUND_UP), // 2.5 -&gt; 2 , 1.6 -&gt; 1 // -1.6 -&gt; -1 , -2.5 -&gt; -2 DOWN(BigDecimal.ROUND_DOWN), // 2.5 -&gt; 3 , 1.6 -&gt; 2 // -1.6 -&gt; -1 , -2.5 -&gt; -2 CEILING(BigDecimal.ROUND_CEILING), // 2.5 -&gt; 2 , 1.6 -&gt; 1 // -1.6 -&gt; -2 , -2.5 -&gt; -3 FLOOR(BigDecimal.ROUND_FLOOR), // 2.5 -&gt; 3 , 1.6 -&gt; 2 // -1.6 -&gt; -2 , -2.5 -&gt; -3 HALF_UP(BigDecimal.ROUND_HALF_UP), //......} 大小比较a.compareTo(b) : 返回 -1 表示 a 小于 b，0 表示 a 等于 b ， 1 表示 a 大于 b。 123BigDecimal a = new BigDecimal(&quot;1.0&quot;);BigDecimal b = new BigDecimal(&quot;0.9&quot;);System.out.println(a.compareTo(b));// 1 保留几位小数通过 setScale 方法设置保留几位小数以及保留规则。 123BigDecimal m = new BigDecimal(&quot;1.255433&quot;);BigDecimal n = m.setScale(3,RoundingMode.HALF_DOWN);System.out.println(n);// 1.255 BigDecimal 等值比较问题 BigDecimal 使用 equals() 方法进行等值比较出现问题的代码示例： 123BigDecimal a = new BigDecimal(&quot;1&quot;);BigDecimal b = new BigDecimal(&quot;1.0&quot;);System.out.println(a.equals(b));//false 这是因为 equals() 方法不仅仅会比较值的大小（value）还会比较精度（scale），而 compareTo() 方法比较的时候会忽略精度。 1.0 的 scale 是 1，1 的 scale 是 0，因此 a.equals(b) 的结果是 false。 compareTo() 方法可以比较两个 BigDecimal 的值，如果相等就返回 0，如果第 1 个数比第 2 个数大则返回 1，反之返回-1。 123BigDecimal a = new BigDecimal(&quot;1&quot;);BigDecimal b = new BigDecimal(&quot;1.0&quot;);System.out.println(a.compareTo(b));//0 BigDecimal 总结浮点数没有办法用二进制精确表示，因此存在精度丢失的风险。 不过，Java 提供了 BigDecimal 来操作浮点数。 BigDecimal 的实现利用到了 BigInteger （用来操作大整数）, 所不同的是 BigDecimal 加入了小数位的概念。 7. Java 魔法类 UnsafeUnsafe 介绍Unsafe 是位于 sun.misc 包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升 Java 运行效率、增强 Java 语言底层资源操作能力方面起到了很大的作用。但由于 Unsafe 类使 Java 语言拥有了类似 C 语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。在程序中过度、不正确使用 Unsafe 类会使得程序出错的概率变大，使得 Java 这种安全的语言变得不再“安全”，因此对 Unsafe 的使用一定要慎重。 另外，Unsafe 提供的这些功能的实现需要依赖本地方法（Native Method）。你可以将本地方法看作是 Java 中使用其他编程语言编写的方法。本地方法使用 native 关键字修饰，Java 代码中只是声明方法头，具体的实现则交给 本地代码。 为什么要使用本地方法呢？ 需要用到 Java 中不具备的依赖于操作系统的特性，Java 在实现跨平台的同时要实现对底层的控制，需要借助其他语言发挥作用。 对于其他语言已经完成的一些现成功能，可以使用 Java 直接调用。 程序对时间敏感或对性能要求非常高时，有必要使用更加底层的语言，例如 C/C++甚至是汇编。 Unsafe 创建sun.misc.Unsafe 部分源码如下： 1234567891011121314151617public final class Unsafe { // 单例对象 private static final Unsafe theUnsafe; ...... private Unsafe() { } @CallerSensitive public static Unsafe getUnsafe() { Class var0 = Reflection.getCallerClass(); // 仅在引导类加载器`BootstrapClassLoader`加载时才合法 if(!VM.isSystemDomainLoader(var0.getClassLoader())) { throw new SecurityException(&quot;Unsafe&quot;); } else { return theUnsafe; } }} Unsafe 类为一单例实现，提供静态方法 getUnsafe 获取 Unsafe 实例。这个看上去貌似可以用来获取 Unsafe 实例。但是，当我们直接调用这个静态方法的时候，会抛出 SecurityException 异常： 123Exception in thread &quot;main&quot; java.lang.SecurityException: Unsafe at sun.misc.Unsafe.getUnsafe(Unsafe.java:90) at com.cn.test.GetUnsafeTest.main(GetUnsafeTest.java:12) 为什么 public static 方法无法被直接调用呢？这是因为在 getUnsafe 方法中，会对调用者的 classLoader 进行检查，判断当前类是否由 Bootstrap classLoader 加载，如果不是的话那么就会抛出一个 SecurityException 异常。也就是说，只有启动类加载器加载的类才能够调用 Unsafe 类中的方法，来防止这些方法在不可信的代码中被调用。 为什么要对 Unsafe 类进行这么谨慎的使用限制呢?Unsafe 提供的功能过于底层（如直接访问系统内存资源、自主管理内存资源等），安全隐患也比较大，使用不当的话，很容易出现很严重的问题。 如若想使用 Unsafe 这个类的话，应该如何获取其实例呢？ 利用反射获得 Unsafe 类中已经实例化完成的单例对象 theUnsafe 。 12345678910private static Unsafe reflectGetUnsafe() { try { Field field = Unsafe.class.getDeclaredField (&quot;theUnsafe&quot;); field.setAccessible(true); return (Unsafe) field.get(null); } catch (Exception e) { log.error(e.getMessage(), e); return null; }} 从 getUnsafe 方法的使用限制条件出发，通过 Java 命令行命令 -Xbootclasspath/a 把调用 Unsafe 相关方法的类 A 所在 jar 包路径追加到默认的 bootstrap 路径中，使得 A 被引导类加载器加载，从而通过 Unsafe.getUnsafe 方法安全的获取 Unsafe 实例。 1java -Xbootclasspath/a: ${path} // 其中path为调用Unsafe相关方法的类所在jar包路径 Unsafe 功能概括的来说，Unsafe 类实现功能可以被分为下面 8 类： 内存操作 内存屏障 对象操作 数据操作 CAS 操作 线程调度 Class 操作 系统信息 内存操作内存操作介绍如果你是一个写过 C 或者 C++ 的程序员，一定对内存操作不会陌生，而在 Java 中是不允许直接对内存进行操作的，对象内存的分配和回收都是由 JVM 自己实现的。但是在 Unsafe 中，提供的下列接口可以直接进行内存操作： 12345678910//分配新的本地空间public native long allocateMemory(long bytes);//重新调整内存空间的大小public native long reallocateMemory(long address, long bytes);//将内存设置为指定值public native void setMemory(Object o, long offset, long bytes, byte value);//内存拷贝public native void copyMemory(Object srcBase, long srcOffset,Object destBase, long destOffset,long bytes);//清除内存public native void freeMemory(long address); 测试： 123456789101112131415161718private void memoryTest() { int size = 4; long addr = unsafe.allocateMemory(size); long addr3 = unsafe.reallocateMemory(addr, size * 2); System.out.println(&quot;addr: &quot;+addr); System.out.println(&quot;addr3: &quot;+addr3); try { unsafe.setMemory(null,addr ,size,(byte)1); for (int i = 0; i &lt; 2; i++) { unsafe.copyMemory(null,addr,null,addr3+size*i,4); } System.out.println(unsafe.getInt(addr)); System.out.println(unsafe.getLong(addr3)); }finally { unsafe.freeMemory(addr); unsafe.freeMemory(addr3); }} output: 1234addr: 2433733895744addr3: 24337338949441684300972340172838076673 分析首先使用 allocateMemory 方法申请 4 字节长度的内存空间，调用 setMemory 方法向每个字节写入内容为 byte 类型的 1，当使用 Unsafe 调用 getInt 方法时，因为一个 int 型变量占 4 个字节，会一次性读取 4 个字节，组成一个 int 的值，对应的十进制结果为 16843009。 在代码中调用 reallocateMemory 方法重新分配了一块 8 字节长度的内存空间，通过比较 addr 和 addr3 可以看到和之前申请的内存地址是不同的。在代码中的第二个 for 循环里，调用 copyMemory 方法进行了两次内存的拷贝，每次拷贝内存地址addr开始的 4 个字节，分别拷贝到以 addr3 和 addr3+4 开始的内存空间上： 拷贝完成后，使用getLong方法一次性读取 8 个字节，得到long类型的值为 72340172838076673。 需要注意，通过这种方式分配的内存属于 堆外内存 ，是无法进行垃圾回收的，需要我们把这些内存当做一种资源去手动调用 freeMemory 方法进行释放，否则会产生内存泄漏。通用的操作内存方式是在 try 中执行对内存的操作，最终在 finally 块中进行内存的释放。 为什么要使用堆外内存？ 对垃圾回收停顿的改善。由于堆外内存是直接受操作系统管理而不是 JVM，所以当我们使用堆外内存时，即可保持较小的堆内内存规模。从而在 GC 时减少回收停顿对于应用的影响。 提升程序 I/O 操作的性能。通常在 I/O 通信过程中，会存在堆内内存到堆外内存的数据拷贝操作，对于需要频繁进行内存间数据拷贝且生命周期较短的暂存数据，都建议存储到堆外内存。 内存操作典型应用DirectByteBuffer 是 Java 用于实现堆外内存的一个重要类，通常用在通信过程中做缓冲池，如在 Netty、MINA 等 NIO 框架中应用广泛。 DirectByteBuffer 对于堆外内存的创建、使用、销毁等逻辑均由 Unsafe 提供的堆外内存 API 来实现。 下例为 DirectByteBuffer 构造函数，创建 DirectByteBuffer 的时候，通过 Unsafe.allocateMemory 分配内存、 Unsafe.setMemory 进行内存初始化，而后构建 Cleaner 对象用于跟踪 DirectByteBuffer 对象的垃圾回收，以实现当 DirectByteBuffer 被垃圾回收时，分配的堆外内存一起被释放。 12345678910111213141516171819202122232425262728DirectByteBuffer(int cap) { // package-private super(-1, 0, cap, cap); boolean pa = VM.isDirectMemoryPageAligned(); int ps = Bits.pageSize(); long size = Math.max(1L, (long)cap + (pa ? ps : 0)); Bits.reserveMemory(size, cap); long base = 0; try { // 分配内存并返回基地址 base = unsafe.allocateMemory(size); } catch (OutOfMemoryError x) { Bits.unreserveMemory(size, cap); throw x; } // 内存初始化 unsafe.setMemory(base, size, (byte) 0); if (pa &amp;&amp; (base % ps != 0)) { // Round up to page boundary address = base + ps - (base &amp; (ps - 1)); } else { address = base; } // 跟踪 DirectByteBuffer 对象的垃圾回收，以实现堆外内存释放 cleaner = Cleaner.create(this, new Deallocator(base, size, cap)); att = null;} 内存屏障内存屏障介绍在介绍内存屏障前，需要知道编译器和 CPU 会在保证程序输出结果一致的情况下，会对代码进行重排序，从指令优化角度提升性能。而指令重排序可能会带来一个不好的结果，导致 CPU 的高速缓存和内存中数据的不一致，而内存屏障（Memory Barrier）就是通过阻止屏障两边的指令重排序从而避免编译器和硬件的不正确优化情况。 在硬件层面上，内存屏障是 CPU 为了防止代码进行重排序而提供的指令，不同的硬件平台上实现内存屏障的方法可能并不相同。在 Java8 中，引入了 3 个内存屏障的函数，它屏蔽了操作系统底层的差异，允许在代码中定义、并统一由 JVM 来生成内存屏障指令，来实现内存屏障的功能。 123456//内存屏障，禁止load操作重排序。屏障前的load操作不能被重排序到屏障后，屏障后的load操作不能被重排序到屏障前public native void loadFence();//内存屏障，禁止store操作重排序。屏障前的store操作不能被重排序到屏障后，屏障后的store操作不能被重排序到屏障前public native void storeFence();//内存屏障，禁止load、store操作重排序public native void fullFence(); 内存屏障可以看做对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作。以 loadFence 方法为例，它会禁止读操作重排序，保证在这个屏障之前的所有读操作都已经完成，并且将缓存数据设为无效，重新从主存中进行加载。 内存屏障典型应用在 Java 8 中引入了一种锁的新机制—— StampedLock ，它可以看成是读写锁的一个改进版本。 StampedLock 提供了一种乐观读锁的实现，这种乐观读锁类似于无锁的操作，完全不会阻塞写线程获取写锁，从而缓解读多写少时写线程“饥饿”现象。由于 StampedLock 提供的乐观读锁不阻塞写线程获取读锁，当线程共享变量从主内存 load 到线程工作内存时，会存在数据不一致问题。 为了解决这个问题， StampedLock 的 validate 方法会通过 Unsafe 的 loadFence 方法加入一个 load 内存屏障。 1234public boolean validate(long stamp) { U.loadFence(); return (stamp &amp; SBITS) == (state &amp; SBITS);}","link":"/2025/03/10/%E5%85%AB%E8%82%A1/Java/Java%E5%9F%BA%E7%A1%80/%E5%85%B6%E4%BB%96%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"title":"","text":"","link":"/2025/05/15/%E5%85%AB%E8%82%A1/Java/%E9%9B%86%E5%90%88/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/ArrayList%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"title":"","text":"","link":"/2025/05/15/%E5%85%AB%E8%82%A1/Java/%E9%9B%86%E5%90%88/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/HashMap%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"title":"","text":"","link":"/2025/05/15/%E5%85%AB%E8%82%A1/Java/%E9%9B%86%E5%90%88/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/DelayQueue%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"title":"","text":"","link":"/2025/05/15/%E5%85%AB%E8%82%A1/Java/%E9%9B%86%E5%90%88/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/LinkedHashMap%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"title":"","text":"","link":"/2025/05/15/%E5%85%AB%E8%82%A1/Java/%E9%9B%86%E5%90%88/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/PriorityQueue%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"title":"","text":"","link":"/2025/05/15/%E5%85%AB%E8%82%A1/Java/%E9%9B%86%E5%90%88/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/LinkedList%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}],"tags":[{"name":"OS","slug":"OS","link":"/tags/OS/"},{"name":"Arch Linux","slug":"Arch-Linux","link":"/tags/Arch-Linux/"},{"name":"Golang","slug":"Golang","link":"/tags/Golang/"},{"name":"English","slug":"English","link":"/tags/English/"},{"name":"test","slug":"test","link":"/tags/test/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"中文","slug":"中文","link":"/tags/%E4%B8%AD%E6%96%87/"},{"name":"Rust","slug":"Rust","link":"/tags/Rust/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"toy projects","slug":"toy-projects","link":"/tags/toy-projects/"},{"name":"翻译","slug":"翻译","link":"/tags/%E7%BF%BB%E8%AF%91/"},{"name":"八股","slug":"八股","link":"/tags/%E5%85%AB%E8%82%A1/"}],"categories":[{"name":"OS","slug":"OS","link":"/categories/OS/"},{"name":"Golang","slug":"Golang","link":"/categories/Golang/"},{"name":"test","slug":"test","link":"/categories/test/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"basics","slug":"Golang/basics","link":"/categories/Golang/basics/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"Rust","slug":"Rust","link":"/categories/Rust/"},{"name":"toy projects","slug":"toy-projects","link":"/categories/toy-projects/"},{"name":"Arch Linux","slug":"Linux/Arch-Linux","link":"/categories/Linux/Arch-Linux/"},{"name":"basics","slug":"Java/basics","link":"/categories/Java/basics/"},{"name":"Rust程序设计语言","slug":"Rust/Rust程序设计语言","link":"/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/"},{"name":"八股","slug":"八股","link":"/categories/%E5%85%AB%E8%82%A1/"},{"name":"Thinking in Java","slug":"Java/basics/Thinking-in-Java","link":"/categories/Java/basics/Thinking-in-Java/"},{"name":"Java集合","slug":"八股/Java集合","link":"/categories/%E5%85%AB%E8%82%A1/Java%E9%9B%86%E5%90%88/"},{"name":"JavaSE","slug":"八股/JavaSE","link":"/categories/%E5%85%AB%E8%82%A1/JavaSE/"}],"pages":[{"title":"categories","text":"","link":"/categories/index.html"}]}