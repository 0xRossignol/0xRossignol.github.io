{"posts":[{"title":"Thinking in Java pt.1","text":"Chapter 1 Introduction to Objects1.1 The progress of abstractionAlan Kay summarized five basic characteristics of Smalltalk, the first successful object-oriented language and one of the languages upon which Java is based. These characteristics represent a pure approach to object-oriented programming: Everything is an object. Think of an object as a fancy variable; it stores data, but you can “make requests” to that object, asking it to perform operations on itself. In theory, you can take any conceptual(概念性的 ) component in the problem you’re trying to solve (dogs, buildings, services, etc.) and represent it as an object in your program. A program is a bunch of objects telling each other what to do by sending messages. To make a request of an object, you “send a message” to that object. More concretely, you can think of a message as a request to call a method that belongs to a particular object. Each object has its own memory made up of other objects. Put another way, you create a new kind of object by making a package containing existing objects. Thus, you can build complexity into a program while hiding it behind the simplicity of objects. Every object has a type. Using the parlance(按照这种说法 ), each object is an instance of a class, in which “class” is synonymous with “type.” The most important distinguishing characteristic of a class is “What messages can you send to it?” All objects of a particular type can receive the same messages. This is actually a loaded statement, as you will see later. Because an object of type “circle” is also an object of type “shape,” a circle is guaranteed to accept shape messages. This means you can write code that talks to shapes and automatically handle anything that fits the description of a shape. This substitutability is one of the powerful concepts in OOP. 1.2 An object has an interfaceSince a class describes a set of objects that have identical characteristics (data elements) and behaviors (functionality), a class is really a data type because a floating point number, for example, also has a set of characteristics and behaviors. The difference is that a programmer defines a class to fit a problem rather than being forced to use an existing data type that was designed to represent a unit of storage in a machine. You extend the programming language by adding new data types specific to your needs. The programming system welcomes the new classes and gives them all the care and type checking that it gives to built-in types. The object-oriented approach is not limited to building simulations. Whether or not you agree that any program is a simulation of the system you’re designing, the use of OOP techniques can easily reduce a large set of problems to a simple solution. Once a class is established, you can make as many objects of that class as you like, and then manipulate those objects as if they are the elements that exist in the problem you are trying to solve. Indeed, one of the challenges of object-oriented programming is to create a one-toone mapping between the elements in the problem space and objects in the solution space. 1.3 An object provides servicesWhile you’re trying to develop or understand a program design, one of the best ways to think about objects is as “service providers.” Your program itself will provide services to the user, and it will accomplish this by using the services offered by other objects. Your goal is to produce (or even better, locate in existing code libraries) a set of objects that provide the ideal services to solve your problem. 1.4 The hidden implementationIt is helpful to break up the playing field into class creators (those who create new data types) and client programmers (the class consumers who use the data types in their applications). The goal of the client programmer is to collect a toolbox full of classes to use for rapid application development. The goal of the class creator is to build a class that exposes only what’s necessary to the client programmer and keeps everything else hidden. Why? Because if it’s hidden, the client programmer can’t access it, which means that the class creator can change the hidden portion at will without worrying about the impact on anyone else. The hidden portion usually represents the tender insides of an object that could easily be corrupted by a careless or uninformed client programmer, so hiding the implementation reduces program bugs. Java uses three explicit keywords to set the boundaries in a class: public, private, and protected. These access specifiers determine who can use the definitions that follow. public means the following element is available to everyone. The private keyword, on the other hand, means that no one can access that element except you, the creator of the type, inside methods of that type. private is a brick wall between you and the client programmer. Someone who tries to access a private member will get a compile-time error. The protected keyword acts like private, with the exception that an inheriting class has access to protected members, but not private members. Inheritance will be introduced shortly. Java also has a “default” access, which comes into play if you don’t use one of the aforementioned specifiers. This is usually called package access because classes can access the members of other classes in the same package (library component), but outside of the package those same members appear to be private. 1.5 Reusing the implementationOnce a class has been created and tested, it should (ideally) represent a useful unit of code. It turns out that this reusability is not nearly so easy to achieve as many would hope; it takes experience and insight to produce a reusable object design. But once you have such a design, it begs to be reused. Code reuse is one of the greatest advantages that object-oriented programming languages provide. The simplest way to reuse a class is to just use an object of that class directly, but you can also place an object of that class inside a new class. We call this “creating a member object.” Your new class can be made up of any number and type of other objects, in any combination that you need to achieve the functionality desired in your new class. Because you are composing a new class from existing classes, this concept is called composition (if the composition happens dynamically, it’s usually called aggregation). Composition is often referred to as a “has-a” relationship, as in “A car has an engine.” Composition comes with a great deal of flexibility. The member objects of your new class are typically private, making them inaccessible to the client programmers who are using the class. This allows you to change those members without disturbing existing client code. You can also change the member objects at run time, to dynamically change the behavior of your program. Inheritance, which is described next, does not have this flexibility since the compiler must place compile-time restrictions on classes created with inheritance. Because inheritance is so important in object-oriented programming, it is often highly emphasized, and the new programmer can get the idea that inheritance should be used everywhere. This can result in awkward and overly complicated designs. Instead, you should first look to composition when creating new classes, since it is simpler and more flexible. If you take this approach, your designs will be cleaner. Once you’ve had some experience, it will be reasonably obvious when you need inheritance. 1.6 InheritanceA type does more than describe the constraints on a set of objects; it also has a relationship with other types. Two types can have characteristics and behaviors in common, but one type may contain more characteristics than another and may also handle more messages (or handle them differently). Inheritance expresses this similarity between types by using the concept of base types and derived types. A base type contains all of the characteristics and behaviors that are shared among the types derived from it. You create a base type to represent the core of your ideas about some objects in your system. From the base type, you derive other types to express the different ways that this core can be realized. 1.7 Interchangeable objects with polymorphismThe compiler cannot make a function call in the traditional sense. The function call generated by a non-OOP compiler causes what is called early binding, a term you may not have heard before because you’ve never thought about it any other way. It means the compiler generates a call to a specific function name, and the runtime system resolves this call to the absolute address of the code to be executed. In OOP, the program cannot determine the address of the code until run time, so some other scheme is necessary when a message is sent to a generic object. To solve the problem, object-oriented languages use the concept of late binding. When you send a message to an object, the code being called isn’t determined until run time. The compiler does ensure that the method exists and performs type checking on the arguments and return value, but it doesn’t know the exact code to execute. 1.8 The singly rooted hierarchyAll objects in a singly rooted hierarchy have an interface in common, so they are all ultimately the same fundamental type. The alternative (provided by C++) is that you don’t know that everything is the same basic type. From a backward-compatibility standpoint this fits the model of C better and can be thought of as less restrictive, but when you want to do full-on objectoriented programming you must then build your own hierarchy to provide the same convenience that’s built into other OOP languages. And in any new class library you acquire, some other incompatible interface will be used. It requires effort (and possibly multiple inheritance) to work the new interface into your design. Is the extra “flexibility” of C++ worth it? If you need it—if you have a large investment in C—it’s quite valuable. If you’re starting from scratch, other alternatives such as Java can often be more productive. All objects in a singly rooted hierarchy can be guaranteed to have certain functionality. You know you can perform certain basic operations on every object in your system. All objects can easily be created on the heap, and argument passing is greatly simplified. A singly rooted hierarchy makes it much easier to implement a garbage collector, which is one of the fundamental improvements of Java over C++. And since information about the type of an object is guaranteed to be in all objects, you’ll never end up with an object whose type you cannot determine. This is especially important with system-level operations, such as exception handling, and to allow greater flexibility in programming. 1.9 ContainersThe solution to most problems in object-oriented design seems flippant: You create another type of object. The new type of object that solves this particular problem holds references to other objects. Of course, you can do the same thing with an array, which is available in most languages. But this new object, generally called a container (also called a collection, but the Java library uses that term in a different sense so this book will use “container”), will expand itself whenever necessary to accommodate everything you place inside it. So you don’t need to know how many objects you’re going to hold in a container. Just create a container object and let it take care of the details. Fortunately, a good OOP language comes with a set of containers as part of the package. In C++, it’s part of the Standard C++ Library and is often called the Standard Template Library (STL). Smalltalk has a very complete set of containers. Java also has numerous containers in its standard library. In some libraries, one or two generic containers is considered good enough for all needs, and in others (Java, for example) the library has different types of containers for different needs: several different kinds of List classes (to hold sequences), Maps (also known as associative arrays, to associate objects with other objects), Sets (to hold one of each type of object), and more components such as queues, trees, stacks, etc. 1.9.1 Parameterized types (generics)One of the big changes in Java SE5 is the addition of parameterized types, called generics in Java. You’ll recognize the use of generics by the angle brackets with types inside; for example, an ArrayList that holds Shape can be created like this: 1ArrayList&lt;Shape&gt; shapes = new ArrayList(); There have also been changes to many of the standard library components in order to take advantage of generics. As you will see, generics have an impact on much of the code in this book. 1.10 Object creation &amp; lifetimeThe dynamic approach makes the generally logical assumption that objects tend to be complicated, so the extra overhead of finding storage and releasing that storage will not have an important impact on the creation of an object. In addition, the greater flexibility is essential to solve the general programming problem. Java uses dynamic memory allocation, exclusively.7 Every time you want to create an object, you use the new operator to build a dynamic instance of that object. Java provides a feature called a garbage collector that automatically discovers when an object is no longer in use and destroys it. A garbage collector is much more convenient because it reduces the number of issues that you must track and the code you must write. More importantly, the garbage collector provides a much higher level of insurance against the insidious problem of memory leaks, which has brought many a C++ project to its knees. With Java, the garbage collector is designed to take care of the problem of releasing the memory (although this doesn’t include other aspects of cleaning up an object). The garbage collector “knows” when an object is no longer in use, and it then automatically releases the memory for that object. This, combined with the fact that all objects are inherited from the single root class Object and that you can create objects only one way—on the heap—makes the process of programming in Java much simpler than programming in C++. You have far fewer decisions to make and hurdles to overcome. 1.11 Exception handling: dealing with errorsException handling wires error handling directly into the programming language and sometimes even the operating system. An exception is an object that is “thrown” from the site of the error and can be “caught” by an appropriate exception handler designed to handle that particular type of error. It’s as if exception handling is a different, parallel path of execution that can be taken when things go wrong. And because it uses a separate execution path, it doesn’t need to interfere with your normally executing code. This tends to make that code simpler to write because you aren’t constantly forced to check for errors. In addition, a thrown exception is unlike an error value that’s returned from a method or a flag that’s set by a method in order to indicate an error condition—these can be ignored. An exception cannot be ignored, so it’s guaranteed to be dealt with at some point. Finally, exceptions provide a way to reliably recover from a bad situation. Instead of just exiting the program, you are often able to set things right and restore execution, which produces much more robust programs. It’s worth noting that exception handling isn’t an object-oriented feature, although in objectoriented languages the exception is normally represented by an object. Exception handling existed before object-oriented languages. 1.12 Concurrent programming (并发编程)Sometimes, interrupts are necessary for handling time-critical tasks, but there’s a large class of problems in which you’re simply trying to partition the problem into separately running pieces (tasks) so that the whole program can be more responsive. Within a program, these separately running pieces are called threads, and the general concept is called concurrency. A common example of concurrency is the user interface. By using tasks, a user can press a button and get a quick response rather than being forced to wait until the program finishes its current task. All this makes concurrency sound pretty simple. There is a catch: shared resources. If you have more than one task running that’s expecting to access the same resource, you have a problem. For example, two processes can’t simultaneously send information to a printer. To solve the problem, resources that can be shared, such as the printer, must be locked while they are being used. So a task locks a resource, completes its task, and then releases the lock so that someone else can use the resource. 1.13 Java and the InternetAlthough Java is very useful for solving traditional standalone programming problems, it is also important because it solves programming problems for the World Wide Web. 1.13.1 What is the Web?1. Client/server computingThe primary idea of a client/server system is that you have a central repository of information— some kind of data, usually in a database—that you want to distribute on demand to some set of people or machines. A key to the client/server concept is that the repository of information is centrally located so that it can be changed and so that those changes will propagate out to the information consumers. Taken together, the information repository, the software that distributes the information, and the machine(s) where the information and software reside are called “*the server*.” The software that resides on the consumer machine, communicates with the server, fetches the information, processes it, and then displays it on the consumer machine is called the client. 2. The Web as a giant serverThe Web browser was a big step forward: the concept that one piece of information can be displayed on any type of computer without change. However, the original browsers were still rather primitive and rapidly bogged down by the demands placed on them. They weren’t particularly interactive, and tended to clog up both the server and the Internet because whenever you needed to do something that required programming you had to send information back to the server to be processed. It could take many seconds or minutes to find out you had misspelled something in your request. Since the browser was just a viewer it couldn’t perform even the simplest computing tasks. (On the other hand, it was safe, because it couldn’t execute any programs on your local machine that might contain bugs or viruses.) To solve this problem, different approaches have been taken. To begin with, graphics standards have been enhanced to allow better animation and video within browsers. The remainder of the problem can be solved only by incorporating the ability to run programs on the client end, under the browser. This is called client-side programming. 1.13.2 Client-side programmingMost desktop computers that run Web browsers are powerful engines capable of doing vast work, and with the original static HTML approach they are sitting there, just idly waiting for the server to dish up the next page. Client-side programming means that the Web browser is harnessed to do whatever work it can, and the result for the user is a much speedier and more interactive experience at your Web site. The problem with discussions of client-side programming is that they aren’t very different from discussions of programming in general. The parameters are almost the same, but the platform is different; a Web browser is like a limited operating system. In the end, you must still program, and this accounts for the dizzying array of problems and solutions produced by client-side programming. The rest of this section provides an overview of the issues and approaches in client-side programming. 1. Plug-insOne of the most significant steps forward in client-side programming is the development of the plug-in. This is a way for a programmer to add new functionality to the browser by downloading a piece of code that plugs itself into the appropriate spot in the browser. The value of the plug-in for client-side programming is that it allows an expert programmer to develop extensions and add those extensions to a browser without the permission of the browser manufacturer. Thus, plug-ins provide a “back door” that allows the creation of new client-side programming languages (although not all languages are implemented as plug-ins). 2. Scripting languagesScripting languages tend to be reasonably easy to understand and, because they are simply text that is part of an HTML page, they load very quickly as part of the single server hit required to procure that page. The trade-off is that your code is exposed for everyone to see (and steal). Generally, however, you aren’t doing amazingly sophisticated things with scripting languages, so this is not too much of a hardship. The scripting languages used inside Web browsers are really intended to solve specific types of problems, primarily the creation of richer and more interactive graphical user interfaces (GUIs). However, a scripting language might solve 80 percent of the problems encountered in client-side programming. Your problems might very well fit completely within that 80 percent, and since scripting languages can allow easier and faster development, you should probably consider a scripting language before looking at a more involved solution such as Java programming. 3. JavaJava is a popular solution for this. Not only is it a powerful programming language built to be secure, cross-platform, and international, but Java is being continually extended to provide language features and libraries that elegantly handle problems that are difficult in traditional programming languages, such as concurrency, database access, network programming, and distributed computing. Java allows client-side programming via the applet and with Java Web Start. An applet is a mini-program that will run only under a Web browser. The applet is downloaded automatically as part of a Web page (just as, for example, a graphic is automatically downloaded). When the applet is activated, it executes a program. This is part of its beauty—it provides you with a way to automatically distribute the client software from the server at the time the user needs the client software, and no sooner. The user gets the latest version of the client software without fail and without difficult reinstallation. Because of the way Java is designed, the programmer needs to create only a single program, and that program automatically works with all computers that have browsers with built-in Java interpreters. (This safely includes the vast majority of machines.) Since Java is a full-fledged programming language, you can do as much work as possible on the client before and after making requests of the server. For example, you won’t need to send a request form across the Internet to discover that you’ve gotten a date or some other parameter wrong, and your client computer can quickly do the work of plotting data instead of waiting for the server to make a plot and ship a graphic image back to you. Not only do you get the immediate win of speed and responsiveness, but the general network traffic and load on servers can be reduced, preventing the entire Internet from slowing down. 4. AlternativesTo be honest, Java applets have not particularly lived up to their initial fanfare. When Java first appeared, what everyone seemed most excited about was applets, because these would finally allow serious client-side programmability, to increase responsiveness and decrease bandwidth requirements for Internet-based applications. People envisioned vast possibilities. Indeed, you can find some very clever applets on the Web. But the overwhelming move to applets never happened. The biggest problem was probably that the 10 MB download necessary to install the Java Runtime Environment (JRE) was too scary for the average user. The fact that Microsoft chose not to include the JRE with Internet Explorer may have sealed its fate. In any event, Java applets didn’t happen on a large scale. 5. .NET and C#Currently, the main vulnerability and important question concerning .NET is whether Microsoft will allow it to be completely ported to other platforms. They claim there’s no problem doing this, and the Mono project (www.go-mono.com) has a partial implementation of .NET working on Linux, but until the implementation is complete and Microsoft has not decided to squash any part of it, .NET as a cross-platform solution is still a risky bet. 6. Internet vs. IntranetWhen Web technology is used for an information network that is restricted to a particular company, it is referred to as an intranet. Intranets provide much greater security than the Internet, since you can physically control access to the servers within your company. When faced with this bewildering array of solutions to the client-side programming problem, the best plan of attack is a cost-benefit analysis. Consider the constraints of your problem and what would be the shortest path to your solution. Since client-side programming is still programming, it’s always a good idea to take the fastest development approach for your particular situation. This is an aggressive stance to prepare for inevitable encounters with the problems of program development. 1.13.3 Server-side programmingA more complicated request to a server generally involves a database transaction. A common scenario involves a request for a complex database search, which the server then formats into an HTML page and sends to you as the result. (Of course, if the client has more intelligence via Java or a scripting language, the raw data can be sent and formatted at the client end, which will be faster and less load on the server.) Or you might want to register your name in a database when you join a group or place an order, which will involve changes to that database. These database requests must be processed via some code on the server side, which is generally referred to as server-side programming. Traditionally, server-side programming has been performed using Perl, Python, C++, or some other language to create CGI programs, but more sophisticated systems have since appeared. These include Java-based Web servers that allow you to perform all your server-side programming in Java by writing what are called servlets. Servlets and their offspring, JSPs, are two of the most compelling reasons that companies that develop Web sites are moving to Java, especially because they eliminate the problems of dealing with differently abled browsers. 1.14 SummaryBecause OOP adds many new concepts on top of what you find in a procedural language, your natural assumption may be that the resulting Java program will be far more complicated than the equivalent procedural program. Here, you’ll be pleasantly surprised: A well-written Java program is generally far simpler and much easier to understand than a procedural program. What you’ll see are the definitions of the objects that represent concepts in your problem space (rather than the issues of the computer representation) and messages sent to those objects to represent the activities in that space. One of the delights of objectoriented programming is that, with a well-designed program, it’s easy to understand the code by reading it. Usually, there’s a lot less code as well, because many of your problems will be solved by reusing existing library code. OOP and Java may not be for everyone. It’s important to evaluate your own needs and decide whether Java will optimally satisfy those needs, or if you might be better off with another programming system (including the one you’re currently using). If you know that your needs will be very specialized for the foreseeable future and if you have specific constraints that may not be satisfied by Java, then you owe it to yourself to investigate the alternatives (in particular, I recommend looking at Python; see www.Python.org). If you still choose Java as your language, you’ll at least understand what the options were and have a clear vision of why you took that direction.","link":"/2025/02/09/Thinking-in-Java/Thinking-in-Java-pt-1/"},{"title":"Thinking in Java pt.5","text":"Chapter 5 Initialization &amp; CleanupAs the computer revolution progresses, “unsafe” programming has become one of the major culprits that makes programming expensive. Two of these safety issues are initialization and cleanup. Many C bugs occur when the programmer forgets to initialize a variable. This is especially true with libraries when users don’t know how to initialize a library component, or even that they must. Cleanup is a special problem because it’s easy to forget about an element when you’re done with it, since it no longer concerns you. Thus, the resources used by that element are retained and you can easily end up running out of resources (most notably, memory). C++ introduced the concept of a constructor, a special method automatically called when an object is created. Java also adopted the constructor, and in addition has a garbage collector that automatically releases memory resources when they’re no longer being used. This chapter examines the issues of initialization and cleanup, and their support in Java. 5.1 Guaranteed initialization with the constructorpass 5.2 Method overloadingpass 5.3 Default constructorspass 5.4 The this keywordpass 5.4.1 Calling constructors from constructorsWhen you write several constructors for a class, there are times when you’d like to call one constructor from another to avoid duplicating code. You can make such a call by using the this keyword. Normally, when you say this, it is in the sense of “this object” or “the current object,” and by itself it produces the reference to the current object. In a constructor, the this keyword takes on a different meaning when you give it an argument list. It makes an explicit call to the constructor that matches that argument list. Thus you have a straightforward way to call other constructors: 123456789101112131415161718192021222324252627282930313233343536373839//: initialization/Flower.java// Calling constructors with &quot;this&quot;import static net.mindview.util.Print.*;public class Flower { int petalCount = 0; String s = &quot;initial value&quot;; Flower(int petals) { petalCount = petals; print(&quot;Constructor w/ int arg only, petalCount= &quot; + petalCount); } Flower(String ss) { print(&quot;Constructor w/ String arg only, s = &quot; + ss); s = ss; } Flower(String s, int petals) { this(petals); //! this(s); // Can’t call two! this.s = s; // Another use of &quot;this&quot; print(&quot;String &amp; int args&quot;); } Flower() { this(&quot;hi&quot;, 47); print(&quot;default constructor (no args)&quot;); } void printPetalCount() { //! this(11); // Not inside non-constructor! print(&quot;petalCount = &quot; + petalCount + &quot; s = &quot;+ s); } public static void main(String[] args) { Flower x = new Flower(); x.printPetalCount(); }} /* Output:Constructor w/ int arg only, petalCount= 47String &amp; int argsdefault constructor (no args)petalCount = 47 s = hi*///:~ The constructor Flower(String s, int petals) shows that, while you can call one constructor using this, you cannot call two. In addition, the constructor call must be the first thing you do, or you’ll get a compiler error message. This example also shows another way you’ll see this used. Since the name of the argument s and the name of the member data s are the same, there’s an ambiguity. You can resolve it using this.s, to say that you’re referring to the member data. You’ll often see this form used in Java code, and it’s used in numerous places in this book. In printPetalCount( ) you can see that the compiler won’t let you call a constructor from inside any method other than a constructor. 5.4.2 The meaning of staticWith the this keyword in mind, you can more fully understand what it means to make a method static. It means that there is no this for that particular method. You cannot call non-static methods from inside static methods[^1] (although the reverse is possible), and you can call a static method for the class itself, without any object. In fact, that’s primarily what a static method is for. It’s as if you’re creating the equivalent of a global method. However, global methods are not permitted in Java, and putting the static method inside a class allows it access to other static methods and to static fields. [^1]: The one case in which this is possible occurs if you pass a reference to an object into the static method (the static method could also create its own object). Then, via the reference (which is now effectively this), you can call non-static methods and access non-static fields. But typically, if you want to do something like this, you’ll just make an ordinary, non-static method. 5.5 Cleanup: finalization and garbage collectionProgrammers know about the importance of initialization, but often forget the importance of cleanup. After all, who needs to clean up an int? But with libraries, simply “letting go” of an object once you’re done with it is not always safe. Of course, Java has the garbage collector to reclaim the memory of objects that are no longer used. Now consider an unusual case: Suppose your object allocates “special” memory without using new. The garbage collector only knows how to release memory allocated with new, so it won’t know how to release the object’s “special” memory. To handle this case, Java provides a method called finalize( ) that you can define for your class. Here’s how it’s supposed to work. When the garbage collector is ready to release the storage used for your object, it will first call finalize( ), and only on the next garbage-collection pass will it reclaim the object’s memory. So if you choose to use finalize( ), it gives you the ability to perform some important cleanup at the time of garbage collection. In C++, objects always get destroyed (in a bug-free program), whereas in Java, objects do not always get garbage collected. Or, put another way: Your objects might not get garbage collected. Garbage collection is not destruction. You might find that the storage for an object never gets released because your program never nears the point of running out of storage. If your program completes and the garbage collector never gets around to releasing the storage for any of your objects, that storage will be returned to the operating system en masse as the program exits. This is a good thing, because garbage collection has some overhead, and if you never do it, you never incur that expense. 5.5.1 What is finalize() for?A third point to remember is: Garbage collection is only about memory. That is, the sole reason for the existence of the garbage collector is to recover memory that your program is no longer using. So any activity that is associated with garbage collection, most notably your finalize( ) method, must also be only about memory and its deallocation. It would seem that finalize( ) is in place because of the possibility that you’ll do something Clike by allocating memory using a mechanism other than the normal one in Java. This can happen primarily through native methods, which are a way to call non-Java code from Java. (Native methods are covered in Appendix B in the electronic 2nd edition of this book, available at www.MindView.net.) C and C++ are the only languages currently supported by native methods, but since they can call subprograms in other languages, you can effectively call anything. Inside the non-Java code, C’s malloc( ) family of functions might be called to allocate storage, and unless you call free( ), that storage will not be released, causing a memory leak. Of course, free( ) is a C and C++ function, so you’d need to call it in a native method inside your finalize( ). After reading this, you probably get the idea that you won’t use finalize( ) much.[^2] You’re correct; it is not the appropriate place for normal cleanup to occur. So where should normal cleanup be performed? [^2]:Joshua Bloch goes further in his section titled “avoid finalizers”: “Finalizers are unpredictable, often dangerous, and generally unnecessary.” Effective JavaTM Programming Language Guide, p. 20 (Addison-Wesley, 2001). 5.5.2 You must perform cleanupTo clean up an object, the user of that object must call a cleanup method at the point the cleanup is desired. This sounds pretty straightforward, but it collides a bit with the C++ concept of the destructor. In C++, all objects are destroyed. Or rather, all objects should be destroyed. If the C++ object is created as a local (i.e., on the stack—not possible in Java), then the destruction happens at the closing curly brace of the scope in which the object was created. If the object was created using new (like in Java), the destructor is called when the programmer calls the C++ operator delete (which doesn’t exist in Java). If the C++ programmer forgets to call delete, the destructor is never called, and you have a memory leak, plus the other parts of the object never get cleaned up. This kind of bug can be very difficult to track down, and is one of the compelling reasons to move from C++ to Java. In contrast, Java doesn’t allow you to create local objects—you must always use new. But in Java, there’s no “delete” for releasing the object, because the garbage collector releases the storage for you. So from a simplistic standpoint, you could say that because of garbage collection, Java has no destructor. You’ll see as this book progresses, however, that the presence of a garbage collector does not remove the need for or the utility of destructors. (And you should never call finalize( ) directly, so that’s not a solution.) If you want some kind of cleanup performed other than storage release, you must still explicitly call an appropriate method in Java, which is the equivalent of a C++ destructor without the convenience Remember that neither garbage collection nor finalization is guaranteed. If the JVM isn’t close to running out of memory, then it might not waste time recovering memory through garbage collection. 5.5.3 The termination conditionIn general, you can’t rely on finalize( ) being called, and you must create separate “cleanup” methods and call them explicitly. So it appears that finalize( ) is only useful for obscure memory cleanup that most programmers will never use. However, there is an interesting use of finalize( ) that does not rely on it being called every time. This is the verification of the termination condition[^3] of an object. [^3]: A term coined by Bill Venners (www.Artima.com) during a seminar that he and I were giving together. At the point that you’re no longer interested in an object—when it’s ready to be cleaned up— that object should be in a state whereby its memory can be safely released. For example, if the object represents an open file, that file should be closed by the programmer before the object is garbage collected. If any portions of the object are not properly cleaned up, then you have a bug in your program that can be very difficult to find. finalize( ) can be used to eventually discover this condition, even if it isn’t always called. If one of the finalizations happens to reveal the bug, then you discover the problem, which is all you really care about. Here’s a simple example of how you might use it: 12345678910111213141516171819202122232425262728293031//: initialization/TerminationCondition.java// Using finalize() to detect an object that// hasn’t been properly cleaned up.class Book { boolean checkedOut = false; Book(boolean checkOut) { checkedOut = checkOut; } void checkIn() { checkedOut = false; } protected void finalize() { if(checkedOut) System.out.println(&quot;Error: checked out&quot;); // Normally, you’ll also do this: // super.finalize(); // Call the base-class version }}public class TerminationCondition { public static void main(String[] args) { Book novel = new Book(true); // Proper cleanup: novel.checkIn(); // Drop the reference, forget to clean up: new Book(true); // Force garbage collection &amp; finalization: System.gc(); }} /* Output:Error: checked out*///:~ The termination condition is that all Book objects are supposed to be checked in before they are garbage collected, but in main( ), a programmer error doesn’t check in one of the books. Without finalize( ) to verify the termination condition, this can be a difficult bug to find. Note that System.gc( ) is used to force finalization. But even if it isn’t, it’s highly probable that the errant Book will eventually be discovered through repeated executions of the program (assuming the program allocates enough storage to cause the garbage collector to execute). You should generally assume that the base-class version of finalize( ) will also be doing something important, and call it using super, as you can see in Book.finalize( ). In this case, it is commented out because it requires exception handling, which we haven’t covered yet. 5.5.4 How a garbage collector worksIf you come from a programming language where allocating objects on the heap is expensive, you may naturally assume that Java’s scheme of allocating everything (except primitives) on the heap is also expensive. However, it turns out that the garbage collector can have a significant impact on increasing the speed of object creation. This might sound a bit odd at first—that storage release affects storage allocation—but it’s the way some JVMs work, and it means that allocating storage for heap objects in Java can be nearly as fast as creating storage on the stack in other languages. To understand garbage collection in Java, it’s helpful learn how garbage-collection schemes work in other systems. A simple but slow garbage-collection technique is called reference counting. This means that each object contains a reference counter, and every time a reference is attached to that object, the reference count is increased. Every time a reference goes out of scope or is set to null, the reference count is decreased. Thus, managing reference counts is a small but constant overhead that happens throughout the lifetime of your program. The garbage collector moves through the entire list of objects, and when it finds one with a reference count of zero it releases that storage (however, reference counting schemes often release an object as soon as the count goes to zero). The one drawback is that if objects circularly refer to each other they can have nonzero reference counts while still being garbage. Locating such self-referential groups requires significant extra work for the garbage collector. Reference counting is commonly used to explain one kind of garbage collection, but it doesn’t seem to be used in any JVM implementations. In faster schemes, garbage collection is not based on reference counting. Instead, it is based on the idea that any non-dead object must ultimately be traceable back to a reference that lives either on the stack or in static storage. The chain might go through several layers of objects. Thus, if you start in the stack and in the static storage area and walk through all the references, you’ll find all the live objects. For each reference that you find, you must trace into the object that it points to and then follow all the references in that object, tracing into the objects they point to, etc., until you’ve moved through the entire Web that originated with the reference on the stack or in static storage. Each object that you move through must still be alive. Note that there is no problem with detached self-referential groups—these are simply not found, and are therefore automatically garbage. In the approach described here, the JVM uses an adaptive garbage-collection scheme, and what it does with the live objects that it locates depends on the variant currently being used. One of these variants is stop-and-copy. This means that—for reasons that will become apparent—the program is first stopped (this is not a background collection scheme). Then, each live object is copied from one heap to another, leaving behind all the garbage. In addition, as the objects are copied into the new heap, they are packed end-to-end, thus compacting the new heap (and allowing new storage to simply be reeled off the end as previously described). Of course, when an object is moved from one place to another, all references that point at the object must be changed. The reference that goes from the heap or the static storage area to the object can be changed right away, but there can be other references pointing to this object that will be encountered later during the “walk.” These are fixed up as they are found (you could imagine a table that maps old addresses to new ones). There are two issues that make these so-called “copy collectors” inefficient. The first is the idea that you have two heaps and you slosh all the memory back and forth between these two separate heaps, maintaining twice as much memory as you actually need. Some JVMs deal with this by allocating the heap in chunks as needed and simply copying from one chunk to another. The second issue is the copying process itself. Once your program becomes stable, it might be generating little or no garbage. Despite that, a copy collector will still copy all the memory from one place to another, which is wasteful. To prevent this, some JVMs detect that no new garbage is being generated and switch to a different scheme (this is the “*adaptive*” part). This other scheme is called mark-and-sweep, and it’s what earlier versions of Sun’s JVM used all the time. For general use, mark-and-sweep is fairly slow, but when you know you’re generating little or no garbage, it’s fast. Mark-and-sweep follows the same logic of starting from the stack and static storage, and tracing through all the references to find live objects. However, each time it finds a live object, that object is marked by setting a flag in it, but the object isn’t collected yet. Only when the marking process is finished does the sweep occur. During the sweep, the dead objects are released. However, no copying happens, so if the collector chooses to compact a fragmented heap, it does so by shuffling objects around. “Stop-and-copy” refers to the idea that this type of garbage collection is not done in the background; instead, the program is stopped while the garbage collection occurs. In the Sun literature you’ll find many references to garbage collection as a low-priority background process, but it turns out that the garbage collection was not implemented that way in earlier versions of the Sun JVM. Instead, the Sun garbage collector stopped the program when memory got low. Mark-and-sweep also requires that the program be stopped. As previously mentioned, in the JVM described here memory is allocated in big blocks. If you allocate a large object, it gets its own block. Strict stop-and-copy requires copying every live object from the source heap to a new heap before you can free the old one, which translates to lots of memory. With blocks, the garbage collection can typically copy objects to dead blocks as it collects. Each block has a generation count to keep track of whether it’s alive. In the normal case, only the blocks created since the last garbage collection are compacted; all other blocks get their generation count bumped if they have been referenced from somewhere. This handles the normal case of lots of short-lived temporary objects. Periodically, a full sweep is made—large objects are still not copied (they just get their generation count bumped), and blocks containing small objects are copied and compacted. The JVM monitors the efficiency of garbage collection and if it becomes a waste of time because all objects are long-lived, then it switches to mark-andsweep. Similarly, the JVM keeps track of how successful mark-and-sweep is, and if the heap starts to become fragmented, it switches back to stop-and-copy. This is where the “adaptive” part comes in, so you end up with a mouthful: “Adaptive generational stop-and-copy mark-andsweep.” There are a number of additional speedups possible in a JVM. An especially important one involves the operation of the loader and what is called a just-in-time (JIT) compiler. A JIT compiler partially or fully converts a program into native machine code so that it doesn’t need to be interpreted by the JVM and thus runs much faster. When a class must be loaded (typically, the first time you want to create an object of that class), the .class file is located, and the bytecodes for that class are brought into memory. At this point, one approach is to simply JIT compile all the code, but this has two drawbacks: It takes a little more time, which, compounded throughout the life of the program, can add up; and it increases the size of the executable (bytecodes are significantly more compact than expanded JIT code), and this might cause paging, which definitely slows down a program. An alternative approach is lazy evaluation, which means that the code is not JIT compiled until necessary. Thus, code that never gets executed might never be JIT compiled. The Java HotSpot technologies in recent JDKs take a similar approach by increasingly optimizing a piece of code each time it is executed, so the more the code is executed, the faster it gets. 5.6 Member initializationpass 5.6.1 Specifying initializationpass 5.7 Constructor initialization5.7.1 Order of initializationWithin a class, the order of initialization is determined by the order that the variables are defined within the class. The variable definitions may be scattered throughout and in between method definitions, but the variables are initialized before any methods can be called—even the constructor. For example: 1234567891011121314151617181920212223242526272829303132//: initialization/OrderOfInitialization.java// Demonstrates initialization order.import static net.mindview.util.Print.*;// When the constructor is called to create a// Window object, you’ll see a message:class Window { Window(int marker) { print(&quot;Window(&quot; + marker + &quot;)&quot;); }}class House { Window w1 = new Window(1); // Before constructor House() { // Show that we’re in the constructor: print(&quot;House()&quot;); w3 = new Window(33); // Reinitialize w3 } Window w2 = new Window(2); // After constructor void f() { print(&quot;f()&quot;); } Window w3 = new Window(3); // At end}public class OrderOfInitialization { public static void main(String[] args) { House h = new House(); h.f(); // Shows that construction is done }} /* Output:Window(1)Window(2)Window(3)House()Window(33)f()*///:~ In House, the definitions of the Window objects are intentionally scattered about to prove that they’ll all get initialized before the constructor is entered or anything else can happen. In addition, w3 is reinitialized inside the constructor. From the output, you can see that the w3 reference gets initialized twice: once before and once during the constructor call. (The first object is dropped, so it can be garbage collected later.) This might not seem efficient at first, but it guarantees proper initialization—what would happen if an overloaded constructor were defined that did not initialize w3 and there wasn’t a “default” initialization for w3 in its definition? 5.7.2 static data initializationThere’s only a single piece of storage for a static, regardless of how many objects are created. You can’t apply the static keyword to local variables, so it only applies to fields. If a field is a static primitive and you don’t initialize it, it gets the standard initial value for its type. If it’s a reference to an object, the default initialization value is null. The order of initialization is statics first, if they haven’t already been initialized by a previous object creation, and then the non-static objects. To summarize the process of creating an object, consider a class called Dog: Even though it doesn’t explicitly use the static keyword, the constructor is actually a static method. So the first time an object of type Dog is created, or the first time a static method or static field of class Dog is accessed, the Java interpreter must locate Dog.class, which it does by searching through the classpath. As Dog.class is loaded (creating a Class object, which you’ll learn about later), all of its static initializers are run. Thus, static initialization takes place only once, as the Class object is loaded for the first time. When you create a new Dog( ), the construction process for a Dog object first allocates enough storage for a Dog object on the heap. This storage is wiped to zero, automatically setting all the primitives in that Dog object to their default values (zero for numbers and the equivalent for boolean and char) and the references to null. Any initializations that occur at the point of field definition are executed. Constructors are executed. As you shall see in the Reusing Classes chapter, this might actually involve a fair amount of activity, especially when inheritance is involved. 5.7.3 Explicit static initializationJava allows you to group other static initializations inside a special “static clause” (sometimes called a static block) in a class. It looks like this: 1234567//: initialization/Spoon.javapublic class Spoon { static int i; static { i = 47; }} ///:~ It appears to be a method, but it’s just the static keyword followed by a block of code. This code, like other static initializations, is executed only once: the first time you make an object of that class or the first time you access a static member of that class (even if you never make an object of that class). 5.7.4 Non-static instance initializationJava provides a similar syntax, called instance initialization, for initializing non-static variables for each object. 123456789101112131415161718192021222324252627282930313233343536373839404142434445//: initialization/Mugs.java// Java &quot;Instance Initialization.&quot;import static net.mindview.util.Print.*;class Mug { Mug(int marker) { print(&quot;Mug(&quot; + marker + &quot;)&quot;); } void f(int marker) { print(&quot;f(&quot; + marker + &quot;)&quot;); }}public class Mugs { Mug mug1; Mug mug2; { mug1 = new Mug(1); mug2 = new Mug(2); print(&quot;mug1 &amp; mug2 initialized&quot;); } Mugs() { print(&quot;Mugs()&quot;); } Mugs(int i) { print(&quot;Mugs(int)&quot;); } public static void main(String[] args) { print(&quot;Inside main()&quot;); new Mugs(); print(&quot;new Mugs() completed&quot;); new Mugs(1); print(&quot;new Mugs(1) completed&quot;); }} /* Output:Inside main()Mug(1)Mug(2)mug1 &amp; mug2 initializedMugs()new Mugs() completedMug(1)Mug(2)mug1 &amp; mug2 initializedMugs(int)new Mugs(1) completed*///:~ You can see that the instance initialization clause: 12345{ mug1 = new Mug(1); mug2 = new Mug(2); print(&quot;mug1 &amp; mug2 initialized&quot;);} looks exactly like the static initialization clause except for the missing static keyword. This syntax is necessary to support the initialization of anonymous inner classes (see the Inner Classes chapter), but it also allows you to guarantee that certain operations occur regardless of which explicit constructor is called. From the output, you can see that the instance initialization clause is executed before either one of the constructors. 5.8 Array initializationAn array is simply a sequence of either objects or primitives that are all the same type and are packaged together under one identifier name. Arrays are defined and used with the squarebrackets indexing operator [ ]. To define an array reference, you simply follow your type name with empty square brackets. 1234int[] a1;// You can also put the square brackets after the identifier to produce exactly the same// meaning:int a1[]; This conforms to expectations from C and C++ programmers. The former style, however, is probably a more sensible syntax, since it says that the type is “an int array.” That style will be used in this book. The compiler doesn’t allow you to tell it how big the array is. This brings us back to that issue of “references.” All that you have at this point is a reference to an array (you’ve allocated enough storage for that reference), and there’s been no space allocated for the array object itself. To create storage for the array, you must write an initialization expression. For arrays, initialization can appear anywhere in your code, but you can also use a special kind of initialization expression that must occur at the point where the array is created. This special initialization is a set of values surrounded by curly braces. The storage allocation (the equivalent of using new) is taken care of by the compiler in this case. 12345678910111213141516171819202122232425int[] a1 = { 1, 2, 3, 4, 5 };// So why would you ever define an array reference without an array?int[] a2;// Well, it’s possible to assign one array to another in Java, so you can say:a2 = a1;// What you’re really doing is copying a reference, as demonstrated here://: initialization/ArraysOfPrimitives.javaimport static net.mindview.util.Print.*; public class ArraysOfPrimitives { public static void main(String[] args) { int[] a1 = { 1, 2, 3, 4, 5 }; int[] a2; a2 = a1; for(int i = 0; i &lt; a2.length; i++) a2[i] = a2[i] + 1; for(int i = 0; i &lt; a1.length; i++) print(&quot;a1[&quot; + i + &quot;] = &quot; + a1[i]); }} /* Output:a1[0] = 2a1[1] = 3a1[2] = 4a1[3] = 5a1[4] = 6*///:~ You can see that a1 is given an initialization value but a2 is not; a2 is assigned later—in this case, to another array. Since a2 and a1 are then aliased to the same array, the changes made via a2 are seen in a1. What if you don’t know how many elements you’re going to need in your array while you’re writing the program? You simply use new to create the elements in the array. Here, new works even though it’s creating an array of primitives (new won’t create a non-array primitive): 12345678910111213141516//: initialization/ArrayNew.java// Creating arrays with new.import java.util.*;import static net.mindview.util.Print.*;public class ArrayNew { public static void main(String[] args) { int[] a; Random rand = new Random(47); a = new int[rand.nextInt(20)]; print(&quot;length of a = &quot; + a.length); print(Arrays.toString(a)); }} /* Output:length of a = 18[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]*///:~ The size of the array is chosen at random by using the Random.nextInt( ) method, which produces a value between zero and that of its argument. Because of the randomness, it’s clear that array creation is actually happening at run time. In addition, the output of this program shows that array elements of primitive types are automatically initialized to “empty” values. (For numerics and char, this is zero, and for boolean, it’s false.) The Arrays.toString( ) method, which is part of the standard java.util library, produces a printable version of a one-dimensional array. Of course, in this case the array could also have been defined and initialized in the same statement: 1int[] a = new int[rand.nextInt(20)]; 5.8.1 Variable argument listspass 5.9 Enumerated typespass 5.10 SummaryThis seemingly elaborate mechanism for initialization, the constructor, should give you a strong hint about the critical importance placed on initialization in the language. As Bjarne Stroustrup, the inventor of C++, was designing that language, one of the first observations he made about productivity in C was that improper initialization of variables causes a significant portion of programming problems. These kinds of bugs are hard to find, and similar issues apply to improper cleanup. Because constructors allow you to guarantee proper initialization and cleanup (the compiler will not allow an object to be created without the proper constructor calls), you get complete control and safety. In C++, destruction is quite important because objects created with new must be explicitly destroyed. In Java, the garbage collector automatically releases the memory for all objects, so the equivalent cleanup method in Java isn’t necessary much of the time (but when it is, you must do it yourself). In cases where you don’t need destructor-like behavior, Java’s garbage collector greatly simplifies programming and adds much-needed safety in managing memory. Some garbage collectors can even clean up other resources like graphics and file handles. However, the garbage collector does add a runtime cost, the expense of which is difficult to put into perspective because of the historical slowness of Java interpreters. Although Java has had significant performance increases over time, the speed problem has taken its toll on the adoption of the language for certain types of programming problems. Because of the guarantee that all objects will be constructed, there’s actually more to the constructor than what is shown here. In particular, when you create new classes using either composition or inheritance, the guarantee of construction also holds, and some additional syntax is necessary to support this. You’ll learn about composition, inheritance, and how they affect constructors in future chapters.","link":"/2025/02/13/Thinking-in-Java/Thinking-in-Java-pt-5/"},{"title":"Write yourself a Git!","text":"1. Introduction本文尝试从底层开始解释 Git 版本控制系统，也就是从底至上逐步讲解。这听起来并不容易，而且他人已经尝试多次，但效果可能都不理想（ with questionable succes ）。但有一种简单的方法：要理解 Git 的内部原理，只需要从零开始重新实现 Git 即可。 不，别跑。（No, don’t run.） 这不是玩笑，而且真的并不复杂：如果你从头到尾阅读这篇文章并亲自编写代码（或者直接下载 ZIP 文件——但你真的应该自己写代码），最终你将得到一个名为 wyag 的程序，它将实现 Git 的所有基本功能：init、add、rm、status、commit、log…… 这些功能与 Git 本身完全兼容，兼容到（ compatible enough that ）在本教程中最后添加关于 commit 章节的提交，实际上是由 wyag 生成的，而不是 Git。而且，整个实现仅用 972 行 非常简单的 Python 代码完成。 但是，Git 对实现来说不是太复杂了吗？（ But isn’t Git too complex for that? ）在我看来，认为 Git 复杂是一种误解。没错，Git 确实是一个庞大的程序，功能众多，但它的核心其实非常简单。Git 之所以显得复杂，首先是（ stems first from ）因为它的工作方式通常非常反直觉（而那些“Git 是墨西哥卷饼”的博客文章可能并没有帮助）。但真正让 Git 变得令人困惑的，或许是它核心模型的极端简单性和强大性。 核心概念既简单又强大的组合（ The combination of core simplicity and powerful applications ），往往会让人难以理解，因为要从基本抽象的简单性跳跃性地推导出各种复杂应用，这种思维转换并不容易（比如单子（monads（函数式编程用语）），有人懂吗？）。 实现 Git 的过程将彻底揭示它的基本原理，让它的本质一览无遗。 我们可以期待去实现什么？本文将详细实现并解释 Git 核心命令的一个极简版本（如果有不清楚的地方，请反馈！）。我会保持代码简洁明了，因此 wyag 远远无法与真正的 Git 命令行相比——但缺失的部分将非常明显，并且对任何想尝试实现的人来说，都很容易补充。正如他们常说的：“将 wyag 升级为完整的 Git 库和 CLI是留给读者的一个练习。” 更具体地说，我们将实现： add(wyag source) git man page cat-file (wyag source) git man page check-ignore (wyag source) git man page checkout (wyag source) git man page commit (wyag source) git man page hash-object (wyag source) git man page init (wyag source) git man page log (wyag source) git man page ls-files (wyag source) git man page ls-tree (wyag source) git man page rev-parse (wyag source) git man page rm (wyag source) git man page show-ref (wyag source) git man page status (wyag source) git man page tag (wyag source) git man page 要跟上本文的内容，你并不需要太多前置知识：只需了解一些基本的 Git 指令（显然）、基本的 Python，以及基本的 Shell 知识即可。 首先，我只假设你对 Git 的基本命令 有一定的了解——不需要是专家级别，但如果你从未使用过 init、add、rm、commit 或 checkout，那你可能会感到困惑。 关于编程语言，wyag 将使用 Python 实现。同样，我不会使用任何花哨的特性，而且 Python 本身就很接近伪代码，因此会很容易理解。（讽刺的是，最复杂的部分可能是命令行参数解析逻辑，不过你其实并不需要完全理解它。）如果你有编程基础但从未接触过 Python，建议先在网上找个快速入门教程熟悉一下。 wyag 和 Git 都是终端程序，我默认你熟悉 Unix 终端 的基本操作。你不需要是个 l33t h4x0r（精英黑客，见[补充1](#1. l33t h4x0r)），但至少应该会使用 cd、ls、rm、tree 这些常见命令。 Warning Windows 用户注意：wyag 应该能在任何类 Unix 系统上运行，并且需要有 Python 解释器，但我完全不确定它在 Windows 上的表现。测试套件明确要求使用一个兼容 bash 的 shell，我假设 WSL（Windows Subsystem for Linux）可以提供这个功能。另外，如果你使用 WSL，确保你的 wyag 文件使用 Unix 风格的换行符（如果你用的是 VS Code，可以参考这个 StackOverflow 解决方案）。欢迎 Windows 用户提供反馈！ Note 致谢：本文得到了许多人重要的贡献，我对他们表示感谢。特别感谢以下几位：- GitHub 用户 tammoippen，他首次草拟了我忘记写的 tag_create 函数（那是 #9）。- GitHub 用户 hjlarry，在 #22 中修复了多个问题。- GitHub 用户 cutebbb，在 #32 中实现了 ls-files 的第一个版本，凭借此功能，wyag 最终实现了“暂存区”的奇妙功能！ 2. Getting started你将需要 Python 3.10 或更高版本，以及你喜欢的文本编辑器。我们不需要第三方包、虚拟环境或其他任何东西，除了常规的 Python 解释器：我们所需的一切都可以通过 Python 的标准库来实现。 我们会将代码分成两个文件： 一个可执行文件，名为 wyag； 一个 Python 库文件，名为 libwyag.py。 现在，每个软件项目开始时都会有一大堆模板代码，我们先把这些简单的部分搞定吧。 我们将从创建一个非常简短的可执行文件开始。在你的文本编辑器中创建一个新的文件，命名为 wyag，然后复制以下几行代码： 1234#!/usr/bin/env python3import libwyaglibwyag.main() 代码解释见[补充2](#2. code 1) 然后，使其变为可执行文件： 1$ chmod +x wyag 完成了！ 接下来是库文件的创建。它必须命名为 libwyag.py，并且与 wyag 可执行文件位于同一目录下。 开始时，打开空的 libwyag.py 文件，准备编写代码。 首先，我们需要导入一系列模块（可以逐个复制每个导入语句，或者将它们合并为一行）。 Git 是一个命令行应用程序，因此我们需要一些工具来解析命令行参数。Python 提供了一个很有用的模块叫做 argparse，它可以为我们完成 99% 的工作。 1import argparse Git 使用的配置文件格式基本上是 Microsoft 的 INI 格式。Python 的 configparser 模块可以用来读取和写入这些文件。 1import configparser 我们将进行一些日期/时间操作： 1from datetime import datetime 我们只需要一次，读取 Unix 上的用户/组数据库（grp 用于组，pwd 用于用户）。这是因为 Git 保存文件的数字所有者/组 ID，我们希望将其以文本形式友好地显示出来。 1import grp, pwd 为了支持 .gitignore，我们需要将文件名与诸如 *.txt 之类的模式进行匹配。文件名匹配在 fnmatch 模块中： 1from fnmatch import fnmatch Git 广泛使用 SHA-1 函数。在 Python 中，它位于 hashlib 模块中。 1import hashlib 仅需要从 math 模块中导入一个函数： 1from math import ceil os 和 os.path 提供了一些很好的文件系统抽象函数。 1import os 我们只使用了一些正则表达式： 1import re 我们还需要 sys 来访问实际的命令行参数（在 sys.argv 中）： 1import sys Git 使用 zlib 压缩所有内容。Python 也有这个模块： 1import zlib 导入完成。我们将频繁处理命令行参数。Python 提供了一个简单而功能强大的解析库 argparse。它是一个很好的库，但它的接口可能不是最直观的；如果有需要，可以参考它的文档。 1argparser = argparse.ArgumentParser(description=&quot;The stupidest content tracker&quot;) 我们需要处理子命令（如 git 中的 init、commit 等）。在 argparse 的术语中，这些被称为“子解析器”（subparsers）。此时，我们只需要声明我们的命令行界面（CLI）将使用一些子命令，并且所有调用实际上都需要一个子命令——你不能仅仅调用 git，你需要调用 git COMMAND。 12argsubparsers = argparser.add_subparsers(title=&quot;Commands&quot;, dest=&quot;command&quot;)argsubparsers.required = True dest=&quot;command&quot; 参数表示所选择的子解析器的名称将作为字符串返回，并存储在一个名为 command 的字段中。因此，我们只需要读取这个字符串，并根据它调用正确的函数。按照惯例，我将这些函数称为“桥接函数”，并在函数名前加上 cmd_ 前缀。桥接函数将解析后的参数作为唯一的参数，并负责在执行实际命令之前处理和验证这些参数。 12345678910111213141516171819def main(argv=sys.argv[1:]): args = argparser.parse_args(argv) match args.command: case &quot;add&quot; : cmd_add(args) case &quot;cat-file&quot; : cmd_cat_file(args) case &quot;check-ignore&quot; : cmd_check_ignore(args) case &quot;checkout&quot; : cmd_checkout(args) case &quot;commit&quot; : cmd_commit(args) case &quot;hash-object&quot; : cmd_hash_object(args) case &quot;init&quot; : cmd_init(args) case &quot;log&quot; : cmd_log(args) case &quot;ls-files&quot; : cmd_ls_files(args) case &quot;ls-tree&quot; : cmd_ls_tree(args) case &quot;rev-parse&quot; : cmd_rev_parse(args) case &quot;rm&quot; : cmd_rm(args) case &quot;show-ref&quot; : cmd_show_ref(args) case &quot;status&quot; : cmd_status(args) case &quot;tag&quot; : cmd_tag(args) case _ : print(&quot;Bad command.&quot;) 3. Creating repositories: init显然，按时间顺序和逻辑顺序，第一个 Git 命令是 git init，因此我们将从创建 wyag init 开始。为了实现这一点，我们首先需要一些非常基础的仓库抽象。 3.1. The Repository object显然，我们需要对仓库进行一些抽象：几乎每次运行 Git 命令时，我们都是在尝试对仓库做某些操作，创建它、读取它或修改它。 一个 Git 仓库由两部分组成：一个“工作树”，存放着要进行版本控制的文件；一个“git 目录”，Git 用来存储自己的数据。在大多数情况下，工作树是一个普通目录，git 目录是工作树的子目录，名为 .git。 Git 支持更多的情况（裸仓库、分离的 gitdir 等），但我们不需要考虑这些情况：我们将坚持使用工作树/ .git 的基本结构。我们的仓库对象将只包含两个路径：工作树路径和 git 目录路径。 要创建一个新的 Repository 对象，我们只需要进行几个检查： 必须验证目录是否存在，并且包含一个名为 .git 的子目录。 然后读取 .git/config 中的配置文件（它只是一个 INI 文件），并检查 core.repositoryformatversion 是否为 0。稍后会详细介绍这个字段。 我们的构造函数接受一个可选的 force 参数，用于禁用所有检查。这是因为稍后我们将创建的 repo_create() 函数会使用 Repository 对象来创建仓库。因此，我们需要一种方法，即使在（仍然）无效的文件系统位置，也能创建这样的对象。 123456789101112131415161718192021222324252627class GitRepository (object): &quot;&quot;&quot;A git repository&quot;&quot;&quot; worktree = None gitdir = None conf = None def __init__(self, path, force=False): self.worktree = path self.gitdir = os.path.join(path, &quot;.git&quot;) if not (force or os.path.isdir(self.gitdir)): raise Exception(f&quot;Not a Git repository {path}&quot;) # Read configuration file in .git/config self.conf = configparser.ConfigParser() cf = repo_file(self, &quot;config&quot;) if cf and os.path.exists(cf): self.conf.read([cf]) elif not force: raise Exception(&quot;Configuration file missing&quot;) if not force: vers = int(self.conf.get(&quot;core&quot;, &quot;repositoryformatversion&quot;)) if vers != 0: raise Exception(&quot;Unsupported repositoryformatversion: {vers}&quot;) 我们将处理仓库中的许多路径。我们不妨创建一些实用函数来计算这些路径，并在需要时创建缺失的目录结构。首先，创建一个通用的路径构建函数： 123def repo_path(repo, *path): &quot;&quot;&quot;Compute path under repo's gitdir.&quot;&quot;&quot; return os.path.join(repo.gitdir, *path) （关于 Python 语法的说明：*path 使得这个函数变为可变参数函数，因此可以将多个路径组件作为单独的参数传入。例如，repo_path(repo, &quot;objects&quot;, &quot;df&quot;, &quot;4ec9fc2ad990cb9da906a95a6eda6627d7b7b0&quot;) 是一个有效的调用。函数接收到的 path 是一个列表。） 接下来的两个函数，repo_file() 和 repo_dir()，分别返回并可选择性地创建文件或目录的路径。它们之间的区别在于，文件版本(repo_file())只会创建到最后一个组件的目录。 123456789101112131415161718192021222324def repo_file(repo, *path, mkdir=False): &quot;&quot;&quot;Same as repo_path, but create dirname(*path) if absent. Forexample, repo_file(r, \\&quot;refs\\&quot;, \\&quot;remotes\\&quot;, \\&quot;origin\\&quot;, \\&quot;HEAD\\&quot;) will create.git/refs/remotes/origin.&quot;&quot;&quot; if repo_dir(repo, *path[:-1], mkdir=mkdir): return repo_path(repo, *path)def repo_dir(repo, *path, mkdir=False): &quot;&quot;&quot;Same as repo_path, but mkdir *path if absent if mkdir.&quot;&quot;&quot; path = repo_path(repo, *path) if os.path.exists(path): if (os.path.isdir(path)): return path else: raise Exception(f&quot;Not a directory {path}&quot;) if mkdir: os.makedirs(path) return path else: return None （关于语法的第二个也是最后一个说明：由于 *path 使得函数成为可变参数函数，因此 mkdir 参数必须通过名称显式传递。例如，repo_file(repo, &quot;objects&quot;, mkdir=True)。） 要创建一个新的仓库，我们首先从一个目录开始（如果该目录不存在，我们会创建它），然后在其中创建 git 目录（该目录必须不存在或为空）。这个目录叫做 .git（前导的点使其在 Unix 系统中成为“隐藏”目录），并包含： .git/objects/：对象存储，我们将在下一节介绍。 .git/refs/：引用存储，稍后会讨论。它包含两个子目录，heads 和 tags。 .git/HEAD：当前 HEAD 的引用（稍后会详细讲解！）。 .git/config：仓库的配置文件。 .git/description：包含一个自由格式的仓库描述，供人类使用，且很少使用。 12345678910111213141516171819202122232425262728293031323334def repo_create(path): &quot;&quot;&quot;Create a new repository at path.&quot;&quot;&quot; repo = GitRepository(path, True) # First, we make sure the path either doesn't exist or is an # empty dir. if os.path.exists(repo.worktree): if not os.path.isdir(repo.worktree): raise Exception (f&quot;{path} is not a directory!&quot;) if os.path.exists(repo.gitdir) and os.listdir(repo.gitdir): raise Exception (f&quot;{path} is not empty!&quot;) else: os.makedirs(repo.worktree) assert repo_dir(repo, &quot;branches&quot;, mkdir=True) assert repo_dir(repo, &quot;objects&quot;, mkdir=True) assert repo_dir(repo, &quot;refs&quot;, &quot;tags&quot;, mkdir=True) assert repo_dir(repo, &quot;refs&quot;, &quot;heads&quot;, mkdir=True) # .git/description with open(repo_file(repo, &quot;description&quot;), &quot;w&quot;) as f: f.write(&quot;Unnamed repository; edit this file 'description' to name the repository.\\n&quot;) # .git/HEAD with open(repo_file(repo, &quot;HEAD&quot;), &quot;w&quot;) as f: f.write(&quot;ref: refs/heads/master\\n&quot;) with open(repo_file(repo, &quot;config&quot;), &quot;w&quot;) as f: config = repo_default_config() config.write(f) return repo 配置文件非常简单，它是一个类似 INI 的文件，包含一个部分（[core]）和三个字段： repositoryformatversion = 0：gitdir 格式的版本。0 表示初始格式，1 表示带扩展的相同格式。如果大于 1，Git 会 panic；wyag 只接受 0。 filemode = false：禁用在工作树中跟踪文件模式（权限）更改。 bare = false：指示该仓库有一个工作树。Git 支持一个可选的 worktree 键，用于指示工作树的位置（如果不是 ..）；wyag 不支持此功能。 我们使用 Python 的 configparser 库来创建这个文件： 123456789def repo_default_config(): ret = configparser.ConfigParser() ret.add_section(&quot;core&quot;) ret.set(&quot;core&quot;, &quot;repositoryformatversion&quot;, &quot;0&quot;) ret.set(&quot;core&quot;, &quot;filemode&quot;, &quot;false&quot;) ret.set(&quot;core&quot;, &quot;bare&quot;, &quot;false&quot;) return ret 3.2. The init command现在我们有了用于读取和创建仓库的代码，让我们通过创建 wyag init 命令来使这些代码可以从命令行使用。wyag init 的行为与 git init 完全相同——当然，自定义性要少得多。wyag init 的语法将是： 1wyag init [path] 我们已经有了完整的仓库创建逻辑。为了创建这个命令，我们只需要再添加两件事： 我们需要创建一个 argparse 子解析器来处理我们命令的参数。 1argsp = argsubparsers.add_parser(&quot;init&quot;, help=&quot;Initialize a new, empty repository.&quot;) 对于 init 命令，有一个单一的可选位置参数：初始化仓库的路径。默认为当前目录 : 123456argsp.add_argument(&quot;path&quot;, metavar=&quot;directory&quot;, nargs=&quot;?&quot;, default=&quot;.&quot;, help=&quot;Where to create the repository.&quot;) 我们还需要一个“桥接”函数，它将从 argparse 返回的对象中读取参数值，并使用正确的值调用实际的函数。 12def cmd_init(args): repo_create(args.path) 完成了！如果你按照这些步骤操作，你现在应该能够在任何地方使用 wyag init 创建一个 Git 仓库了： 1$ wyag init test （wyag 可执行文件通常不在你的 $PATH 中：你需要通过它的完整路径来调用它，例如 ~/projects/wyag/wyag init .。） 3.3. The repo_find() function在我们实现仓库功能时，我们需要一个函数来找到当前仓库的根目录。我们将频繁使用这个函数，因为几乎所有 Git 功能都需要在现有仓库上工作（当然，init 除外！）。有时根目录就是当前目录，但也可能是父目录：比如你的仓库根目录可能在 ~/Documents/MyProject，但你当前可能在 ~/Documents/MyProject/src/tui/frames/mainview/ 工作。我们现在将创建的 repo_find() 函数将从当前目录开始查找仓库根目录，并递归向上查找，直到根目录 /。要识别一个路径是否为仓库，它将检查该路径是否存在 .git 目录。 1234567891011121314151617181920def repo_find(path=&quot;.&quot;, required=True): path = os.path.realpath(path) if os.path.isdir(os.path.join(path, &quot;.git&quot;)): return GitRepository(path) # If we haven't returned, recurse in parent, if w parent = os.path.realpath(os.path.join(path, &quot;..&quot;)) if parent == path: # Bottom case # os.path.join(&quot;/&quot;, &quot;..&quot;) == &quot;/&quot;: # If parent==path, then path is root. if required: raise Exception(&quot;No git directory.&quot;) else: return None # Recursive case return repo_find(parent, required) 仓库部分完成了！ 4. Reading and writing objects: hash-object and cat-file4.1. What are objects?既然我们已经有了仓库，接下来就是往其中放东西。与此同时，仓库本身也很单调，编写 Git 实现不应该仅仅是写一堆 mkdir。让我们来谈谈对象，并实现 git hash-object 和 git cat-file。 也许你不太了解这两个命令——它们并不是 Git 日常工具箱的一部分，而且实际上是非常底层的命令（在 Git 术语中叫做“管道命令”）。它们的功能其实非常简单：hash-object 将一个现有的文件转换成一个 Git 对象，而 cat-file 将一个现有的 Git 对象打印到标准输出。 那么，什么是 Git 对象呢？从本质上来说，Git 是一个“内容寻址文件系统”。这意味着，与普通的文件系统不同，文件名是任意的，与文件内容无关，而 Git 存储的文件名是通过文件内容的数学计算得出的。这有一个非常重要的含义：如果一个文件的内容（例如文本文件）发生了一点变化，它的内部名称也会发生变化。简单来说，你在 Git 中不是修改文件，而是创建一个新文件并将其存储在一个不同的位置。Git 对象就是这样：在 Git 仓库中的文件，它们的路径由文件内容决定。 Warning Git 并不是真正的键值存储一些文档，包括优秀的 Pro Git ，将 Git 称为“键值存储”。这并不完全错误，但可能会引起误解。普通的文件系统实际上比 Git 更接近键值存储。因为 Git 是根据数据计算键，所以更准确的说法是，Git 应该被称为“值-值存储”。 Git 使用对象来存储许多内容：首先是它保持版本控制的实际文件——例如源代码。提交也是对象，标签也是。除了少数几个例外（稍后我们会看到！），在 Git 中，几乎所有的内容都是以对象的形式存储的。 Git 存储给定对象的路径是通过计算其内容的 SHA-1 哈希来确定的。更精确地说，Git 将哈希值转换为小写十六进制字符串，并将其拆分为两部分：前两位字符和其余部分。它使用前两位作为目录名，其余部分作为文件名（这是因为大多数文件系统不喜欢在单个目录中存储太多文件，否则会导致系统变慢。Git 的方法创建了 256 个可能的中间目录，从而将每个目录中的平均文件数量减少了 256 倍）。 Note 哈希函数是什么？SHA-1 就是我们所说的“哈希函数”。简单来说，哈希函数是一种单向数学函数：计算一个值的哈希值很容易，但无法反推出哪个值产生了该哈希值。一个非常简单的哈希函数例子是经典的 len（或 strlen）函数，它返回字符串的长度。计算一个字符串的长度非常容易，并且给定一个字符串，它的长度永远不会改变（当然，除非字符串本身改变！），但是仅凭长度是无法恢复原始字符串的。加密哈希函数是同样原理的更复杂版本，且具有额外的特性：计算一个输入值来产生给定哈希值的难度足够大，以至于实际上几乎不可能做到。（比如，要产生一个长度为 12 的字符串 i，你只需要随便输入 12 个字符。但对于像 SHA-1 这样的算法，需要的时间要长得多——足够长，以至于在实际中几乎不可能做到。[^1] [^1]: You may know that collisions have been discovered in SHA-1. Git actually doesn’t use SHA-1 anymore: it uses a hardened variant which is not SHA, but which applies the same hash to every known input but the two PDF files known to collide. 在我们开始实现对象存储系统之前，必须了解它们的确切存储格式。一个对象以一个头部开始，该头部指定其类型：blob、commit、tag 或 tree（稍后会详细讲解）。这个头部后面跟着一个 ASCII 空格（0x20），然后是对象大小的 ASCII 数字，接着是一个空字符（0x00），最后是对象的内容。在 Wyag 的仓库中，一个 commit 对象的前 48 个字节看起来像这样： 12300000000 63 6f 6d 6d 69 74 20 31 30 38 36 00 74 72 65 65 |commit 1086.tree|00000010 20 32 39 66 66 31 36 63 39 63 31 34 65 32 36 35 | 29ff16c9c14e265|00000020 32 62 32 32 66 38 62 37 38 62 62 30 38 61 35 61 |2b22f8b78bb08a5a| 在第一行中，我们可以看到类型头部，一个空格（0x20），大小的 ASCII 表示（1086）和 null 分隔符 0x00。第一行的最后四个字节是该对象内容的开头，单词“tree”——我们稍后会在讨论 commit 时进一步讲解。 这些对象（包括头部和内容）都是使用 zlib 压缩存储的。 4.2. A generic object object对象可以有多种类型，但它们都共享相同的存储/检索机制以及相同的通用头部格式。在深入了解各种类型的对象之前，我们需要对这些共同特性进行抽象。最简单的方法是创建一个通用的 GitObject 类，具有两个未实现的方法：serialize() 和 deserialize()，并提供一个默认的 init() 方法，用于在需要时创建一个新的空对象（抱歉，Python 用户，这不是非常好的设计，但它可能比使用超级构造器更容易理解）。我们的 __init__ 方法要么从提供的数据中加载对象，要么调用子类提供的 init() 方法来创建一个新的空对象。 稍后，我们将对子类化这个通用类，为每种对象格式实际实现这些函数。 1234567891011121314151617181920212223class GitObject (object): def __init__(self, data=None): if data != None: self.deserialize(data) else: self.init() def serialize(self, repo): &quot;&quot;&quot;This function MUST be implemented by subclasses.It must read the object's contents from self.data, a byte string, anddo whatever it takes to convert it into a meaningful representation.What exactly that means depend on each subclass. &quot;&quot;&quot; raise Exception(&quot;Unimplemented!&quot;) def deserialize(self, data): raise Exception(&quot;Unimplemented!&quot;) def init(self): pass # Just do nothing. This is a reasonable default! 4.3. Reading objects为了读取一个对象，我们需要知道它的 SHA-1 哈希值。然后，我们根据这个哈希值计算其路径（按照之前解释的公式：前两个字符，然后是目录分隔符“/”，然后是剩余部分），并在 gitdir 的“objects”目录中查找它。也就是说，e673d1b7eaa0aa01b5bc2442d570a765bdaae751 的路径是 .git/objects/e6/73d1b7eaa0aa01b5bc2442d570a765bdaae751。 接着，我们将该文件作为二进制文件读取，并使用 zlib 解压它。 从解压后的数据中，我们提取两个头部组件：对象类型和大小。通过类型，我们确定实际使用的类。我们将大小转换为 Python 整数，并进行匹配检查。 完成所有步骤后，我们只需调用该对象格式的正确构造函数。 123456789101112131415161718192021222324252627282930313233def object_read(repo, sha): &quot;&quot;&quot;Read object sha from Git repository repo. Return a GitObject whose exact type depends on the object.&quot;&quot;&quot; path = repo_file(repo, &quot;objects&quot;, sha[0:2], sha[2:]) if not os.path.isfile(path): return None with open (path, &quot;rb&quot;) as f: raw = zlib.decompress(f.read()) # Read object type x = raw.find(b' ') fmt = raw[0:x] # Read and validate object size y = raw.find(b'\\x00', x) size = int(raw[x:y].decode(&quot;ascii&quot;)) if size != len(raw)-y-1: raise Exception(f&quot;Malformed object {sha}: bad length&quot;) # Pick constructor match fmt: case b'commit' : c=GitCommit case b'tree' : c=GitTree case b'tag' : c=GitTag case b'blob' : c=GitBlob case _: raise Exception(f&quot;Unknown type {fmt.decode(&quot;ascii&quot;)} for object {sha}&quot;) # Call constructor and return object return c(raw[y+1:]) 4.4. Writing objects写入对象的过程实际上是读取过程的逆操作：我们先计算哈希值，接着添加头部，然后使用 zlib 压缩所有数据，并将结果写入正确的位置。这里不需要太多解释，值得注意的是哈希值是在添加头部后计算的（因此它是对象本身的哈希值，包括未压缩的头部，而不仅仅是内容的哈希）。 1234567891011121314151617def object_write(obj, repo=None): # Serialize object data data = obj.serialize() # Add header result = obj.fmt + b' ' + str(len(data)).encode() + b'\\x00' + data # Compute hash sha = hashlib.sha1(result).hexdigest() if repo: # Compute path path=repo_file(repo, &quot;objects&quot;, sha[0:2], sha[2:], mkdir=True) if not os.path.exists(path): with open(path, 'wb') as f: # Compress and write f.write(zlib.compress(result)) return sha 4.5. Working with blobs正如之前所说，类型头可以是四种之一：blob、commit、tag 和 tree — 因此 Git 有四种对象类型。 Blobs 是这四种类型中最简单的，因为它们没有实际的格式。Blobs 是用户数据：你放入 Git 中的每个文件（如 main.c、logo.png、README.md）的内容都作为一个 Blob 存储。这使得它们易于操作，因为除了基本的对象存储机制外，它们没有实际的语法或约束：它们只是未指定的数据。因此，创建一个 GitBlob 类是微不足道的，serialize 和 deserialize 函数只需存储和返回它们的输入，不做任何修改。 12345678class GitBlob(GitObject): fmt=b'blob' def serialize(self): return self.blobdata def deserialize(self, data): self.blobdata = data 4.6. The cat-file command我们现在可以创建 wyag cat-file 了。git cat-file 只是将对象的原始内容打印到标准输出，解压缩并去除 Git 头部信息。在 Wyag 的源代码仓库中，运行：git cat-file blob e0695f14a412c29e252c998c81de1dde59658e4a将会显示某个 README 文件的版本内容。 我们的简化版本只需要两个位置参数：一个类型和一个对象标识符。 1wyag cat-file TYPE OBJECT 子解析器非常简单： 1234567891011argsp = argsubparsers.add_parser(&quot;cat-file&quot;, help=&quot;Provide content of repository objects&quot;)argsp.add_argument(&quot;type&quot;, metavar=&quot;type&quot;, choices=[&quot;blob&quot;, &quot;commit&quot;, &quot;tag&quot;, &quot;tree&quot;], help=&quot;Specify the type&quot;)argsp.add_argument(&quot;object&quot;, metavar=&quot;object&quot;, help=&quot;The object to display&quot;) 我们可以实现这些函数，它们只是调用我们之前编写的现有代码： 1234567def cmd_cat_file(args): repo = repo_find() cat_file(repo, args.object, fmt=args.type.encode())def cat_file(repo, obj, fmt=None): obj = object_read(repo, object_find(repo, obj, fmt=fmt)) sys.stdout.buffer.write(obj.serialize()) 这个函数调用了一个尚未介绍的 object_find 函数。目前，它只是返回其中一个参数，像这样： 12def object_find(repo, name, fmt=None, follow=True): return name 之所以需要这个奇怪的小函数，是因为 Git 有许多方式来引用对象：完整哈希、短哈希、标签……object_find() 将作为我们的名称解析函数。我们稍后才会实现它，因此这里只是一个临时占位符。这意味着在实现真正的 object_find() 之前，我们只能通过完整哈希来引用对象。 4.7. The hash-object command我们希望能够将自己的数据存入仓库中。hash-object 基本上是 cat-file 的反向操作：它读取一个文件，将其计算为对象的哈希值，并在仓库中存储该对象（如果传递了 -w 标志），或者只是打印其哈希值。 wyag hash-object 的语法是 git hash-object 的简化版本： 1wyag hash-object [-w] [-t TYPE] FILE 这转换为： 123456789101112131415161718argsp = argsubparsers.add_parser( &quot;hash-object&quot;, help=&quot;Compute object ID and optionally creates a blob from a file&quot;)argsp.add_argument(&quot;-t&quot;, metavar=&quot;type&quot;, dest=&quot;type&quot;, choices=[&quot;blob&quot;, &quot;commit&quot;, &quot;tag&quot;, &quot;tree&quot;], default=&quot;blob&quot;, help=&quot;Specify the type&quot;)argsp.add_argument(&quot;-w&quot;, dest=&quot;write&quot;, action=&quot;store_true&quot;, help=&quot;Actually write the object into the database&quot;)argsp.add_argument(&quot;path&quot;, help=&quot;Read object from &lt;file&gt;&quot;) 实际实现非常简单。像往常一样，我们创建一个小的桥接函数： 123456789def cmd_hash_object(args): if args.write: repo = repo_find() else: repo = None with open(args.path, &quot;rb&quot;) as fd: sha = object_hash(fd, args.type.encode(), repo) print(sha) 实际实现也很简单。repo 参数是可选的，如果它是 None，对象就不会被写入（这一点在上面的 object_write() 中处理）： 12345678910111213def object_hash(fd, fmt, repo=None): &quot;&quot;&quot; Hash object, writing it to repo if provided.&quot;&quot;&quot; data = fd.read() # Choose constructor according to fmt argument match fmt: case b'commit' : obj=GitCommit(data) case b'tree' : obj=GitTree(data) case b'tag' : obj=GitTag(data) case b'blob' : obj=GitBlob(data) case _: raise Exception(f&quot;Unknown type {fmt}!&quot;) return object_write(obj, repo) 4.8. Aside: what about packfiles?我们刚刚实现的被称为“松散对象”（loose objects）。Git 还有另一种对象存储机制，称为 packfiles。Packfiles 比松散对象更高效，但也更复杂。简单来说，packfile 是松散对象的一个集合（类似于 tar 文件），但其中一些对象以增量（delta）的形式存储，即作为另一个对象的变体。Packfiles 过于复杂，wyag 无法支持它们。 Packfile 存储在 .git/objects/pack/ 目录下，扩展名为 .pack，并附带一个同名的索引文件，扩展名为 .idx。如果你想将 packfile 转换为松散对象格式（例如，在现有的仓库上使用 wyag），可以使用以下方法： 首先，将 packfile 移出 gitdir（仅仅复制是无效的）： 1mv .git/objects/pack/pack-d9ef004d4ca729287f12aaaacf36fee39baa7c9d.pack . 你可以忽略 .idx 文件。然后，在工作区中，只需使用 cat 命令输出 packfile 并通过管道传递给 git unpack-objects： 1cat pack-d9ef004d4ca729287f12aaaacf36fee39baa7c9d.pack | git unpack-objects 5. Reading commit history: log5.1. Parsing commits现在我们已经可以读取和写入对象，我们应该考虑提交对象。一个提交对象（未压缩且不含头部）看起来像这样： 12345678910111213141516171819202122tree 29ff16c9c14e2652b22f8b78bb08a5a07930c147parent 206941306e8a8af65b66eaaaea388a7ae24d49a0author Thibault Polge &lt;thibault@thb.lt&gt; 1527025023 +0200committer Thibault Polge &lt;thibault@thb.lt&gt; 1527025044 +0200gpgsig -----BEGIN PGP SIGNATURE----- iQIzBAABCAAdFiEExwXquOM8bWb4Q2zVGxM2FxoLkGQFAlsEjZQACgkQGxM2FxoL kGQdcBAAqPP+ln4nGDd2gETXjvOpOxLzIMEw4A9gU6CzWzm+oB8mEIKyaH0UFIPh rNUZ1j7/ZGFNeBDtT55LPdPIQw4KKlcf6kC8MPWP3qSu3xHqx12C5zyai2duFZUU wqOt9iCFCscFQYqKs3xsHI+ncQb+PGjVZA8+jPw7nrPIkeSXQV2aZb1E68wa2YIL 3eYgTUKz34cB6tAq9YwHnZpyPx8UJCZGkshpJmgtZ3mCbtQaO17LoihnqPn4UOMr V75R/7FjSuPLS8NaZF4wfi52btXMSxO/u7GuoJkzJscP3p4qtwe6Rl9dc1XC8P7k NIbGZ5Yg5cEPcfmhgXFOhQZkD0yxcJqBUcoFpnp2vu5XJl2E5I/quIyVxUXi6O6c /obspcvace4wy8uO0bdVhc4nJ+Rla4InVSJaUaBeiHTW8kReSFYyMmDCzLjGIu1q doU61OM3Zv1ptsLu3gUE6GU27iWYj2RWN3e3HE4Sbd89IFwLXNdSuM0ifDLZk7AQ WBhRhipCCgZhkj9g2NEk7jRVslti1NdN5zoQLaJNqSwO1MtxTmJ15Ksk3QP6kfLB Q52UWybBzpaP9HEd4XnR+HuQ4k2K0ns2KgNImsNvIyFwbpMUyUWLMPimaV1DWUXo 5SBjDB/V/W2JBFR+XKHFJeFwYhj7DD/ocsGr4ZMx/lgc8rjIBkI= =lgTX -----END PGP SIGNATURE-----Create first draft 该格式是 RFC 2822 规定的邮件消息的简化版本。它以一系列键值对开头，使用空格作为键和值的分隔符，并以提交消息结束，提交消息可能会跨多行。值可能会延续到多行，后续行以空格开头，解析器必须忽略这些空格（例如上面的 gpgsig 字段，它跨越了 16 行）。 让我们来看一下这些字段的含义： tree：指向一个树（tree）对象，我们将在接下来介绍它。树对象将 blob ID 映射到文件系统位置，并描述工作区的状态。简单来说，它代表了提交的实际内容：文件内容以及它们的位置。 parent：指向该提交的父提交。该字段可以重复，例如合并提交（merge commit）通常有多个父提交。但它也可能不存在，例如一个仓库中的第一个提交显然没有父提交。 author 和 committer：它们是分开的，因为提交的作者不一定是最终提交的人（对于 GitHub 用户来说，这可能并不明显，但许多项目是通过电子邮件进行 Git 操作的）。 gpgsig：该对象的 PGP 签名。 我们将从编写一个简单的解析器开始，代码很直观。我们即将创建的函数名 kvlm_parse() 可能会让人困惑：它不叫 commit_parse()，因为 tag 对象使用的是完全相同的格式，因此我们会将它用于这两种对象类型。我使用 KVLM 来表示“Key-Value List with Message”（键值列表加消息）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354def kvlm_parse(raw, start=0, dct=None): if not dct: dct = dict() # You CANNOT declare the argument as dct=dict() or all call to # the functions will endlessly grow the same dict. # This function is recursive: it reads a key/value pair, then call # itself back with the new position. So we first need to know # where we are: at a keyword, or already in the messageQ # We search for the next space and the next newline. spc = raw.find(b' ', start) nl = raw.find(b'\\n', start) # If space appears before newline, we have a keyword. Otherwise, # it's the final message, which we just read to the end of the file. # Base case # ========= # If newline appears first (or there's no space at all, in which # case find returns -1), we assume a blank line. A blank line # means the remainder of the data is the message. We store it in # the dictionary, with None as the key, and return. if (spc &lt; 0) or (nl &lt; spc): assert nl == start dct[None] = raw[start+1:] return dct # Recursive case # ============== # we read a key-value pair and recurse for the next. key = raw[start:spc] # Find the end of the value. Continuation lines begin with a # space, so we loop until we find a &quot;\\n&quot; not followed by a space. end = start while True: end = raw.find(b'\\n', end+1) if raw[end+1] != ord(' '): break # Grab the value # Also, drop the leading space on continuation lines value = raw[spc+1:end].replace(b'\\n ', b'\\n') # Don't overwrite existing data contents if key in dct: if type(dct[key]) == list: dct[key].append(value) else: dct[key] = [ dct[key], value ] else: dct[key]=value return kvlm_parse(raw, start=end+1, dct=dct) Note 对象标识规则我们使用 字典（HashMap） 来存储键/值关联，但我们依赖于 Python 字典的一个特性：它会保留插入顺序。这意味着当我们将对象写回时，我们会按字典中字段的添加顺序进行迭代，并以完全相同的顺序输出字段。这一点很重要，因为 Git 对对象标识有两个严格的规则：1. 相同的名称始终引用相同的对象我们之前已经看到过这个规则，它是 Git 计算对象名称的方法的直接结果 —— 对象的名称是其内容的哈希值。2. 相同的对象始终具有相同的名称这条规则稍微复杂一些：它意味着 不应该存在两个等效但名称不同的对象。例如，在 Git 中，如果我们更改提交对象中字段的顺序（比如将 tree 字段放在 parent 之后），那么提交对象的 SHA-1 哈希值 也会改变，从而创建出两个 等效但哈希不同 的提交对象。例如，在比较 tree 对象 时，Git 会假设 哈希不同的两个 tree 是不同的，这就是为什么在存储 tree 对象时，我们必须确保 其中的元素按正确顺序排序，以防止生成 等效但哈希不同的 tree。 我们还需要写类似的对象，因此让我们向工具包中添加一个 kvlm_serialize() 函数。这非常简单：我们先写所有的字段，然后是一个换行符，接着是消息内容，最后再是一个换行符。 12345678910111213141516171819def kvlm_serialize(kvlm): ret = b'' # Output fields for k in kvlm.keys(): # Skip the message itself if k == None: continue val = kvlm[k] # Normalize to a list if type(val) != list: val = [ val ] for v in val: ret += k + b' ' + (v.replace(b'\\n', b'\\n ')) + b'\\n' # Append message ret += b'\\n' + kvlm[None] return ret 5.2. The Commit object现在我们有了解析器，我们可以创建 GitCommit 类： 1234567891011class GitCommit(GitObject): fmt=b'commit' def deserialize(self, data): self.kvlm = kvlm_parse(data) def serialize(self): return kvlm_serialize(self.kvlm) def init(self): self.kvlm = dict() 5.3. The log command我们将实现一个比 Git 提供的版本简单得多的日志功能。最重要的是，我们不会处理日志的表示。相反，我们将输出 Graphviz 数据，让用户使用 dot 来渲染实际的日志。（如果你不知道如何使用 Graphviz，只需将原始输出粘贴到这个网站中。如果该链接无法访问，可以在你喜欢的搜索引擎中搜索“graphviz online”） 12345argsp = argsubparsers.add_parser(&quot;log&quot;, help=&quot;Display history of a given commit.&quot;)argsp.add_argument(&quot;commit&quot;, default=&quot;HEAD&quot;, nargs=&quot;?&quot;, help=&quot;Commit to start at.&quot;) 1234567891011121314151617181920212223242526272829303132333435363738def cmd_log(args): repo = repo_find() print(&quot;digraph wyaglog{&quot;) print(&quot; node[shape=rect]&quot;) log_graphviz(repo, object_find(repo, args.commit), set()) print(&quot;}&quot;)def log_graphviz(repo, sha, seen): if sha in seen: return seen.add(sha) commit = object_read(repo, sha) message = commit.kvlm[None].decode(&quot;utf8&quot;).strip() message = message.replace(&quot;\\\\&quot;, &quot;\\\\\\\\&quot;) message = message.replace(&quot;\\&quot;&quot;, &quot;\\\\\\&quot;&quot;) if &quot;\\n&quot; in message: # Keep only the first line message = message[:message.index(&quot;\\n&quot;)] print(f&quot; c_{sha} [label=\\&quot;{sha[0:7]}: {message}\\&quot;]&quot;) assert commit.fmt==b'commit' if not b'parent' in commit.kvlm.keys(): # Base case: the initial commit. return parents = commit.kvlm[b'parent'] if type(parents) != list: parents = [ parents ] for p in parents: p = p.decode(&quot;ascii&quot;) print (f&quot; c_{sha} -&gt; c_{p};&quot;) log_graphviz(repo, p, seen) 你现在可以像这样使用我们的 log 命令： 12wyag log e03158242ecab460f31b0d6ae1642880577ccbe8 &gt; log.dotdot -O -Tpdf log.dot 5.4. Anatomy of a commit你现在可能注意到了一些事情。 首先也是最重要的一点，我们一直在处理提交，浏览和遍历提交对象，构建提交历史的图形，而从未触及工作树中的任何文件或 Blob。我们做了很多关于提交的事情，但没有考虑它们的内容。这一点很重要：工作树的内容只是提交的一部分。但一个提交由它所包含的一切组成：它的内容、它的作者，还有它的父提交。如果你记得提交的 ID（SHA-1 哈希）是从整个提交对象计算出来的，你就会明白为什么提交是不可变的：如果你更改了作者、父提交或单个文件，你实际上创建了一个新的、不同的对象。每一个提交都与其所在的位置及其与整个仓库的关系绑定，直到第一个提交。换句话说，一个给定的提交 ID 不仅标识了一些文件内容，它还将提交与其完整的历史和整个仓库绑定在一起。 还值得注意的是，从提交的角度来看，时间似乎是倒流的：我们通常是从项目的谦逊起步开始考虑历史，最初可能是作为一种消磨时间的活动，开始时只有几行代码，一些初步的提交，随后逐渐发展到现在的状态（成千上万行代码，几十个贡献者等等）。但是每个提交完全不知未来的情况，它只与过去相连接。提交有“记忆”，但没有预感。 那么，是什么构成了一个提交呢？总结一下： 一个树对象，即工作树的内容，文件和目录； 零个、一个或多个父提交； 一个作者身份（姓名和电子邮件），以及一个时间戳； 一个提交者身份（姓名和电子邮件），以及一个时间戳； 一个可选的 PGP 签名； 一条消息； 所有这些内容哈希在一起，生成一个唯一的 SHA-1 标识符。 Note 等一下，这是否意味着 Git 是区块链？因为加密货币的原因，区块链现在非常火。确实，在某种程度上，Git 可以被视为一个区块链：它是一系列由加密手段连接在一起的区块（提交），以确保每一个元素都与整个历史关联起来。不过，不必太认真地对比这两者：我们不需要 GitCoin，真的。 6. Reading commit data: checkout虽然提交包含了比文件和目录更丰富的信息，但这并不意味着它们就很有用。现在可能是时候开始实现树对象了，这样我们才能将提交检出到工作树中。 6.1. What’s in a tree?非正式地说，树描述了工作树的内容，也就是说，它将 blobs 与路径关联起来。它是由三元组组成的数组，每个三元组包含一个文件模式、一个路径（相对于工作树）和一个 SHA-1。一个典型的树内容可能如下所示： Mode SHA-1 Path 100644 894a44cc066a027465cd26d634948d56d13af9af .gitignore 100644 94a9ed024d3859793618152ea559a168bbcbb5e2 LICENSE 100644 bab489c4f4600a38ce6dbfd652b90383a4aa3e45 README.md 100644 6d208e47659a2a10f5f8640e0155d9276a2130a9 src 040000 e7445b03aea61ec801b20d6ab62f076208b7d097 tests 040000 d5ec863f17f3a2e92aa8f6b66ac18f7b09fd1b38 main.c 模式只是文件的模式，路径是其位置。SHA-1 引用的是 blob 或另一个树对象。如果是 blob，路径是文件；如果是树，它是目录。为了在文件系统中实例化这棵树，我们将从加载与第一个路径（.gitignore）相关的对象开始，并检查它的类型。由于它是一个 blob，我们将创建一个名为 .gitignore 的文件，并填充该 blob 的内容；LICENSE 和 README.md 也按同样的方法处理。但是与 src 相关联的对象不是一个 blob，而是另一棵树：我们将创建目录 src，并在该目录中对新的树重复相同的操作。 Warning 路径是一个单一的文件系统条目路径准确地标识一个文件或目录。不是两个，也不是三个。如果你有五级嵌套的目录，即使其中四个除了下一个目录外都是空的，你也需要五个树对象，递归地相互引用。你不能通过将一个完整的路径放在单个树条目中来走捷径，比如 dir1/dir2/dir3/dir4/dir5。 6.2. Parsing trees与标签和提交不同，树对象是二进制对象，但它们的格式实际上非常简单。一个树是由以下格式的记录连接而成： 1[mode] space [path] 0x00 [sha-1] [mode] 是最多六个字节，是文件模式的八进制表示，以 ASCII 存储。例如，100644 使用字节值 49（ASCII “1”），48（ASCII “0”），48，54，52，54 来编码。前两位数字编码文件类型（文件、目录、符号链接或子模块），最后四位是权限。 它后面跟着 0x20，一个 ASCII 空格； 接下来是以 null 终止的（0x00）路径； 然后是对象的 SHA-1，以二进制编码，长度为 20 字节。 解析器将非常简单。首先，为单个记录（叶子，单个路径）创建一个小的对象封装器： 12345class GitTreeLeaf (object): def __init__(self, mode, path, sha): self.mode = mode self.path = path self.sha = sha 因为树对象只是相同基本数据结构的重复，我们将解析器写成两个函数。首先，编写一个解析单个记录的函数，返回解析的数据和它在输入数据中到达的位置： 12345678910111213141516171819202122def tree_parse_one(raw, start=0): # Find the space terminator of the mode x = raw.find(b' ', start) assert x-start == 5 or x-start==6 # Read the mode mode = raw[start:x] if len(mode) == 5: # Normalize to six bytes. mode = b&quot;0&quot; + mode # Find the NULL terminator of the path y = raw.find(b'\\x00', x) # and read the path path = raw[x+1:y] # Read the SHA… raw_sha = int.from_bytes(raw[y+1:y+21], &quot;big&quot;) # and convert it into an hex string, padded to 40 chars # with zeros if needed. sha = format(raw_sha, &quot;040x&quot;) return y+21, GitTreeLeaf(mode, path.decode(&quot;utf8&quot;), sha) 然后是“真正的”解析器，它只是循环调用前一个解析器，直到输入数据耗尽。 123456789def tree_parse(raw): pos = 0 max = len(raw) ret = list() while pos &lt; max: pos, data = tree_parse_one(raw, pos) ret.append(data) return ret 最终，我们需要一个序列化器来将树对象写回去。由于我们可能已经添加或修改了条目，因此需要对它们重新排序。保持一致的排序很重要，因为我们需要遵守 Git 的身份规则，该规则规定不能有两个等效的对象具有不同的哈希值——但是如果相同内容的树对象排序不同，它们仍然是等效的（描述相同的目录结构），但在数值上是不同的（不同的 SHA-1 标识符）。不正确排序的树对象是无效的，但 Git 并不会强制执行这一点。我在编写 wyag 时意外创建了一些无效的树对象，结果导致 Git 状态显示奇怪的错误（具体来说，git status 会报告一个实际上是干净的工作区被完全修改）。我们不希望发生这种情况。 排序函数非常简单，但有一个意想不到的细节。条目是按名称按字母顺序排序的，但目录（即树对象的条目）会在末尾添加一个 / 进行排序。这一点很重要，因为这意味着如果 whatever 是一个普通文件，它将在 whatever.c 之前排序，但如果 whatever 是一个目录，它将作为 whatever/ 排序在后。（我不确定 Git 为什么这样做。如果你感兴趣，可以查看 Git 源码中 tree.c 文件里的 base_name_compare 函数。） 12345678910# Notice this isn't a comparison function, but a conversion function.# Python's default sort doesn't accept a custom comparison function,# like in most languages, but a `key` arguments that returns a new# value, which is compared using the default rules. So we just return# the leaf name, with an extra / if it's a directory.def tree_leaf_sort_key(leaf): if leaf.mode.startswith(b&quot;10&quot;): return leaf.path else: return leaf.path + &quot;/&quot; 然后是序列化器本身。这部分非常简单：我们使用新创建的转换函数对项进行排序，然后按顺序写入。 1234567891011def tree_serialize(obj): obj.items.sort(key=tree_leaf_sort_key) ret = b'' for i in obj.items: ret += i.mode ret += b' ' ret += i.path.encode(&quot;utf8&quot;) ret += b'\\x00' sha = int(i.sha, 16) ret += sha.to_bytes(20, byteorder=&quot;big&quot;) return ret 现在，我们只需要将所有内容组合到一个类中即可。 1234567891011class GitTree(GitObject): fmt=b'tree' def deserialize(self, data): self.items = tree_parse(data) def serialize(self): return tree_serialize(self) def init(self): self.items = list() 6.3. Showing trees: ls-tree既然如此，我们顺便给 wyag 添加 ls-tree 命令吧。这么简单的功能，没有理由不加。git ls-tree [-r] TREE 只是打印树的内容，带 -r 标志时会递归打印。在递归模式下，它不会显示子树，而是仅显示最终对象及其完整路径。 123456789101112131415161718192021222324252627282930313233argsp = argsubparsers.add_parser(&quot;ls-tree&quot;, help=&quot;Pretty-print a tree object.&quot;)argsp.add_argument(&quot;-r&quot;, dest=&quot;recursive&quot;, action=&quot;store_true&quot;, help=&quot;Recurse into sub-trees&quot;)argsp.add_argument(&quot;tree&quot;, help=&quot;A tree-ish object.&quot;)def cmd_ls_tree(args): repo = repo_find() ls_tree(repo, args.tree, args.recursive)def ls_tree(repo, ref, recursive=None, prefix=&quot;&quot;): sha = object_find(repo, ref, fmt=b&quot;tree&quot;) obj = object_read(repo, sha) for item in obj.items: if len(item.mode) == 5: type = item.mode[0:1] else: type = item.mode[0:2] match type: # Determine the type. case b'04': type = &quot;tree&quot; case b'10': type = &quot;blob&quot; # A regular file. case b'12': type = &quot;blob&quot; # A symlink. Blob contents is link target. case b'16': type = &quot;commit&quot; # A submodule case _: raise Exception(f&quot;Weird tree leaf mode {item.mode}&quot;) if not (recursive and type=='tree'): # This is a leaf print(f&quot;{'0' * (6 - len(item.mode)) + item.mode.decode(&quot;ascii&quot;)} {type} {item.sha}\\t{os.path.join(prefix, item.path)}&quot;) else: # This is a branch, recurse ls_tree(repo, item.sha, recursive, os.path.join(prefix, item.path)) 6.4. The checkout commandgit checkout 只是将某个提交实例化到工作区。为了让我们的实现清晰易懂，我们将对实际的 git checkout 命令进行简化，同时添加一些安全措施。我们的 checkout 版本将按以下方式工作： 它需要两个参数：一个提交（commit）和一个目录（directory）。Git 的 checkout 命令只需要一个提交。 它会在指定目录中实例化该提交的树，但仅当该目录为空时才进行操作。Git 具有许多安全机制来防止数据丢失，而在 wyag 中尝试完全复现这些机制既复杂又不安全。由于 wyag 的目的是演示 Git，而不是提供完整的实现，这一限制是可以接受的。 让我们开始实现。如往常一样，我们需要一个子解析器（subparser）： 1234567argsp = argsubparsers.add_parser(&quot;checkout&quot;, help=&quot;Checkout a commit inside of a directory.&quot;)argsp.add_argument(&quot;commit&quot;, help=&quot;The commit or tree to checkout.&quot;)argsp.add_argument(&quot;path&quot;, help=&quot;The EMPTY directory to checkout on.&quot;) 一个包装函数（wrapper function）： 12345678910111213141516171819def cmd_checkout(args): repo = repo_find() obj = object_read(repo, object_find(repo, args.commit)) # If the object is a commit, we grab its tree if obj.fmt == b'commit': obj = object_read(repo, obj.kvlm[b'tree'].decode(&quot;ascii&quot;)) # Verify that path is an empty directory if os.path.exists(args.path): if not os.path.isdir(args.path): raise Exception(f&quot;Not a directory {args.path}!&quot;) if os.listdir(args.path): raise Exception(f&quot;Not empty {args.path}!&quot;) else: os.makedirs(args.path) tree_checkout(repo, obj, os.path.realpath(args.path)) 以及一个执行实际工作的函数： 123456789101112def tree_checkout(repo, tree, path): for item in tree.items: obj = object_read(repo, item.sha) dest = os.path.join(path, item.path) if obj.fmt == b'tree': os.mkdir(dest) tree_checkout(repo, obj, dest) elif obj.fmt == b'blob': # @TODO Support symlinks (identified by mode 12****) with open(dest, 'wb') as f: f.write(obj.blobdata) 7. Refs, tags and branches7.1. What a ref is, and the show-ref command到目前为止，我们唯一可以引用对象的方式是使用完整的十六进制标识符。然而，在 git 中，我们实际上很少看到这些标识符，除了在讨论特定提交时。通常，我们会使用 HEAD，或者某个名为 main 或 feature/more-bombs 的分支名称等。这是通过一个简单的机制——引用（references）来处理的。 Git 引用（refs）可能是 git 存储的最简单的内容。它们位于 .git/refs 的子目录中，并且是包含对象哈希值的文本文件，使用 ASCII 编码。它们实际上就是这样简单： 16071c08bcb4757d8c89a30d9755d2466cef8c1de 引用（Refs）也可以间接地引用对象，即引用另一个引用，在这种情况下，它们看起来像这样： 1ref: refs/remotes/origin/master Note 直接和间接引用从现在开始，我将把形式为 ref: path/to/other/ref 的引用称为间接引用，而把包含 SHA-1 对象 ID 的引用称为直接引用。 这一部分将描述引用（refs）的用途。目前，最重要的是： 它们是文本文件，位于 .git/refs 目录结构中； 它们保存一个对象的 SHA-1 标识符，或者引用另一个引用，最终指向一个 SHA-1（没有循环！） 为了操作引用，我们首先需要一个简单的递归解析器，它将接受一个引用名称，跟踪可能存在的递归引用（即以 ref: 开头的引用，如上所示），并返回最终的 SHA-1 标识符： 123456789101112131415161718def ref_resolve(repo, ref): path = repo_file(repo, ref) # Sometimes, an indirect reference may be broken. This is normal # in one specific case: we're looking for HEAD on a new repository # with no commits. In that case, .git/HEAD points to &quot;ref: # refs/heads/main&quot;, but .git/refs/heads/main doesn't exist yet # (since there's no commit for it to refer to). if not os.path.isfile(path): return None with open(path, 'r') as fp: data = fp.read()[:-1] # Drop final \\n ^^^^^ if data.startswith(&quot;ref: &quot;): return ref_resolve(repo, data[5:]) else: return data 让我们创建两个小函数，并实现 show-refs 命令——它仅列出仓库中的所有引用。首先，创建一个简单的递归函数来收集引用，并将它们作为字典返回： 1234567891011121314def ref_list(repo, path=None): if not path: path = repo_dir(repo, &quot;refs&quot;) ret = dict() # Git shows refs sorted. To do the same, we sort the output of # listdir for f in sorted(os.listdir(path)): can = os.path.join(path, f) if os.path.isdir(can): ret[f] = ref_list(repo, can) else: ret[f] = ref_resolve(repo, can) return ret 以及，像往常一样，一个子解析器，一个桥接函数和一个（递归）工作函数： 1234567891011121314151617argsp = argsubparsers.add_parser(&quot;show-ref&quot;, help=&quot;List references.&quot;)def cmd_show_ref(args): repo = repo_find() refs = ref_list(repo) show_ref(repo, refs, prefix=&quot;refs&quot;)def show_ref(repo, refs, with_hash=True, prefix=&quot;&quot;): if prefix: prefix = prefix + '/' for k, v in refs.items(): if type(v) == str and with_hash: print (f&quot;{v} {prefix}{k}&quot;) elif type(v) == str: print (f&quot;{prefix}{k}&quot;) else: show_ref(repo, v, with_hash=with_hash, prefix=f&quot;{prefix}{k}&quot;) 7.2. Tags as referencesrefs的最简单用途是标签。标签只是一个用户定义的对象名称，通常是一个提交。标签的一个非常常见的用途是标识软件版本：例如，您刚刚合并了程序的版本12.78.52的最后一个提交，所以您最近的提交（我们称之为6071c08）就是您的版本12.78.52。为了使这种关联显式化，您只需要这样做： 12git tag v12.78.52 6071c08# the object hash ^here^^ is optional and defaults to HEAD. 这会创建一个新的标签，叫做 v12.78.52，指向 6071c08。标签就像别名：标签为现有对象引入了一种新的引用方式。标签创建之后，v12.78.52 这个名称就指向了 6071c08。例如，下面这两个命令现在是完全等价的： 12git checkout v12.78.52git checkout 6071c08 Note 版本是标签的一个常见用途，但像 Git 中几乎所有东西一样，标签没有预定义的语义：它们的意义由你决定，并且可以指向你想指向的任何对象，甚至可以为 blobs 打标签！ 7.3. Lightweight tags and tag objects, and parsing the latter你可能已经猜到了，标签实际上就是 refs。它们位于 .git/refs/tags/ 层级。唯一需要注意的地方是，它们有两种类型：轻量标签和标签对象。 “轻量级”标签只是指向提交、树或 Blob 的常规 refs。 标签对象是指向类型为 tag 的对象的常规 refs。与轻量标签不同，标签对象具有作者、日期、可选的 PGP 签名和可选的注释。它们的格式与提交对象相同。 我们甚至不需要实现标签对象，可以重用 GitCommit 类，只需更改 fmt 字段即可。 12class GitTag(GitCommit): fmt = b'tag' 现在我们支持标签了。 7.4. The tag command让我们添加 tag 命令。在 Git 中，它做两件事：创建一个新的标签或列出现有标签（默认情况下）。所以你可以用以下方式调用它： 12345git tag # List all tagsgit tag NAME [OBJECT] # create a new *lightweight* tag NAME, pointing # at HEAD (default) or OBJECTgit tag -a NAME [OBJECT] # create a new tag *object* NAME, pointing at # HEAD (default) or OBJECT 这在 argparse 中的实现如下。请注意，我们忽略了 --list 和 [-a] name [object] 之间的互斥关系，因为对于 argparse 来说，这看起来太复杂了。 1234567891011121314151617argsp = argsubparsers.add_parser( &quot;tag&quot;, help=&quot;List and create tags&quot;)argsp.add_argument(&quot;-a&quot;, action=&quot;store_true&quot;, dest=&quot;create_tag_object&quot;, help=&quot;Whether to create a tag object&quot;)argsp.add_argument(&quot;name&quot;, nargs=&quot;?&quot;, help=&quot;The new tag's name&quot;)argsp.add_argument(&quot;object&quot;, default=&quot;HEAD&quot;, nargs=&quot;?&quot;, help=&quot;The object the new tag will point to&quot;) cmd_tag 函数将根据是否提供了 name 来分派行为（列出或创建）。 1234567891011def cmd_tag(args): repo = repo_find() if args.name: tag_create(repo, args.name, args.object, create_tag_object = args.create_tag_object) else: refs = ref_list(repo) show_ref(repo, refs[&quot;tags&quot;], with_hash=False) 我们只需要一个函数来实际创建标签： 1234567891011121314151617181920212223242526def tag_create(repo, name, ref, create_tag_object=False): # get the GitObject from the object reference sha = object_find(repo, ref) if create_tag_object: # create tag object (commit) tag = GitTag() tag.kvlm = dict() tag.kvlm[b'object'] = sha.encode() tag.kvlm[b'type'] = b'commit' tag.kvlm[b'tag'] = name.encode() # Feel free to let the user give their name! # Notice you can fix this after commit, read on! tag.kvlm[b'tagger'] = b'Wyag &lt;wyag@example.com&gt;' # …and a tag message! tag.kvlm[None] = b&quot;A tag generated by wyag, which won't let you customize the message!\\n&quot; tag_sha = object_write(tag, repo) # create reference ref_create(repo, &quot;tags/&quot; + name, tag_sha) else: # create lightweight tag (ref) ref_create(repo, &quot;tags/&quot; + name, sha)def ref_create(repo, ref_name, sha): with open(repo_file(repo, &quot;refs/&quot; + ref_name), 'w') as fp: fp.write(sha + &quot;\\n&quot;) 7.5. What’s a branch?标签已完成，现在是另一个大块内容：分支。 是时候处理问题了：像大多数 Git 用户一样，wyag 仍然没有任何关于分支的概念。它目前将一个仓库视为一堆杂乱无章的对象，其中一些是提交对象，而完全没有表示提交是如何在分支中组织的，也没有表示在任何时候都有一个提交是 HEAD，即活跃分支的头部提交（或“尖端”）。 那么，什么是分支呢？答案其实出奇地简单，但也可能让人惊讶：分支就是对某个提交的引用。你甚至可以说分支是对某个提交的别名。在这方面，分支和标签完全一样。标签是引用，存在于 .git/refs/tags 中，而分支是引用，存在于 .git/refs/heads 中。 当然，分支和标签之间是有区别的： 分支是对一个提交的引用，标签可以引用任何对象； 最重要的是，分支引用在每次提交时会被更新。这意味着每当你提交时，Git 实际上会执行以下操作： 创建一个新的提交对象，当前分支的提交 ID 作为其父提交； 提交对象被哈希并存储； 分支引用被更新，指向新提交的哈希值。 仅此而已。 但当前分支又是什么呢？实际上，它更简单。它是一个位于 refs 层级外的引用文件，存在于 .git/HEAD 中，它是一个间接引用（即它是类似 ref: path/to/other/ref 的形式，而不是简单的哈希值）。 Note 分离的 HEAD当你仅仅检出一个随机的提交时，Git 会警告你它处于“分离的 HEAD 状态”。这意味着你不再处于任何分支上。在这种情况下，.git/HEAD 是一个直接引用：它包含一个 SHA-1 值。 7.6. Referring to objects: the object_find function7.6.1. Resolving names记得我们创建的 [愚蠢的 object_find 函数](#4.6. The cat-file command) 吗？它接受四个参数，返回第二个参数不变，并忽略其他三个参数。现在是时候用一个更有用的函数来替换它了。我们将实现 Git 名称解析算法的一个小而实用的子集。新的 object_find() 将分为两步：首先，给定一个名称，它将返回一个完整的 sha-1 哈希。例如，对于 HEAD，它将返回当前分支的头部提交的哈希，等等。更精确地说，这个名称解析函数将按以下方式工作： 如果名称是 HEAD，它将解析为 .git/HEAD； 如果名称是完整的哈希，则直接返回该哈希； 如果名称看起来像是短哈希，它将收集所有完整哈希以该短哈希为前缀的对象； 最后，它将解析与名称匹配的标签和分支。 请注意，最后两步是收集值：前两步是绝对引用，因此我们可以安全地返回结果。但短哈希或分支名称可能是模糊的，我们希望列举出所有可能的含义，并在找到多个结果时抛出错误。 短哈希为了方便，Git 允许通过哈希值的前缀来引用哈希。例如，5bd254aa973646fa16f66d702a5826ea14a3eb45 可以简称为 5bd254。这被称为“短哈希”。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647def object_resolve(repo, name): &quot;&quot;&quot;Resolve name to an object hash in repo.This function is aware of: - the HEAD literal - short and long hashes - tags - branches - remote branches&quot;&quot;&quot; candidates = list() hashRE = re.compile(r&quot;^[0-9A-Fa-f]{4,40}$&quot;) # Empty string? Abort. if not name.strip(): return None # Head is nonambiguous if name == &quot;HEAD&quot;: return [ ref_resolve(repo, &quot;HEAD&quot;) ] # If it's a hex string, try for a hash. if hashRE.match(name): # This may be a hash, either small or full. 4 seems to be the # minimal length for git to consider something a short hash. # This limit is documented in man git-rev-parse name = name.lower() prefix = name[0:2] path = repo_dir(repo, &quot;objects&quot;, prefix, mkdir=False) if path: rem = name[2:] for f in os.listdir(path): if f.startswith(rem): # Notice a string startswith() itself, so this # works for full hashes. candidates.append(prefix + f) # Try for references. as_tag = ref_resolve(repo, &quot;refs/tags/&quot; + name) if as_tag: # Did we find a tag? candidates.append(as_tag) as_branch = ref_resolve(repo, &quot;refs/heads/&quot; + name) if as_branch: # Did we find a branch? candidates.append(as_branch) return candidates 第二步是，如果提供了类型参数，我们将找到的对象跟踪到所需类型的对象。这是一个非常简单的迭代过程，因为我们只需要处理简单的情况： 如果我们有一个标签，并且 fmt 不是我们期望的类型（例如 commit 或其他），则我们跟踪该标签。 如果我们有一个 commit 并且 fmt 是 tree，则返回该 commit 的树对象。 在所有其他情况下，我们中止操作：因为没有其他合理的情况需要处理。 这个过程是迭代的，因为它可能需要不确定的步骤，原因在于标签本身也可以被标记。这意味着如果一个标签指向另一个标签，我们需要继续解析，直到最终找到一个直接指向某个对象（如 commit 或 tree）的标签。这个递归过程确保我们能够跟踪所有引用，直到找到所需类型的对象。 12345678910111213141516171819202122232425262728293031323334def object_find(repo, name, fmt=None, follow=True): sha = object_resolve(repo, name) if not sha: raise Exception(f&quot;No such reference {name}.&quot;) if len(sha) &gt; 1: raise Exception(&quot;Ambiguous reference {name}: Candidates are:\\n - {'\\n - '.join(sha)}.&quot;) sha = sha[0] if not fmt: return sha while True: obj = object_read(repo, sha) # ^^^^^^^^^^^ &lt; this is a bit agressive: we're reading # the full object just to get its type. And we're doing # that in a loop, albeit normally short. Don't expect # high performance here. if obj.fmt == fmt: return sha if not follow: return None # Follow tags if obj.fmt == b'tag': sha = obj.kvlm[b'object'].decode(&quot;ascii&quot;) elif obj.fmt == b'commit' and fmt == b'tree': sha = obj.kvlm[b'tree'].decode(&quot;ascii&quot;) else: return None 通过新的 object_find() 函数，CLI wyag 变得更加易用。你现在可以执行以下操作： 123456$ wyag checkout v3.11 # A tag$ wyag checkout feature/explosions # A branch$ wyag ls-tree -r HEAD # The active branch or commit. There's also a # follow here: HEAD is actually a commit.$ wyag cat-file blob e0695f # A short hash$ wyag cat-file tree master # A branch, as a tree (another &quot;follow&quot;) 7.6.2. The rev-parse command让我们实现 wyag rev-parse。git rev-parse 命令的功能很多，但我们要克隆的用例之一是解析引用。为了进一步测试 object_find 的“跟随”功能，我们将在其接口中添加一个可选的 wyag-type 参数。 12345678910111213argsp = argsubparsers.add_parser( &quot;rev-parse&quot;, help=&quot;Parse revision (or other objects) identifiers&quot;)argsp.add_argument(&quot;--wyag-type&quot;, metavar=&quot;type&quot;, dest=&quot;type&quot;, choices=[&quot;blob&quot;, &quot;commit&quot;, &quot;tag&quot;, &quot;tree&quot;], default=None, help=&quot;Specify the expected type&quot;)argsp.add_argument(&quot;name&quot;, help=&quot;The name to parse&quot;) 桥接函数完成所有工作： 123456789def cmd_rev_parse(args): if args.type: fmt = args.type.encode() else: fmt = None repo = repo_find() print (object_find(repo, args.name, fmt, follow=True)) 并且它可以正常运行： 123456$ wyag rev-parse --wyag-type commit HEAD6c22393f5e3830d15395fd8d2f8b0cf8eb40dd58$ wyag rev-parse --wyag-type tree HEAD11d33fad71dbac72840aff1447e0d080c7484361$ wyag rev-parse --wyag-type tag HEADNone 8. Working with the staging area and the index file8.1. What’s the index file?这最后一步将带我们进入提交的过程（尽管实际创建提交的部分将在下一节进行！）。 你可能知道，在 Git 中进行提交之前，首先需要使用 git add 和 git rm 来“暂存”一些更改，然后才能执行提交。这种介于上一次提交和下一次提交之间的中间状态被称为 暂存区（staging area）。 看起来用提交对象（commit object）或树对象（tree object）来表示暂存区似乎是合乎逻辑的，但 Git 实际上使用了一种完全不同的机制，即所谓的 索引文件（index file）。 在一次提交之后，索引文件可以看作是该提交的一种副本：它存储了与对应树相同的“路径-Blob”关联信息。但除此之外，它还保存了工作区文件的额外信息，比如文件的创建/修改时间，因此 git status 通常不需要实际对比文件内容，而是仅检查文件的修改时间是否与索引文件中存储的时间相同，只有当两者不匹配时，它才会进行真正的内容比较。 因此，你可以将索引文件视为一个 三方关联表（three-way association list）：不仅包含路径与 Blob 的映射关系，还包含路径与实际文件系统条目的映射关系。 索引文件的另一个重要特点是：它可以表示不一致的状态，比如合并冲突，而树对象总是完整且明确的表示一个文件系统状态。 当你执行提交（commit）时，Git 实际上会将索引文件转换为一个新的 树对象（tree object）。总结如下： 当仓库处于“干净”状态（即没有未提交的更改）时，索引文件的内容与 HEAD 指向的提交完全相同，同时还包含关于对应文件系统条目的元数据。例如，它可能包含如下信息： 1There’s a file called src/disp.c whose contents are blob 797441c76e59e28794458b39b0f1eff4c85f4fa0. The real src/disp.c file, in the worktree, was created on 2023-07-15 15:28:29.168572151, and last modified 2023-07-15 15:28:29.1689427709. It is stored on device 65026, inode 8922881. 当你执行 git add 或 git rm 时，索引文件会相应地被修改。在上面的示例中，如果你修改了 src/disp.c 并添加你的更改，索引文件将使用新的 blob ID 进行更新（当然，blob 本身也会在此过程中被创建），并且各种文件元数据也会被更新，以便 git status 知道何时不需要比较文件内容。 当你 git commit 这些更改时，一个新的树对象将从索引文件中生成，一个新的提交对象将使用该树创建，分支将被更新，然后操作完成。 Note 关于术语的说明暂存区（staging area）和索引（index）实际上是同一回事，但“暂存区”更侧重于 Git 面向用户的功能名称（这一功能本可以通过其他方式实现），可以理解为一种抽象概念；而“索引文件”（index file）则特指 Git 实际实现该抽象功能的方式。 8.2. Parsing the index索引文件是 Git 仓库中最复杂的数据结构。其完整文档可以在 Git 源代码树的 Documentation/gitformat-index.txt 中找到，你也可以在 GitHub 镜像上浏览。索引文件由三部分组成： 一个包含格式版本号和索引中条目数量的头部； 一系列按排序存储的条目，每个条目代表一个文件，并填充至 8 字节的倍数； 一系列可选扩展，我们将在此忽略。 我们需要表示的第一个部分是一个条目。它实际上包含了很多信息，我会在注释中留下详细说明。值得注意的是，一个条目存储了与其关联的 blob 的 SHA-1 值，以及关于实际文件在实际文件系统上的大量元数据。再次强调，这是因为 git/wyag status 需要确定索引中哪些文件已经被修改：最有效的做法是先检查最后修改的时间戳，并将其与已知值进行比较，而不是直接比较文件内容。 1234567891011121314151617181920212223242526272829303132class GitIndexEntry (object): def __init__(self, ctime=None, mtime=None, dev=None, ino=None, mode_type=None, mode_perms=None, uid=None, gid=None, fsize=None, sha=None, flag_assume_valid=None, flag_stage=None, name=None): # The last time a file's metadata changed. This is a pair # (timestamp in seconds, nanoseconds) self.ctime = ctime # The last time a file's data changed. This is a pair # (timestamp in seconds, nanoseconds) self.mtime = mtime # The ID of device containing this file self.dev = dev # The file's inode number self.ino = ino # The object type, either b1000 (regular), b1010 (symlink), # b1110 (gitlink). self.mode_type = mode_type # The object permissions, an integer. self.mode_perms = mode_perms # User ID of owner self.uid = uid # Group ID of ownner self.gid = gid # Size of this object, in bytes self.fsize = fsize # The object's SHA self.sha = sha self.flag_assume_valid = flag_assume_valid self.flag_stage = flag_stage # Name of the object (full path this time!) self.name = name 索引文件是一个二进制文件，可能是出于性能原因。不过格式相对简单。它以一个包含 DIRC 魔术字节、版本号和索引文件中条目总数的头部开始。我们创建 GitIndex 类来存储这些内容： 123456789101112class GitIndex (object): version = None entries = [] # ext = None # sha = None def __init__(self, version=2, entries=None): if not entries: entries = list() self.version = version self.entries = entries 并且我们需要一个解析器，将索引文件读入这些对象。在读取完 12 字节的头部后，我们按照出现顺序解析条目。每个条目以一组固定长度的数据开头，后面跟着一个可变长度的文件名。 这段代码相当直接，但由于它在读取二进制格式，它比我们之前的代码稍显杂乱。我们频繁使用 int.from_bytes(bytes, endianness) 来将原始字节转换成整数，并且进行少量的位运算来分离共享同一字节的数据。 （这种格式可能是为了让索引文件能够直接映射到内存（mmapp()），并像 C 结构体一样直接读取，通常在大多数情况下构建索引的时间复杂度为 O(n)。这种方法在 C 中往往能产生比 Python 更优雅的代码……） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108def index_read(repo): index_file = repo_file(repo, &quot;index&quot;) # New repositories have no index! if not os.path.exists(index_file): return GitIndex() with open(index_file, 'rb') as f: raw = f.read() header = raw[:12] signature = header[:4] assert signature == b&quot;DIRC&quot; # Stands for &quot;DirCache&quot; version = int.from_bytes(header[4:8], &quot;big&quot;) assert version == 2, &quot;wyag only supports index file version 2&quot; count = int.from_bytes(header[8:12], &quot;big&quot;) entries = list() content = raw[12:] idx = 0 for i in range(0, count): # Read creation time, as a unix timestamp (seconds since # 1970-01-01 00:00:00, the &quot;epoch&quot;) ctime_s = int.from_bytes(content[idx: idx+4], &quot;big&quot;) # Read creation time, as nanoseconds after that timestamps, # for extra precision. ctime_ns = int.from_bytes(content[idx+4: idx+8], &quot;big&quot;) # Same for modification time: first seconds from epoch. mtime_s = int.from_bytes(content[idx+8: idx+12], &quot;big&quot;) # Then extra nanoseconds mtime_ns = int.from_bytes(content[idx+12: idx+16], &quot;big&quot;) # Device ID dev = int.from_bytes(content[idx+16: idx+20], &quot;big&quot;) # Inode ino = int.from_bytes(content[idx+20: idx+24], &quot;big&quot;) # Ignored. unused = int.from_bytes(content[idx+24: idx+26], &quot;big&quot;) assert 0 == unused mode = int.from_bytes(content[idx+26: idx+28], &quot;big&quot;) mode_type = mode &gt;&gt; 12 assert mode_type in [0b1000, 0b1010, 0b1110] mode_perms = mode &amp; 0b0000000111111111 # User ID uid = int.from_bytes(content[idx+28: idx+32], &quot;big&quot;) # Group ID gid = int.from_bytes(content[idx+32: idx+36], &quot;big&quot;) # Size fsize = int.from_bytes(content[idx+36: idx+40], &quot;big&quot;) # SHA (object ID). We'll store it as a lowercase hex string # for consistency. sha = format(int.from_bytes(content[idx+40: idx+60], &quot;big&quot;), &quot;040x&quot;) # Flags we're going to ignore flags = int.from_bytes(content[idx+60: idx+62], &quot;big&quot;) # Parse flags flag_assume_valid = (flags &amp; 0b1000000000000000) != 0 flag_extended = (flags &amp; 0b0100000000000000) != 0 assert not flag_extended flag_stage = flags &amp; 0b0011000000000000 # Length of the name. This is stored on 12 bits, some max # value is 0xFFF, 4095. Since names can occasionally go # beyond that length, git treats 0xFFF as meaning at least # 0xFFF, and looks for the final 0x00 to find the end of the # name --- at a small, and probably very rare, performance # cost. name_length = flags &amp; 0b0000111111111111 # We've read 62 bytes so far. idx += 62 if name_length &lt; 0xFFF: assert content[idx + name_length] == 0x00 raw_name = content[idx:idx+name_length] idx += name_length + 1 else: print(f&quot;Notice: Name is 0x{name_length:X} bytes long.&quot;) # This probably wasn't tested enough. It works with a # path of exactly 0xFFF bytes. Any extra bytes broke # something between git, my shell and my filesystem. null_idx = content.find(b'\\x00', idx + 0xFFF) raw_name = content[idx: null_idx] idx = null_idx + 1 # Just parse the name as utf8. name = raw_name.decode(&quot;utf8&quot;) # Data is padded on multiples of eight bytes for pointer # alignment, so we skip as many bytes as we need for the next # read to start at the right position. idx = 8 * ceil(idx / 8) # And we add this entry to our list. entries.append(GitIndexEntry(ctime=(ctime_s, ctime_ns), mtime=(mtime_s, mtime_ns), dev=dev, ino=ino, mode_type=mode_type, mode_perms=mode_perms, uid=uid, gid=gid, fsize=fsize, sha=sha, flag_assume_valid=flag_assume_valid, flag_stage=flag_stage, name=name)) return GitIndex(version=version, entries=entries) 8.3. The ls-files commandgit ls-files 显示暂存区中文件的名称，并且通常会有许多选项。我们的 ls-files 会简单得多，但我们会添加一个 --verbose 选项，虽然在 git 中并没有这个选项，但为了能够显示索引文件中的每一项信息，我们会加上它。 123456789101112131415161718192021argsp = argsubparsers.add_parser(&quot;ls-files&quot;, help = &quot;List all the stage files&quot;)argsp.add_argument(&quot;--verbose&quot;, action=&quot;store_true&quot;, help=&quot;Show everything.&quot;)def cmd_ls_files(args): repo = repo_find() index = index_read(repo) if args.verbose: print(f&quot;Index file format v{index.version}, containing {len(index.entries)} entries.&quot;) for e in index.entries: print(e.name) if args.verbose: entry_type = { 0b1000: &quot;regular file&quot;, 0b1010: &quot;symlink&quot;, 0b1110: &quot;git link&quot; }[e.mode_type] print(f&quot; {entry_type} with perms: {e.mode_perms:o}&quot;) print(f&quot; on blob: {e.sha}&quot;) print(f&quot; created: {datetime.fromtimestamp(e.ctime[0])}.{e.ctime[1]}, modified: {datetime.fromtimestamp(e.mtime[0])}.{e.mtime[1]}&quot;) print(f&quot; device: {e.dev}, inode: {e.ino}&quot;) print(f&quot; user: {pwd.getpwuid(e.uid).pw_name} ({e.uid}) group: {grp.getgrgid(e.gid).gr_name} ({e.gid})&quot;) print(f&quot; flags: stage={e.flag_stage} assume_valid={e.flag_assume_valid}&quot;) 如果运行 ls-files，你会注意到在一个“干净”的工作区（一个未修改的 HEAD 检出）中，它列出了 HEAD 上的所有文件。同样，索引文件并不是从 HEAD 提交的增量（即差异集），而是以不同的格式作为 HEAD 的副本开始的。 8.4. A detour: the check-ignore command我们想要实现 status 命令，但 status 需要了解忽略规则，这些规则存储在各种 .gitignore 文件中。因此，我们首先需要在 wyag 中添加一些基本的对忽略文件的支持。我们将通过 check-ignore 命令来暴露这一支持，该命令接受一组路径并返回那些应该被忽略的路径。 同样，命令解析器是非常简单的： 12argsp = argsubparsers.add_parser(&quot;check-ignore&quot;, help = &quot;Check path(s) against ignore rules.&quot;)argsp.add_argument(&quot;path&quot;, nargs=&quot;+&quot;, help=&quot;Paths to check&quot;) 而这个函数也同样简单： 123456def cmd_check_ignore(args): repo = repo_find() rules = gitignore_read(repo) for path in args.path: if check_ignore(rules, path): print(path) 当然，许多我们调用的函数在 wyag 中还不存在。我们将首先编写一个用于读取忽略文件规则的函数 gitignore_read()。这些规则的语法相当简单：忽略文件中的每一行都是一个排除模式，匹配此模式的文件会被 status、add -A 等操作忽略。然而，有三种特殊情况： 以感叹号 ! 开头的行会否定该模式（即使之前的模式已经忽略了文件，这些文件也会被包括在内）。 以井号 # 开头的行是注释，会被跳过。 行首的反斜杠 \\ 会将 ! 和 # 视为普通字符。 首先，我们需要编写一个解析单个模式的函数。这个解析器返回一个元组：模式本身，以及一个布尔值，用于指示匹配该模式的文件是应该被排除（True）还是包括（False）。换句话说，如果模式是以 ! 开头的，返回 False，否则返回 True。 1234567891011def gitignore_parse1(raw): raw = raw.strip() # Remove leading/trailing spaces if not raw or raw[0] == &quot;#&quot;: return None elif raw[0] == &quot;!&quot;: return (raw[1:], False) elif raw[0] == &quot;\\\\&quot;: return (raw[1:], True) else: return (raw, True) 解析文件就是收集文件中的所有规则。注意，这个函数并不直接解析文件，而是解析行的列表：这是因为我们不仅需要从常规文件中读取规则，还需要从 Git 的 blob 中读取规则。 123456789def gitignore_parse(lines): ret = list() for line in lines: parsed = gitignore_parse1(line) if parsed: ret.append(parsed) return ret 最后我们需要做的是收集各种忽略文件。它们有两种类型： 一些文件存在于索引中：它们是各种 gitignore 文件。强调一下复数形式；虽然通常只有一个这样的文件，位于根目录，但每个目录下都可以有一个，这个文件适用于该目录及其子目录。我将这些称为“作用域”，因为它们仅适用于其所在目录及其子目录。 另一些文件存在于索引之外。它们是全局忽略文件（通常位于 ~/.config/git/ignore）和存储在 .git/info/exclude 中的仓库特定忽略文件。我将这些称为“绝对”，因为它们适用于整个仓库，但优先级较低。 再次创建一个类来持有这些文件的信息：包括一个绝对规则的列表和一个相对规则的字典。这个字典的键是相对于工作区根目录的目录路径。 1234567class GitIgnore(object): absolute = None scoped = None def __init__(self, absolute, scoped): self.absolute = absolute self.scoped = scoped 最后，我们编写一个函数来收集仓库中所有的 gitignore 规则，并返回一个 GitIgnore 对象。需要注意的是，它从索引中读取作用域文件，而不是从工作区读取：只有已暂存的 .gitignore 文件才有意义（还要记住：HEAD 已经被暂存——暂存区是一个副本，而不是增量）。 123456789101112131415161718192021222324252627282930def gitignore_read(repo): ret = GitIgnore(absolute=list(), scoped=dict()) # Read local configuration in .git/info/exclude repo_file = os.path.join(repo.gitdir, &quot;info/exclude&quot;) if os.path.exists(repo_file): with open(repo_file, &quot;r&quot;) as f: ret.absolute.append(gitignore_parse(f.readlines())) # Global configuration if &quot;XDG_CONFIG_HOME&quot; in os.environ: config_home = os.environ[&quot;XDG_CONFIG_HOME&quot;] else: config_home = os.path.expanduser(&quot;~/.config&quot;) global_file = os.path.join(config_home, &quot;git/ignore&quot;) if os.path.exists(global_file): with open(global_file, &quot;r&quot;) as f: ret.absolute.append(gitignore_parse(f.readlines())) # .gitignore files in the index index = index_read(repo) for entry in index.entries: if entry.name == &quot;.gitignore&quot; or entry.name.endswith(&quot;/.gitignore&quot;): dir_name = os.path.dirname(entry.name) contents = object_read(repo, entry.sha) lines = contents.blobdata.decode(&quot;utf8&quot;).splitlines() ret.scoped[dir_name] = gitignore_parse(lines) return ret 我们快完成了。为了将所有内容结合在一起，我们需要一个 check_ignore 函数，它将路径与一组规则进行匹配，这些路径是相对于工作树的根目录的。这个函数的工作方式如下： 作用域规则匹配：它首先尝试将路径与作用域规则进行匹配。匹配的顺序是从路径的最深父级开始，逐级向上查找。例如，如果路径是 src/support/w32/legacy/sound.c~，它会先查找 src/support/w32/legacy/.gitignore 中的规则，然后是 src/support/w32/.gitignore，再是 src/support/.gitignore，直到根目录下的 .gitignore。 绝对规则匹配：如果作用域规则没有匹配，它将继续使用绝对规则进行匹配。 我们将编写三个小的支持函数。第一个是用来将路径与规则集进行匹配的，并返回最后一个匹配规则的结果。注意，这不是一个真正的布尔函数，因为它有三个可能的返回值：True、False 和 None。如果没有匹配，它将返回 None，这样调用者就知道应该继续尝试更一般的忽略文件（例如，向上移动一个目录级别）。 123456def check_ignore1(rules, path): result = None for (pattern, value) in rules: if fnmatch(path, pattern): result = value return result 这是一个用于匹配作用域规则字典（即各种 .gitignore 文件）的函数。它从路径所在的目录开始，逐级向上递归查找父目录，直到测试到根目录。请注意，这个函数（以及接下来的两个函数）在处理每个 .gitignore 文件时不会提前停止。即使某个规则匹配，它们会继续扫描整个文件，因为该文件中的其他规则可能会反转之前的效果（规则是按顺序处理的，因此如果你想排除 *.c 但不排除 generator.c，通用规则必须放在特定规则之前）。但是，一旦在某个文件中至少匹配到一个规则，我们就停止继续检查该文件的剩余规则，因为更一般的文件永远不会取消更具体规则的效果（这就是为什么 check_ignore1 是三值而不是布尔的原因）。 1234567891011def check_ignore_scoped(rules, path): parent = os.path.dirname(path) while True: if parent in rules: result = check_ignore1(rules[parent], path) if result != None: return result if parent == &quot;&quot;: break parent = os.path.dirname(parent) return None 这是一个用于匹配绝对规则列表的简单函数。请注意，我们将这些规则推送到列表的顺序很重要（因为我们确实先读取了仓库规则，再读取了全局规则！）。 1234567def check_ignore_absolute(rules, path): parent = os.path.dirname(path) for ruleset in rules: result = check_ignore1(ruleset, path) if result != None: return result return False # This is a reasonable default at this point. 最后，我们需要一个函数将它们全部绑定在一起。 123456789def check_ignore(rules, path): if os.path.isabs(path): raise Exception(&quot;This function requires path to be relative to the repository's root&quot;) result = check_ignore_scoped(rules.scoped, path) if result != None: return result return check_ignore_absolute(rules.absolute, path) 现在，您可以在其源代码树上调用 wyag check-ignore。 1234$ wyag check-ignore hello.el hello.elc hello.html wyag.zip wyag.tarhello.elchello.htmlwyag.zip Warning 这只是一个近似实现这并不是一个完美的重新实现。特别是，通过仅使用目录名称（例如 __pycache__）的规则排除整个目录将不起作用，因为 fnmatch 需要的模式是 __pycache__/**。如果你真的想深入了解忽略规则，这可能是一个很好的起点。 8.5. The status command补充1. l33t h4x0r“l33t h4x0r” 是一种 黑客文化（hacker culture） 里的 Leetspeak（精英语） 表达方式，它的原意是 **”leet hacker”**，即 elite hacker（精英黑客）。 在 Leetspeak 里： l33t = leet（elite 的变形，意为“精英”） h4x0r = hacker（haxor 是 hacker 的变体，”4” 代替 “a”，”0” 代替 “o”） 这个词通常用来形容那些技术高超的黑客（有时也带有一点戏谑或自嘲的意味），或者用来调侃那些自认为是黑客但实际上技术并不高的人。 2. code 11234#!/usr/bin/env python3import libwyaglibwyag.main() 这段代码是 wyag 可执行文件的内容。我们可以逐行解释： #!/usr/bin/env python3这一行是 shebang（或称作 hashbang），它告诉操作系统应该使用哪个解释器来运行这个文件。在这里，它指定了 python3 作为解释器，并使用 env 命令来确保使用系统中可用的 Python 3 版本。 import libwyag这行代码导入了我们之前提到的 libwyag.py 库文件，这个文件包含了实际的逻辑和功能。导入后，wyag 可以调用库中的函数和类。 libwyag.main()这一行调用了 libwyag.py 中的 main() 函数。通常，main() 函数是程序的入口点，它会处理主要的任务和逻辑。在这里，它可能会启动执行 Git 核心命令的相关功能。","link":"/2025/02/17/Write%20yourself%20a%20Git!/Write%20yourself%20a%20Git!/"},{"title":"Thinking in Java pt.4","text":"Chapter 4 Controlling ExecutionLike a sentient creature, a program must manipulate its world and make choices during execution. In Java you make choices with execution control statements. Java uses all of C’s execution control statements, so if you’ve programmed with C or C++, then most of what you see will be familiar. Most procedural programming languages have some kind of control statements, and there is often overlap among languages. In Java, the keywords include if-else, while, do-while, for, return, break, and a selection statement called switch. Java does not, however, support the much-maligned goto (which can still be the most expedient way to solve certain types of problems). You can still do a goto-like jump, but it is much more constrained than a typical goto. 4.1 true and falsepass 4.2 if-elsepass 4.3 Iterationpass Exercise 1Write a program that prints values from 1 to 100. 1234567public class exer_1 { public static void main(String[] args) { for (int i = 1; i &lt;= 100; i++) { System.out.println(i); } }} Exercise 2Write a program that generates 25 random int values. For each value, use an if-else statement to classify it as greater than, less than, or equal to a second randomly generated value. 1234567891011121314151617public class exer_2 { public static void main(String[] args) { Random random = new Random(); int i1 = random.nextInt(); for (int i = 1; i &lt; 25; i++) { int i2 = random.nextInt(); if (i1 &gt; i2) { System.out.println(i1 + &quot; &gt; &quot; + i2); } else if (i1 &lt; i2) { System.out.println(i1 + &quot; &lt; &quot; + i2); } else { System.out.println(i1 + &quot; = &quot; + i2); } i1 = i2; } }} Exercise 3:Modify Exercise 2 so that your code is surrounded by an “infinite” while loop. It will then run until you interrupt it from the keyboard (typically by pressing ControlC). 1234567891011121314151617public class exer_3 { public static void main(String[] args) { Random random = new Random(); int i1 = random.nextInt(); while (true) { int i2 = random.nextInt(); if (i1 &gt; i2) { System.out.println(i1 + &quot; &gt; &quot; + i2); } else if (i1 &lt; i2) { System.out.println(i1 + &quot; &lt; &quot; + i2); } else { System.out.println(i1 + &quot; = &quot; + i2); } i1 = i2; } }} Exercise 4:Write a program that uses two nested for loops and the modulus operator (%) to detect and print prime numbers (integral numbers that are not evenly divisible by any other numbers except for themselves and 1). 12345678910111213141516public class exer_4 { public static void main(String[] args) { for (int i = 0; i &lt; 10000; i++) { boolean flag = true; for (int j = 2; j &lt; i; j++) { if (i % j == 0) { flag = false; break; } } if (flag) { System.out.println(i); } } }} Exercise 5:Repeat Exercise 10 from the previous chapter, using the ternary operator and a bitwise test to display the ones and zeroes, instead of Integer.toBinaryString( ). 1pass 4.4 Foreach syntaxpass 4.5 returnpass 4.6 break and continuepass 4.7 The infamous “goto”Although goto is a reserved word in Java, it is not used in the language; Java has no goto. However, it does have something that looks a bit like a jump tied in with the break and continue keywords. It’s not a jump but rather a way to break out of an iteration statement. The reason it’s often thrown in with discussions of goto is because it uses the same mechanism: a label. A label is an identifier followed by a colon, like this: 1label1: The only place a label is useful in Java is right before an iteration statement. And that means right before—it does no good to put any other statement between the label and the iteration. And the sole reason to put a label before an iteration is if you’re going to nest another iteration or a switch (which you’ll learn about shortly) inside it. That’s because the break and continue keywords will normally interrupt only the current loop, but when used with a label, they’ll interrupt the loops up to where the label exists: 12345678910111213label1:outer-iteration { inner-iteration { //... break; // (1) //... continue; // (2) //... continue label1; // (3) //... break label1; // (4) }} In (1), the break breaks out of the inner iteration and you end up in the outer iteration. In (2), the continue moves back to the beginning of the inner iteration. But in (3), the continue label1 breaks out of the inner iteration and the outer iteration, all the way back to label1. Then it does in fact continue the iteration, but starting at the outer iteration. In (4), the break label1 also breaks all the way out to label1, but it does not reenter the iteration. It actually does break out of both iterations. Here is an example using for loops: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// For loops with &quot;labeled break&quot; and &quot;labeled continue.&quot;import static net.mindview.util.Print.*;public class LabeledFor { public static void main(String[] args) { int i = 0; outer: // Can’t have statements here for(; true ;) { // infinite loop inner: // Can’t have statements here for(; i &lt; 10; i++) { print(&quot;i = &quot; + i); if(i == 2) { print(&quot;continue&quot;); continue; } if(i == 3) { print(&quot;break&quot;); i++; // Otherwise i never // gets incremented. break; } if(i == 7) { print(&quot;continue outer&quot;); i++; // Otherwise i never // gets incremented. continue outer; } if(i == 8) { print(&quot;break outer&quot;); break outer; } for(int k = 0; k &lt; 5; k++) { if(k == 3) { print(&quot;continue inner&quot;); continue inner; } } } } // Can’t break or continue to labels here }} /* Output:i = 0continue inneri = 1continue inneri = 2continuei = 3breaki = 4continue inneri = 5continue inneri = 6continue inneri = 7continue outeri = 8break outer *///:~ The same rules hold true for while: A plain continue goes to the top of the innermost loop and continues. A labeled continue goes to the label and reenters the loop right after that label. A break “drops out of the bottom” of the loop. A labeled break drops out of the bottom of the end of the loop denoted by the label. In Dijkstra’s “Goto considered harmful” paper, what he specifically objected to was the labels, not the goto. He observed that the number of bugs seems to increase with the number of labels in a program, and that labels and gotos make programs difficult to analyze. Note that Java labels don’t suffer from this problem, since they are constrained in their placement and can’t be used to transfer control in an ad hoc manner. It’s also interesting to note that this is a case where a language feature is made more useful by restricting the power of the statement. 4.8 switchpass 4.9 SummaryThis chapter concludes the study of fundamental features that appear in most programming languages: calculation, operator precedence, type casting, and selection and iteration. Now you’re ready to begin taking steps that move you closer to the world of object-oriented programming. The next chapter will cover the important issues of initialization and cleanup of objects, followed in the subsequent chapter by the essential concept of implementation hiding.","link":"/2025/02/12/Thinking-in-Java/Thinking-in-Java-pt-4/"},{"title":"Test","text":"Testit’s a test file for hexo","link":"/2024/12/21/test/Test/"},{"title":"Operating System pt.2","text":"Install Your OS in a Virtual Machine1. 修改Makefile制作iso文件1234567891011121314mykernel.iso: mykernel.bin mkdir iso mkdir iso/boot mkdir iso/boot/grub cp $&lt; iso/boot echo 'set timeout=0' &gt;&gt; iso/boot/grub/grub.cfg echo 'set default=0' &gt;&gt; iso/boot/grub/grub.cfg echo '' &gt;&gt; iso/boot/grub/grub.cfg echo 'menuentry &quot;My Operating System&quot;{' &gt;&gt; iso/boot/grub/grub.cfg echo ' multiboot /boot/mykernel.bin' &gt;&gt; iso/boot/grub/grub.cfg echo ' boot' &gt;&gt; iso/boot/grub/grub.cfg echo '}' &gt;&gt; iso/boot/grub/grub.cfg grub-mkrescue --output=$@ iso rm -rf iso 这段Makefile用于生成一个名为mykernel.iso的可启动ISO镜像文件。它依赖于一个名为mykernel.bin的二进制文件，该文件通常是一个操作系统内核或引导程序。以下是逐行解释： mykernel.iso: mykernel.bin: 这行定义了目标文件mykernel.iso和它的依赖文件mykernel.bin。当mykernel.bin发生变化时，mykernel.iso将会被重新生成。 mkdir iso: 创建一个名为iso的目录，用于临时存放构建ISO文件所需的文件。 mkdir iso/boot: 在iso目录下创建一个boot子目录，用于存放引导相关的文件。 mkdir iso/boot/grub: 在iso/boot目录下创建一个grub子目录，用于存放GRUB引导加载器的配置文件。 cp $&lt; iso/boot: 将依赖文件mykernel.bin复制到iso/boot目录中。$&lt;是Makefile中的自动变量，表示第一个依赖文件（即mykernel.bin）。 echo 'set timeout=0' &gt;&gt; iso/boot/grub/grub.cfg: 向iso/boot/grub/grub.cfg文件中追加一行，设置GRUB菜单的超时时间为0秒，即不显示菜单直接启动。 echo 'set default=0' &gt;&gt; iso/boot/grub/grub.cfg: 向grub.cfg文件中追加一行，设置默认启动项为第一个菜单项。 echo '' &gt;&gt; iso/boot/grub/grub.cfg: 向grub.cfg文件中追加一个空行。 echo 'menuentry &quot;My Operating System&quot;{' &gt;&gt; iso/boot/grub/grub.cfg: 向grub.cfg文件中追加一行，定义一个名为”My Operating System”的菜单项。 echo ' multiboot /boot/mykernel.bin' &gt;&gt; iso/boot/grub/grub.cfg: 向grub.cfg文件中追加一行，指定使用multiboot命令加载/boot/mykernel.bin文件。 echo ' boot' &gt;&gt; iso/boot/grub/grub.cfg: 向grub.cfg文件中追加一行，执行boot命令以启动加载的内核。 echo '}' &gt;&gt; iso/boot/grub/grub.cfg: 向grub.cfg文件中追加一行，结束菜单项的定义。 grub-mkrescue --output=$@ iso: 使用grub-mkrescue命令将iso目录中的内容打包成一个可启动的ISO镜像文件。$@是Makefile中的自动变量，表示目标文件（即mykernel.iso）。 rm -rf iso: 删除临时创建的iso目录及其内容，以清理构建过程中生成的临时文件。 这段Makefile的作用是将mykernel.bin文件打包成一个可启动的ISO镜像文件mykernel.iso。它使用GRUB作为引导加载器，并配置GRUB直接启动mykernel.bin。构建完成后，临时目录iso会被删除 2. 定义types.h12345678910111213141516#ifndef __TYPES_H__#define __TYPES_H__ typedef char int8_t; typedef unsigned char uint8_t; typedef short int16_t; typedef unsigned short uint16_t; typedef int int32_t; typedef unsigned int uint32_t; typedef long long int int64_t; typedef unsigned long long int uint64_t;#endif 3. 修改kernel.cpp123456789101112131415161718192021222324#include &lt;types.h&gt;void printf(char* str) { uint16_t* VideoMemory = (uint16_t*) 0xB8000; for(int i = 0; str[i] != '\\0'; ++i) { VideoMemory[i] = (VideoMemory[i] &amp; 0xFF00) | str[i]; }}typedef void (*constructor)();extern &quot;C&quot; constructor start_ctors;extern &quot;C&quot; constructor end_ctors;extern &quot;C&quot; void callConstructors() { for(constructor* i = &amp;start_ctors; i != &amp;end_ctors; i++) { (*i)(); }}extern &quot;C&quot; void kernelMain(void* multiboot_structure, uint32_t magicnumber) { printf(&quot;Hello World!\\n&quot;); while(1);} Memory Segments, Global Descriptor Table","link":"/2025/01/11/Write%20your%20own%20Operating%20System/Operating-System-pt-2/"},{"title":"Thinking in Java pt.3","text":"Chapter 3 OperatorsAt the lowest level, data in Java is manipulated using operators. If you’re familiar with C or C++ syntax, you can skim through this chapter and the next, looking for places where Java is different from those languages. 3.1 Simpler print statementsIn the previous chapter, you were introduced to the Java print statement: 1System.out.println(&quot;Rather a lot to type&quot;); The Access Control chapter introduces the concept of the static import that was added to Java SE5, and creates a tiny library to simplify writing print statements. However, you don’t need to know those details in order to begin using that library. We can rewrite the program from the last chapter using this new library: 123456789101112//: operators/HelloDate.javaimport java.util.*;import static net.mindview.util.Print.*;public class HelloDate { public static void main(String[] args) { print(&quot;Hello, it’s: &quot;); print(new Date()); }} /* Output: (55% match)Hello, it’s:Wed Oct 05 14:39:05 MDT 2005*///:~ The results are much cleaner. Notice the insertion of the static keyword in the second import statement. Although the use of net.mindview.util.Print nicely simplifies most code, it is not justifiable everywhere. If there are only a small number of print statements in a program, I forego the import and write out the full System.out.println( ). Exercise 1Write a program that uses the “short” and normal form of print statement. 123456789// short versionimport java.util.*;import static net.mindview.util.Print.*;public class exer { public static void main(String[] args) { print(&quot;Hello, it’s: &quot;); print(new Date()); }} 12345678// normal versionimport java.util.*;public class exer { public static void main(String[] args) { System.out.print(&quot;Hello, it’s: &quot;); System.out.print(new Date()); }} 3.2 Using Java operatorspass 3.3 PrecedenceOperator precedence defines how an expression evaluates when several operators are present. Java has specific rules that determine the order of evaluation. The easiest one to remember is that multiplication and division happen before addition and subtraction. Programmers often forget the other precedence rules, so you should use parentheses to make the order of evaluation explicit. 1234567891011//: operators/Precedence.javapublic class Precedence { public static void main(String[] args) { int x = 1, y = 2, z = 3; int a = x + y - 2/2 + z; // (1) int b = x + (y - 2)/(2 + z); // (2) System.out.println(&quot;a = &quot; + a + &quot; b = &quot; + b); }} /* Output:a = 5 b = 1*///:~ These statements look roughly the same, but from the output you can see that they have very different meanings which depend on the use of parentheses. Notice that the System.out.println( ) statement involves the ‘**+’ operator. In this context, ‘+’ means “string concatenation**” and, if necessary, “string conversion.” When the compiler sees a String followed by a ‘+’ followed by a non-String, it attempts to convert the nonString into a String. As you can see from the output, it successfully converts from int into String for a and b. 3.4 AssignmentWhenever you manipulate an object, what you’re manipulating is the reference, so when you assign “from one object to another,” you’re actually copying a reference from one place to another. This means that if you say c = d for objects, you end up with both c and d pointing to the object that, originally, only d pointed to. Here’s an example that demonstrates this behavior: 1234567891011121314151617181920212223242526//: operators/Assignment.java// Assignment with objects is a bit tricky.import static net.mindview.util.Print.*;class Tank { int level;}public class Assignment { public static void main(String[] args) { Tank t1 = new Tank(); Tank t2 = new Tank(); t1.level = 9; t2.level = 47; print(&quot;1: t1.level: &quot; + t1.level + &quot;, t2.level: &quot; + t2.level); t1 = t2; print(&quot;2: t1.level: &quot; + t1.level + &quot;, t2.level: &quot; + t2.level); t1.level = 27; print(&quot;3: t1.level: &quot; + t1.level + &quot;, t2.level: &quot; + t2.level); }} /* Output:1: t1.level: 9, t2.level: 472: t1.level: 47, t2.level: 473: t1.level: 27, t2.level: 27*///:~ This phenomenon is often called aliasing, and it’s a fundamental way that Java works with objects. But what if you don’t want aliasing to occur in this case? You could forego the assignment and say: 1t1.level = t2.level; This retains the two separate objects instead of discarding one and tying t1 and t2 to the same object. You’ll soon realize that manipulating the fields within objects is messy and goes against good object-oriented design principles. This is a nontrivial topic, so you should keep in mind that assignment for objects can add surprises. Exercise 2Create a class containing a float and use it to demonstrate aliasing. 1234567891011121314151617181920class Tank { float level;}public class exer_2 { public static void main(String[] args) { Tank t1 = new Tank(); Tank t2 = new Tank(); t1.level = 9; t2.level = 47; System.out.print(&quot;1: t1.level: &quot; + t1.level + &quot;, t2.level: &quot; + t2.level); t1 = t2; System.out.print(&quot;2: t1.level: &quot; + t1.level + &quot;, t2.level: &quot; + t2.level); t1.level = 27; System.out.print(&quot;3: t1.level: &quot; + t1.level + &quot;, t2.level: &quot; + t2.level); }} 3.4.1 Aliasing during method callsAliasing will also occur when you pass an object into a method: 12345678910111213141516171819202122//: operators/PassObject.java// Passing objects to methods may not be// what you’re used to.import static net.mindview.util.Print.*;class Letter { char c;}public class PassObject { static void f(Letter y) { y.c = ‘z’; } public static void main(String[] args) { Letter x = new Letter(); x.c = ‘a’; print(&quot;1: x.c: &quot; + x.c); f(x); print(&quot;2: x.c: &quot; + x.c); }} /* Output:1: x.c: a2: x.c: z*///:~ In many programming languages, the method f( ) would appear to be making a copy of its argument Letter y inside the scope of the method. But once again a reference is being passed, so the line 1y.c = ‘z’; is actually changing the object outside of f( ). Exercise 3Create a class containing a float and use it to demonstrate aliasing during method calls. pass 3.5 Mathematical operatorsThe basic mathematical operators are the same as the ones available in most programming languages: addition (+), subtraction (-), division (/), multiplication (*) and modulus (%, which produces the remainder from integer division). Integer division truncates, rather than rounds, the result. Java also uses the shorthand notation from C/C++ that performs an operation and an assignment at the same time. This is denoted by an operator followed by an equal sign, and is consistent with all the operators in the language (whenever it makes sense). For example, to add 4 to the variable x and assign the result to x, use: x += 4. The program generates a number of different types of random numbers with the Random object simply by calling the methods nextInt( ) and nextFloat( ) (you can also call nextLong( ) or nextDouble( )). The argument to nextInt( ) sets the upper bound on the generated number. The lower bound is zero, which we don’t want because of the possibility of a divide-by-zero, so the result is offset by one. Exercise 4Write a program that calculates velocity using a constant distance and a constant time. pass 3.5.1 Unary minus and plus operatorspass 3.6 Auto increment and decrementTwo of the nicer shortcuts are the increment and decrement operators (often referred to as the auto-increment and auto-decrement operators). The decrement operator is – and means “decrease by one unit.” The increment operator is ++ and means “increase by one unit.” If a is an int, for example, the expression ++a is equivalent to (a = a + 1). Increment and decrement operators not only modify the variable, but also produce the value of the variable as a result. There are two versions of each type of operator, often called the prefix and postfix versions. Preincrement means the ++ operator appears before the variable, and post-increment means the ++ operator appears after the variable. Similarly, pre-decrement means the – operator appears before the variable, and post-decrement means the – operator appears after the variable. For pre-increment and pre-decrement (i.e., ++a or –a), the operation is performed and the value is produced. For post-increment and post-decrement (i.e., a++ or a–), the value is produced, then the operation is performed. 3.7 Relational operatorsRelational operators generate a boolean result. They evaluate the relationship between the values of the operands. A relational expression produces true if the relationship is true, and false if the relationship is untrue. The relational operators are less than (&lt;), greater than (&gt;), less than or equal to (&lt;=), greater than or equal to (&gt;=), equivalent (==) and not equivalent (!=). Equivalence and nonequivalence work with all primitives, but the other comparisons won’t work with type boolean. Because boolean values can only be true or false, “greater than” and “less than” doesn’t make sense. 3.7.1 Testing object equivalenceThe relational operators == and != also work with all objects, but their meaning often confuses the first-time Java programmer. Exercise 5Create a class called Dog containing two Strings: name and says. In main( ), create two dog objects with names “spot” (who says, “Ruff!”) and “scruffy” (who says, “Wurf!”). Then display their names and what they say. pass Exercise 6Following Exercise 5, create a new Dog reference and assign it to spot’s object. Test for comparison using == and equals( ) for all references. 3.8 Logical operatorsEach of the logical operators AND (&amp;&amp;), OR (||) and NOT (!) produces a boolean value of true or false based on the logical relationship of its arguments. You can apply AND, OR, or NOT to boolean values only. You can’t use a non-boolean as if it were a boolean in a logical expression as you can in C and C++. You can see the failed attempts at doing this commented out with a ‘//!’ (this comment syntax enables automatic removal of comments to facilitate testing). The subsequent expressions, however, produce boolean values using relational comparisons, then use logical operations on the results. Exercise 7Write a program that simulates coin-flipping. 3.8.1 Short-circuitingWhen dealing with logical operators, you run into a phenomenon called “short-circuiting.” This means that the expression will be evaluated only until the truth or falsehood of the entire expression can be unambiguously determined. As a result, the latter parts of a logical expression might not be evaluated. 3.9 Literalspass Exercise 8Show that hex and octal notations work with long values. Use Long.toBinaryString( ) to display the results. pass 3.9.1 Exponential notationpass Exercise 9Display the largest and smallest numbers for both float and double exponential notation. pass 3.10 Bitwise operatorspass Exercise 10Write a program with two constant values, one with alternating binary ones and zeroes, with a zero in the least-significant digit, and the second, also alternating, with a one in the least-significant digit (hint: It’s easiest to use hexadecimal constants for this). Take these two values and combine them in all possible ways using the bitwise operators, and display the results using Integer.toBinaryString( ). 3.11 Shift operatorspass Exercise 11Start with a number that has a binary one in the most significant position (hint: Use a hexadecimal constant). Using the signed right-shift operator, right shift it all the way through all of its binary positions, each time displaying the result using Integer.toBinaryString( ). pass Exercise 12Start with a number that is all binary ones. Left shift it, then use the unsigned right-shift operator to right shift through all of its binary positions, each time displaying the result using Integer.toBinaryString( ). pass Exercise 13Write a method that displays char values in binary form. Demonstrate it using several different characters. pass 3.12 Ternary if-else operatorpass 3.13 String operator + and +=pass 3.14 Common pitfalls when using operatorspass 3.15 Casting operatorspass 3.15.1 Truncation and roundingpass 3.15.2 PromotionYou’ll discover that if you perform any mathematical or bitwise operations on primitive data types that are smaller than an int (that is, char, byte, or short), those values will be promoted to int before performing the operations, and the resulting value will be of type int. So if you want to assign back into the smaller type, you must use a cast. (And, since you’re assigning back into a smaller type, you might be losing information.) In general, the largest data type in an expression is the one that determines the size of the result of that expression; if you multiply a float and a double, the result will be double; if you add an int and a long, the result will be long. 3.16 Java has no “sizeof”pass 3.17 A compendium of operatorspass 3.18 Summarypass","link":"/2025/02/11/Thinking-in-Java/Thinking-in-Java-pt-3/"},{"title":"test-pic","text":"test file for insert imgs","link":"/2024/12/21/test/test-pic/"},{"title":"Thinking in Java pt.2","text":"Chapter 2 Everything Is an ObjectAlthough it is based on C++, Java is more of a “pure” object-oriented language. Both C++ and Java are hybrid languages, but in Java the designers felt that the hybridization was not as important as it was in C++. A hybrid language allows multiple programming styles; the reason C++ is hybrid is to support backward compatibility with the C language. Because C++ is a superset of the C language, it includes many of that language’s undesirable features, which can make some aspects of C++ overly complicated. The Java language assumes that you want to do only object-oriented programming. This means that before you can begin you must shift your mindset into an object-oriented world (unless it’s already there). The benefit of this initial effort is the ability to program in a language that is simpler to learn and to use than many other OOP languages. In this chapter you’ll see the basic components of a Java program and learn that (almost) everything in Java is an object. 2.1 You manipulate objects with referencesYou treat everything as an object, using a single consistent syntax. Although you treat everything as an object, the identifier you manipulate is actually a “reference” to an object[^1] You might imagine a television (the object) and a remote control (the reference). As long as you’re holding this reference, you have a connection to the television, but when someone says, “Change the channel” or “Lower the volume,” what you’re manipulating is the reference, which in turn modifies the object. If you want to move around the room and still control the television, you take the remote/reference with you, not the television. [^1]: This can be a flashpoint. There are those who say, “Clearly, it’s a pointer,” but this presumes an underlying implementation. Also, Java references are much more akin to C++ references than to pointers in their syntax. In the 1st edition of this book, I chose to invent a new term, “handle,” because C++ references and Java references have some important differences. I was coming out of C++ and did not want to confuse the C++ programmers whom I assumed would be the largest audience for Java. In the 2nd edition, I decided that “reference” was the more commonly used term, and that anyone changing from C++ would have a lot more to cope with than the terminology of references, so they might as well jump in with both feet. However, there are people who disagree even with the term “reference.” I read in one book where it was “completely wrong to say that Java supports pass by reference,” because Java object identifiers (according to that author) are actually “object references.” And (he goes on) everything is actually pass by value. So you’re not passing by reference, you’re “passing an object reference by value.” One could argue for the precision of such convoluted explanations, but I think my approach simplifies the understanding of the concept without hurting anything (well, the language lawyers may claim that I’m lying to you, but I’ll say that I’m providing an appropriate abstraction). 2.2 You must create all the objectsWhen you create a reference, you want to connect it with a new object. You do so, in general, with the new operator. The keyword new says, “Make me a new one of these objects.” 1String s = new String(&quot;asdf&quot;); Not only does this mean “Make me a new String,” but it also gives information about how to make the String by supplying an initial character string. 2.2.1 Where storage livesIt’s useful to visualize some aspects of how things are laid out while the program is running— in particular how memory is arranged. There are five different places to store data: Registers. This is the fastest storage because it exists in a place different from that of other storage: inside the processor. However, the number of registers is severely limited, so registers are allocated as they are needed. You don’t have direct control, nor do you see any evidence in your programs that registers even exist (C &amp; C++, on the other hand, allow you to suggest register allocation to the compiler). The stack. This lives in the general random-access memory (RAM) area, but has direct support from the processor via its stack pointer. The stack pointer is moved down to create new memory and moved up to release that memory. This is an extremely fast and efficient way to allocate storage, second only to registers. The Java system must know, while it is creating the program, the exact lifetime of all the items that are stored on the stack. This constraint places limits on the flexibility of your programs, so while some Java storage exists on the stack—in particular, object references—Java objects themselves are not placed on the stack. The heap. This is a general-purpose pool of memory (also in the RAM area) where all Java objects live. The nice thing about the heap is that, unlike the stack, the compiler doesn’t need to know how long that storage must stay on the heap. Thus, there’s a great deal of flexibility in using storage on the heap. Whenever you need an object, you simply write the code to create it by using new, and the storage is allocated on the heap when that code is executed. Of course there’s a price you pay for this flexibility: It may take more time to allocate and clean up heap storage than stack storage (if you even could create objects on the stack in Java, as you can in C++). Constant storage. Constant values are often placed directly in the program code, which is safe since they can never change. Sometimes constants are cordoned off by themselves so that they can be optionally placed in read-only memory (ROM), in embedded systems.[^2] [^2]: An example of this is the string pool. All literal strings and string-valued constant expressions are interned automatically and put into special static storage. Non-RAM storage. If data lives completely outside a program, it can exist while the program is not running, outside the control of the program. The two primary examples of this are streamed objects, in which objects are turned into streams of bytes, generally to be sent to another machine, and persistent objects, in which the objects are placed on disk so they will hold their state even when the program is terminated. The trick with these types of storage is turning the objects into something that can exist on the other medium, and yet can be resurrected into a regular RAMbased object when necessary. Java provides support for lightweight persistence, and mechanisms such as JDBC and Hibernate provide more sophisticated support for storing and retrieving object information in databases. 2.2.2 Special case:primitive typesOne group of types, which you’ll use quite often in your programming, gets special treatment. You can think of these as “primitive” types. The reason for the special treatment is that to create an object with new—especially a small, simple variable—isn’t very efficient, because new places objects on the heap. For these types Java falls back on the approach taken by C and C++. That is, instead of creating the variable by using new, an “automatic” variable is created that is not a reference. The variable holds the value directly, and it’s placed on the stack, so it’s much more efficient. Java determines the size of each primitive type. These sizes don’t change from one machine architecture to another as they do in most languages. This size invariance is one reason Java programs are more portable than programs in most other languages. Primitive type Size Minimum Maximum Wrapper type boolean — — — Boolean char 16 bits Unicode 0 Unicode (2^16) - 1 Character byte 8 bits -128 +127 Byte short 16 bits -2^15 +(2^15) - 1 Short int 32 bits -2^31 +(2^31) - 1 Integer long 64 bits -2^63 +(2^63) - 1 Long float 32 bits IEEE754 IEEE754 Float double 64 bits IEEE754 IEEE754 Double void — — — Void All numeric types are signed, so don’t look for unsigned types. The size of the boolean type is not explicitly specified; it is only defined to be able to take the literal values true or false. The “wrapper” classes for the primitive data types allow you to make a non-primitive object on the heap to represent that primitive type. For example: 12345678char c = ‘x’;Character ch = new Character(c);// Or you could also use:Character ch = new Character(‘x’);// Java SE5 autoboxing will automatically convert from a primitive to a wrapper type:Character ch = ‘x’; // and back:char c = ch; The reasons for wrapping primitives will be shown in a later chapter. High-precision numbersJava includes two classes for performing high-precision arithmetic: BigInteger and BigDecimal. Although these approximately fit into the same category as the “wrapper” classes, neither one has a primitive analogue. Both classes have methods that provide analogues for the operations that you perform on primitive types. That is, you can do anything with a BigInteger or BigDecimal that you can with an int or float, it’s just that you must use method calls instead of operators. Also, since there’s more involved, the operations will be slower. You’re exchanging speed for accuracy. BigInteger supports arbitrary-precision integers. This means that you can accurately represent integral values of any size without losing any information during operations. BigDecimal is for arbitrary-precision fixed-point numbers; you can use these for accurate monetary calculations, for example. Consult the JDK documentation for details about the constructors and methods you can call for these two classes. 2.2.3 Arrays in JavaOne of the primary goals of Java is safety, so many of the problems that plague programmers in C and C++ are not repeated in Java. A Java array is guaranteed to be initialized and cannot be accessed outside of its range. The range checking comes at the price of having a small amount of memory overhead on each array as well as verifying the index at run time, but the assumption is that the safety and increased productivity are worth the expense (and Java can sometimes optimize these operations). When you create an array of objects, you are really creating an array of references, and each of those references is automatically initialized to a special value with its own keyword: null. When Java sees null, it recognizes that the reference in question isn’t pointing to an object. You must assign an object to each reference before you use it, and if you try to use a reference that’s still null, the problem will be reported at run time. Thus, typical array errors are prevented in Java. You can also create an array of primitives. Again, the compiler guarantees initialization because it zeroes the memory for that array. 2.3 You never need to destroy an objectIn most programming languages, the concept of the lifetime of a variable occupies a significant portion of the programming effort. How long does the variable last? If you are supposed to destroy it, when should you? Confusion over variable lifetimes can lead to a lot of bugs, and this section shows how Java greatly simplifies the issue by doing all the cleanup work for you. 2.3.1 ScopingMost procedural languages have the concept of scope. This determines both the visibility and lifetime of the names defined within that scope. In C, C++, and Java, scope is determined by the placement of curly braces {}. So for example: 1234567891011{ int x = 12; // Only x available { int q = 96; // Both x &amp; q available } // Only x available // q is &quot;out of scope&quot;} A variable defined within a scope is available only to the end of that scope. Any text after a ‘//’ to the end of a line is a comment. Indentation makes Java code easier to read. Since Java is a free-form language, the extra spaces, tabs, and carriage returns do not affect the resulting program. You cannot do the following, even though it is legal in C and C++: 123456{ int x = 12; { int x = 96; // Illegal }} The compiler will announce that the variable x has already been defined. Thus the C and C++ ability to “hide” a variable in a larger scope is not allowed, because the Java designers thought that it led to confusing programs. 2.3.2 Scope of objectsJava objects do not have the same lifetimes as primitives. When you create a Java object using new, it hangs around past the end of the scope. Thus if you use: 123{ String s = new String(&quot;a string&quot;);} // End of scope the reference s vanishes at the end of the scope. However, the String object that s was pointing to is still occupying memory. In this bit of code, there is no way to access the object after the end of the scope, because the only reference to it is out of scope. In later chapters you’ll see how the reference to the object can be passed around and duplicated during the course of a program. It turns out that because objects created with new stay around for as long as you want them, a whole slew of C++ programming problems simply vanish in Java. In C++ you must not only make sure that the objects stay around for as long as you need them, you must also destroy the objects when you’re done with them. That brings up an interesting question. If Java leaves the objects lying around, what keeps them from filling up memory and halting your program? This is exactly the kind of problem that would occur in C++. This is where a bit of magic happens. Java has a garbage collector, which looks at all the objects that were created with new and figures out which ones are not being referenced anymore. Then it releases the memory for those objects, so the memory can be used for new objects. This means that you never need to worry about reclaiming memory yourself. You simply create objects, and when you no longer need them, they will go away by themselves. This eliminates a certain class of programming problem: the so-called “memory leak,” in which a programmer forgets to release memory. 2.4 Creating new data types: classIf everything is an object, what determines how a particular class of object looks and behaves? Put another way, what establishes the type of an object? You might expect there to be a keyword called “type,” and that certainly would have made sense. Historically, however, most objectoriented languages have used the keyword class to mean “I’m about to tell you what a new type of object looks like.” The class keyword (which is so common that it will not usually be boldfaced throughout this book) is followed by the name of the new type. For example: 123class ATypeName { /* Class body goes here */ } This introduces a new type, although the class body consists only of a comment (the stars and slashes and what is inside, which will be discussed later in this chapter), so there is not too much that you can do with it. However, you can create an object of this type using new: 1ATypeName a = new ATypeName(); But you cannot tell it to do much of anything (that is, you cannot send it any interesting messages) until you define some methods for it. 2.4.1 Fields and methodsWhen you define a class (and all you do in Java is define classes, make objects of those classes, and send messages to those objects), you can put two types of elements in your class: fields (sometimes called data members), and methods (sometimes called member functions). A field is an object of any type that you can talk to via its reference, or a primitive type. If it is a reference to an object, you must initialize that reference to connect it to an actual object (using new, as seen earlier). Each object keeps its own storage for its fields; ordinary fields are not shared among objects. Here is an example of a class with some fields: 12345class DataOnly { int i; double d; boolean b;} This class doesn’t do anything except hold data. But you can create an object like this: 1DataOnly data = new DataOnly(); You can assign values to the fields, but you must first know how to refer to a member of an object. This is accomplished by stating the name of the object reference, followed by a period (dot), followed by the name of the member inside the object: 1objectReference.member For example: 123data.i = 47;data.d = 1.1;data.b = false; It is also possible that your object might contain other objects that contain data you’d like to modify. For this, you just keep “connecting the dots.” For example: 1myPlane.leftTank.capacity = 100; The DataOnly class cannot do much of anything except hold data, because it has no methods. To understand how those work, you must first understand arguments and return values, which will be described shortly. 2.4.2 Default values for primitive membersWhen a primitive data type is a member of a class, it is guaranteed to get a default value if you do not initialize it: Primitive type Default boolean false char ‘\\u0000’ (null) byte (byte)0 short (short)0 int 0 long 0L float 0.0f double 0.0d The default values are only what Java guarantees when the variable is used as a member of a class. This ensures that member variables of primitive types will always be initialized (something C++ doesn’t do), reducing a source of bugs. However, this initial value may not be correct or even legal for the program you are writing. It’s best to always explicitly initialize your variables. This guarantee doesn’t apply to *local variables*—those that are not fields of a class. Thus, if within a method definition you have: 1int x; Then x will get some arbitrary value (as in C and C++); it will not automatically be initialized to zero. You are responsible for assigning an appropriate value before you use x. If you forget, Java definitely improves on C++: You get a compile-time error telling you the variable might not have been initialized. (Many C++ compilers will warn you about uninitialized variables, but in Java these are errors.) 2.5 Methods, arguments, and return valuesMethods in Java determine the messages an object can receive. The fundamental parts of a method are the name, the arguments, the return type, and the body. Here is the basic form: 123ReturnType methodName( /* Argument list */ ) { /* Method body */} The return type describes the value that comes back from the method after you call it. The argument list gives the types and names for the information that you want to pass into the method. The method name and argument list (which is called the signature of the method) uniquely identify that method. Methods in Java can be created only as part of a class. A method can be called only for an object[^3], and that object must be able to perform that method call. If you try to call the wrong method for an object, you’ll get an error message at compile time. You call a method for an object by naming the object followed by a period (dot), followed by the name of the method and its argument list, like this: [^3]: static methods, which you’ll learn about soon, can be called for the class, without an object. 1objectName.methodName(arg1, arg2, arg3); For example, suppose you have a method f( ) that takes no arguments and returns a value of type int. Then, if you have an object called a for which f( ) can be called, you can say this: 1int x = a.f(); The type of the return value must be compatible with the type of x. This act of calling a method is commonly referred to as sending a message to an object. In the preceding example, the message is f( ) and the object is a. Object-oriented programming is often summarized as simply “sending messages to objects.” 2.5.1 The argument listConsider a method that takes a String as its argument. Here is the definition, which must be placed within a class definition for it to be compiled: 123int storage(String s) { return s.length() * 2;} This method tells you how many bytes are required to hold the information in a particular String. (The size of each char in a String is 16 bits, or two bytes, to support Unicode characters) The argument is of type String and is called s. Once s is passed into the method, you can treat it just like any other object. (You can send messages to it.) Here, the length( ) method is called, which is one of the methods for Strings; it returns the number of characters in a string. You can also see the use of the return keyword, which does two things. First, it means “Leave the method, I’m done.” Second, if the method produces a value, that value is placed right after the return statement. In this case, the return value is produced by evaluating the expression s.length( ) * 2. You can return any type you want, but if you don’t want to return anything at all, you do so by indicating that the method returns void. Here are some examples: 1234boolean flag() { return true; }double naturalLogBase() { return 2.718; }void nothing() { return; }void nothing2() {} When the return type is void, then the return keyword is used only to exit the method, and is therefore unnecessary when you reach the end of the method. You can return from a method at any point, but if you’ve given a non-void return type, then the compiler will force you (with error messages) to return the appropriate type of value regardless of where you return. 2.6 Building a Java program2.6.1 Name visibilityTo produce an unambiguous name for a library, the Java creators want you to use your Internet domain name in reverse since domain names are guaranteed to be unique. Since my domain name is MindView.net, my utility library of foibles would be named net.mindview.utility.foibles. After your reversed domain name, the dots are intended to represent subdirectories. This mechanism means that all of your files automatically live in their own namespaces, and each class within a file must have a unique identifier—the language prevents name clashes for you. 2.6.2 Using other componentsThis is accomplished by telling the Java compiler exactly what classes you want by using the import keyword. import tells the compiler to bring in a package, which is a library of classes. (In other languages, a library could consist of functions and data as well as classes, but remember that all code in Java must be written inside a class.) Most of the time you’ll be using components from the standard Java libraries that come with your compiler. With these, you don’t need to worry about long, reversed domain names; you just say, for example: 1import java.util.ArrayList; to tell the compiler that you want to use Java’s ArrayList class. However, util contains a number of classes, and you might want to use several of them without declaring them all explicitly. This is easily accomplished by using ‘*****’ to indicate a wild card: 1import java.utils.*; It is more common to import a collection of classes in this manner than to import classes individually. 2.6.3 The static keywordThere are two situations in which this approach is not sufficient. One is if you want to have only a single piece of storage for a particular field, regardless of how many objects of that class are created, or even if no objects are created. The other is if you need a method that isn’t associated with any particular object of this class. That is, you need a method that you can call even if no objects are created. You can achieve both of these effects with the static keyword. When you say something is static, it means that particular field or method is not tied to any particular object instance of that class. So even if you’ve never created an object of that class you can call a static method or access a static field. With ordinary, non-static fields and methods, you must create an object and use that object to access the field or method, since non-static fields and methods must know the particular object they are working with[^4]. [^4]: Of course, since static methods don’t need any objects to be created before they are used, they cannot directly access non-static members or methods by simply calling those other members without referring to a named object (since nonstatic members and methods must be tied to a particular object). To make a field or method static, you simply place the keyword before the definition. For example, the following produces a static field and initializes it: 123class StaticTest { static int i = 47;} Now even if you make two StaticTest objects, there will still be only one piece of storage for StaticTest.i. Both objects will share the same i. Consider: 12StaticTest st1 = new StaticTest();StaticTest st2 = new StaticTest(); At this point, both st1.i and st2.i have the same value of 47 since they refer to the same piece of memory. There are two ways to refer to a static variable. As the preceding example indicates, you can name it via an object, by saying, for example, st2.i. You can also refer to it directly through its class name, something you cannot do with a non-static member. 1StaticTest.i++; The ++ operator adds one to the variable. At this point, both st1.i and st2.i will have the value 48. Using the class name is the preferred way to refer to a static variable. Not only does it emphasize that variable’s static nature, but in some cases it gives the compiler better opportunities for optimization. Similar logic applies to static methods. You can refer to a static method either through an object as you can with any method, or with the special additional syntax ClassName.method( ). You define a static method in a similar way: 123class Incrementable { static void increment() { StaticTest.i++; }} You can see that the Incrementable method increment( ) increments the static data i using the ++ operator. You can call increment( ) in the typical way, through an object: 12Incrementable sf = new Incrementable();sf.increment(); Or, because increment( ) is a static method, you can call it directly through its class: 1Incrementable.increment(); Although static, when applied to a field, definitely changes the way the data is created (one for each class versus the non-static one for each object), when applied to a method it’s not so dramatic. An important use of static for methods is to allow you to call that method without creating an object. This is essential, as you will see, in defining the main( ) method that is the entry point for running an application. 2.7 Your first Java programFinally, here’s the first complete program. It starts by printing a string, and then the date, using the Date class from the Java standard library. 12345678// HelloDate.javaimport java.util.*;public class HelloDate { public static void main(String[] args) { System.out.println(&quot;Hello, it’s: &quot;); System.out.println(new Date()); }} The name of the class is the same as the name of the file.When you’re creating a standalone program such as this one, one of the classes in the file must have the same name as the file. (The compiler complains if you don’t do this.) That class must contain a method called main( ) with this signature and return type: 1public static void main(String[] args) { The public keyword means that the method is available to the outside world (described in detail in the Access Control chapter). The argument to main( ) is an array of String objects. The args won’t be used in this program, but the Java compiler insists that they be there because they hold the arguments from the command line. The line that prints the date is quite interesting: 1System.out.println(new Date()); The argument is a Date object that is being created just to send its value (which is automatically converted to a String) to println( ). As soon as this statement is finished, that Date is unnecessary, and the garbage collector can come along and get it anytime. We don’t need to worry about cleaning it up. When you look at the JDK documentation from http://java.sun.com, you will see that System has many other methods that allow you to produce interesting effects (one of Java’s most powerful assets is its large set of standard libraries). For example: 12345678910//: object/ShowProperties.javapublic class ShowProperties { public static void main(String[] args) { System.getProperties().list(System.out); System.out.println(System.getProperty(&quot;user.name&quot;)); System.out.println( System.getProperty(&quot;java.library.path&quot;) ); }} ///:~ The first line in main( ) displays all of the “properties” from the system where you are running the program, so it gives you environment information. The list( ) method sends the results to its argument, System.out. You will see later in the book that you can send the results elsewhere, to a file, for example. You can also ask for a specific property—in this case, the user name and java.library.path. (The unusual comments at the beginning and end will be explained a little later.) Output(part): 123456789101112131415161718192021222324-- listing properties --java.specification.version=17sun.cpu.isalist=amd64sun.jnu.encoding=GBKjava.class.path=.java.vm.vendor=Oracle Corporationsun.arch.data.model=64java.specification.vendor=Oracle Corporationjava.version.date=2024-01-16java.home=C:\\Program Files\\Java\\jdk-17file.separator=\\java.vm.compressedOopsMode=Zero basedline.separator=sun.stdout.encoding=ms936java.vm.specification.vendor=Oracle Corporationjava.specification.name=Java Platform API Specificationuser.script=sun.management.compiler=HotSpot 64-Bit Tiered Compilersjava.vm.version=17.0.10+11-LTS-240sun.io.unicode.encoding=UnicodeLittlejava.class.version=61.0...... 2.7.1 Compiling and runningpass 2.8 Comments and embedded documentationThere are two types of comments in Java. The first is the traditional C-style comment that was inherited by C++. These comments begin with a /* and continue, possibly across many lines, until a */. Note that many programmers will begin each line of a continued comment with a *, so you’ll often see: 1234/* This is a comment * that continues * across lines */ Remember, however, that everything inside the /* and ***/** is ignored, so there’s no difference in saying: 12/* This is a comment thatcontinues across lines */ The second form of comment comes from C++. It is the single-line comment, which starts with a // and continues until the end of the line. This type of comment is convenient and commonly used because it’s easy. You don’t need to hunt on the keyboard to find / and then * (instead, you just press the same key twice), and you don’t need to close the comment. So you will often see: 1// This is a one-line comment 2.8.1 Comment documentationThe tool to extract the comments is called Javadoc, and it is part of the JDK installation. It uses some of the technology from the Java compiler to look for special comment tags that you put in your programs. It not only extracts the information marked by these tags, but it also pulls out the class name or method name that adjoins the comment. This way you can get away with the minimal amount of work to generate decent program documentation. The output of Javadoc is an HTML file that you can view with your Web browser. Thus, Javadoc allows you to create and maintain a single source file and automatically generate useful documentation. Because of Javadoc, you have a straightforward standard for creating documentation, so you can expect or even demand documentation with all Java libraries. 2.8.2 SyntaxAll of the Javadoc commands occur only within /** comments. The comments end with */ as usual. There are two primary ways to use Javadoc: Embed HTML or use “*doc tags*.” Standalone doc tags are commands that start with an @ and are placed at the beginning of a comment line. (A leading *, however, is ignored.) Inline doc tags can appear anywhere within a Javadoc comment and also start with an @ but are surrounded by curly braces. There are three “types” of comment documentation, which correspond to the element the comment precedes: class, field, or method. That is, a class comment appears right before the definition of a class, a field comment appears right in front of the definition of a field, and a method comment appears right in front of the definition of a method. As a simple example: 12345678//: object/Documentation1.java/** A class comment */public class Documentation1 { /** A field comment */ public int i; /** A method comment */ public void f() {}} ///:~ Note that Javadoc will process comment documentation for only public and protected members. Comments for private and package-access members (see the Access Control chapter) are ignored, and you’ll see no output. (However, you can use the -private flag to include private members as well.) This makes sense, since only public and protected members are available outside the file, which is the client programmer’s perspective. The output for the preceding code is an HTML file that has the same standard format as all the rest of the Java documentation, so users will be comfortable with the format and can easily navigate your classes. It’s worth entering the preceding code, sending it through Javadoc, and viewing the resulting HTML file to see the results. 2.8.3 Embedded HTMLJavadoc passes HTML commands through to the generated HTML document. This allows you full use of HTML; however, the primary motive is to let you format code, such as: 1234567//: object/Documentation2.java/*** &lt;pre&gt;* System.out.println(new Date());* &lt;/pre&gt;*////:~ You can also use HTML just as you would in any other Web document to format the regular text in your descriptions: 12345678910//: object/Documentation3.java/*** You can &lt;em&gt;even&lt;/em&gt; insert a list:* &lt;ol&gt;* &lt;li&gt; Item one* &lt;li&gt; Item two* &lt;li&gt; Item three* &lt;/ol&gt;*////:~ Note that within the documentation comment, asterisks at the beginning of a line are thrown away by Javadoc, along with leading spaces. Javadoc reformats everything so that it conforms to the standard documentation appearance. Don’t use headings such as Note that within the documentation comment, asterisks at the beginning of a line are thrown away by Javadoc, along with leading spaces. Javadoc reformats everything so that it conforms to the standard documentation appearance. Don’t use headings such as&lt;h1&gt; or &lt;hr&gt; as embedded HTML, because Javadoc inserts its own headings and yours will interfere with them. All types of comment documentation—class, field, and method—can support embedded HTML. 2.8.4 Some example tagsHere are some of the Javadoc tags available for code documentation. Before trying to do anything serious using Javadoc, you should consult the Javadoc reference in the JDK documentation to learn all the different ways that you can use Javadoc. 1. @seeThis tag allows you to refer to the documentation in other classes. Javadoc will generate HTML with the @see tags hyperlinked to the other documentation. The forms are: 123@see classname@see fully-qualified-classname@see fully-qualified-classname#method-name Each one adds a hyperlinked “See Also” entry to the generated documentation. Javadoc will not check the hyperlinks you give it to make sure they are valid. 2. {@link package.class#member label}Very similar to @see, except that it can be used inline and uses the label as the hyperlink text rather than “See Also.” 3. {@docRoot}Produces the relative path to the documentation root directory. Useful for explicit hyperlinking to pages in the documentation tree. 4. {@inheritDoc}Inherits the documentation from the nearest base class of this class into the current doc comment. 5. @versionThis is of the form: 1@version version-information in which version-information is any significant information you see fit to include. When the - version flag is placed on the Javadoc command line, the version information will be called out specially in the generated HTML documentation. 6. @authorThis is of the form: 1@author author-information in which author-information is, presumably, your name, but it could also include your email address or any other appropriate information. When the -author flag is placed on the Javadoc command line, the author information will be called out specially in the generated HTML documentation. 7. @sinceThis tag allows you to indicate the version of this code that began using a particular feature. You’ll see it appearing in the HTML Java documentation to indicate what version of the JDK is used. 8. @paramThis is used for method documentation, and is of the form: 1@param parameter-name description in which parameter-name is the identifier in the method parameter list, and description is text that can continue on subsequent lines. The description is considered finished when a new documentation tag is encountered. You can have any number of these, presumably one for each parameter. 9. @returnThis is used for method documentation, and looks like this: 1@return description in which description gives you the meaning of the return value. It can continue on subsequent lines. 10. @throwsAlthough only one exception object can emerge when you call a method, a particular method might produce any number of different types of exceptions, all of which need descriptions. So the form for the exception tag is: 1@throws fully-qualified-class-name description in which fully-qualified-class-name gives an unambiguous name of an exception class that’s defined somewhere, and description (which can continue on subsequent lines) tells you why this particular type of exception can emerge from the method call. 11. @deprecatedThis is used to indicate features that were superseded by an improved feature. The deprecated tag is a suggestion that you no longer use this particular feature, since sometime in the future it is likely to be removed. A method that is marked @deprecated causes the compiler to issue a warning if it is used. In Java SE5, the @deprecated Javadoc tag has been superseded by the @Deprecated annotation (you’ll learn about these in the Annotations chapter). 2.8.5 Documentation exampleHere is the first Java program again, this time with documentation comments added: 123456789101112131415161718192021//: object/HelloDate.javaimport java.util.*;/** The first Thinking in Java example program. * Displays a string and today’s date. * @author Bruce Eckel * @author www.MindView.net * @version 4.0*/public class HelloDate { /** Entry point to class &amp; application. * @param args array of string arguments * @throws exceptions No exceptions thrown */ public static void main(String[] args) { System.out.println(&quot;Hello, it’s: &quot;); System.out.println(new Date()); }} /* Output: (55% match)Hello, it’s:Wed Oct 05 14:39:36 MDT 2005*///:~ The first line of the file uses my own technique of putting a ‘//:’ as a special marker for the comment line containing the source file name. That line contains the path information to the file (object indicates this chapter) followed by the file name. The last line also finishes with a comment, and this one (‘///:~’) indicates the end of the source code listing, which allows it to be automatically updated into the text of this book after being checked with a compiler and executed. The /* Output: tag indicates the beginning of the output that will be generated by this file. In this form, it can be automatically tested to verify its accuracy. In this case, the (55% match) indicates to the testing system that the output will be fairly different from one run to the next so it should only expect a 55 percent correlation with the output shown here. Most examples in this book that produce output will contain the output in this commented form, so you can see the output and know that it is correct. 2.9 Coding styleThe style described in the Code Conventions for the Java Programming Language[^5] is to capitalize the first letter of a class name. If the class name consists of several words, they are run together (that is, you don’t use underscores to separate the names), and the first letter of each embedded word is capitalized, such as: [^5]: https://docs.oracle.com/javase/specs/jls/se23/html/index.html (原网站已不存在，该网站是读时添加的) To preserve space in this book and seminar presentations, not all of these guidelines could be followed, but you’ll see that the style I use here matches the Java standard as much as possible. 1class AllTheColorsOfTheRainbow { // ... This is sometimes called “camel-casing.” For almost everything else—methods, fields (member variables), and object reference names—the accepted style is just as it is for classes except that the first letter of the identifier is lowercase. For example: 1234567class AllTheColorsOfTheRainbow { int anIntegerRepresentingColors; void changeTheHueOfTheColor(int newHue) { // ... } // ...} The user must also type all these long names, so be merciful. The Java code you will see in the Sun libraries also follows the placement of open-and-close curly braces that you see used in this book. 2.10 SummaryThe goal of this chapter is just enough Java to understand how to write a simple program. You’ve also gotten an overview of the language and some of its basic ideas. However, the examples so far have all been of the form “Do this, then do that, then do something else.” The next two chapters will introduce the basic operators used in Java programming, and then show you how to control the flow of your program. 2.11 ExercisesExercise 1:Create a class containing an int and a char that are not initialized, and print their values to verify that Java performs default initialization. 12345678910public class exer_1 { public int testInt; public char testChar; public static void main(String[] args) { exer_1 obj = new exer_1(); System.out.println(obj.testInt); System.out.println(obj.testChar); }} output: 120 (null) Exercise 2:Following the HelloDate.java example in this chapter, create a “hello, world” program that simply displays that statement. You need only a single method in your class (the “main” one that gets executed when the program starts). Remember to make it static and to include the argument list, even though you don’t use the argument list. Compile the program with javac and run it using java. If you are using a different development environment than the JDK, learn how to compile and run programs in that environment. 123456public class exer_2 { public static void main(String[] args) { System.out.println(&quot;hello world&quot;); }} output: 1hello world Exercise 3:Find the code fragments involving ATypeName and turn them into a program that compiles and runs. 1234567891011public class exer_3 { int i; char c; public static void main(String[] args) { exer_3 obj = new exer_3(); System.out.println(&quot;int i : &quot; + obj.i); System.out.println(&quot;char i : &quot; + obj.c); }} output: 12int i : 0char i : Exercise 4:Turn the DataOnly code fragments into a program that compiles and runs. 12345678910111213141516171819202122232425public class exer_4 { int i; double d; boolean b; @Override public String toString() { return &quot;exer_4{&quot; + &quot;i=&quot; + i + &quot;, d=&quot; + d + &quot;, b=&quot; + b + '}'; } public static void main(String[] args) { exer_4 obj = new exer_4(); obj.i = 47; obj.d = 1.1; obj.b = false; System.out.println(&quot;exer_4:&quot; + obj); }} outputs: 1exer_4:exer_4{i=47, d=1.1, b=false} Exercise 5:Modify the previous exercise so that the values of the data in DataOnly are assigned to and printed in main( ). 同上 Exercise 6:Write a program that includes and calls the storage( ) method defined as a code fragment in this chapter. 1234567891011public class exer_6 { int storage(String s) { return s.length() * 2; } public static void main(String[] args) { exer_6 obj = new exer_6(); System.out.println(obj.storage(&quot;A&quot;)); }} outputs: 12 Exercise 7:Turn the Incrementable code fragments into a working program. 1234567891011121314class StaticTest { static int i = 47;}public class exer_7 { static void increment() { StaticTest.i++; } public static void main(String[] args) { exer_7.increment(); System.out.println(StaticTest.i); }} outputs: 148 Exercise 8:Write a program that demonstrates that, no matter how many objects you create of a particular class, there is only one instance of a particular static field in that class. pass Exercise 9:Write a program that demonstrates that autoboxing works for all the primitive types and their wrappers. pass Exercise 10:Write a program that prints three arguments taken from the command line. To do this, you’ll need to index into the command-line array of Strings. pass Exercise 11:Turn the AllTheColorsOfTheRainbow example into a program that compiles and runs. pass Exercise 12:Find the code for the second version of HelloDate.java, which is the simple comment documentation example. Execute Javadoc on the file and view the results with your Web browser. pass Exercise 13:Run Documentation1.java, Documentation2.java, and Documentation3.java through Javadoc. Verify the resulting documentation with your Web browser. pass Exercise 14:Add an HTML list of items to the documentation in the previous exercise. pass Exercise 15:Take the program in Exercise 2 and add comment documentation to it. Extract this comment documentation into an HTML file using Javadoc and view it with your Web browser. pass Exercise 16:In the Initialization &amp; Cleanup chapter, locate the Overloading.java example and add Javadoc documentation. Extract this comment documentation into an HTML file using Javadoc and view it with your Web browser. pass","link":"/2025/02/10/Thinking-in-Java/Thinking-in-Java-pt-2/"},{"title":"Operating System pt.01","text":"Write your Own Operating System in 1 hour1. 准备四个文件1234kernel.cpplinker.ldloader.sMakefile 2. 编写Makefile12345678910111213141516GPPPARAMS = -m32ASPARAMS = --32LDPARAMS = -melf_i386objects = loader.o kernel.o%.o: %.cpp g++ $(GPPPARAMS) -o $@ -c $&lt;%.o: %.s as $(ASPARAMS) -o $@ $&lt;mykernel.bin: linker.ld $(objects) ld $(LDPARAMS) -T $&lt; -o $@ $(objects)install: mykernel.bin sudo cp $&lt; /boot/mykernel.bin 这段Makefile用于编译和链接一个简单的内核项目。它定义了如何从C++源文件、汇编源文件生成目标文件，并将这些目标文件链接成一个内核二进制文件。最后，它还定义了一个install目标，用于将生成的内核二进制文件复制到系统的/boot目录下。 1. 变量定义1234GPPPARAMS = -m32ASPARAMS = --32LDPARAMS = -melf_i386objects = loader.o kernel.o GPPPARAMS = -m32: 定义了一个变量GPPPARAMS，用于指定g++编译器的参数。-m32表示生成32位的代码。 ASPARAMS = --32: 定义了一个变量ASPARAMS，用于指定as汇编器的参数。--32表示生成32位的汇编代码。 LDPARAMS = -melf_i386: 定义了一个变量LDPARAMS，用于指定ld链接器的参数。-melf_i386表示生成32位的ELF格式的可执行文件。 objects = loader.o kernel.o: 定义了一个变量objects，包含了需要链接的目标文件列表。 2.编译C++源文件12%.o: %.cpp g++ $(GPPPARAMS) -o $@ -c $&lt; %.o: %.cpp: 这是一个模式规则，表示如何从.cpp文件生成对应的.o目标文件。 g++ $(GPPPARAMS) -o $@ -c $&lt;: 使用g++编译器编译.cpp文件。$(GPPPARAMS)展开为-m32，-o $@指定输出文件名为目标文件（即.o文件），-c表示只编译不链接，$&lt;表示第一个依赖文件（即.cpp文件）。 3.编译汇编源文件12%.o: %.s as $(ASPARAMS) -o $@ $&lt; %.o: %.s: 这是一个模式规则，表示如何从.s汇编文件生成对应的.o目标文件。 as $(ASPARAMS) -o $@ $&lt;: 使用as汇编器编译.s文件。$(ASPARAMS)展开为--32，-o $@指定输出文件名为目标文件（即.o文件），$&lt;表示第一个依赖文件（即.s文件）。 4.链接目标文件生成内核二进制文件 12mykernel.bin: linker.ld $(objects) ld $(LDPARAMS) -T $&lt; -o $@ $(objects) mykernel.bin: linker.ld $(objects): 定义了一个目标mykernel.bin，它依赖于linker.ld链接脚本和$(objects)中的目标文件。 ld $(LDPARAMS) -T $&lt; -o $@ $(objects): 使用ld链接器将目标文件链接成mykernel.bin。$(LDPARAMS)展开为-melf_i386，-T $&lt;指定链接脚本为linker.ld，-o $@指定输出文件名为mykernel.bin，$(objects)是要链接的目标文件列表。 安装内核二进制文件: 12install: mykernel.bin sudo cp $&lt; /boot/mykernel.bin install: mykernel.bin: 定义了一个目标install，它依赖于mykernel.bin。 sudo cp $&lt; /boot/mykernel.bin: 使用sudo权限将mykernel.bin复制到/boot目录下。$&lt;表示第一个依赖文件（即mykernel.bin）。 3.kernel.cpp12345void kernelMain(){ printf(&quot;Hello World!\\n&quot;); while(1);} 由于缺少printf函数的定义导致编译失败 4.loader.s1234567891011121314151617181920212223242526272829.set MAGIC, 0x1badb002.set FLAGS, (1&lt;&lt;0 | 1&lt;&lt;1).set CHECKSUM, -(MAGIC + FLAGS).section .multiboot .long MAGIC .long FLAGS .long CHECKSUM.section .text.extern kernelMain.global loaderloader: mov $kernel_stack, %esp push %eax push %ebx call kernelMain_stop: cli hlt jmp _stop.section .bss.space 2*1024*1024; # 2MBkernel_stack: 这段程序是一个简单的操作系统引导程序，使用了Multiboot标准来确保与兼容Multiboot的引导加载程序（如GRUB）兼容。以下是对这段程序的详细解释： 1. 定义常量123.set MAGIC, 0x1badb002.set FLAGS, (1&lt;&lt;0 | 1&lt;&lt;1).set CHECKSUM, -(MAGIC + FLAGS) MAGIC：这是一个魔数，值为 0x1badb002，用于标识这是一个Multiboot兼容的内核。引导加载程序会检查这个值来确定内核是否遵循Multiboot标准。 FLAGS：这是一个标志位，用于指定内核需要的特性。1&lt;&lt;0 表示要求引导加载程序在加载内核时提供内存布局信息，1&lt;&lt;1 表示要求提供引导设备信息。 CHECKSUM：这是一个校验和，用于验证Multiboot头的完整性。它的值是 -(MAGIC + FLAGS)，确保 MAGIC + FLAGS + CHECKSUM 的结果为0。 2. Multiboot头1234.section .multiboot .long MAGIC .long FLAGS .long CHECKSUM .section .multiboot：定义了一个名为 .multiboot 的节，用于存放Multiboot头。 .long MAGIC、.long FLAGS、.long CHECKSUM：分别将 MAGIC、FLAGS 和 CHECKSUM 的值写入Multiboot头。引导加载程序会读取这些值来验证内核的兼容性。 3. 代码段1234567891011121314.section .text.extern kernelMain.global loaderloader: mov $kernel_stack, %esp push %eax push %ebx call kernelMain_stop: cli hlt jmp _stop .section .text：定义了一个名为 .text 的节，用于存放代码。 .extern kernelMain：声明 kernelMain 是一个外部函数，通常这是操作系统内核的主函数。 .global loader：声明 loader 是一个全局符号，表示操作系统的入口点。 loader:：这是操作系统的入口点。引导加载程序在加载内核后会跳转到这个标签处执行。 mov $kernel_stack, %esp：将栈指针 esp 设置为 kernel_stack 的地址，初始化栈。 push %eax 和 push %ebx：将寄存器 eax 和 ebx 的值压入栈中。根据Multiboot标准，eax 包含魔数 0x2BADB002，ebx 包含Multiboot信息结构的地址。 call kernelMain：调用 kernelMain 函数，进入操作系统内核的主逻辑。 _stop:：这是一个无限循环，用于在 kernelMain 返回后停止CPU的执行。 cli：禁用中断。 hlt：使CPU进入休眠状态。 jmp _stop：跳转到 _stop 标签，形成一个无限循环。 4. 未初始化数据段123.section .bss.space 2*1024*1024; # 2MBkernel_stack: .section .bss：定义了一个名为 .bss 的节，用于存放未初始化的数据。 .space 2*1024*1024：在 .bss 节中分配了2MB的空间，用于内核栈。 kernel_stack:：这是内核栈的起始地址，loader 标签处的代码将栈指针 esp 设置为这个地址。 总结这段程序是一个简单的操作系统引导程序，它遵循Multiboot标准，确保与兼容Multiboot的引导加载程序（如GRUB）兼容。程序的主要功能是初始化栈，保存引导加载程序传递的参数，并跳转到操作系统内核的主函数 kernelMain。如果 kernelMain 返回，程序将进入一个无限循环，停止CPU的执行。 5. 编写自己的printf函数1234567void printf(char* str) { unsigned short* VideoMemory = (unsigned short*) 0xB8000; for(int i = 0; str[i] != '\\0'; ++i) { VideoMemory[i] = (VideoMemory[i] &amp; 0xFF00) | str[i]; }} 这段代码实现了一个简单的 printf 函数，用于在文本模式下将字符串输出到屏幕。它直接操作显存，将字符写入显存地址 0xB8000，这是x86架构中文本模式下的显存起始地址。以下是对代码的详细解释： 1. 函数定义1void printf(char* str) { 这是一个名为 printf 的函数，接受一个 char* 类型的参数 str，表示要输出的字符串。 2. 显存地址1unsigned short* VideoMemory = (unsigned short*) 0xB8000; 0xB8000 是x86架构中文本模式下的显存起始地址。在文本模式下，屏幕上的每个字符由两个字节表示： 低字节：字符的ASCII码。 高字节：字符的属性（如颜色、背景等）。 VideoMemory 是一个指向 unsigned short 类型的指针，每个 unsigned short（16位）对应屏幕上的一个字符。 将 0xB8000 强制转换为 unsigned short* 类型，表示从该地址开始，每两个字节对应屏幕上的一个字符。 3. 循环输出字符123for(int i = 0; str[i] != '\\0'; ++i) { VideoMemory[i] = (VideoMemory[i] &amp; 0xFF00) | str[i];} 这是一个 for 循环，用于遍历字符串 str 中的每个字符，直到遇到字符串结束符 \\0。 对于每个字符 str[i]： VideoMemory[i] &amp; 0xFF00：保留当前显存位置的高字节（属性部分），清除低字节（字符部分）。 | str[i]：将字符 str[i] 的ASCII码写入低字节。 最终结果是将字符 str[i] 写入显存，同时保留原有的属性（如颜色）。 4. 显存写入的细节 在文本模式下，显存的每个字符由两个字节组成： 低字节：字符的ASCII码。 高字节：字符的属性（如前景色、背景色等）。 例如，如果 VideoMemory[i] 的当前值是 0x0720： 0x07 是属性（灰色前景，黑色背景）。 0x20 是字符（空格）。 如果 str[i] 是字符 A（ASCII码为 0x41），则： VideoMemory[i] = (0x0720 &amp; 0xFF00) | 0x41 的结果是 0x0741。 屏幕上的对应位置会显示字符 A，颜色为灰色前景，黑色背景。 6.linker.ld123456789101112131415161718192021222324252627282930313233343536ENTRY(loader)OUTPUT_FORMAT(elf32-i386)OUTPUT_ARCH(i386:i386)SECTIONS{ . = 0x0100000; .text : { *(.mutiboot) *(.text*) *(.rodata) } .data : { start_ctors = .; KEEP(*( .init_array )); KEEP(*(SORT_BY_INIT_PRIORITY( .init_array*))); end_ctors = .; *(.data) } .bss : { *(.bss) } /DISCARD/ : { *(.fini_array*) *(.comment) }} 这是一个链接器脚本（Linker Script），用于定义操作系统内核的内存布局和段（Section）的组织方式。它指定了内核的入口点、输出格式、架构以及各个段（如 .text、.data、.bss 等）的加载地址和顺序。以下是对脚本的详细解释： 1. 入口点和输出格式123ENTRY(loader)OUTPUT_FORMAT(elf32-i386)OUTPUT_ARCH(i386:i386) **ENTRY(loader)**：指定程序的入口点为 loader 符号。这是操作系统内核的启动代码，通常是引导加载程序（如 GRUB）跳转到的第一个函数。 **OUTPUT_FORMAT(elf32-i386)**：指定输出文件的格式为 32 位 ELF 格式，适用于 x86 架构。 **OUTPUT_ARCH(i386:i386 )**：指定输出文件的架构为 32 位 x86（i386）。 2. 内存布局123SECTIONS{ . = 0x0100000; SECTIONS：定义内存布局的起始。 . = 0x0100000：设置当前地址为 0x0100000（1 MB）。这是内核加载的起始地址，通常用于操作系统内核的加载地址。 3. .text 段123456.text :{ *(.mutiboot) *(.text*) *(.rodata)} .text：定义代码段（.text），包含可执行代码和只读数据。 ***(.mutiboot)**：包含所有输入文件中的 .multiboot 段（Multiboot 头）。 ***(.text*)**：包含所有输入文件中的代码段（.text 及其变体）。 ***(.rodata)**：包含所有输入文件中的只读数据段（.rodata）。 4. .data 段123456789.data :{ start_ctors = .; KEEP(*( .init_array )); KEEP(*(SORT_BY_INIT_PRIORITY( .init_array*))); end_ctors = .; *(.data)} .data：定义数据段（.data），包含已初始化的全局变量和静态变量。 **start_ctors = .;**：定义一个符号 start_ctors，表示构造函数（全局对象的构造函数）的起始地址。 **KEEP(*( .init_array ))**：保留所有输入文件中的 .init_array 段，用于存放全局对象的构造函数指针。 **KEEP(*(SORT_BY_INIT_PRIORITY( .init_array* )))**：保留所有输入文件中的 .init_array* 段，并按初始化优先级排序。 **end_ctors = .;**：定义一个符号 end_ctors，表示构造函数的结束地址。 ***(.data)**：包含所有输入文件中的数据段（.data）。 5. .bss 段1234.bss :{ *(.bss)} .bss：定义未初始化数据段（.bss），包含未初始化的全局变量和静态变量。 ***(.bss)**：包含所有输入文件中的 .bss 段。 6. 丢弃的段12345/DISCARD/ : { *(.fini_array*) *(.comment)} **/DISCARD/**：定义需要丢弃的段。 ***(.fini_array*)**：丢弃所有输入文件中的 .fini_array* 段（析构函数表）。 ***(.comment)**：丢弃所有输入文件中的 .comment 段（注释信息）。 7. 总结这个链接器脚本的主要功能是： 定义内核的入口点为 loader。 指定输出文件为 32 位 ELF 格式，适用于 x86 架构。 设置内核的加载地址为 0x0100000（1 MB）。 组织代码段（.text）、数据段（.data）和未初始化数据段（.bss）的内存布局。 保留构造函数表（.init_array），丢弃析构函数表（.fini_array）和注释信息（.comment）。 8. 关键点 Multiboot 头：.multiboot 段必须位于内核的最开始，以便引导加载程序（如 GRUB）能够正确识别内核。 构造函数和析构函数：.init_array 和 .fini_array 用于全局对象的构造和析构。操作系统内核通常不需要析构函数，因此丢弃 .fini_array。 内存布局：内核的加载地址和段的组织方式对操作系统的正常运行至关重要。 9. 示例内核的加载过程 引导加载程序（如 GRUB）将内核加载到 0x0100000 地址。 跳转到 loader 入口点，开始执行内核代码。 内核的代码段、数据段和未初始化数据段按照链接器脚本的定义进行布局。 全局对象的构造函数在启动时被调用（通过 .init_array）。 通过这个链接器脚本，操作系统内核可以正确地加载到内存中，并按照预期的布局运行。 7.kernelMain函数修改12345extern &quot;C&quot; void kernelMain(void* multiboot_structure, unsigned int magicnumber) { printf(&quot;Hello World!\\n&quot;); while(1);} extern &quot;C&quot; 是 C++ 中的一个关键字，用于指定函数使用 C 语言的链接规则（linkage）。它的主要作用是防止 C++ 编译器对函数名进行名称修饰（name mangling），从而确保函数名在编译后的目标文件中保持原样，以便与 C 代码或其他外部代码正确链接。 1. C++ 的名称修饰（Name Mangling）在 C++ 中，函数名在编译时会被编译器修饰（mangled），以支持函数重载和其他 C++ 特性。例如，一个函数 void foo(int) 可能会被修饰为 _Z3fooi。这种修饰后的名称包含了函数的参数类型和返回类型信息。 然而，C 语言没有名称修饰的概念。C 编译器会直接使用函数名作为符号名。因此，如果 C++ 代码需要与 C 代码或其他外部代码（如汇编代码或操作系统引导加载程序）交互，就需要使用 extern &quot;C&quot; 来禁用名称修饰。 2. extern &quot;C&quot; 的作用extern &quot;C&quot; 的作用是告诉 C++ 编译器： 按照 C 语言的规则处理函数的链接。 不进行名称修饰，直接使用函数名作为符号名。 8. 修改grub.cfg123456### BEGIN MYKERNEL ###menuentry 'My Operating System'{ mutiboot /boot/mykernel.bin boot}### END MYKERNEL ### 这段代码是一个 GRUB 引导加载程序的配置文件片段，用于定义一个名为 “My Operating System” 的菜单项，并指定如何加载和启动你的操作系统内核（mykernel.bin）。以下是对这段配置的详细解释： 1. 配置文件的作用GRUB（Grand Unified Bootloader）是一个常用的引导加载程序，用于加载操作系统内核。GRUB 的配置文件（通常是 /boot/grub/grub.cfg 或 /boot/grub2/grub.cfg）定义了启动菜单和启动选项。 这段代码是 GRUB 配置文件的一部分，用于添加一个自定义的启动项，加载你的操作系统内核。 2. 配置内容解析123456### BEGIN MYKERNEL ###menuentry 'My Operating System'{ multiboot /boot/mykernel.bin boot}### END MYKERNEL ### (1) ### BEGIN MYKERNEL ### 和 ### END MYKERNEL ### 这是注释，用于标记配置文件的开始和结束。GRUB 会忽略这些注释。 它们的作用是帮助开发者识别和区分不同的配置块。 (2) menuentry 'My Operating System' { ... } menuentry 是 GRUB 配置中的一个关键字，用于定义一个启动菜单项。 'My Operating System' 是菜单项的名称，显示在 GRUB 启动菜单中。 { ... } 中是菜单项的具体配置。 (3) multiboot /boot/mykernel.bin multiboot 是 GRUB 的一个命令，用于加载符合 Multiboot 规范 的内核文件。 /boot/mykernel.bin 是你的操作系统内核文件的路径。GRUB 会从文件系统中加载这个文件。 /boot/ 是内核文件通常存放的目录。 mykernel.bin 是你的内核文件名。 (4) boot boot 是 GRUB 的一个命令，用于启动已加载的内核。 执行 boot 后，GRUB 会将控制权交给内核，开始操作系统的启动过程。 9.Addendum12345678typedef void (*constructor)();extern &quot;C&quot; constructor start_ctors;extern &quot;C&quot; constructor end_ctors;extern &quot;C&quot; void callConstructors() { for(constructor* i = &amp;start_ctors; i != &amp;end_ctors; i++) { (*i)(); }} 12345678910111213.section .text.extern kernelMain.extern callConstructors.global loaderloader: mov $kernel_stack, %esp call callConstructors push %eax push %ebx call kernelMain 这段代码是操作系统内核启动代码的一部分，主要用于调用全局对象的构造函数（constructors），然后跳转到内核的主函数 kernelMain。以下是对代码的详细解释： 1. 构造函数指针类型1typedef void (*constructor)(); 定义了一个函数指针类型 constructor，指向一个没有参数和返回值的函数。 这种类型的函数通常用于全局对象的构造函数。 2. 外部符号声明12extern &quot;C&quot; constructor start_ctors;extern &quot;C&quot; constructor end_ctors; start_ctors 和 end_ctors 是两个外部符号，分别表示构造函数表的起始和结束地址。 这些符号通常在链接器脚本中定义，用于标记全局构造函数表的范围。 extern &quot;C&quot; 用于禁用 C++ 的名称修饰（name mangling），确保符号名在链接时保持一致。 3. 调用构造函数12345extern &quot;C&quot; void callConstructors() { for(constructor* i = &amp;start_ctors; i != &amp;end_ctors; i++) { (*i)(); }} callConstructors 是一个函数，用于遍历构造函数表并调用每个构造函数。 start_ctors 和 end_ctors 分别指向构造函数表的起始和结束地址。 通过 for 循环遍历构造函数表，依次调用每个构造函数。 4. 汇编代码12345678910111213.section .text.extern kernelMain.extern callConstructors.global loaderloader: mov $kernel_stack, %esp call callConstructors push %eax push %ebx call kernelMain (1) .section .text 定义代码段（.text），用于存放可执行代码。 (2) .extern kernelMain 和 .extern callConstructors 声明 kernelMain 和 callConstructors 是外部符号，分别表示内核的主函数和构造函数调用函数。 (3) .global loader 声明 loader 是一个全局符号，表示操作系统的入口点。 (4) loader: 这是操作系统的入口点，引导加载程序（如 GRUB）会跳转到这个标签处执行。 (5) mov $kernel_stack, %esp 将栈指针 esp 设置为 kernel_stack 的地址，初始化栈。 kernel_stack 是一个符号，通常在链接器脚本中定义，表示内核栈的起始地址。 (6) call callConstructors 调用 callConstructors 函数，遍历并调用所有全局对象的构造函数。 (7) push %eax 和 push %ebx 将寄存器 eax 和 ebx 的值压入栈中。 根据 Multiboot 规范，eax 包含魔数 0x2BADB002，ebx 包含 Multiboot 信息结构的地址。 (8) call kernelMain 调用 kernelMain 函数，进入操作系统内核的主逻辑。 5. 链接器脚本中的构造函数表在链接器脚本中，通常会定义 start_ctors 和 end_ctors 符号，用于标记构造函数表的范围。例如： 12345678910111213141516171819202122232425SECTIONS{ . = 0x0100000; .text : { *(.multiboot) *(.text*) } .data : { start_ctors = .; KEEP(*(.init_array)); KEEP(*(SORT_BY_INIT_PRIORITY(.init_array.*))); end_ctors = .; *(.data) } .bss : { *(.bss) }} start_ctors 和 end_ctors 分别指向 .init_array 段的起始和结束地址。 .init_array 段存放全局对象的构造函数指针。 6. 总结这段代码的主要功能是： 定义构造函数指针类型 constructor。 声明外部符号 start_ctors 和 end_ctors，表示构造函数表的范围。 实现 callConstructors 函数，遍历并调用所有全局对象的构造函数。 在汇编代码中，初始化栈，调用构造函数，然后跳转到内核的主函数 kernelMain。 通过这种方式，操作系统内核可以在启动时正确初始化全局对象，然后进入主逻辑。","link":"/2025/01/10/Write%20your%20own%20Operating%20System/Operating-System-pt-1/"},{"title":"goByExample pt.1","text":"Hello WorldGo by Example: hello-world 123456789package mainimport ( &quot;fmt&quot;)func main() { fmt.Println(&quot;Hello World&quot;)} To run the program, put the code in hello-world.go and use go run. Sometimes we’ll want to build our programs into binaries. We can do this using go build. We can then execute the built binary directly. Now that we can run and build basic Go programs, let’s learn more about the language. ValuesGo by Example: values 1234567891011121314151617181920212223package mainimport ( &quot;fmt&quot;)func main() { // &quot;golang&quot; fmt.Println(&quot;go&quot; + &quot;lang&quot;) // &quot;1 + 1 = 2&quot; fmt.Println(&quot;1 + 1 =&quot;, 1 + 1) // &quot;7.0 / 3.0 = 2.3333333333333335&quot; fmt.Println(&quot;7.0 / 3.0 =&quot;, 7.0 / 3.0) // false fmt.Println(true &amp;&amp; false) // true fmt.Println(true || false) // false fmt.Println(!true)} Go has various value types including strings, integers, floats, booleans, etc. Here are a few basic examples. VariablesGo by Example: Variables 1234567891011121314151617181920package mainimport &quot;fmt&quot;func main() { var a = &quot;initial&quot; fmt.Println(a) var b, c int= 1, 2 fmt.Println(b, c) var d = true fmt.Println(d) var e int fmt.Println(e) f := &quot;apple&quot; fmt.Println(f)} In Go, variables are explicitly (明确的) declared and used by the compiler to e.g. check type-correctness of function calls. var declares 1 or more variables. You can declare multiple variables at once. Go will infer the type of initialized variables. Variables declared without a corresponding initialization are zero-valued. For example, the zero value for an int is 0. The := syntax is shorthand for declaring and initializing a variable, e.g. for var f string = &quot;apple&quot; in this case. This syntax is only available inside functions. ConstantsGo by Example: Constants 123456789101112131415161718192021package mainimport ( &quot;fmt&quot; &quot;math&quot;)const s string = &quot;constant&quot;func main(){ fmt.Println(s) const n = 500000000 const d = 3e20 / n fmt.Println(d) fmt.Println(int64(d)) fmt.Println(math.Sin(n))} Go supports constants of character, string, boolean, and numeric (数学) values. const declares a constant value. A const statement can appear anywhere a var statement can. Constant expressions perform arithmetic (算数) with arbitrary precision (任意精度). A numeric constant has no type until it’s given one, such as by an explicit conversion (转换). A number can be given a type by using it in a context that requires one, such as a variable assignment or function call. For example, here math.Sin expects a float64. ForGo by Example: For 1234567891011121314151617181920212223242526272829303132package mainimport &quot;fmt&quot;func main() { i := 1 for i &lt;= 3 { fmt.Println(i) i = i + 1 } for j := 0; j &lt; 3; j++ { fmt.Println(j) } for i := range 3 { fmt.Println(&quot;range&quot;, i) } for { fmt.Println(&quot;loop&quot;) break } for n := range 6 { if n % 2 == 0 { continue } fmt.Println(n) }} for is Go’s only looping construct. Here are some basic types of for loops. 1st: The most basic type, with a single condition. 2nd: A classic initial/condition/after for loop. 3rd: Another way of accomplishing the basic “do this N times” iteration is range over an integer. 4th: for without a condition will loop repeatedly until you break out of the loop or return from the enclosing function.(the while in go) 5th: You can also continue to the next iteration of the loop. If/ElseGo by Example: If/Else 12345678910111213141516171819202122232425262728package mainimport &quot;fmt&quot;func main() { if 7%2 == 0 { fmt.Println(&quot;7 is even&quot;) } else { fmt.Println(&quot;7 is odd&quot;) } if 8%4 == 0 { fmt.Println(&quot;8 is divisible by 4&quot;) } if 8%2 == 0 || 7%2 == 0 { fmt.Println(&quot;either 8 or 7 are even&quot;) } if num := 9; num &lt; 0 { fmt.Println(num, &quot;is negative&quot;) } else if num &lt; 10 { fmt.Println(num, &quot;has 1 digit&quot;) } else { fmt.Println(num, &quot;has multiple digits&quot;) }} Branching with if and else in Go is straight-forward. You can have an if statement without an else. Logical operators like &amp;&amp; and || are often useful in conditions. A statement can precede conditionals; any variables declared in this statement are available in the current and all subsequent branches. 语句可以位于条件之前；此语句中声明的任何变量均可在当前分支和所有后续分支中使用。 Note that you don’t need parentheses (小括号) around conditions in Go, but that the braces (大括号) are required. There is no ternary if (三元运算符) in Go, so you’ll need to use a full if statement even for basic conditions. SwitchGo by Example: Switch 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package mainimport ( &quot;fmt&quot; &quot;time&quot;)func main() { i := 2 fmt.Print(&quot;Write &quot;, i, &quot; as &quot;) switch i { case 1: fmt.Println(&quot;one&quot;) case 2: fmt.Println(&quot;two&quot;) case 3: fmt.Println(&quot;three&quot;) } switch time.Now().Weekday() { case time.Saturday, time.Sunday: fmt.Println(&quot;It's the weekend&quot;) default: fmt.Println(&quot;It's a weekday&quot;) } t := time.Now() switch { case t.Hour() &lt; 12: fmt.Println(&quot;It's before noon&quot;) default: fmt.Println(&quot;It's after noon&quot;) } whatAmI := func(i interface{}) { switch t := i.(type) { case bool: fmt.Println(&quot;I'm a bool&quot;) case int: fmt.Println(&quot;I'm an int&quot;) default: fmt.Printf(&quot;Don't know type %T\\n&quot;, t) } } whatAmI(true) whatAmI(1) whatAmI(&quot;hey&quot;)} Switch statements express conditionals across many branches. You can use commas to separate multiple expressions in the same case statement. We use the optional default case in this example as well. switch without an expression is an alternate way to express if/else logic. Here we also show how the case expressions can be non-constants (case 表达式如何可以是非常量). A type switch compares types instead of values. You can use this to discover the type of an interface value. In this example, the variable t will have the type corresponding to its clause. ArraysGo by Example: Arrays 12345678910111213141516171819202122232425262728293031323334353637383940414243package mainimport &quot;fmt&quot;func main() { // a: 0 0 0 0 0 var a [5]int fmt.Println(&quot;emp:&quot;, a) // a: 0 0 0 0 100 a[4] = 100 fmt.Println(&quot;set:&quot;, a) fmt.Println(&quot;get:&quot;, a[4]) fmt.Println(&quot;len:&quot;, len(a)) // b: 1 2 3 4 5 b := [5]int{1, 2, 3, 4, 5} fmt.Println(&quot;dcl:&quot;, b) // b: 1 2 3 4 5 // len = 5 b = [...]int{1, 2, 3, 4, 5} fmt.Println(&quot;dcl:&quot;, b) b = [...]int{100, 3: 400, 500} fmt.Println(&quot;idx:&quot;, b) var twoD [2][3]int for i := 0; i &lt; 2; i++ { for j := 0; j &lt; 3; j++ { twoD[i][j] = i + j } } fmt.Println(&quot;2d: &quot;, twoD) twoD = [2][3]int{ {1, 2, 3}, {1, 2, 3}, } fmt.Println(&quot;2d: &quot;, twoD)} In Go, an array is a numbered sequence of elements of a specific length. In typical Go code, slices (the next) are much more common; arrays are useful in some special scenarios (场景). Here we create an array a that will hold exactly 5 ints. The type of elements and length are both part of the array’s type. By default an array is zero-valued, which for ints means 0s. We can set a value at an index using the array[index] = value syntax, and get a value with array[index]. The builtin len returns the length of an array. Use this syntax to declare and initialize an array in one line. You can also have the compiler count the number of elements for you with ... If you specify the index with :, the elements in between will be zeroed. 如果使用 : 指定索引，则其间的元素将被清零 b = [...]int{100, 3: 400, 500} [...]int 表示一个整数类型的数组，Go会根据初始化时的元素数量自动推断数组的大小。 100 赋值给数组的第一个位置，b[0] = 100。 3: 400 表示将数组的索引 3 设置为 400，即 b[3] = 400。这里使用了索引赋值的语法：索引:值，它将数组的特定位置初始化为给定的值。 500 会自动赋值给数组的最后一个位置，也就是 b[4] = 500。 Array types are one-dimensional, but you can compose types to build multi-dimensional data structures. You can create and initialize multi-dimensional arrays at once too. Note that arrays appear in the form [v1 v2 v3 ...] when printed with fmt.Println. SlicesGo by Example: Slices 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package mainimport ( &quot;fmt&quot; &quot;slices&quot;)func main() { var s []string fmt.Println(&quot;uninit:&quot;, s, s == nil, len(s) == 0) s = make([]string, 3) fmt.Println(&quot;emp:&quot;, s, &quot;len:&quot;, len(s), &quot;cap:&quot;, cap(s)) s[0] = &quot;a&quot; s[1] = &quot;b&quot; s[2] = &quot;c&quot; fmt.Println(&quot;set:&quot;, s) fmt.Println(&quot;get:&quot;, s[2]) fmt.Println(&quot;len:&quot;, len(s)) s = append(s, &quot;d&quot;) s = append(s, &quot;e&quot;, &quot;f&quot;) fmt.Println(&quot;apd:&quot;, s) c := make([]string, len(s)) copy(c, s) fmt.Println(&quot;cpy:&quot;, c) l := s[2:5] fmt.Println(&quot;sl1:&quot;, l) l = s[:5] fmt.Println(&quot;sl2:&quot;, l) l = s[2:] fmt.Println(&quot;sl3:&quot;, l) t := []string{&quot;g&quot;, &quot;h&quot;, &quot;i&quot;} fmt.Println(&quot;dcl:&quot;, t) t2 := []string{&quot;g&quot;, &quot;h&quot;, &quot;i&quot;} if slices.Equal(t, t2) { fmt.Println(&quot;t == t2&quot;) } twoD := make([][]int, 3) for i := 0; i &lt; 3; i++ { innerLen := i + 1 twoD[i] = make([]int, innerLen) for j := 0; j &lt; innerLen; j++ { twoD[i][j] = i + j } } fmt.Println(&quot;2d: &quot;, twoD)} Slices are an important data type in Go, giving a more powerful interface to sequences than arrays. Unlike arrays, slices are typed only by the elements they contain (not the number of elements). An uninitialized slice equals to nil and has length 0. To create an empty slice with non-zero length, use the builtin make. Here we make a slice of strings of length 3 (initially zero-valued). By default a new slice’s capacity is equal to its length; if we know the slice is going to grow ahead of time, it’s possible to pass a capacity explicitly as an additional parameter to make. We can set and get just like with arrays. len returns the length of the slice as expected. In addition to these basic operations, slices support several more that make them richer than arrays. One is the builtin append, which returns a slice containing one or more new values. Note that we need to accept a return value from append as we may get a new slice value. Slices can also be copy’d. Here we create an empty slice c of the same length as s and copy into c from s. Slices support a “slice” operator with the syntax slice[low:high]. For example, this gets a slice of the elements s[2], s[3], and s[4]. This slices up to (but excluding) s[5]. And this slices up from (and including) s[2]. We can declare and initialize a variable for slice in a single line as well. The slices package contains a number of useful utility functions for slices. Slices can be composed into multi-dimensional data structures. The length of the inner slices can vary, unlike with multi-dimensional arrays. Note that while slices are different types than arrays, they are rendered (呈现) similarly by fmt.Println. Check out this great blog post (maybe in another blog) by the Go team for more details on the design and implementation of slices in Go.Now that we’ve seen arrays and slices we’ll look at Go’s other key builtin data structure: maps. MapsGo by Example: Maps 1234567891011121314151617181920212223242526272829303132333435363738394041package mainimport ( &quot;fmt&quot; &quot;maps&quot;)func main() { m := make(map[string]int) m[&quot;k1&quot;] = 7 m[&quot;k2&quot;] = 13 fmt.Println(&quot;map:&quot;, m) v1 := m[&quot;k1&quot;] fmt.Println(&quot;v1:&quot;, v1) v3 := m[&quot;k3&quot;] fmt.Println(&quot;v3:&quot;, v3) fmt.Println(&quot;len:&quot;, len(m)) delete(m, &quot;k2&quot;) fmt.Println(&quot;map:&quot;, m) clear(m) fmt.Println(&quot;map:&quot;, m) _, prs := m[&quot;k2&quot;] fmt.Println(&quot;prs:&quot;, prs) n := map[string]int{&quot;foo&quot;: 1, &quot;bar&quot;: 2} fmt.Println(&quot;map:&quot;, n) n2 := map[string]int{&quot;foo&quot;: 1, &quot;bar&quot;: 2} if maps.Equal(n, n2) { fmt.Println(&quot;n == n2&quot;) }} Maps are Go’s built-in associative data type (内置关联数据类型) (sometimes called hashes or dicts in other languages). To create an empty map, use the builtin make: make(map[key-type]val-type). Set key/value pairs using typical name[key] = val syntax. Printing a map with e.g. fmt.Println will show all of its key/value pairs. Get a value for a key with name[key]. If the key doesn’t exist, the zero value (maybe another blog) of the value type is returned. The builtin len returns the number of key/value pairs when called on a map. The builtin delete removes key/value pairs from a map. To remove all key/value pairs from a map, use the clear builtin. The optional second return value when getting a value from a map indicates if the key was present in the map. This can be used to disambiguate between missing keys and keys with zero values like 0 or &quot;&quot;. Here we didn’t need the value itself, so we ignored it with the blank identifier _. 当从一个 map 中取值时，还有可以选择是否接收的第二个返回值，该值表明了 map 中是否存在这个键。 这可以用来消除 键不存在 和 键的值为零值 产生的歧义， 例如 0 和 &quot;&quot;。这里我们不需要值，所以用 空白标识符(blank identifier) _ 将其忽略。 You can also declare and initialize a new map in the same line with this syntax. The maps package contains a number of useful utility functions for maps. Note that maps appear in the form map[k:v k:v] when printed with fmt.Println. next part: goByExample pt.2","link":"/2024/12/21/goByExample/goByExample-pt-1/"},{"title":"goByExample pt.2","text":"FunctionsGo by Example: Functions 1234567891011121314151617181920package mainimport &quot;fmt&quot;func plus(a, b int) int { return a + b}func plusPlus(a, b, c int) int { return a + b + c}func main(){ res := plus(1, 2) fmt.Println(&quot;1 + 2 =&quot;, res) res = plusPlus(1, 2, 3) fmt.Println( &quot;1 + 2 + 3 =&quot;, res)} Functions are central (核心/中心) in Go. We’ll learn about functions with a few different examples. Here’s a function that takes two ints and returns their sum as an int. Go requires explicit returns, i.e. (即 ) it won’t automatically return the value of the last expression. When you have multiple consecutive (连续的 ) parameters of the same type, you may omit (省略 ) the type name for the like-typed (相同类型的 ) parameters up to the final parameter that declares the type. Call a function just as you’d expect, with name(args). There are several other features to Go functions. One is multiple return values, which we’ll look at next. 123goByExample&gt; go run .\\11.functions.go1 + 2 = 31 + 2 + 3 = 6 Multiple Return ValuesGo by Example: Multiple Return Values 1234567891011121314151617package mainimport &quot;fmt&quot;func vals() (int, int) { return 3, 7}func main() { a, b := vals() fmt.Println(a) fmt.Println(b) _, c := vals() fmt.Println(c)} Go has built-in support for multiple return values. This feature is used often in idiomatic Go (这个特性在 Go 语言中经常用到), for example to return both result and error values from a function. The (int, int) in this function signature shows that the function returns 2 ints. Here we use the 2 different return values from the call with multiple assignment (多赋值操作). If you only want a subset (子集 / 一部分) of the returned values, use the blank identifier _. Accepting a variable (可变的 ) number of arguments is another nice feature of Go functions; we’ll look at this next. 1234goByExample&gt; go run '.\\12.multiple return values.go'377 Variadic FunctionsGo by Example: Variadic Functions 12345678910111213141516171819202122package mainimport &quot;fmt&quot;func sum(nums ...int) { fmt.Print(nums, &quot; &quot;) total := 0 for _, num := range nums { total += num } fmt.Println(total)}func main() { sum(1, 2) sum(1, 2, 3) nums := []int{1, 2, 3, 4} sum(nums...)} Variadic functions can be called with any number of trailing (尾随 ) arguments. For example, fmt.Println is a common variadic function. Here’s a function that will take an arbitrary (随意的 ) number of ints as arguments. Within the function, the type of nums is equivalent to []int. We can call len(nums), iterate over it with range, etc. for _, num := range nums 解释： range 表达式通常返回两个值：一个是索引，另一个是值。在这段代码中 第一个值是数组 nums 中每个元素的索引。 第二个值是数组中相应位置的元素值。 Variadic functions can be called in the usual way with individual arguments. If you already have multiple args in a slice, apply them to a variadic function using func(slice...) like this. Another key aspect of functions in Go is their ability to form closures (闭包 ) , which we’ll look at next. 1234goByExample&gt; go run '.\\13.Variadic Functions.go' [1 2] 3[1 2 3] 6[1 2 3 4] 10 ClosuresGo by Example: Closures 1234567891011121314151617181920212223package mainimport &quot;fmt&quot;func intSeq() func() int { i := 0 return func() int { i++ return i }}func main() { nextInt := intSeq() fmt.Println(nextInt()) fmt.Println(nextInt()) fmt.Println(nextInt()) newInts := intSeq() fmt.Println(newInts())} Go supports anonymous functions, which can form closures. Anonymous functions are useful when you want to define a function inline without having to name it. This function intSeq returns another function, which we define anonymously in the body of intSeq. The returned function closes over the variable i to form a closure. We call intSeq, assigning the result (a function) to nextInt. This function value captures its own i value, which will be updated each time we call nextInt. See the effect of the closure by calling nextInt a few times. To confirm that the state is unique to that particular function, create and test a new one. The last feature of functions we’ll look at for now is recursion. 12345goByExample&gt; go run '.\\14.closures.go' 1231 RecursionGo by Example: Recursion 1234567891011121314151617181920212223242526package mainimport &quot;fmt&quot;func fact(n int) int { if n == 0 { return 1 } return n * fact(n-1)}func main() { fmt.Println(fact(7)) var fib func(n int) int fib = func(n int) int { if n &lt; 2 { return n } return fib(n-1) + fib(n-2) } fmt.Println(fib(7))} Go supports recursive functions. Here’s a classic example. This fact function calls itself until it reaches the base case of fact(0). Anonymous functions can also be recursive, but this requires explicitly declaring a variable with var to store the function before it’s defined. Since fib was previously declared in main, Go knows which function to call with fib here. 123goByExample&gt; go run '.\\15.recursion.go'504013 Range over Built-in TypesGo by Example: Range over Built-in Types 1234567891011121314151617181920212223242526272829303132package mainimport &quot;fmt&quot;func main() { nums := []int{2, 3, 4} sum := 0 for _, num := range nums { sum += num } fmt.Println(&quot;sum:&quot;, sum) for i, num := range nums { if num == 3 { fmt.Println(&quot;index:&quot;, i) } } kvs := map[string]string{&quot;a&quot;: &quot;apple&quot;, &quot;b&quot;: &quot;banana&quot;} for k, v := range kvs { fmt.Printf(&quot;%s -&gt; %s\\n&quot;, k, v) } for k := range kvs { fmt.Println(&quot;key:&quot;, k) } for i, c := range &quot;go&quot; { fmt.Println(i, c) }} range iterates over elements in a variety of built-in data structures. Let’s see how to use range with some of the data structures we’ve already learned. Here we use range to sum the numbers in a slice. Arrays work like this too. range on arrays and slices provides both the index and value for each entry. Above we didn’t need the index, so we ignored it with the blank identifier _. Sometimes we actually want the indexes though. range on map iterates over key/value pairs. range can also iterate over just the keys of a map. range on strings iterates over Unicode code points. The first value is the starting byte index of the rune and the second the rune itself. See [Strings and Runes](##Strings and Runes) for more details. 123456789goByExample&gt; go run '.\\16.Range over Built-in Types.go'sum: 9index: 1a -&gt; appleb -&gt; bananakey: akey: b0 1031 111 PointersGo by Example: Pointers 123456789101112131415161718192021222324package mainimport &quot;fmt&quot;func zeroval(ival int) { ival = 0}func zeroptr(iptr *int) { *iptr = 0}func main() { i := 1 fmt.Println(&quot;initial:&quot;, i) zeroval(i) fmt.Println(&quot;zeroval:&quot;, i) zeroptr(&amp;i) fmt.Println(&quot;zeroptr:&quot;, i) fmt.Println(&quot;pointer:&quot;, &amp;i)} Go supports pointers, allowing you to pass references to values and records within your program. We’ll show how pointers work in contrast to values with 2 functions: zeroval and zeroptr. zeroval has an int parameter, so arguments will be passed to it by value. zeroval will get a copy of ival distinct from the one in the calling function. zeroptr in contrast has an *int parameter, meaning that it takes an int pointer. The *iptr code in the function body then dereferences the pointer from its memory address to the current value at that address. Assigning a value to a dereferenced pointer changes the value at the referenced address. The &amp;i syntax gives the memory address of i, i.e. a pointer to i. Pointers can be printed too. zeroval doesn’t change the i in main, but zeroptr does because it has a reference to the memory address for that variable. 12345goByExample&gt; go run '.\\17.pointers.go' initial: 1zeroval: 1zeroptr: 0pointer: 0xc00000a0d8 Strings and RunesGo by Example: Strings and Runes 123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport ( &quot;fmt&quot; &quot;unicode/utf8&quot;)func main() { const s = &quot;สวัสดี&quot; fmt.Println(&quot;Len:&quot;, len(s)) for i := 0; i &lt; len(s); i++ { fmt.Printf(&quot;%x &quot;, s[i]) } fmt.Println() fmt.Println(&quot;Rune count:&quot;, utf8.RuneCountInString(s)) for idx, runeValue := range s { fmt.Printf(&quot;%#U starts at %d\\n&quot;, runeValue, idx) } fmt.Println(&quot;\\nUsing DecodeRuneInString&quot;) for i, w := 0, 0; i &lt; len(s); i += w { runeValue, width := utf8.DecodeRuneInString(s[i:]) fmt.Printf(&quot;%#U starts at %d\\n&quot;, runeValue, i) w = width examineRune(runeValue) }}func examineRune(r rune) { if r == 't' { fmt.Println(&quot;found tee&quot;) } else if r == 'ส' { fmt.Println(&quot;found so sua&quot;) }} A Go string is a read-only slice of bytes. The language and the standard library treat strings specially - as containers of text encoded in UTF-8. In other languages, strings are made of “characters”. In Go, the concept of a character is called a rune - it’s an integer that represents a Unicode code point. This Go blog post (maybe another blog) is a good introduction to the topic. s is a string assigned a literal value representing the word “hello” in the Thai language. Go string literals are UTF-8 encoded text. Since strings are equivalent to []byte, this will produce the length of the raw bytes stored within. 因为字符串等价于 []byte， 这会产生存储在其中的原始字节的长度。 Indexing into a string produces the raw byte values at each index. This loop generates the hex values of all the bytes that constitute the code points in s. To count how many runes are in a string, we can use the utf8 package. Note that the run-time of RuneCountInString depends on the size of the string, because it has to decode each UTF-8 rune sequentially. Some Thai characters are represented by UTF-8 code points that can span multiple bytes, so the result of this count may be surprising. 要计算字符串中有多少rune，我们可以使用utf8包。 注意RuneCountInString的运行时取决于字符串的大小。 因为它必须按顺序解码每个 UTF-8 rune。 一些泰语字符由多个 UTF-8 code point 表示， 所以这个计数的结果可能会令人惊讶。 A range loop handles strings specially and decodes each rune along with its offset in the string. We can achieve the same iteration by using the utf8.DecodeRuneInString function explicitly. This demonstrates passing a rune value to a function. Values enclosed in single quotes are rune literals. We can compare a rune value to a rune literal directly. 1234567891011121314151617181920goByExample&gt; go run '.\\18.Strings and Runes.go'Len: 18e0 b8 aa e0 b8 a7 e0 b8 b1 e0 b8 aa e0 b8 94 e0 b8 b5Rune count: 6U+0E2A 'ส' starts at 0U+0E27 'ว' starts at 3U+0E31 'ั' starts at 6U+0E2A 'ส' starts at 9U+0E14 'ด' starts at 12U+0E35 'ี' starts at 15Using DecodeRuneInStringU+0E2A 'ส' starts at 0found so suaU+0E27 'ว' starts at 3U+0E31 'ั' starts at 6U+0E2A 'ส' starts at 9found so suaU+0E14 'ด' starts at 12U+0E35 'ี' starts at 15 StructsGo by Example: Structs 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package mainimport &quot;fmt&quot;type person struct { name string age int}func newPerson(name string) *person { p := person{name: name} p.age = 42 return &amp;p}func main() { fmt.Println(person{&quot;Bob&quot;, 20}) fmt.Println(person{name: &quot;Alice&quot;, age: 30}) fmt.Println(person{name: &quot;Fred&quot;}) fmt.Println(&amp;person{name: &quot;Ann&quot;, age: 40}) fmt.Println(newPerson(&quot;Jon&quot;)) s := person{name: &quot;Sean&quot;, age: 50} fmt.Println(s.name) sp := &amp;s fmt.Println(sp.age) sp.age = 51 fmt.Println(sp.age) dog := struct { name string isGood bool }{ &quot;Rex&quot;, true, } fmt.Println(dog)} Go’s structs are typed collections of fields. They’re useful for grouping data together to form records. This person struct type has name and age fields. newPerson constructs a new person struct with the given name. Go is a garbage collected language; you can safely return a pointer to a local variable - it will only be cleaned up by the garbage collector when there are no active references to it. This syntax creates a new struct. You can name the fields when initializing a struct. Omitted fields will be zero-valued. An &amp; prefix yields a pointer to the struct. It’s idiomatic to encapsulate new struct creation in constructor functions 在构造函数中封装创建新的结构实例是一种习惯用法 Access struct fields with a dot. You can also use dots with struct pointers - the pointers are automatically dereferenced. Structs are mutable (可变的 ). If a struct type is only used for a single value, we don’t have to give it a name. The value can have an anonymous struct type. This technique is commonly used for table-driven tests (goByExample pt.8). 12345678910goByExample&gt; go run '.\\19.structs.go' {Bob 20}{Alice 30}{Fred 0}&amp;{Ann 40}&amp;{Jon 42}Sean5051{Rex true} MethodsGo by Example: Methods 1234567891011121314151617181920212223242526package mainimport &quot;fmt&quot;type rect struct { width, height int}func (r *rect) area() int { return r.width * r.height}func (r rect) perim() int { return 2*r.width + 2*r.height}func main() { r := rect{width: 10, height: 5} fmt.Println(&quot;area: &quot;, r.area()) fmt.Println(&quot;perim:&quot;, r.perim()) rp := &amp;r fmt.Println(&quot;area: &quot;, rp.area()) fmt.Println(&quot;perim:&quot;, rp.perim())} Go supports methods defined on struct types. This area method has a receiver type of *rect. Methods can be defined for either pointer or value receiver types. Here’s an example of a value receiver. Here we call the 2 methods defined for our struct. Go automatically handles conversion between values and pointers for method calls. You may want to use a pointer receiver type to avoid copying on method calls or to allow the method to mutate the receiving struct. Next we’ll look at Go’s mechanism (机制 ) for grouping and naming related sets of methods: interfaces. 12345goByExample&gt; go run '.\\20.Methods.go'area: 50perim: 30area: 50perim: 30","link":"/2024/12/23/goByExample/goByExample-pt-2/"},{"title":"goByExample pt.3","text":"InterfacesGo by Example: Interfaces 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package mainimport ( &quot;fmt&quot; &quot;math&quot;)type geometry interface { area() float64 perim() float64}type rect struct { width, height float64}type circle struct { radius float64}func (r rect) area() float64 { return r.width * r.height}func (r rect) perim() float64 { return 2*r.width + 2*r.height}func (c circle) area() float64 { return math.Pi * c.radius * c.radius}func (c circle) perim() float64 { return 2 * math.Pi * c.radius}func measure(g geometry) { fmt.Println(g) fmt.Println(g.area()) fmt.Println(g.perim())}func main() { r := rect{width: 3, height: 4} c := circle{radius: 5} measure(r) measure(c)} Interfaces are named collections of method signatures. Here’s a basic interface for geometric shapes. For our example we’ll implement this interface on rect and circle types. To implement an interface in Go, we just need to implement all the methods in the interface. Here we implement geometry on rects. The implementation for circles. If a variable has an interface type, then we can call methods that are in the named interface. Here’s a generic measure function taking advantage of this to work on any geometry. The circle and rect struct types both implement the geometry interface so we can use instances of these structs as arguments to measure. To learn more about Go’s interfaces, check out this great blog post (maybe another blog). 1234567goByExample&gt; go run .\\21.Interfaces.go{3 4}1214{5}78.5398163397448331.41592653589793 EnumsGo by Example: Enums 1234567891011121314151617181920212223242526272829303132333435363738394041424344package mainimport &quot;fmt&quot;type ServerState intconst ( StateIdle ServerState = iota StateConnected StateError StateRetrying)var stateName = map[ServerState]string{ StateIdle: &quot;idle&quot;, StateConnected: &quot;connected&quot;, StateError: &quot;error&quot;, StateRetrying: &quot;retrying&quot;,}func (ss ServerState) String() string { return stateName[ss]}func main() { ns := transition(StateIdle) fmt.Println(ns) ns2 := transition(ns) fmt.Println(ns2)}func transition(s ServerState) ServerState { switch s { case StateIdle: return StateConnected case StateConnected, StateRetrying: return StateIdle case StateError: return StateError default: panic(fmt.Errorf(&quot;unknown state: %s&quot;, s)) }} Enumerated types (enums) are a special case of sum types. An enum is a type that has a fixed number of possible values, each with a distinct name. Go doesn’t have an enum type as a distinct language feature, but enums are simple to implement using existing language idioms. Our enum type ServerState has an underlying int type. The possible values for ServerState are defined as constants. The special keyword iota generates successive (连续 ) constant values automatically; in this case 0, 1, 2 and so on. 特殊关键字 iota 自动生成连续的常量值；在本例中为 0、1、2 等等。 By implementing the fmt.Stringer interface, values of ServerState can be printed out or converted to strings. 通过实现 fmt.Stringer 接口，可以打印出 ServerState 的值或将其转换为字符串。 This can get cumbersome (繁琐 ) if there are many possible values. In such cases the [stringer tool](###stringer tool) can be used in conjunction with go:generate to automate the process. See this post(maybe another blog) for a longer explanation. 如果可能的值太多，这可能会变得很麻烦。在这种情况下，stringer 工具可以与 go:generate 结合使用来自动化该过程。 If we have a value of type int, we cannot pass it to transition - the compiler will complain about type mismatch. This provides some degree of compile-time type safety for enums. transition emulates a state transition for a server; it takes the existing state and returns a new state. Suppose we check some predicates here to determine the next state… 123goByExample&gt; go run .\\22.Enums.go connectedidle Struct EmbeddingGo by Example: Struct Embedding 123456789101112131415161718192021222324252627282930313233343536373839package mainimport &quot;fmt&quot;type base struct { num int}func (b base) describe() string { return fmt.Sprintf(&quot;base with num=%v&quot;, b.num)}type container struct { base str string}func main() { co := container{ base: base{ num: 1, }, str: &quot;some name&quot;, } fmt.Printf(&quot;co={num: %v, str: %v}\\n&quot;, co.num, co.str) fmt.Println(&quot;also num:&quot;, co.base.num) fmt.Println(&quot;describe:&quot;, co.describe()) type describer interface { describe() string } var d describer = co fmt.Println(&quot;describer:&quot;, d.describe())} Go supports embedding (嵌入 ) of structs and interfaces to express a more seamless (无缝的 ) composition of types. This is not to be confused with //go:embed which is a go directive introduced (go 指令 ) in Go version 1.16+ to embed files and folders into the application binary. A container embeds a base. An embedding looks like a field without a name. When creating structs with literals, we have to initialize the embedding explicitly; here the embedded type serves as the field name. We can access the base’s fields directly on co, e.g. co.num. Alternatively, we can spell out the full path using the embedded type name. Since container embeds base, the methods of base also become methods of a container. Here we invoke a method that was embedded from base directly on co. Embedding structs with methods may be used to bestow (赋予 ) interface implementations onto other structs. Here we see that a container now implements the describer interface because it embeds base. 12345goByExample&gt; go run '.\\23.Struct Embedding.go'co={num: 1, str: some name}also num: 1describe: base with num=1describer: base with num=1 Generics(泛型)Go by Example: Generics 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package mainimport &quot;fmt&quot;func SlicesIndex[S ~[]E, E comparable](s S, v E) int { for i := range s { if v == s[i] { return i } } return -1}type List[T any] struct { head, tail *element[T]}type element[T any] struct { next *element[T] val T}func (lst *List[T]) Push(v T) { if lst.tail == nil { lst.head = &amp;element[T]{val: v} lst.tail = lst.head } else { lst.tail.next = &amp;element[T]{val: v} lst.tail = lst.tail.next }}func (lst *List[T]) AllElements() []T { var elems []T for e := lst.head; e != nil; e = e.next { elems = append(elems, e.val) } return elems}func main() { var s = []string{&quot;foo&quot;, &quot;bar&quot;, &quot;zoo&quot;} fmt.Println(&quot;index of zoo:&quot;, SlicesIndex(s, &quot;zoo&quot;)) _ = SlicesIndex[[]string, string](s, &quot;zoo&quot;) lst := List[int]{} lst.Push(10) lst.Push(13) lst.Push(23) fmt.Println(&quot;list:&quot;, lst.AllElements())} Starting with version 1.18, Go has added support for generics, also known as type parameters. As an example of a generic function, SlicesIndex takes a slice of any comparable type and an element of that type and returns the index of the first occurrence of v in s, or -1 if not present. The comparable constraint means that we can compare values of this type with the == and != operators. For a more thorough explanation of this type signature, see this blog post (maybe another blog). Note that this function exists in the standard library as slices.Index. As an example of a generic type, List is a singly-linked list with values of any type. We can define methods on generic types just like we do on regular types, but we have to keep the type parameters in place. The type is List[T], not List. AllElements returns all the List elements as a slice. In the next example we’ll see a more idiomatic way of iterating over all elements of custom types. When invoking generic functions, we can often rely on type inference. Note that we don’t have to specify the types for S and E when calling SlicesIndex - the compiler infers them automatically. … though we could also specify them explicitly. 123goByExample&gt; go run '.\\24.generics.go' index of zoo: 2list: [10 13 23] Range over IteratorsGo by Example: Range over Iterators 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package mainimport ( &quot;fmt&quot; &quot;iter&quot; &quot;slices&quot;)type List[T any] struct { head, tail *element[T]}type element[T any] struct { next *element[T] val T}func (lst *List[T]) Push(v T) { if lst.tail == nil { lst.head = &amp;element[T]{val: v} lst.tail = lst.head } else { lst.tail.next = &amp;element[T]{val: v} lst.tail = lst.tail.next }}func (lst *List[T]) All() iter.Seq[T] { return func(yield func(T) bool) { for e := lst.head; e != nil; e = e.next { if !yield(e.val) { return } } }}func genFib() iter.Seq[int] { return func(yield func(int) bool) { a, b := 1, 1 for { if !yield(a) { return } a, b = b, a+b } }}func main() { lst := List[int]{} lst.Push(10) lst.Push(13) lst.Push(23) for e := range lst.All() { fmt.Println(e) } all := slices.Collect(lst.All()) fmt.Println(&quot;all:&quot;, all) for n := range genFib() { if n &gt;= 10 { break } fmt.Println(n) }} Starting with version 1.23, Go has added support for iterators, which lets us range over pretty much anything! Let’s look at the List type from the previous example again. In that example we had an AllElements method that returned a slice of all elements in the list. With Go iterators, we can do it better - as shown below. All returns an iterator, which in Go is a function with a special signature. The iterator function takes another function as a parameter, called yield by convention (but the name can be arbitrary). It will call yield for every element we want to iterate over, and note yield’s return value for a potential early termination. 迭代器函数将另一个函数作为参数，按照惯例称为yield（但名称可以任意）。它将为我们想要迭代的每个元素调用yield，并记录yield的返回值以防可能提前终止。 Iteration doesn’t require an underlying data structure, and doesn’t even have to be finite! Here’s a function returning an iterator over Fibonacci numbers: it keeps running as long as yield keeps returning true. 迭代不需要底层数据结构，甚至不必是有限的！这是一个返回斐波那契数列迭代器的函数：只要yield一直返回true，它就会一直运行。 Since List.All returns an iterator, we can use it in a regular range loop. Packages like slices have a number of useful functions to work with iterators. For example, Collect takes any iterator and collects all its values into a slice. Once the loop hits break or an early return, the yield function passed to the iterator will return false. 1234567891011goByExample&gt; go run '.\\25.Range over Iterators.go'101323all: [10 13 23]112358 ErrorsGo by Example: Errors 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package mainimport ( &quot;errors&quot; &quot;fmt&quot;)func f(arg int) (int, error) { if arg == 42 { return -1, errors.New(&quot;can't work with 42&quot;) } return arg + 3, nil}var ErrOutOfTea = fmt.Errorf(&quot;no more tea available&quot;)var ErrPower = fmt.Errorf(&quot;can't boil water&quot;)func makeTea(arg int) error { if arg == 2 { return ErrOutOfTea } else if arg == 4 { return fmt.Errorf(&quot;making tea: %w&quot;, ErrPower) } return nil}func main() { for _, i := range []int{7, 42} { if r, e := f(i); e != nil { fmt.Println(&quot;f failed:&quot;, e) } else { fmt.Println(&quot;f worked:&quot;, r) } } for i := range 5 { if err := makeTea(i); err != nil { if errors.Is(err, ErrOutOfTea) { fmt.Println(&quot;We should buy new tea!&quot;) } else if errors.Is(err, ErrPower) { fmt.Println(&quot;Now it is dark.&quot;) } else { fmt.Printf(&quot;unknown error: %s\\n&quot;, err) } continue } fmt.Println(&quot;Tea is ready!&quot;) }} In Go it’s idiomatic to communicate errors via an explicit, separate return value. This contrasts with the exceptions used in languages like Java and Ruby and the overloaded single result / error value sometimes used in C. Go’s approach makes it easy to see which functions return errors and to handle them using the same language constructs employed for other, non-error tasks. 扩展：fmt.Stringer官方文档：fmt.Stringer type Stringer : 123type Stringer interface { String() string} Stringer is implemented by any value that has a String method, which defines the “native” format for that value. The String method is used to print values passed as an operand to any format that accepts a string or to an unformatted printer such as Print. Example: 12345678910111213141516171819202122232425package mainimport ( &quot;fmt&quot;)// Animal has a Name and an Age to represent an animal.type Animal struct { Name string Age uint}// String makes Animal satisfy the Stringer interface.func (a Animal) String() string { return fmt.Sprintf(&quot;%v (%d)&quot;, a.Name, a.Age)}func main() { a := Animal{ Name: &quot;Gopher&quot;, Age: 2, } fmt.Println(a)} 123Output:Gopher (2) stringer toolStringer is a tool to automate the creation of methods that satisfy the fmt.Stringer interface. Given the name of a (signed or unsigned) integer type T that has constants defined, stringer will create a new self-contained Go source file implementing 1func (t T) String() string The file is created in the same package and directory as the package that defines T. It has helpful defaults designed for use with go generate. Stringer works best with constants that are consecutive values such as created using iota, but creates good code regardless. In the future it might also provide custom support for constant sets that are bit patterns. For example, given this snippet, 1234567891011package painkillertype Pill intconst ( Placebo Pill = iota Aspirin Ibuprofen Paracetamol Acetaminophen = Paracetamol) running this command 1stringer -type=Pill in the same directory will create the file pill_string.go, in package painkiller, containing a definition of 1func (Pill) String() string That method will translate the value of a Pill constant to the string representation of the respective constant name, so that the call fmt.Print(painkiller.Aspirin) will print the string “Aspirin”. Typically this process would be run using go generate, like this: 1//go:generate stringer -type=Pill If multiple constants have the same value, the lexically (词汇上 ) first matching name will be used (in the example, Acetaminophen will print as “Paracetamol”). With no arguments, it processes the package in the current directory. Otherwise, the arguments must name a single directory holding a Go package or a set of Go source files that represent a single Go package. The -type flag accepts a comma-separated list of types so a single run can generate methods for multiple types. The default output file is t_string.go, where t is the lower-cased name of the first type listed. It can be overridden with the -output flag. Types can also be declared in tests, in which case type declarations in the non-test package or its test variant are preferred over types defined in the package with suffix “_test”. The default output file for type declarations in tests is t_string_test.go with t picked as above. The -linecomment flag tells stringer to generate the text of any line comment, trimmed of leading spaces (去掉前导空格 ), instead of the constant name. For instance, if the constants above had a Pill prefix, one could write 1PillAspirin // Aspirin to suppress it in the output. slices.Indexfunc Index 1func Index[S ~[]E, E comparable](s S, v E) int Index returns the index of the first occurrence of v in s, or -1 if not present. Example: 123456789101112package mainimport ( &quot;fmt&quot; &quot;slices&quot;)func main() { numbers := []int{0, 42, 8} fmt.Println(slices.Index(numbers, 8)) fmt.Println(slices.Index(numbers, 7))} 1234Output:2-1","link":"/2024/12/24/goByExample/goByExample-pt-3/"},{"title":"Reading 1-Static Checking","text":"ObjectivesToday’s class has two topics: static typing the big three properties of good software Hailstone sequenceAs a running example, we’re going to explore the hailstone sequence, which is defined as follows. Starting with a number n, the next number in the sequence is n/2 if n is even, or 3n+1 if n is odd. The sequence ends when it reaches 1. Here are some examples: 1234562, 13, 10, 5, 16, 8, 4, 2, 14, 2, 12n, 2n-1 , … , 4, 2, 15, 16, 8, 4, 2, 17, 22, 11, 34, 17, 52, 26, 13, 40, …? (where does this stop?) Because of the odd-number rule, the sequence may bounce up and down before decreasing to 1. It’s conjectured that all hailstones eventually fall to the ground – i.e., the hailstone sequence reaches 1 for all starting n – but that’s still an open question. Why is it called a hailstone sequence? Because hailstones form in clouds by bouncing up and down, until they eventually build enough weight to fall to earth. Computing hailstonesHere’s some code for computing and printing the hailstone sequence for some starting n. We’ll write JavaScript and Python versions of the code side by side for comparison: 1234567891011# Pythonn = 3while n != 1: print(n) if n % 2 == 0: n = n / 2 else: n = 3 * n + 1print(n) 1234567891011// JavaScript (or TypeScript, this code works in both languages)let n = 3;while (n !== 1) { console.log(n); if (n % 2 === 0) { n = n / 2; } else { n = 3 * n + 1; }}console.log(n); The basic semantics of expressions and statements in JavaScript are very similar to Python. The while and if keywords behave the same, for example. A few points of syntax are worth noting here: JavaScript requires parentheses around the conditions of the if and while. A JavaScript statement ends with a semicolon. This is technically optional, because JavaScript has rules for automatically inserting a semicolon at the end of a line. But these rules have obscure pitfalls that can lead to unexpected behavior and bugs, so always using semicolons is a good practice. JavaScript uses curly braces around blocks, instead of indentation. But you should still always indent the block, even though JavaScript won’t pay any attention to your extra spaces. Programming is a form of communication, and you’re communicating not only to the compiler, but to human beings. Humans need that indentation. We’ll come back to this later. You may also notice that the JavaScript version uses === and !== where the Python uses == and !=. That’s because == and != in JavaScript do a variety of automatic type conversions to try to make the values on the lefthand side and righthand side comparable to each other. For example, 0 == &quot;&quot; is true in JavaScript, which is surprising and confusing. The triple-equals versions of these operators are much safer and more predictable: 0 === &quot;&quot; is false. Good JavaScript programmers will only use === and !==. This is a potential pitfall when moving from Python. TypesBut we are not using JavaScript in this class, strictly speaking. We are using TypeScript, which extends JavaScript with the ability to declare types in the program. In this case, we can specify that the variable n has type number: 1let n: number = 3; A type is a set of values, along with operations that can be performed on those values. TypeScript has several built-in types, including: number, which represents both integers and floating-point numbers boolean, which represents true or false string, which represents a sequence of characters Operations are functions that take inputs and produce outputs (and sometimes change the values themselves). The syntax for operations varies, but we still think of them as functions no matter how they’re written. Here are several different syntaxes for an operation in Python or TypeScript: As an operator. For example, a + b invokes the operation + : number × number → number.(In this notation: + is the name of the operation, number × number before the arrow gives the types of the two inputs, and number after the arrow gives the type of the output.) As a function. For example, Math.sin(theta) calls the operation sin: number → number. Here, Math is not an object. It’s the class that contains the sin function. As a method of an object. For example, str1.concat(str2) calls the operation concat: string × string → string. As a property of an object. For example, str.length calls the operation length: string → number. Note the lack of parentheses after str.length. Contrast TypeScript’s str.length with Python’s len(str). It’s the same operation in both languages – taking a string and returning its length – but it just uses different syntax. Some operations are overloaded in the sense that the same operation name is used for functions that take different types of arguments. The operator + is overloaded in TypeScript. With numbers, 5 + 3 naturally produces 8. But when + is used on strings, it does string concatenation instead, so “5” + “3” produces “53”. Overloading is not limited to operators like +; methods and functions can also be overloaded. Most programming languages have some degree of overloading. Static typingTypeScript is a statically-typed language. Variables can be assigned a type at compile time (before the program runs), and the compiler can therefore deduce the types of expressions using those variables. If a and b are declared as number, then the compiler concludes that a+b is also number. The VS Code environment does this while you’re writing the code, in fact, so you find out about many errors while you’re still typing. JavaScript and Python, by contrast, are dynamically-typed languages, because this kind of checking is deferred until runtime (while the program is running). Static typing is a particular kind of static checking, which means checking for bugs at compile time. Bugs are the bane of programming. Many of the ideas in this course are aimed at eliminating bugs from your code, and static checking is the first idea that we’ve seen for this. Static typing prevents a large class of bugs from infecting your program: to be precise, bugs caused by applying an operation to the wrong types of arguments. If you write a broken line of code like: 1&quot;5&quot; * &quot;6&quot; that tries to multiply two strings, then static typing will catch this error while you’re still programming, rather than waiting until the line is reached during execution. Static types at compile time, dynamic types at runtimeStatic type declarations are used at compile time to perform static checking. Adding static types doesn’t change the fact that the behavior of our program at runtime is driven by actual values. In the hailstone program, if we declare let n: number = 3; to specify the static type of n, the initial value at runtime is still 3, not any other number. We’ll need to keep this distinction in mind when our static type encompasses more than one possible runtime type: a variable of static type Animal (let’s imagine) might really be a Dog or a Fish or a SpottedOwl at runtime. In fact, TypeScript (like many statically-typed languages) throws away the static type information after compilation. What does the TypeScript compiler generate? JavaScript! Here is a bit of code in well-typed TypeScript, and the generated JavaScript: 12345// TypeScript to compilefunction hello(name: string): string { return 'Hi, ' + name;}let greeting: string = hello('types'); 12345// JavaScript generatedfunction hello(name) { return 'Hi, ' + name;}let greeting = hello('types'); Support for static typing in dynamically-typed languagesJust like TypeScript adds static typing to the dynamically-typed JavaScript language, Python also has extensions that support static typing. Python 3.5 and later allow you to declare type hints in the code, e.g.: 123# Python function declared with type hintsdef hello(name:str)-&gt;str: return 'Hi, ' + name The declared types can be used by a checker like Mypy to find type errors statically without having to run the code. The addition of static types to dynamically-typed languages like Python and JavaScript reflects a widespread belief among software engineers that the use of static types is essential to building and maintaining a large software system. The rest of this reading, and in fact this entire course, will show reasons for this belief. Adding static types to a dynamically-typed language enables a programming approach called gradual typing, in which some parts of the code have static type declarations and other parts omit them. Gradual typing can provide a smoother path for a small experimental prototype to grow into a large, stable, maintainable system. Static checking, dynamic checking, no checkingIt’s useful to think about three kinds of automatic checking that a language can provide: Static checking: the bug is found automatically before the program even runs. Dynamic checking: the bug is found automatically when the code is executed. No checking: the language doesn’t help you find the error at all. You have to watch for it yourself, or end up with wrong answers. Needless to say, catching a bug statically is better than catching it dynamically, and catching it dynamically is better than not catching it at all. Here are some rules of thumb for what errors you can expect to be caught at each of these times. Static checking can catch: syntax errors, like extra punctuation or spurious words. Even dynamically-typed languages like Python do this kind of static checking. If you have an indentation error in your Python program, you’ll find out before the program starts running. misspelled names, like Math.sine(2). (The correct spelling is sin.) wrong number of arguments, like Math.sin(30, 20). wrong argument types, like Math.sin(&quot;30&quot;). wrong return types, like return &quot;30&quot;; from a function that’s declared to return a number. Dynamic checking can catch, for example: specific illegal argument values. For example, the expression x/y is erroneous when y is zero, but well-defined for other values of y. So divide-by-zero is not a static error, because you can’t know until runtime whether y is actually zero or not. But divide-by-zero can be caught as a dynamic error; Python throws ZeroDivisionError when it happens. illegal conversions, i.e., when the specific value can’t be converted to or represented in the target type. For example, in Python, int(&quot;hello&quot;) throws ValueError, because the string &quot;hello&quot; cannot be parsed as a decimal integer. out-of-range indices, e.g., using a too-large index on a string or array. In Python, &quot;hello&quot;[13] throws IndexError. calling a method on a bad object reference (None in Python, or undefined or null in TypeScript). Static checking can detect errors related to the type of a variable – the set of values it is allowed to have, which is known at compile time in statically-typed languages like TypeScript – but is generally unable to find errors related to a specific value from that type. But you may have noticed that the dynamic-checking examples above mostly came from Python. What about dynamic checking in TypeScript? TypeScript does the static checking, but its runtime behavior is entirely provided by JavaScript, and JavaScript’s designers decided to do no checking for many of these cases. So, for example, when a string or array index is out of bounds, JavaScript returns the special value undefined, rather than throwing an error as Python would. When dividing by zero, JavaScript returns a special value representing infinity, rather than throwing an error. No checking makes bugs harder to find than they might otherwise be, because the special values can propagate through further computations until a failure finally occurs, much farther away from the original mistake in the code. Surprise: number is not a true numberAnother trap in TypeScript – which is shared by many other programming languages – is that its numeric type has corner cases that do not behave like the integers and real numbers we’re used to. As a result, some errors that really should be dynamically checked are not checked at all. Here are some of the traps hiding in TypeScript: Limited precision for integers. All numbers in TypeScript are floating-point numbers, which means that large-magnitude integers can only be represented approximately. Integers from -253 to 253 can be represented exactly, but beyond that range, the floating-point representation preserves only the most-significant binary digits of the number. What does that mean if you have, say, 260 and try to increment it? You get the same number back again: 2**60 + 1 === 2**60 in TypeScript. So this is an example of where what we might have hoped would be a dynamic error (because the computation we wrote can’t be represented correctly) produces the wrong answer instead. These limits on representable integers are available as the built-in constants Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER. Special values. The number type has several special values that aren’t real numbers: Number.NaN (which stands for “Not a Number”), Number.POSITIVE_INFINITY, and Number.NEGATIVE_INFINITY. So when you apply certain operations to a number that you’d expect to produce dynamic errors, like dividing by zero or taking the square root of a negative number, you will get one of these special values instead. If you keep computing with it, you’ll end up with a bad final answer. Overflow and underflow. Very large and very small numbers can’t be represented either, beyond a certain point. Number.MAX_VALUE is roughly 10308, and Number.MIN_VALUE is roughly 10-324. What happens when you do a computation whose answer is too large or too small (too close to zero) to fit in that finite range? The computation quietly overflows (becoming POSITIVE_INFINITY or NEGATIVE_INFINITY) or underflows (becoming zero). ArraysLet’s change our hailstone computation so that it stores the sequence in a data structure, instead of just printing it out. For that, we can use an array type. Arrays are variable-length sequences of another type, similar to Python lists. Here’s how we can declare an array of numbers and make an empty array value: 1let array: Array&lt;number&gt; = []; And here are some of its operations, which are very similar to Python: indexing: array[2] assignment: array[2] = 0 length: array.length add an element to the end: array.push(5) remove an element from the end: array.pop() You can see all the operations of Array in the Mozilla Developer Network (MDN) documentation; find it with a web search like “mdn array”. Get to know the MDN docs, they’re your friend. Here’s the hailstone code written with arrays: 1234567891011let array: Array&lt;number&gt; = [];let n: number = 3;while (n !== 1) { array.push(n); if (n % 2 === 0) { n = n / 2; } else { n = 3 * n + 1; }}array.push(n); IteratingA for loop steps through the elements of an array, just as in Python, though the syntax looks a little different. For example: 12345// find the maximum point of a hailstone sequence stored in arraylet max: number = 0;for (let x of array) { max = Math.max(x, max);} Be careful! Where in Python you use for ... in ..., the equivalent in TypeScript is for ... of .... TypeScript also has a for...in construct which iterates over the keys of a collection, instead of its values. In the case of an array, the keys are the indices of the array. Note the difference that one word makes: for (let x in [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]) { console.log(x); } // prints 0, 1, 2 for (let x of [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]) { console.log(x); } // prints &quot;a&quot;, &quot;b&quot;, &quot;c&quot; When you’re iterating over an array, you almost always want for...of, so you will need to untrain your Python habits here. The example above also used Math.max(), which is a handy function from the JavaScript library. The Math class is full of useful functions like this – web search “mdn math” to find its documentation in MDN. FunctionsIf we want to wrap this code into a reusable module, we can write a function: 123456789101112131415161718/** * Compute a hailstone sequence. * @param n starting number for sequence. Assumes n &gt; 0. * @returns hailstone sequence starting with n and ending with 1. */function hailstoneSequence(n: number): Array&lt;number&gt; { let array: Array&lt;number&gt; = []; while (n !== 1) { array.push(n); if (n % 2 === 0) { n = n / 2; } else { n = 3 * n + 1; } } array.push(n); return array;} Take note of the /** ... */ comment before the function, because it’s very important. This comment is a specification of the function, describing the inputs and outputs of the operation. The specification should be concise, clear, and precise. The comment provides information that is not already clear from the function types. It doesn’t say, for example, that the return value is an array of numbers, because the Array&lt;number&gt; return type declaration just below already says that. But it does say that the sequence starts with n and ends with 1, which is not captured by the type declaration but is important for the caller to know. We’ll have a lot more to say about how to write good specifications in a few classes, but you’ll have to start reading them and using them right away. Mutating values vs. reassigning variablesChange is a necessary evil. But good programmers try to avoid things that change, because they may change unexpectedly. Immutability – intentionally forbidding certain things from changing at runtime – will be a major design principle in this course. For example, an immutable type is a type whose values can never change once they have been created. The string type is immutable in both Python and TypeScript. TypeScript also allows us to declare immutable references: variables that are assigned once and never reassigned. To make a reference unreassignable, declare it with the keyword const instead of let: 1const n: number = 5; If the TypeScript compiler isn’t convinced that your const variable will only be assigned once at runtime, then it will produce a compiler error. So const gives you static checking for unreassignable references. It’s good practice to use const for as many variables as possible. Like the type of the variable, these declarations are important documentation, useful to the reader of the code and statically checked by the compiler. Documenting assumptionsWriting the type of a variable down documents an assumption about it: e.g., the variable n will always refer to a number. TypeScript actually checks this assumption at compile time, and guarantees that there’s no place in your program where you violated this assumption. Declaring a variable const is also a form of documentation, a claim that the variable will never be reassigned after its initial assignment. TypeScript checks that too, statically. We documented another assumption that TypeScript (unfortunately) doesn’t check automatically: that n must be positive. Why do we need to write down our assumptions? Because programming is full of them, and if we don’t write them down, we won’t remember them, and other people who need to read or change our programs later won’t know them. They’ll have to guess. Programs have to be written with two goals in mind: communicating with the computer. First persuading the compiler that your program is sensible – syntactically correct and type-correct. Then getting the logic right so that it gives the right results at runtime. communicating with other people. Making the program easy to understand, so that when somebody has to fix it, improve it, or adapt it in the future, they can do so. Hacking vs. engineeringWe’ve written some hacky code in this reading. Hacking is often marked by unbridled optimism: Bad: writing lots of code before testing any of it. Bad: keeping all the details in your head, assuming you’ll remember them forever, instead of writing them down in your code. Bad: assuming that bugs will be nonexistent or else easy to find and fix. But software engineering is not hacking. Engineers are pessimists: Good: write a little bit at a time, testing as you go. In a future class, we’ll talk about test-first programming. Good: document the assumptions that your code depends on. Good: defend your code against stupidity – especially your own! Static checking helps with that. The goal of 6.031Our primary goal in this course is learning how to produce software that is: Safe from bugs. Correctness (correct behavior right now) and defensiveness (correct behavior in the future) are required in any software we build. Easy to understand. The code has to communicate to future programmers who need to understand it and make changes in it (fixing bugs or adding new features). That future programmer might be you, months or years from now. You’ll be surprised how much you forget if you don’t write it down, and how much it helps your own future self to have a good design. Ready for change. Software always changes. Some designs make it easy to make changes; others require throwing away and rewriting a lot of code. There are other important properties of software (like performance, usability, security), and they may trade off against these three. But these are the Big Three that we care about in 6.031, and that software developers generally put foremost in the practice of building software. It’s worth considering every language feature, every programming practice, every design pattern that we study in this course, and understanding how they relate to the Big Three. Why we use TypeScript in this courseSince you’ve had 6.009, we’re assuming that you’re comfortable with Python. So why aren’t we using Python in this course? Why do we use TypeScript/JavaScript in 6.031? Safety is the first reason. TypeScript has static checking (primarily type checking, but other kinds of static checks too, like that your code returns values from methods declared to do so). We’re studying software engineering in this course, and safety from bugs is a key tenet of that approach. TypeScript dials safety up to a high level, which makes it a good language for learning about good software engineering practices. It’s certainly possible to write safe code in dynamic languages like Python or JavaScript, but it’s easier to understand what you need to do if you learn how in a safe, statically-checked language. Ubiquity is another reason. TypeScript compiles into pure JavaScript, which is widely used in research, education, and industry. JavaScript runs on many platforms, not just in the web browser where it originally became widespread, but now also in web servers and even in desktop applications for Windows/Mac/Linux. Compared to Java, TypeScript has a richer type system, needs less boilerplate code to write a program, and is a better choice for creating modern user interfaces and web apps. In any case, a good programmer must be multilingual. Programming languages are tools, and you have to use the right tool for the job. You will very likely have to pick up other programming languages (such as Java, C/C++, or Scheme or Ruby or Haskell) for classes, internships, or UROPs before you even finish your MIT career, so we’re getting started now by learning a second one. As a result of its ubiquity, JavaScript has a wide array of interesting and useful libraries, and excellent free tools for development (IDEs like VS Code, editors, compilers, test frameworks, profilers, code coverage, style checkers). JavaScript and Python are close competitors in the richness of their ecosystems, and TypeScript can take full advantage of JavaScript libraries. There are some reasons to regret using JavaScript. It’s large, having accumulated many features in the decades since it was originally designed. It’s weighed down by the baggage of older languages like C/C++ — the switch statement is a good example of an antiquated and unsafe language construct inherited from C. And JavaScript itself started with some poor design decisions, including type conversion rules that make 0 == “” return true and “[] + [] “somehow produce the empty string , as well as less dynamic checking than other languages. TypeScript fixes some of these warts in JavaScript, but not all. There are many parts of JavaScript that are now deprecated and avoided by programmers, because they’re risky to use. But on the whole, TypeScript is a reasonable choice of language right now to learn how to write code that is safe from bugs, easy to understand, and ready for change. And that’s our goal. Don’t get us wrong: the real skills you’ll get from this course are not language-specific, but carry over to any language that you might program in. The most important lessons from this course will survive language fads: safety, clarity, abstraction, engineering instincts. SummaryThe main idea we introduced today is static checking. Here’s how this idea relates to the goals of the course: Safe from bugs. Static checking helps with safety by catching type errors and other bugs before runtime. Easy to understand. It helps with understanding, because types are explicitly stated in the code. Ready for change. Static checking makes it easier to change your code by identifying other places that need to change in tandem.","link":"/2025/01/25/MIT6.031/Readings/01_Static_Checking/"},{"title":"Reading 2-Basic TypeScript","text":"Objectives Learn basic JavaScript and TypeScript syntax and semantics Transition from writing Python to writing TypeScript Software in 6.031 Safe from bugs Easy to understand Ready for change Correct today and correct in the unknown future. Communicating clearly with future programmers, including future you. Designed to accommodate change without rewriting. Arrays, Maps, and SetsArrayA TypeScript Array is similar to a Python list. An Array contains an ordered collection of zero or more objects, where the same object might appear multiple times. We can add and remove items to and from the Array, which will grow and shrink to accommodate its contents. Example Array operations: TypeScript description Python lst.length count the number of elements len(lst) lst.push(e) append an element to the end lst.append(e) if ( lst.length === 0 ) ... test if the list is empty if not lst: ... lst.includes(e) test if an element is in the list e in lst lst.splice(i, 1) remove the element at index i del lst[i] MapA Map is similar to a Python dictionary. In Python, the keys of a map must be hashable. TypeScript has an even stricter requirement that we’ll discuss when we confront how equality works between objects; for now, it’s safest to use only strings and numbers as keys, rather than arbitrary objects. Example Map operations: TypeScript description Python map.set(key, val) add the mapping key → val map[key] = val map.get(key) get the value for a key map[key] map.has(key) test whether the map has a key key in map map.delete(key) delete a mapping del map[key] map.size count the number of mappings len(map) SetA Set is an unordered collection of zero or more unique objects. Like a mathematical set or a Python set – and unlike an Array – an object cannot appear in a set multiple times. Either it’s in or it’s out. Like the keys of a map, the objects in a Python set must be hashable. Similarly, the TypeScript Set should be used with a type that is safe for use as the key of a Map, which (for now) means strings and numbers. Example Set operations: TypeScript description Python s.has(e) test if the set contains an element e in s s.add(e) add an element s.add(e) s.delete(e) remove an element s.remove(e) s.size count the number of elements len(s) LiteralsPython provides convenient syntax for creating lists: 1letters = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ] And maps: 1fruits = { &quot;apple&quot;: 5, &quot;banana&quot;: 7 } TypeScript has the same syntax for array literals: 1let letters:Array&lt;string&gt; = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]; but the syntax for creating a Map literal is a bit more involved. The best approach is an array of key-value pairs, like this: 1234let fruits:Map&lt;string, number&gt; = new Map([ [&quot;apple&quot;, 5], [&quot;banana&quot;, 7],]); Generics: declaring Array, Set, and Map variablesUnlike Python collection types, with TypeScript collections we can restrict the type of objects contained in the collection. When we add an item, the compiler can perform static checking to ensure we only add items of the appropriate type. Then, when we pull out an item, we can be confident that its type will be what we expect. Here’s the syntax for declaring some variables to hold collections: 123let cities:Array&lt;string&gt;; // an Array of stringslet numbers:Set&lt;number&gt;; // a Set of numberslet turtles:Map&lt;string,Turtle&gt;; // a Map with string keys and Turtle values TypeScript offers an alternative syntax for declaring an Array type, putting square brackets after the element type: 1let cities:string[]; // also an Array of strings We will generally use the Array&lt;T&gt; form, to make the meaning of the code clearer, but the T[] form is fine too. Note that Array&lt;T&gt; and T[] mean exactly the same thing in TypeScript (unlike other languages you may have encountered). IterationA very common task is iterating through our cities/numbers/turtles/etc. In Python: 12345678for city in cities: print(city)for num in numbers: print(num)for key in turtles: print(&quot;%s: %s&quot; % (key, turtles[key])) TypeScript provides a similar syntax for iterating over the items in arrays and sets, but using of rather than in: 1234567for (const city of cities) { console.log(city);}for (const num of numbers) { console.log(num);} TypeScript also allows let city of cities, but const is preferable because it prevents you from inadvertently reassigning city in the body of the loop. TypeScript doesn’t allow declaring the type of the variable (e.g. with const city:string of cities); the type of city is inferred automatically from the element type of cities. Warning: avoid using for...in in TypeScript. It’s unfortunately legal syntax, but it does a very different thing than you expect. With an array ['a', 'b'], for example, for...in will not loop over the elements of the array (a, b), but instead the indices of the array (0, 1). With a set or map, for...in quietly does nothing at all, leading you to think that the set or map is empty when it’s not. Avoid for...in, and use for...of instead. We can also iterate over the keys or values of a Map as we did in Python: 1234567891011for (const key of turtles.keys()) { console.log(key + &quot;: &quot; + turtles.get(key));}for (const value of turtles.values()) { console.log(value); // prints each Turtle}for (const [key, value] of turtles.entries()) { console.log(key + &quot;: &quot; + value);} Under the hood this kind of for loop uses an Iterator, a design pattern we’ll see later in the class. Warning: be careful not to mutate a collection while you’re iterating over it. Adding, removing, or replacing elements disrupts the iteration and can even cause your program to crash. We’ll discuss the reason in more detail in a future class. Note that this warning applies to Python as well. The Python code below does not do what you might expect: 1234numbers = [100,200,300]for num in numbers: numbers.remove(num) # danger!!! mutates the list we're iterating overprint(numbers) # list should be empty here -- is it? Iterating with indicesIf you want to, TypeScript provides different for loops that we can use to iterate through an array using its indices: 123for (let ii = 0; ii &lt; cities.length; ii++) { console.log(cities[ii]);} Unless we actually need the index value ii, this code is verbose and has more places for bugs to hide (starting at 1 instead of 0, using &lt;= instead of &lt;, using the wrong variable name for one of the occurrences of ii, …) Avoid it if you can. Missing values in maps and arraysIf you try to use get() to get a key that isn’t defined, then it returns the special value undefined: 1234const prices: Map&lt;string, number&gt; = new Map();prices.set(&quot;apple&quot;, 5);prices.get(&quot;apple&quot;) // returns 5prices.get(&quot;banana&quot;) // returns undefined Similarly, if you index into an array with an illegal index, the result is undefined: 12345const fruits: Array&lt;string&gt; = [&quot;apple&quot;, &quot;banana&quot;];fruits[0] // returns &quot;apple&quot;fruits[1] // returns &quot;banana&quot;fruits[2] // returns undefinedfruits[-1] // returns undefined Surprisingly, JavaScript arrays are actually sparse: you can place a new element at an arbitrary index, not just in a contiguous sequence numbered from 0. Any unassigned indexes return undefined. For example: 123456const arr:Array&lt;string&gt; = [];arr[2] = &quot;x&quot;;arr[0] // returns undefinedarr[1] // returns undefinedarr[2] // returns &quot;x&quot;arr[3] // returns undefined Array sparsity is used very rarely by TypeScript/JavaScript programmers. Most of the time, an array should be used like a list in other languages, with contiguous indices numbered from 0. Variable declarationsInferring the type from the initializerWhen we declare a variable with an initializer, we can often omit the type declaration, and TypeScript will automatically infer it from the type of the initializing expression. So instead of: 12let x:number = 5;let name:string = 'Frodo'; we can simply write: 12let x = 5; // infers that x:numberlet name = 'Frodo'; // infers that name:string For Array, Set, and Map types, we can write the full type either in the declaration or in the initializer, and TypeScript will infer the other one: 1234567// full type in the declaration; initializer type inferredlet numbers:Array&lt;string&gt; = [];let map:Map&lt;string,number&gt; = new Map();// full type in the initializer; declaration type inferredlet numbers = new Array&lt;string&gt;();let map = new Map&lt;string,number&gt;(); But the declarations below are incomplete, and will lead to static type errors somewhere down the line: 123let numbers = []; // NO: what is the element type of the array?let ages = new Set(); // NO: what is the element type of the set?let map = new Map(); // NO: what are the types of the keys and values? let vs. varAs we have seen, TypeScript has two ways to declare local variables: let for variables that may need to be reassigned, and const for unreassignable variables. In older JavaScript code, you may also see var used to declare a variable, like this: 1var x = 5; // NO: avoid var These old-style var declarations are not recommended, because their scope is the entire function (like Python variables), while a let variable’s scope is just its enclosing curly braces. You can read more about the difference between let and var in the TypeScript Handbook. Object literals and object typesTypeScript has a syntax for creating an object with initialized instance variables: 1{ x: 5, y: -2 } pointObjectxy52 (Python has a similar syntax that creates a dictionary, not an object.) The static type of this expression is { x:number, y:number }, which can be used to declare a variable: 1let point: { x: number, y: number } = { x: 5, y: 2 }; Now point.x and point.y can be used to access the x and y values stored in the object that point refers to. An object type that is just a collection of named fields, without any methods or operations, is called a record type (also called a struct in languages like C/C++). We will see better ways to manage complex data when we talk about abstract data types in a future class. But simple record types like this are useful for bundling together related bits of data temporarily, particularly when a function wants to return multiple values, e.g.: 123456function integerDivision(a:number, b:number): { quotient:number, remainder:number } { return { quotient: ..., // result of dividing a by b remainder: ... // remainder after dividing a by b };} TypeScript has a number of shortcuts for object literals, including destructuring assignment: 1const { quotient, remainder } = integerDivision(23, 7); This code declares the local variables quotient and remainder and initializes them with the correspondingly-named fields of the object returned by integerDivision(). EnumerationsSometimes a type has a small, finite set of immutable values, such as: months of the year: January, February, …, November, December days of the week: Monday, Tuesday, …, Saturday, Sunday compass points: north, south, east, west available colors: black, gray, red, … When the set of values is small and finite, it makes sense to define all the values as named constants, which TypeScript calls an enumeration and expresses with the enum construct. 12345678910enum Month { JANUARY, FEBRUARY, MARCH, APRIL, MAY, JUNE, JULY, AUGUST, SEPTEMBER, OCTOBER, NOVEMBER, DECEMBER}enum PenColor { BLACK, GRAY, RED, PINK, ORANGE, YELLOW, GREEN, CYAN, BLUE, MAGENTA} You can use an enumeration type name like PenColor in a variable or method declaration: 1let drawingColor: PenColor; Refer to the values of the enumeration as if they were named constants: 1drawingColor = PenColor.RED; Note that an enumeration is a distinct new type. Older languages, like Python 2 or JavaScript, tend to use numeric constants or string literals to represent a finite set of values like this. But an enumeration is more typesafe, because it can catch mistakes like type mismatches: 12let month:number = TUESDAY; // no error if numeric constants are usedlet month:Month = DayOfWeek.TUESDAY; // static error if enumerations are used or misspellings: 12let color:string = &quot;REd&quot;; // no error, misspelling isn't caughtlet drawingColor:PenColor = PenColor.REd; // static error when enumeration value is misspelled Python 3 has enumerations, similar to TypeScript’s, though not statically type-checked. API documentationPrevious sections in this reading have a number of links to documentation for the JavaScript and TypeScript API. API stands for application programming interface. If you want to program an app that talks to Facebook, Facebook publishes an API (more than one, in fact, for different languages and frameworks) you can program against. TypeScript is a superset of JavaScript, so it relies on the JavaScript API for much of its functionality. JavaScript, in turn, runs in two different contexts: inside the web browser, and outside it (in Node.js). Each context has different APIs with different capabilities. So three sources of API documentation are widely used for TypeScript/JavaScript programming: MDN JavaScript reference, for general features of JavaScript, and for web-browser-specific APIs. Node.js reference, for outside-the-browser APIs specific to Node.js. The TypeScript Handbook, for features specific to TypeScript. Here are some examples from MDN of APIs that are available in every TypeScript/JavaScript context: String is the type that TypeScript calls string. We can create String objects by using &quot;double quotes&quot; or 'single quotes'. Array is like a Python list. Map is like a Python dictionary. And here are some APIs from Node.js, available only for a program running in Node: fs.readFileSync() reads a file from disk. os.homedir() gets the pathname of the user’s home directory. And here are some types we’ve discussed from TypeScript: arrays enumerations Programming toolboxIn your Python programming, you may have written your code using a programming editor, and then run it using the python command. (Or you may have used a development environment like Spyder, or a computational notebook like Jupyter.) In the TypeScript/JavaScript world, the set of tools you’ll need is more elaborate. This section briefly introduces you to each tool that we’ll use in 6.031 problem sets. The Getting Started page has instructions for installing the correct versions of all these tools. Visual Studio Code. This is the programming editor we’ll be using. It has good support for programming in a wide variety of languages, not just TypeScript/JavaScript. TypeScript compiler. The compiler statically-checks your TypeScript code and converts it into JavaScript code (we saw an example of this in the Static Checking reading). Visual Studio Code has a TypeScript compiler built into it, which displays error messages as you’re typing the code. When it’s time to run the code, we will use tsc (short for “TypeScript compiler”) to convert the TypeScript files into JavaScript files on disk. We won’t run tsc directly; instead we will run it through npm, discussed below. Node.js. Node is a JavaScript interpreter. The node command runs a file of JavaScript code, so it plays the analogous function as the python command in the Python world. JavaScript can also be run by a web browser. We will mostly be using node to run code in this class, but occasionally we will run some code in the web browser too. npm. NPM is short for “Node Package Manager,” which actually has two functions. First, it manages the library of external packages that you’re using for your program. Before you use almost any TypeScript/JavaScript project, your first step is likely to be npm install to install all the libraries it depends on. You will get used to running this command on all problem sets and in-class exercises. The other function of npm is as a general-purpose runner of other programming tools. For example, we will use npm test to compile code with the TypeScript compiler and run a test suite on it. npm gets its configuration from a file called package.json which you will find in all our problem sets and in-class exercises. You can inspect it if you’re curious, but don’t modify this file in your 6.031 work. When npm install installs libraries, it puts them into a subfolder called node_modules, so that every project has its own copy of its libraries, rather than installing them globally across your machine. If you are getting strange errors from a project you’ve just downloaded, it might be because you haven’t yet run npm install to create your node_modules folder. Experimenting with TypeScript codeIn the Python world, you can use the python command (with no file argument) to get a Python interpreter prompt, where you can experiment with writing short bits of Python code. This is a bit more complicated in the TypeScript/JavaScript world. Although running node with no arguments does give you an interpreter prompt, it is a JavaScript prompt, not a TypeScript prompt. The node command alone doesn’t understand the extra features of TypeScript, like static checking. Here are two ways to get a TypeScript prompt: Run npx ts-node in a project, like a 6.031 problem set or inclass exercise. (If you get a Not Found error, then you may need to npm install ts-node to make sure it’s installed in the project.) This will give you a prompt where you can type TypeScript code (not just JavaScript), and you will also be able to import any of the external libraries used by the project. Use the TypeScript Playground in your web browser. This gives you an editor for writing and running short snippets of TypeScript code, but note that your code is running in a web browser environment, so it doesn’t have access to any of the libraries that Node provides.","link":"/2025/01/28/MIT6.031/Readings/02_Basic_TypeScript/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"English","slug":"English","link":"/tags/English/"},{"name":"中文","slug":"中文","link":"/tags/%E4%B8%AD%E6%96%87/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"toy projects","slug":"toy-projects","link":"/tags/toy-projects/"},{"name":"翻译","slug":"翻译","link":"/tags/%E7%BF%BB%E8%AF%91/"},{"name":"test","slug":"test","link":"/tags/test/"},{"name":"OS","slug":"OS","link":"/tags/OS/"},{"name":"汇编","slug":"汇编","link":"/tags/%E6%B1%87%E7%BC%96/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"Golang","slug":"Golang","link":"/tags/Golang/"},{"name":"TypeScript","slug":"TypeScript","link":"/tags/TypeScript/"},{"name":"Software Construction","slug":"Software-Construction","link":"/tags/Software-Construction/"}],"categories":[{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"toy projects","slug":"toy-projects","link":"/categories/toy-projects/"},{"name":"basics","slug":"Java/basics","link":"/categories/Java/basics/"},{"name":"Thinking in Java","slug":"Java/basics/Thinking-in-Java","link":"/categories/Java/basics/Thinking-in-Java/"},{"name":"test","slug":"test","link":"/categories/test/"},{"name":"OS","slug":"OS","link":"/categories/OS/"},{"name":"Golang","slug":"Golang","link":"/categories/Golang/"},{"name":"TypeScript","slug":"TypeScript","link":"/categories/TypeScript/"},{"name":"basics","slug":"Golang/basics","link":"/categories/Golang/basics/"},{"name":"Software Construction","slug":"Software-Construction","link":"/categories/Software-Construction/"},{"name":"MIT6.031","slug":"Software-Construction/MIT6-031","link":"/categories/Software-Construction/MIT6-031/"}],"pages":[{"title":"categories","text":"","link":"/categories/index.html"}]}