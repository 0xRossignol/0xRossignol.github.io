<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>MyBlog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="MyBlog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="MyBlog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="MyBlog"><meta property="og:url" content="http://example.com/"><meta property="og:site_name" content="MyBlog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:author" content="Rossignol"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"MyBlog","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"Rossignol"},"publisher":{"@type":"Organization","name":"MyBlog","logo":{"@type":"ImageObject","url":"http://example.com/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="MyBlog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/0xRossignol"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-05-24T06:00:26.000Z" title="2025/5/24 14:00:26">2025-05-24</time>发表</span><span class="level-item"><time dateTime="2025-05-24T06:16:45.503Z" title="2025/5/24 14:16:45">2025-05-24</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Rust/">Rust</a><span> / </span><a class="link-muted" href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></span><span class="level-item">19 分钟读完 (大约2909个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/05/24/Rust/The%20Rust%20Programming%20Language/08.1%20%E4%BD%BF%E7%94%A8%20Vector%20%E5%82%A8%E5%AD%98%E5%88%97%E8%A1%A8/">8.1 使用 Vector 储存列表</a></p><div class="content"><h2 id="使用-Vector-储存列表"><a href="#使用-Vector-储存列表" class="headerlink" title="使用 Vector 储存列表"></a>使用 Vector 储存列表</h2><p>我们要讲到的第一个类型是 <code>Vec&lt;T&gt;</code>，也被称为 <em>vector</em>。vector 允许我们在一个单独的数据结构中储存多于一个的值，它在内存中彼此相邻地排列所有的值。vector 只能储存相同类型的值。它们在拥有一系列项的场景下非常实用，例如文件中的文本行或是购物车中商品的价格。</p>
<h3 id="新建-vector"><a href="#新建-vector" class="headerlink" title="新建 vector"></a>新建 vector</h3><p>为了新建一个的空 vector，可以调用 <code>Vec::new</code> 函数，如示例 8-1 所示。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br></pre></td></tr></table></figure>

<p>示例 8-1：新建一个的空 vector 来储存 <code>i32</code> 类型的值</p>
<p>注意这里我们增加了一个类型注解。因为没有向这个 vector 中插入任何值，Rust 并不知道我们想要储存什么类型的元素。这是一个非常重要的点。vector 是用泛型实现的，第十章会涉及到如何对你自己的类型使用它们。现在，所有你需要知道的就是 <code>Vec&lt;T&gt;</code> 是一个由标准库提供的类型，它可以存放任何类型，而当 <code>Vec</code> 存放某个特定类型时，那个类型位于尖括号中。在示例 8-1 中，我们告诉 Rust <code>v</code> 这个 <code>Vec&lt;T&gt;</code> 将存放 <code>i32</code> 类型的元素。</p>
<p>通常，我们会用初始值来创建一个 <code>Vec&lt;T&gt;</code> 而 Rust 会推断出储存值的类型，所以很少会需要这些类型注解。为了方便 Rust 提供了 <code>vec!</code> 宏，这个宏会根据我们提供的值来创建一个新的 vector。示例 8-2 新建一个拥有值 <code>1</code>、<code>2</code> 和 <code>3</code> 的 <code>Vec&lt;i32&gt;</code>。推断为 <code>i32</code> 是因为这是默认整型类型，第三章的 [“数据类型”](.&#x2F;03.2 数据类型) 讨论过：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p>示例 8-2：新建一个包含初值的 vector</p>
<p>因为我们提供了 <code>i32</code> 类型的初始值，Rust 可以推断出 <code>v</code> 的类型是 <code>Vec&lt;i32&gt;</code>，因此类型注解就不是必须的。接下来让我们看看如何修改一个 vector。</p>
<h3 id="更新-vector"><a href="#更新-vector" class="headerlink" title="更新 vector"></a>更新 vector</h3><p>对于新建一个 vector 并向其增加元素，可以使用 <code>push</code> 方法，如示例 8-3 所示：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">5</span>);</span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">6</span>);</span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">7</span>);</span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">8</span>);</span><br></pre></td></tr></table></figure>

<p>示例 8-3：使用 <code>push</code> 方法向 vector 增加值</p>
<p>如第三章中讨论的任何变量一样，如果想要能够改变它的值，必须使用 <code>mut</code> 关键字使其可变。放入其中的所有值都是 <code>i32</code> 类型的，而且 Rust 也根据数据做出如此判断，所以不需要 <code>Vec&lt;i32&gt;</code> 注解。</p>
<h3 id="读取-vector-的元素"><a href="#读取-vector-的元素" class="headerlink" title="读取 vector 的元素"></a>读取 vector 的元素</h3><p>有两种方法引用 vector 中储存的值：通过索引或使用 <code>get</code> 方法。在接下来的示例中，为了更加清楚的说明，我们已经标注了这些函数返回的值的类型。</p>
<p>示例 8-4 展示了访问 vector 中一个值的两种方式，索引语法或者 <code>get</code> 方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">third</span>: &amp;<span class="type">i32</span> = &amp;v[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The third element is &#123;third&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">third</span>: <span class="type">Option</span>&lt;&amp;<span class="type">i32</span>&gt; = v.<span class="title function_ invoke__">get</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">match</span> third &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(third) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The third element is &#123;third&#125;&quot;</span>),</span><br><span class="line">    <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;There is no third element.&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>列表 8-4：使用索引语法或 <code>get</code> 方法来访问 vector 中的项</p>
<p>这里有几个细节需要注意。我们使用索引值 <code>2</code> 来获取第三个元素，因为索引是从数字 0 开始的。使用 <code>&amp;</code> 和 <code>[]</code> 会得到一个索引位置元素的引用。当使用索引作为参数调用 <code>get</code> 方法时，会得到一个可以用于 <code>match</code> 的 <code>Option&lt;&amp;T&gt;</code>。</p>
<p>Rust 提供了两种引用元素的方法的原因是当尝试使用现有元素范围之外的索引值时可以选择让程序如何运行。举个例子，让我们看看使用这个技术，尝试在当有一个 5 个元素的 vector 接着访问索引 100 位置的元素会发生什么，如示例 8-5 所示：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">does_not_exist</span> = &amp;v[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">does_not_exist</span> = v.<span class="title function_ invoke__">get</span>(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>示例 8-5：尝试访问一个包含 5 个元素的 vector 的索引 100 处的元素</p>
<p>当运行这段代码，你会发现对于第一个 <code>[]</code> 方法，当引用一个不存在的元素时 Rust 会造成 panic。此方法适用于当你希望在尝试访问 vector 末尾之外的元素时让程序直接崩溃的场景。</p>
<p>当 <code>get</code> 方法被传递了一个数组外的索引时，它不会 panic 而是返回 <code>None</code>。当偶尔出现超过 vector 范围的访问属于正常情况的时候可以考虑使用它。接着你的代码可以有处理 <code>Some(&amp;element)</code> 或 <code>None</code> 的逻辑，如第六章讨论的那样。例如，索引可能来源于用户输入的数字。如果它们不慎输入了一个过大的数字那么程序就会得到 <code>None</code> 值，你可以告诉用户当前 vector 元素的数量并再请求它们输入一个有效的值。这就比因为输入错误而使程序崩溃要友好的多！</p>
<p>一旦程序获取了一个有效的引用，借用检查器将会执行所有权和借用规则（第四章讲到）来确保 vector 内容的这个引用和任何其他引用保持有效。回忆一下不能在相同作用域中同时存在可变和不可变引用的规则。这个规则适用于示例 8-6，当我们获取了 vector 的第一个元素的不可变引用并尝试在 vector 末尾增加一个元素的时候，如果尝试在函数的后面再次引用这个元素是行不通的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">first</span> = &amp;v[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The first element is: &#123;first&#125;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>示例 8-6：尝试在拥有 vector 中项的引用的同时向其增加一个元素</p>
<p>编译会给出这个错误：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">   Compiling collections v0.1.0 (file:///projects/collections)</span><br><span class="line">error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable</span><br><span class="line"><span class="meta prompt_"> --&gt; </span><span class="language-bash">src/main.rs:6:5</span></span><br><span class="line">  |</span><br><span class="line">4 |     let first = &amp;v[0];</span><br><span class="line">  |                  - immutable borrow occurs here</span><br><span class="line">5 |</span><br><span class="line">6 |     v.push(6);</span><br><span class="line">  |     ^^^^^^^^^ mutable borrow occurs here</span><br><span class="line">7 |</span><br><span class="line">8 |     println!(&quot;The first element is: &#123;first&#125;&quot;);</span><br><span class="line">  |                                     ------- immutable borrow later used here</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0502`.</span><br><span class="line">error: could not compile `collections` (bin &quot;collections&quot;) due to 1 previous error</span><br></pre></td></tr></table></figure>

<p>示例 8-6 中的代码看起来应该能够运行：为什么第一个元素的引用会关心 vector 结尾的变化？不能这么做的原因是由于 vector 的工作方式：在 vector 的结尾增加新元素时，在没有足够空间将所有元素依次相邻存放的情况下，可能会要求分配新内存并将老的元素拷贝到新的空间中。这时，第一个元素的引用就指向了被释放的内存。借用规则阻止程序陷入这种状况。</p>
<blockquote>
<p>注意：关于 <code>Vec&lt;T&gt;</code> 类型的更多实现细节，请查看 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nomicon/vec/vec.html">“The Rustonomicon”</a></p>
</blockquote>
<h3 id="遍历-vector-中的元素"><a href="#遍历-vector-中的元素" class="headerlink" title="遍历 vector 中的元素"></a>遍历 vector 中的元素</h3><p>如果想要依次访问 vector 中的每一个元素，我们可以遍历其所有的元素而无需通过索引一次一个的访问。示例 8-7 展示了如何使用 <code>for</code> 循环来获取 <code>i32</code> 值的 vector 中的每一个元素的不可变引用并将其打印：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> &amp;v &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;i&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 8-7：通过 <code>for</code> 循环遍历 vector 的元素并打印</p>
<p>我们也可以遍历可变 vector 的每一个元素的可变引用以便能改变它们。示例 8-8 中的 <code>for</code> 循环会给每一个元素加 <code>50</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> &amp;<span class="keyword">mut</span> v &#123;</span><br><span class="line">    *i += <span class="number">50</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 8-8：遍历 vector 中元素的可变引用</p>
<p>为了修改可变引用所指向的值，在使用 <code>+=</code> 运算符之前必须使用解引用运算符（<code>*</code>）获取 <code>i</code> 中的值。第十五章的[“通过解引用运算符追踪指针的值”](.&#x2F;15.2 通过 Deref trait 将智能指针当作常规引用处理)部分会详细介绍解引用运算符。</p>
<p>由于借用检查器的规则，无论可变还是不可变地遍历一个 vector 都是安全的。如果尝试在示例 8-7 和 示例 8-8 的 <code>for</code> 循环体内插入或删除项，都会得到一个类似示例 8-6 代码中类似的编译错误。<code>for</code> 循环中获取的 vector 引用阻止了同时对整个 vector 进行修改。</p>
<h3 id="使用枚举来储存多种类型"><a href="#使用枚举来储存多种类型" class="headerlink" title="使用枚举来储存多种类型"></a>使用枚举来储存多种类型</h3><p>vector 只能储存相同类型的值。这是很不方便的；绝对会有需要储存一系列不同类型的值的用例。幸运的是，枚举的成员都被定义为相同的枚举类型，所以当需要在 vector 中储存不同类型值时，我们可以定义并使用一个枚举！</p>
<p>例如，假如我们想要从电子表格的一行中获取值，而这一行的有些列包含数字，有些包含浮点值，还有些是字符串。我们可以定义一个枚举，其成员会存放这些不同类型的值，同时所有这些枚举成员都会被当作相同类型：那个枚举的类型。接着可以创建一个储存该枚举值的 vector，这样最终就能够储存不同类型的值了。示例 8-9 展示了这个用法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">SpreadsheetCell</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Int</span>(<span class="type">i32</span>),</span><br><span class="line">    <span class="title function_ invoke__">Float</span>(<span class="type">f64</span>),</span><br><span class="line">    <span class="title function_ invoke__">Text</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">row</span> = <span class="built_in">vec!</span>[</span><br><span class="line">    SpreadsheetCell::<span class="title function_ invoke__">Int</span>(<span class="number">3</span>),</span><br><span class="line">    SpreadsheetCell::<span class="title function_ invoke__">Text</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;blue&quot;</span>)),</span><br><span class="line">    SpreadsheetCell::<span class="title function_ invoke__">Float</span>(<span class="number">10.12</span>),</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>示例 8-9：定义一个枚举，以便能在 vector 中存放不同类型的数据</p>
<p>Rust 在编译时必须确切知道 vector 中的类型，这样它才能确定在堆上需要为每个元素分配多少内存。我们还必须明确这个 vector 中允许的类型。如果 Rust 允许 vector 存储任意类型，那么可能会因为一个或多个类型在对 vector 元素执行操作时导致（类型相关）错误。使用枚举加上 <code>match</code> 表达式意味着 Rust 会在编译时确保每种可能的情况都得到处理，正如第六章讲到的那样。</p>
<p>如果在编写程序时不能确切无遗地知道运行时会储存进 vector 的所有类型，枚举技术就行不通了。相反，你可以使用 trait 对象，第十八章会讲到它。</p>
<p>现在我们了解了一些使用 vector 的最常见的方式，请一定去看看标准库中 <code>Vec</code> 定义的很多其他实用方法的 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/vec/struct.Vec.html">API 文档</a>。例如，除了 <code>push</code> 之外还有一个 <code>pop</code> 方法，它会移除并返回 vector 的最后一个元素。</p>
<h3 id="丢弃-vector-时也会丢弃其所有元素"><a href="#丢弃-vector-时也会丢弃其所有元素" class="headerlink" title="丢弃 vector 时也会丢弃其所有元素"></a>丢弃 vector 时也会丢弃其所有元素</h3><p>类似于任何其他的 <code>struct</code>，vector 在其离开作用域时会被释放，如示例 8-10 所标注的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do stuff with v</span></span><br><span class="line">&#125; <span class="comment">// &lt;- v goes out of scope and is freed here</span></span><br></pre></td></tr></table></figure>

<p>示例 8-10：展示 vector 和其元素于何处被丢弃</p>
<p>当 vector 被丢弃时，所有其内容也会被丢弃，这意味着这里它包含的整数将被清理。借用检查器确保了任何 vector 中内容的引用仅在 vector 本身有效时才可用。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-05-23T07:50:26.000Z" title="2025/5/23 15:50:26">2025-05-23</time>发表</span><span class="level-item"><time dateTime="2025-05-23T08:26:39.802Z" title="2025/5/23 16:26:39">2025-05-23</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Rust/">Rust</a><span> / </span><a class="link-muted" href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></span><span class="level-item">10 分钟读完 (大约1484个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/05/23/Rust/The%20Rust%20Programming%20Language/07.5%20%E5%B0%86%E6%A8%A1%E5%9D%97%E6%8B%86%E5%88%86%E6%88%90%E5%A4%9A%E4%B8%AA%E6%96%87%E4%BB%B6/">7.5 将模块拆分成多个文件</a></p><div class="content"><h2 id="将模块拆分成多个文件"><a href="#将模块拆分成多个文件" class="headerlink" title="将模块拆分成多个文件"></a>将模块拆分成多个文件</h2><p>到目前为止，本章所有的例子都在一个文件中定义多个模块。当模块变得更大时，你可能想要将它们的定义移动到单独的文件中，从而使代码更容易阅读。</p>
<p>例如，我们从示例 7-17 中包含多个餐厅模块的代码开始。我们会将模块提取到各自的文件中，而不是将所有模块都定义到 crate 根文件中。在这里，crate 根文件是 <em>src&#x2F;lib.rs</em>，不过这个过程也适用于 crate 根文件是 <em>src&#x2F;main.rs</em> 的二进制 crate。</p>
<p>首先将 <code>front_of_house</code> 模块提取到其自己的文件中。删除 <code>front_of_house</code> 模块的大括号中的代码，只留下 <code>mod front_of_house;</code> 声明，这样 <em>src&#x2F;lib.rs</em> 会包含如示例 7-21 所示的代码。注意直到创建示例 7-22 中的 <em>src&#x2F;front_of_house.rs</em> 文件之前代码都不能编译。</p>
<p>文件名：src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> crate::front_of_house::hosting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 7-21: 声明 <code>front_of_house</code> 模块，其内容将位于 <em>src&#x2F;front_of_house.rs</em></p>
<p>接下来将之前大括号内的代码放入一个名叫 <em>src&#x2F;front_of_house.rs</em> 的新文件中，如示例 7-22 所示。因为编译器找到了 crate 根中名叫 <code>front_of_house</code> 的模块声明，它就知道去搜寻这个文件。</p>
<p>文件名：src&#x2F;front_of_house.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 7-22: 在 <em>src&#x2F;front_of_house.rs</em> 中定义 <code>front_of_house</code> 模块</p>
<p>注意你只需在模块树中的某处使用一次 <code>mod</code> 声明就可以加载这个文件。一旦编译器知道了这个文件是项目的一部分（并且通过 <code>mod</code> 语句的位置知道了代码在模块树中的位置），项目中的其他文件应该使用其所声明的位置的路径来引用那个文件的代码，这在[“引用模块项目的路径”](.&#x2F;07.3 引用模块项目的路径)部分有讲到。换句话说，<code>mod</code> <strong>不是</strong>你可能会在其他编程语言中看到的 “include” 操作。</p>
<p>接下来我们同样将 <code>hosting</code> 模块提取到自己的文件中。这个过程会有所不同，因为 <code>hosting</code> 是 <code>front_of_house</code> 的子模块而不是根模块。我们将 <code>hosting</code> 的文件放在与模块树中它的父模块同名的目录中，在这里是 *src&#x2F;front_of_house&#x2F;*。</p>
<p>为了移动 <code>hosting</code>，修改 <em>src&#x2F;front_of_house.rs</em> 使之仅包含 <code>hosting</code> 模块的声明。</p>
<p>文件名：src&#x2F;front_of_house.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> hosting;</span><br></pre></td></tr></table></figure>

<p>接着我们创建一个 <em>src&#x2F;front_of_house</em> 目录和一个包含 <code>hosting</code> 模块定义的 <em>hosting.rs</em> 文件：</p>
<p>文件名：src&#x2F;front_of_house&#x2F;hosting.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>如果将 <em>hosting.rs</em> 放在 <em>src</em> 目录，编译器会认为 <code>hosting</code> 模块中的 <em>hosting.rs</em> 的代码声明于 crate 根，而不是声明为 <code>front_of_house</code> 的子模块。编译器所遵循的哪些文件对应哪些模块的代码的规则，意味着目录和文件更紧密地贴合模块树。</p>
<blockquote>
<h3 id="另一种文件路径"><a href="#另一种文件路径" class="headerlink" title="另一种文件路径"></a>另一种文件路径</h3><p>目前为止我们介绍了 Rust 编译器所最常用的文件路径，但 Rust 也支持一种更老的路径风格。</p>
<p>对于声明于 crate 根的 <code>front_of_house</code> 模块，编译器会在如下位置查找模块代码：</p>
<ul>
<li><em>src&#x2F;front_of_house.rs</em>（我们所介绍的）</li>
<li><em>src&#x2F;front_of_house&#x2F;mod.rs</em>（老风格，不过仍然支持）</li>
</ul>
<p>对于 <code>front_of_house</code> 的子模块 <code>hosting</code>，编译器会在如下位置查找模块代码：</p>
<ul>
<li><em>src&#x2F;front_of_house&#x2F;hosting.rs</em>（我们所介绍的）</li>
<li><em>src&#x2F;front_of_house&#x2F;hosting&#x2F;mod.rs</em>（老风格，不过仍然支持）</li>
</ul>
<p>如果你对同一模块同时使用这两种路径风格，会得到一个编译错误。在同一项目中的不同模块混用不同的路径风格是允许的，不过这会使他人感到疑惑。</p>
<p>使用 <em>mod.rs</em> 这一文件名的风格的主要缺点是会导致项目中出现很多 <em>mod.rs</em> 文件，当你在编辑器中同时打开它们时会感到疑惑。</p>
</blockquote>
<p>我们将各个模块的代码移动到独立文件了，同时模块树保持不变。<code>eat_at_restaurant</code> 中的函数调用也无需修改继续保持有效，即便其定义存在于不同的文件中。这个技巧让你可以在模块代码增长时，将它们移动到新文件中。</p>
<p>注意，<em>src&#x2F;lib.rs</em> 中的 <code>pub use crate::front_of_house::hosting</code> 语句也并未发生改变，<code>use</code> 也不会对哪些文件会被编译为 crate 的一部分有任何影响。<code>mod</code> 关键字声明了模块，而 Rust 会在与模块同名的文件中查找模块的代码。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Rust 允许你将一个包拆分为多个 crate，并将一个 crate 拆分为若干模块，从而可以在一个模块中引用另一个模块中定义的项。你可以使用绝对路径或相对路径来实现这一点。你可以通过使用 <code>use</code> 语句将路径引入作用域，这样在多次使用时可以使用更短的路径。模块定义的代码默认是私有的，不过可以选择增加 <code>pub</code> 关键字使其定义变为公有。</p>
<p>接下来，让我们看看一些标准库提供的集合数据类型，你可以利用它们编写出漂亮整洁的代码。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-05-23T07:40:26.000Z" title="2025/5/23 15:40:26">2025-05-23</time>发表</span><span class="level-item"><time dateTime="2025-05-23T08:19:11.987Z" title="2025/5/23 16:19:11">2025-05-23</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Rust/">Rust</a><span> / </span><a class="link-muted" href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></span><span class="level-item">9 分钟读完 (大约1297个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/05/23/Rust/The%20Rust%20Programming%20Language/07.4%20%E4%BD%BF%E7%94%A8%20use%20%E5%85%B3%E9%94%AE%E5%AD%97%E5%B0%86%E8%B7%AF%E5%BE%84%E5%BC%95%E5%85%A5%E4%BD%9C%E7%94%A8%E5%9F%9F/">7.4 使用 use 关键字将路径引入作用域</a></p><div class="content"><h2 id="使用-use-关键字将路径引入作用域"><a href="#使用-use-关键字将路径引入作用域" class="headerlink" title="使用 use 关键字将路径引入作用域"></a>使用 <code>use</code> 关键字将路径引入作用域</h2><p>不得不编写路径来调用函数显得繁琐且重复。在示例 7-7 中，无论我们选择 <code>add_to_waitlist</code> 函数的绝对路径还是相对路径，每次我们想要调用 <code>add_to_waitlist</code> 时，都必须指定<code>front_of_house</code> 和 <code>hosting</code>。幸运的是，有一种方法可以简化这个过程。我们可以使用 <code>use</code> 关键字创建一个捷径，然后就可以在作用域中的任何地方使用这个更短的名字。</p>
<p>在示例 7-11 中，我们将 <code>crate::front_of_house::hosting</code> 模块引入了 <code>eat_at_restaurant</code> 函数的作用域，而我们只需要指定 <code>hosting::add_to_waitlist</code> 即可在 <code>eat_at_restaurant</code> 中调用 <code>add_to_waitlist</code> 函数。</p>
<p>文件名：src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::front_of_house::hosting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 7-11: 使用 <code>use</code> 将模块引入作用域</p>
<p>在作用域中增加 <code>use</code> 和路径类似于在文件系统中创建软连接（符号连接，symbolic link）。通过在 crate 根增加 <code>use crate::front_of_house::hosting</code>，现在 <code>hosting</code> 在作用域中就是有效的名称了，如同 <code>hosting</code> 模块被定义于 crate 根一样。通过 <code>use</code> 引入作用域的路径也会检查私有性，同其它路径一样。</p>
<p>注意 <code>use</code> 只能创建 <code>use</code> 所在的特定作用域内的捷径。示例 7-12 将 <code>eat_at_restaurant</code> 函数移动到了一个叫 <code>customer</code> 的子模块，这又是一个不同于 <code>use</code> 语句的作用域，所以函数体不能编译。</p>
<p>文件名：src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::front_of_house::hosting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> customer &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">        hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 7-12: <code>use</code> 语句只适用于其所在的作用域</p>
<p>编译器错误显示捷径不再适用于 <code>customer</code> 模块中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo build</span></span><br><span class="line">   Compiling restaurant v0.1.0 (file:///projects/restaurant)</span><br><span class="line">error[E0433]: failed to resolve: use of undeclared crate or module `hosting`</span><br><span class="line"><span class="meta prompt_">  --&gt; </span><span class="language-bash">src/lib.rs:11:9</span></span><br><span class="line">   |</span><br><span class="line">11 |         hosting::add_to_waitlist();</span><br><span class="line">   |         ^^^^^^^ use of undeclared crate or module `hosting`</span><br><span class="line">   |</span><br><span class="line">help: consider importing this module through its public re-export</span><br><span class="line">   |</span><br><span class="line">10 +     use crate::hosting;</span><br><span class="line">   |</span><br><span class="line"></span><br><span class="line">warning: unused import: `crate::front_of_house::hosting`</span><br><span class="line"><span class="meta prompt_"> --&gt; </span><span class="language-bash">src/lib.rs:7:5</span></span><br><span class="line">  |</span><br><span class="line">7 | use crate::front_of_house::hosting;</span><br><span class="line">  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span><br><span class="line">  |</span><br><span class="line">  = note: `#[warn(unused_imports)]` on by default</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0433`.</span><br><span class="line">warning: `restaurant` (lib) generated 1 warning</span><br><span class="line">error: could not compile `restaurant` (lib) due to 1 previous error; 1 warning emitted</span><br></pre></td></tr></table></figure>

<p>注意这里还有一个警告说 <code>use</code> 在其作用域内不再被使用！为了修复这个问题，可以将 <code>use</code> 移动到 <code>customer</code> 模块内，或者在子模块 <code>customer</code> 内通过 <code>super::hosting</code> 引用父模块中的这个捷径。</p>
<h3 id="创建惯用的-use-路径"><a href="#创建惯用的-use-路径" class="headerlink" title="创建惯用的 use 路径"></a>创建惯用的 <code>use</code> 路径</h3><p>在示例 7-11 中，你可能会比较疑惑，为什么我们是指定 <code>use crate::front_of_house::hosting</code>，然后在 <code>eat_at_restaurant</code> 中调用 <code>hosting::add_to_waitlist</code> ，而不是通过指定一直到 <code>add_to_waitlist</code> 函数的 <code>use</code> 路径来得到相同的结果，如示例 7-13 所示。</p>
<p>文件名：src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::front_of_house::hosting::add_to_waitlist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 7-13: 使用 <code>use</code> 将 <code>add_to_waitlist</code> 函数引入作用域，这并不符合习惯</p>
<p>虽然示例 7-11 和 7-13 都完成了相同的任务，但示例 7-11 是使用 <code>use</code> 将函数引入作用域的习惯用法。要想使用 <code>use</code> 将函数的父模块引入作用域，我们必须在调用函数时指定父模块，这样可以清晰地表明函数不是在本地定义的，同时使完整路径的重复度最小化。示例 7-13 中的代码不清楚 <code>add_to_waitlist</code> 是在哪里被定义的。</p>
<p>另一方面，使用 <code>use</code> 引入结构体、枚举和其他项时，习惯是指定它们的完整路径。示例 7-14 展示了将 <code>HashMap</code> 结构体引入二进制 crate 作用域的习惯用法。</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    map.<span class="title function_ invoke__">insert</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 7-14: 将 <code>HashMap</code> 引入作用域的习惯用法</p>
<p>这种习惯用法背后没有什么硬性要求：它只是一种惯例，人们已经习惯了以这种方式阅读和编写 Rust 代码。</p>
<p>这个习惯用法有一个例外，那就是我们想使用 <code>use</code> 语句将两个具有相同名称的项带入作用域，因为 Rust 不允许这样做。示例 7-15 展示了如何将两个具有相同名称但不同父模块的 <code>Result</code> 类型引入作用域，以及如何引用它们。</p>
<p>文件名：src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">function1</span>() <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">function2</span>() <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 7-15: 使用父模块将两个具有相同名称的类型引入同一作用域</p>
<p>如你所见，使用父模块可以区分这两个 <code>Result</code> 类型。如果我们是指定 <code>use std::fmt::Result</code> 和 <code>use std::io::Result</code>，我们将在同一作用域拥有了两个 <code>Result</code> 类型，当我们使用 <code>Result</code> 时，Rust 则不知道我们要用的是哪个。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-05-23T07:30:26.000Z" title="2025/5/23 15:30:26">2025-05-23</time>发表</span><span class="level-item"><time dateTime="2025-05-23T08:13:00.303Z" title="2025/5/23 16:13:00">2025-05-23</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Rust/">Rust</a><span> / </span><a class="link-muted" href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></span><span class="level-item">28 分钟读完 (大约4182个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/05/23/Rust/The%20Rust%20Programming%20Language/07.3%20%E5%BC%95%E7%94%A8%E6%A8%A1%E5%9D%97%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%B7%AF%E5%BE%84/">7.3 引用模块项目的路径</a></p><div class="content"><h2 id="引用模块树中项的路径"><a href="#引用模块树中项的路径" class="headerlink" title="引用模块树中项的路径"></a>引用模块树中项的路径</h2><p>为了向 Rust 指示在模块树中从何处查找某个项，我们使用路径，就像在文件系统中使用路径一样。为了调用一个函数，我们需要知道它的路径。</p>
<p>路径有两种形式：</p>
<ul>
<li><strong>绝对路径</strong>（<em>absolute path</em>）是以 crate 根（root）开头的完整路径；对于外部 crate 的代码，是以 crate 名开头的绝对路径，对于当前 crate 的代码，则以字面值 <code>crate</code> 开头。</li>
<li><strong>相对路径</strong>（<em>relative path</em>）从当前模块开始，以 <code>self</code>、<code>super</code> 或当前模块中的某个标识符开头。</li>
</ul>
<p>绝对路径和相对路径都后跟一个或多个由双冒号（<code>::</code>）分割的标识符。</p>
<p>回到示例 7-1，假设我们希望调用 <code>add_to_waitlist</code> 函数。这相当于在问：<code>add_to_waitlist</code> 函数的路径是什么？在示例 7-3 中删除了示例 7-1 的一些模块和函数。</p>
<p>我们在 crate 根定义了一个新函数 <code>eat_at_restaurant</code>，并在其中展示调用 <code>add_to_waitlist</code> 函数的两种方法。这些路径都是正确的，不过因为存在另一个问题导致示例无法照原样编译。稍后我们会解释为什么。</p>
<p><code>eat_at_restaurant</code> 函数是我们 crate 库的一个公共 API，所以我们使用 <code>pub</code> 关键字来标记它。在 <a href="#%E4%BD%BF%E7%94%A8-pub-%E5%85%B3%E9%94%AE%E5%AD%97%E6%9A%B4%E9%9C%B2%E8%B7%AF%E5%BE%84">“使用 <code>pub</code> 关键字暴露路径”</a> 一节，我们将详细介绍 <code>pub</code>。</p>
<p>文件名：src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    <span class="comment">// 绝对路径</span></span><br><span class="line">    crate::front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相对路径</span></span><br><span class="line">    front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 7-3: 使用绝对路径和相对路径来调用 <code>add_to_waitlist</code> 函数</p>
<p>第一次在 <code>eat_at_restaurant</code> 中调用 <code>add_to_waitlist</code> 函数时，使用的是绝对路径。<code>add_to_waitlist</code> 函数与 <code>eat_at_restaurant</code> 被定义在同一 crate 中，这意味着我们可以使用 <code>crate</code> 关键字为起始的绝对路径。接着我们依次包含各级模块，直到我们找到 <code>add_to_waitlist</code>。你可以想象出一个相同结构的文件系统：我们通过指定路径 <code>/front_of_house/hosting/add_to_waitlist</code> 来执行 <code>add_to_waitlist</code> 程序。我们使用 <code>crate</code> 从 crate 根开始就类似于在 shell 中使用 <code>/</code> 从文件系统根开始。</p>
<p>第二次在 <code>eat_at_restaurant</code> 中调用 <code>add_to_waitlist</code> 时，使用的是相对路径。这个路径以 <code>front_of_house</code> 为起始，这个模块在模块树中与 <code>eat_at_restaurant</code> 定义在同一层级。与之等价的文件系统路径就是 <code>front_of_house/hosting/add_to_waitlist</code>。以模块名开头意味着该路径是相对路径。</p>
<p>选择使用相对路径还是绝对路径要取决于你的项目，也取决于你是更倾向于将项的定义代码与使用该项的代码分开来移动，还是一起移动。例如，如果我们要将 <code>front_of_house</code> 模块和 <code>eat_at_restaurant</code> 函数一起移动到一个名为 <code>customer_experience</code> 的模块中，我们需要更新 <code>add_to_waitlist</code> 的绝对路径，但是相对路径还是可用的。相反，如果我们要将 <code>eat_at_restaurant</code> 函数单独移到一个名为 <code>dining</code> 的模块中，还是可以使用原本的绝对路径来调用 <code>add_to_waitlist</code>，但是相对路径必须要更新。我们更倾向于使用绝对路径，因为把代码定义和项调用各自独立地移动是更常见的。</p>
<p>让我们试着编译一下示例 7-3，并查明其为何不能编译！示例 7-4 展示了这个错误。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo build</span></span><br><span class="line">   Compiling restaurant v0.1.0 (file:///projects/restaurant)</span><br><span class="line">error[E0603]: module `hosting` is private</span><br><span class="line"><span class="meta prompt_"> --&gt; </span><span class="language-bash">src/lib.rs:9:28</span></span><br><span class="line">  |</span><br><span class="line">9 |     crate::front_of_house::hosting::add_to_waitlist();</span><br><span class="line">  |                            ^^^^^^^  --------------- function `add_to_waitlist` is not publicly re-exported</span><br><span class="line">  |                            |</span><br><span class="line">  |                            private module</span><br><span class="line">  |</span><br><span class="line">note: the module `hosting` is defined here</span><br><span class="line"><span class="meta prompt_"> --&gt; </span><span class="language-bash">src/lib.rs:2:5</span></span><br><span class="line">  |</span><br><span class="line">2 |     mod hosting &#123;</span><br><span class="line">  |     ^^^^^^^^^^^</span><br><span class="line"></span><br><span class="line">error[E0603]: module `hosting` is private</span><br><span class="line"><span class="meta prompt_">  --&gt; </span><span class="language-bash">src/lib.rs:12:21</span></span><br><span class="line">   |</span><br><span class="line">12 |     front_of_house::hosting::add_to_waitlist();</span><br><span class="line">   |                     ^^^^^^^  --------------- function `add_to_waitlist` is not publicly re-exported</span><br><span class="line">   |                     |</span><br><span class="line">   |                     private module</span><br><span class="line">   |</span><br><span class="line">note: the module `hosting` is defined here</span><br><span class="line"><span class="meta prompt_">  --&gt; </span><span class="language-bash">src/lib.rs:2:5</span></span><br><span class="line">   |</span><br><span class="line">2  |     mod hosting &#123;</span><br><span class="line">   |     ^^^^^^^^^^^</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0603`.</span><br><span class="line">error: could not compile `restaurant` (lib) due to 2 previous errors</span><br></pre></td></tr></table></figure>

<p>示例 7-4: 构建示例 7-3 出现的编译器错误</p>
<p>错误信息说 <code>hosting</code> 模块是私有的。换句话说，我们拥有 <code>hosting</code> 模块和 <code>add_to_waitlist</code> 函数的正确路径，但是 Rust 不让我们使用，因为它不能访问私有片段。在 Rust 中，所有项（函数、方法、结构体、枚举、模块和常量）默认对父模块都是私有的。如果希望创建一个如函数或结构体的私有项，可以将其放入一个模块。</p>
<p>父模块中的项不能使用子模块中的私有项，但是子模块中的项可以使用它们父模块中的项。这是因为子模块封装并隐藏了它们的实现详情，但是子模块可以看到定义它们的上下文。继续我们的比喻，把私有性规则想象成餐馆的后台办公室：后台的事务对餐厅顾客来说是不可知的，但办公室经理可以洞悉其经营的餐厅并在其中做任何事情。</p>
<p>Rust 选择以这种方式来实现模块系统功能，因此默认隐藏内部实现细节。这样一来，你就知道可以更改内部代码的哪些部分而不会破坏外部代码。不过 Rust 也确实提供了通过使用 <code>pub</code> 关键字来创建公共项，使子模块的内部部分暴露给上级模块。</p>
<h3 id="使用-pub-关键字暴露路径"><a href="#使用-pub-关键字暴露路径" class="headerlink" title="使用 pub 关键字暴露路径"></a>使用 <code>pub</code> 关键字暴露路径</h3><p>让我们回头看一下示例 7-4 的错误，它告诉我们 <code>hosting</code> 模块是私有的。我们想让父模块中的 <code>eat_at_restaurant</code> 函数可以访问子模块中的 <code>add_to_waitlist</code> 函数，因此我们使用 <code>pub</code> 关键字来标记 <code>hosting</code> 模块，如示例 7-5 所示。</p>
<p>文件名：src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -- snip --</span></span><br></pre></td></tr></table></figure>

<p>示例 7-5: 使用 <code>pub</code> 关键字声明 <code>hosting</code> 模块使其可在 <code>eat_at_restaurant</code> 使用</p>
<p>不幸的是，示例 7-5 的代码编译仍然有错误，如示例 7-6 所示。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo build</span></span><br><span class="line">   Compiling restaurant v0.1.0 (file:///projects/restaurant)</span><br><span class="line">error[E0603]: function `add_to_waitlist` is private</span><br><span class="line"><span class="meta prompt_">  --&gt; </span><span class="language-bash">src/lib.rs:10:37</span></span><br><span class="line">   |</span><br><span class="line">10 |     crate::front_of_house::hosting::add_to_waitlist();</span><br><span class="line">   |                                     ^^^^^^^^^^^^^^^ private function</span><br><span class="line">   |</span><br><span class="line">note: the function `add_to_waitlist` is defined here</span><br><span class="line"><span class="meta prompt_">  --&gt; </span><span class="language-bash">src/lib.rs:3:9</span></span><br><span class="line">   |</span><br><span class="line">3  |         fn add_to_waitlist() &#123;&#125;</span><br><span class="line">   |         ^^^^^^^^^^^^^^^^^^^^</span><br><span class="line"></span><br><span class="line">error[E0603]: function `add_to_waitlist` is private</span><br><span class="line"><span class="meta prompt_">  --&gt; </span><span class="language-bash">src/lib.rs:13:30</span></span><br><span class="line">   |</span><br><span class="line">13 |     front_of_house::hosting::add_to_waitlist();</span><br><span class="line">   |                              ^^^^^^^^^^^^^^^ private function</span><br><span class="line">   |</span><br><span class="line">note: the function `add_to_waitlist` is defined here</span><br><span class="line"><span class="meta prompt_">  --&gt; </span><span class="language-bash">src/lib.rs:3:9</span></span><br><span class="line">   |</span><br><span class="line">3  |         fn add_to_waitlist() &#123;&#125;</span><br><span class="line">   |         ^^^^^^^^^^^^^^^^^^^^</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0603`.</span><br><span class="line">error: could not compile `restaurant` (lib) due to 2 previous errors</span><br></pre></td></tr></table></figure>

<p>示例 7-6: 构建示例 7-5 出现的编译器错误</p>
<p>发生了什么？在 <code>mod hosting</code> 前添加了 <code>pub</code> 关键字，使其变成公有的。伴随着这种变化，如果我们可以访问 <code>front_of_house</code>，那我们也可以访问 <code>hosting</code>。但是 <code>hosting</code> 的<strong>内容</strong>（<em>contents</em>）仍然是私有的；这表明使模块公有并不使其内容也是公有的。模块上的 <code>pub</code> 关键字只允许其父模块引用它，而不允许访问内部代码。因为模块是一个容器，只是将模块变为公有能做的其实并不太多；同时需要更深入地选择将一个或多个项变为公有。</p>
<p>示例 7-6 中的错误说，<code>add_to_waitlist</code> 函数是私有的。私有性规则不但应用于模块，还应用于结构体、枚举、函数和方法。</p>
<p>让我们继续将 <code>pub</code> 关键字放置在 <code>add_to_waitlist</code> 函数的定义之前，使其变成公有。如示例 7-7 所示。</p>
<p>文件名：src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -- snip --</span></span><br></pre></td></tr></table></figure>

<p>示例 7-7: 为 <code>mod hosting</code> 和 <code>fn add_to_waitlist</code> 添加 <code>pub</code> 关键字使它们可以在 <code>eat_at_restaurant</code> 函数中被调用</p>
<p>现在代码可以编译通过了！为了了解为何增加 <code>pub</code> 关键字使得我们可以在 <code>eat_at_restaurant</code> 中调用这些路径与私有性规则有关，让我们看看绝对路径和相对路径。</p>
<p>在绝对路径，我们从 <code>crate</code> 也就是 crate 根开始。crate 根中定义了 <code>front_of_house</code> 模块。虽然 <code>front_of_house</code> 模块不是公有的，不过因为 <code>eat_at_restaurant</code> 函数与 <code>front_of_house</code> 定义于同一级模块中（即，<code>eat_at_restaurant</code> 和 <code>front_of_house</code> 是兄弟），我们可以从 <code>eat_at_restaurant</code> 中引用 <code>front_of_house</code>。接下来是使用 <code>pub</code> 标记的 <code>hosting</code> 模块。我们可以访问 <code>hosting</code> 的父模块，所以可以访问 <code>hosting</code>。最后，<code>add_to_waitlist</code> 函数被标记为 <code>pub</code> ，我们可以访问其父模块，所以这个函数调用是有效的！</p>
<p>在相对路径，其逻辑与绝对路径相同，除了第一步：不同于从 crate 根开始，路径从 <code>front_of_house</code> 开始。<code>front_of_house</code> 模块与 <code>eat_at_restaurant</code> 定义于同一级模块，所以从 <code>eat_at_restaurant</code> 中开始定义的该模块相对路径是有效的。接下来因为 <code>hosting</code> 和 <code>add_to_waitlist</code> 被标记为 <code>pub</code>，路径其余的部分也是有效的，因此函数调用也是有效的！</p>
<p>如果你计划共享你的库 crate 以便其它项目可以使用你的代码，公有 API 将是决定 crate 用户如何与你代码交互的契约。关于管理公有 API 的修改以便被人更容易依赖你的库有着很多考量。这些考量超出了本书的范畴；如果你对这些话题感兴趣，请查阅 <a target="_blank" rel="noopener" href="https://rust-lang.github.io/api-guidelines/">The Rust API Guidelines</a>。</p>
<blockquote>
<h3 id="二进制和库-crate-包的最佳实践"><a href="#二进制和库-crate-包的最佳实践" class="headerlink" title="二进制和库 crate 包的最佳实践"></a>二进制和库 crate 包的最佳实践</h3><p>我们提到过包（package）可以同时包含一个 <em>src&#x2F;main.rs</em> 二进制 crate 根和一个 <em>src&#x2F;lib.rs</em> 库 crate 根，并且这两个 crate 默认以包名来命名。通常，这种包含二进制 crate 和库 crate 的模式的包，在二进制 crate 中只保留足以生成一个可执行文件的代码，并由可执行文件调用库 crate 的代码。又因为库 crate 可以共享，这使得其它项目从包提供的大部分功能中受益。</p>
<p>模块树应该定义在 <em>src&#x2F;lib.rs</em> 中。这样通过以包名开头的路径，公有项就可以在二进制 crate 中使用。二进制 crate 就变得像一个一个完全外部的 crate 来使用库 crate 的用户一样：它只能使用 public API。你不仅仅是作者，也是用户！</p>
<p>在第十二章我们会通过一个同时包含二进制 crate 和库 crate 的命令行程序来展示这些组织上的实践。</p>
</blockquote>
<h3 id="super-开始的相对路径"><a href="#super-开始的相对路径" class="headerlink" title="super 开始的相对路径"></a><code>super</code> 开始的相对路径</h3><p>我们可以通过在路径的开头使用 <code>super</code> ，从父模块开始构建相对路径，而不是从当前模块或者 crate 根开始。这类似以 <code>..</code> 语法开始一个文件系统路径。使用 <code>super</code> 允许我们引用父模块中的已知项，这使得当模块与父模块关联的很紧密，但某天父模块可能要移动到模块树的其它位置时重新组织模块树变得更容易。</p>
<p>考虑一下示例 7-8 中的代码，它模拟了厨师更正了一个错误订单并亲自将其提供给客户的情况。<code>back_of_house</code> 模块中的定义的 <code>fix_incorrect_order</code> 函数通过指定的 <code>super</code> 起始的 <code>deliver_order</code> 路径来调用父模块中的 <code>deliver_order</code> 函数。</p>
<p>文件名：src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">deliver_order</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> back_of_house &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fix_incorrect_order</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">cook_order</span>();</span><br><span class="line">        super::<span class="title function_ invoke__">deliver_order</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">cook_order</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 7-8: 使用以 <code>super</code> 开头的相对路径调用函数</p>
<p><code>fix_incorrect_order</code> 函数在 <code>back_of_house</code> 模块中，所以我们可以使用 <code>super</code> 进入 <code>back_of_house</code> 父模块，也就是本例中的 <code>crate</code> 根。在这里，我们可以找到 <code>deliver_order</code>。成功！我们认为 <code>back_of_house</code> 模块和 <code>deliver_order</code> 函数之间可能保持某种关联关系并且如果我们要重新组织这个 crate 的模块树时，需要一起移动它们。因此，我们使用 <code>super</code>，这样一来，如果这些代码被移动到了其他模块，只需要更新很少的代码。</p>
<h3 id="创建公有的结构体和枚举"><a href="#创建公有的结构体和枚举" class="headerlink" title="创建公有的结构体和枚举"></a>创建公有的结构体和枚举</h3><p>我们还可以使用 <code>pub</code> 来设计公有的结构体和枚举，不过关于在结构体和枚举上使用 <code>pub</code> 还有一些额外的细节需要注意。如果我们在一个结构体定义的前面使用了 <code>pub</code>，这个结构体会变成公有的，但是这个结构体的字段仍然是私有的。我们可以根据情况决定每个字段是否公有。在示例 7-9 中，我们定义了一个公有结构体 <code>back_of_house::Breakfast</code>，其中有一个公有字段 <code>toast</code> 和私有字段 <code>seasonal_fruit</code>。这个例子模拟的情况是，在一家餐馆中，顾客可以选择随餐面包的类型，但是厨师会根据季节和库存情况来决定随餐搭配的水果。餐馆可用的水果变化是很快的，所以顾客不能选择水果，甚至无法看到他们将会得到什么水果。</p>
<p>文件名：src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> back_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Breakfast</span> &#123;</span><br><span class="line">        <span class="keyword">pub</span> toast: <span class="type">String</span>,</span><br><span class="line">        seasonal_fruit: <span class="type">String</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">Breakfast</span> &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">summer</span>(toast: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> Breakfast &#123;</span><br><span class="line">            Breakfast &#123;</span><br><span class="line">                toast: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(toast),</span><br><span class="line">                seasonal_fruit: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;peaches&quot;</span>),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    <span class="comment">// 在夏天订购一个黑麦土司作为早餐</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">meal</span> = back_of_house::Breakfast::<span class="title function_ invoke__">summer</span>(<span class="string">&quot;Rye&quot;</span>);</span><br><span class="line">    <span class="comment">// 改变主意更换想要面包的类型</span></span><br><span class="line">    meal.toast = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Wheat&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;I&#x27;d like &#123;&#125; toast please&quot;</span>, meal.toast);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果取消下一行的注释代码不能编译；</span></span><br><span class="line">    <span class="comment">// 不允许查看或修改早餐附带的季节水果</span></span><br><span class="line">    <span class="comment">// meal.seasonal_fruit = String::from(&quot;blueberries&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 7-9: 带有公有和私有字段的结构体</p>
<p>因为 <code>back_of_house::Breakfast</code> 结构体的 <code>toast</code> 字段是公有的，所以我们可以在 <code>eat_at_restaurant</code> 中使用点号来读写 <code>toast</code> 字段。注意，我们不能在 <code>eat_at_restaurant</code> 中使用 <code>seasonal_fruit</code> 字段，因为 <code>seasonal_fruit</code> 是私有的。尝试去除那一行修改 <code>seasonal_fruit</code> 字段值的代码的注释，看看你会得到什么错误！</p>
<p>还请注意一点，因为 <code>back_of_house::Breakfast</code> 具有私有字段，所以这个结构体需要提供一个公共的关联函数来构造 <code>Breakfast</code> 的实例 (这里我们命名为 <code>summer</code>)。如果 <code>Breakfast</code> 没有这样的函数，我们将无法在 <code>eat_at_restaurant</code> 中创建 <code>Breakfast</code> 实例，因为我们不能在 <code>eat_at_restaurant</code> 中设置私有字段 <code>seasonal_fruit</code> 的值。</p>
<p>与之相反，如果我们将枚举设为公有，则它的所有变体都将变为公有。我们只需要在 <code>enum</code> 关键字前面加上 <code>pub</code>，就像示例 7-10 展示的那样。</p>
<p>文件名：src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> back_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Appetizer</span> &#123;</span><br><span class="line">        Soup,</span><br><span class="line">        Salad,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">order1</span> = back_of_house::Appetizer::Soup;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">order2</span> = back_of_house::Appetizer::Salad;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 7-10: 设计公有枚举，使其所有成员公有</p>
<p>因为我们将 <code>Appetizer</code> 枚举声明为公有，所以可以在 <code>eat_at_restaurant</code> 中使用 <code>Soup</code> 和 <code>Salad</code> 变体。</p>
<p>如果枚举变体不是公有的，那么枚举会显得用处不大；给枚举的所有变体挨个添加 <code>pub</code> 是很令人恼火的，因此枚举变体默认就是公有的。结构体在许多情况下即使字段不可公有也能正常使用，所以结构体字段遵循默认私有的通用规则，除非使用 <code>pub</code> 关键字。</p>
<p>还有一个我们尚未介绍的与 <code>pub</code> 相关的情形，那就是模块系统的最后一个特性：<code>use</code> 关键字。我们将先单独介绍 <code>use</code>，然后展示如何结合使用 <code>pub</code> 和 <code>use</code>。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-05-23T07:00:26.000Z" title="2025/5/23 15:00:26">2025-05-23</time>发表</span><span class="level-item"><time dateTime="2025-05-23T07:44:41.325Z" title="2025/5/23 15:44:41">2025-05-23</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Rust/">Rust</a><span> / </span><a class="link-muted" href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></span><span class="level-item">15 分钟读完 (大约2204个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/05/23/Rust/The%20Rust%20Programming%20Language/07.2%20%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97%E6%9D%A5%E6%8E%A7%E5%88%B6%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E7%A7%81%E6%9C%89%E6%80%A7/">7.2 定义模块来控制作用域与私有性</a></p><div class="content"><h2 id="定义模块来控制作用域与私有性"><a href="#定义模块来控制作用域与私有性" class="headerlink" title="定义模块来控制作用域与私有性"></a>定义模块来控制作用域与私有性</h2><p>在本节，我们将讨论模块和其它一些关于模块系统的部分，如允许你命名项的 <em>路径</em>（<em>paths</em>）；用来将路径引入作用域的 <code>use</code> 关键字；以及使项变为公有的 <code>pub</code> 关键字。我们还将讨论 <code>as</code> 关键字、外部包（external packages）和 glob 运算符（glob operator）。</p>
<p>首先，我们将从一系列的规则开始，在你未来组织代码的时候，这些规则可被用作简单的参考。接下来我们将会详细的解释每条规则。</p>
<h2 id="模块小抄（Cheat-Sheet）"><a href="#模块小抄（Cheat-Sheet）" class="headerlink" title="模块小抄（Cheat Sheet）"></a>模块小抄（Cheat Sheet）</h2><p>在深入了解模块和路径的细节之前，这里提供一个简单的参考，用来解释模块、路径、<code>use</code>关键词和<code>pub</code>关键词如何在编译器中工作，以及大部分开发者如何组织他们的代码。我们将在本章中举例说明每条规则，但这是回顾模块工作原理的绝佳参考。</p>
<ul>
<li><p><strong>从 crate 根节点开始</strong> : 当编译一个 crate, 编译器首先在 crate 根文件（通常，对于一个库 crate 而言是 <em>src&#x2F;lib.rs</em>，对于一个二进制 crate 而言是 <em>src&#x2F;main.rs</em>）中寻找需要被编译的代码。</p>
</li>
<li><p><strong>声明模块</strong> : 在 crate 根文件中，你可以声明一个新模块；比如，用 <code>mod garden;</code> 声明了一个叫做 <code>garden</code> 的模块。编译器会在下列路径中寻找模块代码：</p>
<ul>
<li>内联，用大括号替换 <code>mod garden</code> 后跟的分号</li>
<li>在文件 <em>src&#x2F;garden.rs</em></li>
<li>在文件 <em>src&#x2F;garden&#x2F;mod.rs</em></li>
</ul>
</li>
<li><p><strong>声明子模块</strong> : 在除了 crate 根节点以外的任何文件中，你可以定义子模块。比如，你可能在 <em>src&#x2F;garden.rs</em> 中声明 <code>mod vegetables;</code>  。编译器会在以父模块命名的目录中寻找子模块代码：</p>
<ul>
<li>内联，直接在 <code>mod vegetables</code> 后方不是一个分号而是一个大括号</li>
<li>在文件 <em>src&#x2F;garden&#x2F;vegetables.rs</em></li>
<li>在文件 <em>src&#x2F;garden&#x2F;vegetables&#x2F;mod.rs</em></li>
</ul>
</li>
<li><p><strong>模块中的代码路径</strong>: 一旦一个模块是你 crate 的一部分，你可以在隐私规则允许的前提下，从同一个 crate 内的任意地方，通过代码路径引用该模块的代码。举例而言，一个 garden vegetables 模块下的 <code>Asparagus</code> 类型可以通过 <code>crate::garden::vegetables::Asparagus</code> 访问。</p>
</li>
<li><p><strong>私有 vs 公用</strong>: 一个模块里的代码默认对其父模块私有。为了使一个模块公用，应当在声明时使用 <code>pub mod</code> 替代 <code>mod</code>。为了使一个公用模块内部的成员公用，应当在声明前使用<code>pub</code>。</p>
</li>
<li><p><strong><code>use</code> 关键字</strong>: 在一个作用域内，<code>use</code>关键字创建了一个项的快捷方式，用来减少长路径的重复。在任何可以引用 <code>crate::garden::vegetables::Asparagus</code> 的作用域，你可以通过 <code>use crate::garden::vegetables::Asparagus;</code> 创建一个快捷方式，然后你就可以在作用域中只写 <code>Asparagus</code> 来使用该类型。</p>
</li>
</ul>
<p>这里我们创建一个名为<code>backyard</code>的二进制 crate 来说明这些规则。该 crate 的路径同样命名为<code>backyard</code>，该路径包含了这些文件和目录：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">backyard</span><br><span class="line">├── Cargo.lock</span><br><span class="line">├── Cargo.toml</span><br><span class="line">└── src</span><br><span class="line">    ├── garden</span><br><span class="line">    │   └── vegetables.rs</span><br><span class="line">    ├── garden.rs</span><br><span class="line">    └── main.rs</span><br></pre></td></tr></table></figure>

<p>这个例子中的 crate 根文件是 <em>src&#x2F;main.rs</em>，该文件包含了：</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::garden::vegetables::Asparagus;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> garden;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">plant</span> = Asparagus &#123;&#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;I&#x27;m growing &#123;plant:?&#125;!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>pub mod garden;</code> 行告诉编译器将 <em>src&#x2F;garden.rs</em> 中发现的代码包含进来：</p>
<p>文件名：src&#x2F;garden.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> vegetables;</span><br></pre></td></tr></table></figure>

<p>在此处，<code>pub mod vegetables;</code> 意味着在 <em>src&#x2F;garden&#x2F;vegetables.rs</em> 中的代码也应该被包含。这些代码是：</p>
<p>文件名：src&#x2F;garden.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Asparagus</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>现在让我们深入了解这些规则的细节并在实践中演示它们！</p>
<h3 id="在模块中对相关代码进行分组"><a href="#在模块中对相关代码进行分组" class="headerlink" title="在模块中对相关代码进行分组"></a>在模块中对相关代码进行分组</h3><p><strong>模块</strong>让我们可以将一个 crate 中的代码进行分组，以提高可读性与重用性。因为一个模块中的代码默认是私有的，所以还可以利用模块控制项的<strong>私有性</strong>（<em>privacy</em>）。私有项是不可为外部使用的内在详细实现。我们也可以将模块和它其中的项标记为公开的，这样，外部代码就可以使用并依赖于它们。</p>
<p>作为示例，让我们编写一个提供餐厅功能的库 <code>crate</code>。我们将定义函数的签名，但将其函数体留空以便将注意力集中在代码的组织结构上而不是餐厅实现的细节。</p>
<p>在餐饮业，餐馆中会有一些地方被称之为<strong>前台</strong>（<em>front of house</em>），还有另外一些地方被称之为<strong>后台</strong>（<em>back of house</em>）。前台是招待顾客的地方；这包括接待员为顾客安排座位、服务员接受点单和付款、调酒师制作饮品的地方。后台则是厨师和烹饪人员在厨房工作、洗碗工清理餐具，以及经理处理行政事务的区域。</p>
<p>为了以这种方式构建我们的 <code>crate</code>，我们可以将其功能组织到嵌套模块中。通过执行 <code>cargo new restaurant --lib</code> 来创建一个新的名为 <code>restaurant</code> 的库。然后将示例 7-1 中所罗列出来的代码放入 <em>src&#x2F;lib.rs</em> 中，来定义一些模块和函数签名；这段代码即为前台部分。</p>
<p>文件名：src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">seat_at_table</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mod</span> serving &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">take_order</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">serve_order</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">take_payment</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 7-1：一个包含了其他内置了函数的模块的 <code>front_of_house</code> 模块</p>
<p>我们使用 <code>mod</code> 关键字来定义模块，后跟模块名（本例中叫做 <code>front_of_house</code>），并且用花括号包围模块的主体。在模块内，我们还可以定义其它的模块，就像本例中的 <code>hosting</code> 和 <code>serving</code> 模块。模块还可以保存一些定义的其它项，比如结构体、枚举、常量、trait、或者如示例 7-1 所示的函数。</p>
<p>通过使用模块，我们可以将相关的定义分组到一起，并指出它们为什么相关。程序员可以通过使用这段代码，更加容易地找到他们想要的定义，因为他们可以基于分组来对代码进行导航，而不需要阅读所有的定义。程序员向这段代码中添加一个新的功能时，他们也会知道代码应该放置在何处，可以保持程序的组织性。</p>
<p>在前面我们提到了，<code>src/main.rs</code> 和 <code>src/lib.rs</code> 叫做 crate 根。之所以这样叫它们是因为这两个文件的内容都分别在 crate 模块结构的根组成了一个名为 <code>crate</code> 的模块，该结构被称为<strong>模块树</strong>（<em>module tree</em>）。</p>
<p>示例 7-2 展示了示例 7-1 中模块树的结构。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">crate</span><br><span class="line"> └── front_of_house</span><br><span class="line">     ├── hosting</span><br><span class="line">     │   ├── add_to_waitlist</span><br><span class="line">     │   └── seat_at_table</span><br><span class="line">     └── serving</span><br><span class="line">         ├── take_order</span><br><span class="line">         ├── serve_order</span><br><span class="line">         └── take_payment</span><br></pre></td></tr></table></figure>

<p>示例 7-2: 示例 7-1 中代码的模块树</p>
<p>这个树展示了一些模块是如何被嵌入到另一个模块的（例如，<code>hosting</code> 嵌套在 <code>front_of_house</code> 中）。这个树还展示了一些模块是互为<strong>兄弟</strong>（<em>siblings</em>）的，这意味着它们定义在同一模块中；<code>hosting</code> 和 <code>serving</code> 被一起定义在 <code>front_of_house</code> 中。继续沿用家庭关系的比喻，如果一个模块 A 被包含在模块 B 中，我们将模块 A 称为模块 B 的 <strong>子</strong>（<em>child</em>）模块，模块 B 则是模块 A 的 <strong>父</strong>（<em>parent</em>）模块。注意，整个模块树都植根于名为 <code>crate</code> 的隐式模块下。</p>
<p>这个模块树可能会令你想起电脑上文件系统的目录树；这是一个非常恰当的类比！就像文件系统的目录，你可以使用模块来组织你的代码。并且，就像目录中的文件，我们需要一种方法来找到模块。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-05-23T06:30:26.000Z" title="2025/5/23 14:30:26">2025-05-23</time>发表</span><span class="level-item"><time dateTime="2025-05-23T07:32:14.231Z" title="2025/5/23 15:32:14">2025-05-23</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Rust/">Rust</a><span> / </span><a class="link-muted" href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></span><span class="level-item">6 分钟读完 (大约935个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/05/23/Rust/The%20Rust%20Programming%20Language/07.1%20%E5%8C%85%E5%92%8C%20Crate/">7.1 包和 Crate</a></p><div class="content"><h2 id="包和-Crate"><a href="#包和-Crate" class="headerlink" title="包和 Crate"></a>包和 Crate</h2><p>模块系统的第一部分，我们将介绍包和 crate。</p>
<p>crate 是 Rust 在编译时最小的代码单位。即使你用 <code>rustc</code> 而不是 <code>cargo</code> 来编译一个单独的源代码文件（正如我们在第 1 章“编写并运行 Rust 程序”中所做的那样），编译器还是会将那个文件视为一个 crate。crate 可以包含模块，模块可以定义在其他文件，然后和 crate 一起编译，我们会在接下来的章节中遇到。</p>
<p>crate 有两种形式：二进制 crate 和库 crate。<strong>二进制 crate</strong>（<em>Binary crates</em>）可以被编译为可执行程序，比如命令行程序或者服务端。它们必须有一个名为 <code>main</code> 函数来定义当程序被执行的时候所需要做的事情。目前我们所创建的 crate 都是二进制 crate。</p>
<p><strong>库 crate</strong>（<em>Library crates</em>）并没有 <code>main</code> 函数，它们也不会编译为可执行程序。相反它们定义了可供多个项目复用的功能模块。比如 [第二章](.&#x2F;02 编写一个猜数游戏) 的 <code>rand</code> crate 就提供了生成随机数的功能。大多数时间 <code>Rustaceans</code> 说的 “crate” 指的都是库 crate，这与其他编程语言中 “library” 概念一致。</p>
<p><em>crate root</em> 是一个源文件，Rust 编译器以它为起始点，并构成你的 crate 的根模块（我们将在 [“定义模块来控制作用域与私有性”](.&#x2F;07.2 定义模块来控制作用域与私有性) 一节深入解读）。</p>
<p><em>包</em>（<em>package</em>）是提供一系列功能的一个或者多个 crate 的捆绑。一个包会包含一个 <em>Cargo.toml</em> 文件，阐述如何去构建这些 crate。Cargo 实际上就是一个包，它包含了用于构建你代码的命令行工具的二进制 crate。其他项目也依赖 Cargo 库来实现与 Cargo 命令行程序一样的逻辑。</p>
<p>包中可以包含至多一个库 crate(library crate)。包中可以包含任意多个二进制 crate(binary crate)，但是必须至少包含一个 crate（无论是库的还是二进制的）。</p>
<p>让我们来看看创建包的时候会发生什么。首先，我们输入命令 <code>cargo new my-project</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo new my-project</span></span><br><span class="line">     Created binary (application) `my-project` package</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> my-project</span></span><br><span class="line">Cargo.toml</span><br><span class="line">src</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> my-project/src</span></span><br><span class="line">main.rs</span><br></pre></td></tr></table></figure>

<p>运行了这条命令后，我们先用 <code>ls</code> 来看看 Cargo 给我们创建了什么，Cargo 会给我们的包创建一个 <em>Cargo.toml</em> 文件。查看 <em>Cargo.toml</em> 的内容，会发现并没有提到 <em>src&#x2F;main.rs</em>，因为 Cargo 遵循的一个约定：<em>src&#x2F;main.rs</em> 就是一个与包同名的二进制 crate 的 crate 根。同样的，Cargo 知道如果包目录中包含 <em>src&#x2F;lib.rs</em>，则包带有与其同名的库 crate，且 <em>src&#x2F;lib.rs</em> 是 crate 根。crate 根文件将由 Cargo 传递给 <code>rustc</code> 来实际构建库或者二进制项目。</p>
<p>在此，我们有了一个只包含 <em>src&#x2F;main.rs</em> 的包，意味着它只含有一个名为 <code>my-project</code> 的二进制 crate。如果一个包同时含有 <em>src&#x2F;main.rs</em> 和 <em>src&#x2F;lib.rs</em>，则它有两个 crate：一个二进制的和一个库的，且名字都与包相同。通过将文件放在 <em>src&#x2F;bin</em> 目录下，一个包可以拥有多个二进制 crate：每个 <em>src&#x2F;bin</em> 下的文件都会被编译成一个独立的二进制 crate。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-05-22T06:30:26.000Z" title="2025/5/22 14:30:26">2025-05-22</time>发表</span><span class="level-item"><time dateTime="2025-05-22T06:35:46.571Z" title="2025/5/22 14:35:46">2025-05-22</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Rust/">Rust</a><span> / </span><a class="link-muted" href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></span><span class="level-item">22 分钟读完 (大约3265个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/05/22/Rust/The%20Rust%20Programming%20Language/06.2%20match%20%E6%8E%A7%E5%88%B6%E6%B5%81%E7%BB%93%E6%9E%84/">6.2 match 控制流结构</a></p><div class="content"><h2 id="match-控制流结构"><a href="#match-控制流结构" class="headerlink" title="match 控制流结构"></a><code>match</code> 控制流结构</h2><p>Rust 有一个叫做 <code>match</code> 的极为强大的控制流运算符，它允许我们将一个值与一系列的模式相比较，并根据相匹配的模式执行相应代码。模式可由字面值、变量、通配符和许多其他内容构成；第十九章会涉及到所有不同种类的模式以及它们的作用。<code>match</code> 的力量来源于模式的表现力，以及编译器能够确认所有可能情况均已被覆盖。</p>
<p>可以把 <code>match</code> 表达式想象成某种硬币分类器：硬币滑入有着不同大小孔洞的轨道，每一个硬币都会掉入符合它大小的孔洞。同样地，值也会通过 <code>match</code> 的每一个模式，并且在遇到第一个 “符合” 的模式时，值会进入相关联的代码块并在执行中被使用。</p>
<p>因为刚刚提到了硬币，让我们用它们来作为一个使用 <code>match</code> 的例子！我们可以编写一个函数来获取一个未知的美国硬币，并以一种类似验钞机的方式，确定它是何种硬币并返回它的美分值，如示例 6-3 中所示。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Coin</span> &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">value_in_cents</span>(coin: Coin) <span class="punctuation">-&gt;</span> <span class="type">u8</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; <span class="number">1</span>,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter =&gt; <span class="number">25</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 6-3：一个枚举和一个以枚举变体作为模式的 <code>match</code> 表达式</p>
<p>拆开 <code>value_in_cents</code> 函数中的 <code>match</code> 来看。首先，我们列出 <code>match</code> 关键字后跟一个表达式，在这个例子中是 <code>coin</code> 的值。这看起来非常像 <code>if</code> 所使用的条件表达式，不过这里有一个非常大的区别：对于 <code>if</code>，表达式必须返回一个布尔值，而这里它可以是任何类型的。例子中的 <code>coin</code> 的类型是示例 6-3 中定义的 <code>Coin</code> 枚举。</p>
<p>接下来是 <code>match</code> 的分支。一个分支有两个部分：一个模式和一些代码。第一个分支的模式是值 <code>Coin::Penny</code> 而之后的 <code>=&gt;</code> 运算符将模式和将要运行的代码分开。这里的代码就仅仅是值 <code>1</code>。每一个分支之间使用逗号分隔。</p>
<p>当 <code>match</code> 表达式执行时，它将结果值按顺序与每一个分支的模式相比较。如果模式匹配了这个值，这个模式相关联的代码将被执行。如果模式并不匹配这个值，将继续执行下一个分支，非常类似一个硬币分类器。可以拥有任意多的分支：示例 6-3 中的 <code>match</code> 有四个分支。</p>
<p>每个分支相关联的代码是一个表达式，而表达式的结果值将作为整个 <code>match</code> 表达式的返回值。</p>
<p>如果分支代码较短的话通常不使用大括号，正如示例 6-3 中的每个分支都只是返回一个值。如果想要在分支中运行多行代码，可以使用大括号，而分支后的逗号是可选的。例如，如下代码在每次使用<code>Coin::Penny</code> 调用时都会打印出 “Lucky penny!”，同时仍然返回代码块最后的值，<code>1</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">value_in_cents</span>(coin: Coin) <span class="punctuation">-&gt;</span> <span class="type">u8</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Lucky penny!&quot;</span>);</span><br><span class="line">            <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter =&gt; <span class="number">25</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="绑定值的模式"><a href="#绑定值的模式" class="headerlink" title="绑定值的模式"></a>绑定值的模式</h3><p>匹配分支的另一个有用的功能是可以绑定匹配的模式的部分值。这也就是如何从枚举变体中提取值的。</p>
<p>作为一个例子，让我们修改枚举的一个变体来存放数据。1999 年到 2008 年间，美国在 25 美分的硬币的一侧为 50 个州的每一个都印刷了不同的设计。其他的硬币都没有这种区分州的设计，所以只有这些 25 美分硬币有特殊的价值。可以将这些信息加入我们的 <code>enum</code>，通过改变 <code>Quarter</code> 变体来包含一个 <code>State</code> 值，示例 6-4 中完成了这些修改：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span> <span class="comment">// 这样可以立刻看到州的名称</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">UsState</span> &#123;</span><br><span class="line">    Alabama,</span><br><span class="line">    Alaska,</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Coin</span> &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    <span class="title function_ invoke__">Quarter</span>(UsState),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 6-4：<code>Quarter</code> 变体也存放了一个 <code>UsState</code> 值的 <code>Coin</code> 枚举</p>
<p>想象一下我们的一个朋友尝试收集所有 50 个州的 25 美分硬币。在根据硬币类型分类零钱的同时，也可以报告出每个 25 美分硬币所对应的州名称，这样如果我们的朋友没有的话，他可以将其加入收藏。</p>
<p>在这些代码的匹配表达式中，我们在匹配 <code>Coin::Quarter</code> 变体的分支的模式中增加了一个叫做 <code>state</code> 的变量。当匹配到 <code>Coin::Quarter</code> 时，变量 <code>state</code> 将会绑定 25 美分硬币所对应州的值。接着在那个分支的代码中使用 <code>state</code>，如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">value_in_cents</span>(coin: Coin) <span class="punctuation">-&gt;</span> <span class="type">u8</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; <span class="number">1</span>,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::<span class="title function_ invoke__">Quarter</span>(state) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;State quarter from &#123;state:?&#125;!&quot;</span>);</span><br><span class="line">            <span class="number">25</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果调用 <code>value_in_cents(Coin::Quarter(UsState::Alaska))</code>，<code>coin</code> 将是 <code>Coin::Quarter(UsState::Alaska)</code>。当将值与每个分支相比较时，没有分支会匹配，直到遇到 <code>Coin::Quarter(state)</code>。这时，<code>state</code> 绑定的将会是值 <code>UsState::Alaska</code>。接着就可以在 <code>println!</code> 表达式中使用这个绑定了，像这样就可以获取 <code>Coin</code> 枚举的 <code>Quarter</code> 变体中内部的州的值。</p>
<h3 id="匹配-Option"><a href="#匹配-Option" class="headerlink" title="匹配 Option"></a>匹配 <code>Option</code></h3><p>我们在之前的部分中使用 <code>Option&lt;T&gt;</code> 时，是为了从 <code>Some</code> 中取出其内部的 <code>T</code> 值；我们还可以像处理 <code>Coin</code> 枚举那样使用 <code>match</code> 处理 <code>Option&lt;T&gt;</code>！只不过这回比较的不再是硬币，而是 <code>Option&lt;T&gt;</code> 的变体，但 <code>match</code> 表达式的工作方式保持不变。</p>
<p>比如我们想要编写一个函数，它获取一个 <code>Option&lt;i32&gt;</code> ，如果其中含有一个值，将其加一。如果其中没有值，函数应该返回 <code>None</code> 值，而不尝试执行任何操作。</p>
<p>得益于 <code>match</code>，编写这个函数非常简单，它将看起来像示例 6-5 中这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">plus_one</span>(x: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(i) =&gt; <span class="title function_ invoke__">Some</span>(i + <span class="number">1</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">five</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">six</span> = <span class="title function_ invoke__">plus_one</span>(five);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">none</span> = <span class="title function_ invoke__">plus_one</span>(<span class="literal">None</span>);</span><br></pre></td></tr></table></figure>

<p>示例 6-5：一个在 <code>Option&lt;i32&gt;</code> 上使用 <code>match</code> 表达式的函数</p>
<p>让我们更仔细地检查 <code>plus_one</code> 的第一行操作。当调用 <code>plus_one(five)</code> 时，<code>plus_one</code> 函数体中的 <code>x</code> 将会是值 <code>Some(5)</code>。接着将其与每个分支比较。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br></pre></td></tr></table></figure>

<p>值 <code>Some(5)</code> 并不匹配模式 <code>None</code>，所以继续进行下一个分支。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">Some</span>(i) =&gt; <span class="title function_ invoke__">Some</span>(i + <span class="number">1</span>),</span><br></pre></td></tr></table></figure>

<p><code>Some(5)</code> 与 <code>Some(i)</code> 匹配吗？当然匹配！它们是相同的变体。<code>i</code> 绑定了 <code>Some</code> 中包含的值，所以 <code>i</code> 的值是 <code>5</code>。接着匹配分支的代码被执行，所以我们将 <code>i</code> 的值加一并返回一个含有值 <code>6</code> 的新 <code>Some</code>。</p>
<p>接着考虑下示例 6-5 中 <code>plus_one</code> 的第二个调用，这里 <code>x</code> 是 <code>None</code>。我们进入 <code>match</code> 并与第一个分支相比较。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br></pre></td></tr></table></figure>

<p>匹配成功！这里没有值来加一，所以程序结束并返回 <code>=&gt;</code> 右侧的值 <code>None</code>，因为第一个分支就匹配到了，其他的分支将不再比较。</p>
<p>将 <code>match</code> 与枚举相结合在很多场景中都是有用的。你会在 Rust 代码中看到很多这样的模式：<code>match</code> 一个枚举，绑定其中的值到一个变量，接着根据其值执行代码。这在一开始有点复杂，不过一旦习惯了，你会希望所有语言都拥有它！这一直是用户的最爱。</p>
<h3 id="匹配是穷尽的"><a href="#匹配是穷尽的" class="headerlink" title="匹配是穷尽的"></a>匹配是穷尽的</h3><p><code>match</code> 还有另一方面需要讨论：这些分支必须覆盖了所有的可能性。考虑一下 <code>plus_one</code> 函数的这个版本，它有一个 bug 并不能编译：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">plus_one</span>(x: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(i) =&gt; <span class="title function_ invoke__">Some</span>(i + <span class="number">1</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们没有处理 <code>None</code> 的情况，所以这些代码会造成一个 bug。幸运的是，这是一个 Rust 知道如何处理的 bug。如果尝试编译这段代码，会得到这个错误：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">   Compiling enums v0.1.0 (file:///projects/enums)</span><br><span class="line">error[E0004]: non-exhaustive patterns: `None` not covered</span><br><span class="line"><span class="meta prompt_"> --&gt; </span><span class="language-bash">src/main.rs:3:15</span></span><br><span class="line">  |</span><br><span class="line">3 |         match x &#123;</span><br><span class="line">  |               ^ pattern `None` not covered</span><br><span class="line">  |</span><br><span class="line">note: `Option&lt;i32&gt;` defined here</span><br><span class="line"><span class="meta prompt_"> --&gt; </span><span class="language-bash">/rustc/4eb161250e340c8f48f66e2b929ef4a5bed7c181/library/core/src/option.rs:572:1</span></span><br><span class="line"> ::: /rustc/4eb161250e340c8f48f66e2b929ef4a5bed7c181/library/core/src/option.rs:576:5</span><br><span class="line">  |</span><br><span class="line">  = note: not covered</span><br><span class="line">  = note: the matched value is of type `Option&lt;i32&gt;`</span><br><span class="line">help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown</span><br><span class="line">  |</span><br><span class="line">4 ~             Some(i) =&gt; Some(i + 1),</span><br><span class="line">5 ~             None =&gt; todo!(),</span><br><span class="line">  |</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0004`.</span><br><span class="line">error: could not compile `enums` (bin &quot;enums&quot;) due to 1 previous error</span><br></pre></td></tr></table></figure>

<p>Rust 知道我们没有覆盖所有可能的情况甚至知道哪些模式被忘记了！Rust 中的匹配是 <strong>穷尽的</strong>（<em>exhaustive</em>）：必须穷举到最后的可能性来使代码有效。特别的在这个 <code>Option&lt;T&gt;</code> 的例子中，Rust 防止我们忘记明确的处理 <code>None</code> 的情况，这让我们免于假设拥有一个实际上为空的值，从而使之前提到的价值亿万的错误不可能发生。</p>
<h3 id="通配模式和-占位符"><a href="#通配模式和-占位符" class="headerlink" title="通配模式和 _ 占位符"></a>通配模式和 <code>_</code> 占位符</h3><p>使用枚举，我们也可以针对少数几个特定值执行特殊操作，而对其他所有值采取默认操作。想象我们正在玩一个游戏，如果你掷出骰子的值为 3，角色不会移动，而是会得到一顶新奇的帽子。如果你掷出了 7，你的角色将失去一顶新奇的帽子。对于其他的数值，你的角色会在棋盘上移动相应的格子。这是一个实现了上述逻辑的 <code>match</code>，骰子的结果是硬编码而不是一个随机值，其他的逻辑部分使用了没有函数体的函数来表示，实现它们超出了本例的范围：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">dice_roll</span> = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">match</span> dice_roll &#123;</span><br><span class="line">    <span class="number">3</span> =&gt; <span class="title function_ invoke__">add_fancy_hat</span>(),</span><br><span class="line">    <span class="number">7</span> =&gt; <span class="title function_ invoke__">remove_fancy_hat</span>(),</span><br><span class="line">    other =&gt; <span class="title function_ invoke__">move_player</span>(other),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add_fancy_hat</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">remove_fancy_hat</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">move_player</span>(num_spaces: <span class="type">u8</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>对于前两个分支，匹配模式是字面值 <code>3</code> 和 <code>7</code>，最后一个分支则涵盖了所有其他可能的值，模式是我们命名为 <code>other</code> 的一个变量。<code>other</code> 分支的代码通过将其传递给 <code>move_player</code> 函数来使用这个变量。</p>
<p>即使我们没有列出 <code>u8</code> 所有可能的值，这段代码依然能够编译，因为最后一个模式将匹配所有未被特殊列出的值。这种通配模式满足了 <code>match</code> 必须被穷尽的要求。请注意，我们必须将通配分支放在最后，因为模式是按顺序匹配的。如果我们在通配分支后添加其他分支，Rust 将会警告我们，因为此后的分支永远不会被匹配到。</p>
<p>Rust 还提供了一个模式，当我们不想使用通配模式获取的值时，请使用 <code>_</code> ，这是一个特殊的模式，可以匹配任意值而不绑定到该值。这告诉 Rust 我们不会使用这个值，所以 Rust 也不会警告我们存在未使用的变量。</p>
<p>让我们改变游戏规则：现在，当你掷出的值不是 3 或 7 的时候，你必须再次掷出。这种情况下我们不需要使用这个值，所以我们改动代码使用 <code>_</code> 来替代变量 <code>other</code> ：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">dice_roll</span> = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">match</span> dice_roll &#123;</span><br><span class="line">    <span class="number">3</span> =&gt; <span class="title function_ invoke__">add_fancy_hat</span>(),</span><br><span class="line">    <span class="number">7</span> =&gt; <span class="title function_ invoke__">remove_fancy_hat</span>(),</span><br><span class="line">    _ =&gt; <span class="title function_ invoke__">reroll</span>(),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add_fancy_hat</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">remove_fancy_hat</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">reroll</span>() &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子也满足穷尽性要求，因为我们在最后一个分支中显式地忽略了其它值。我们没有忘记处理任何东西。</p>
<p>最后，让我们再次改变游戏规则，如果你掷出 3 或 7 以外的值，你的回合将无事发生。我们可以使用单元值（在[“元组类型”](.&#x2F;03.2 数据类型)一节中提到的空元组）作为 <code>_</code> 分支的代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">dice_roll</span> = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">match</span> dice_roll &#123;</span><br><span class="line">    <span class="number">3</span> =&gt; <span class="title function_ invoke__">add_fancy_hat</span>(),</span><br><span class="line">    <span class="number">7</span> =&gt; <span class="title function_ invoke__">remove_fancy_hat</span>(),</span><br><span class="line">    _ =&gt; (),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add_fancy_hat</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">remove_fancy_hat</span>() &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，我们明确告诉 Rust 我们不会使用与前面模式不匹配的值，并且这种情况下我们不想运行任何代码。</p>
<p>我们将在第十九章中介绍更多关于模式和匹配的内容。现在，让我们继续讨论 <code>if let</code> 语法，这在 <code>match</code> 表达式显得有些冗长时非常有用。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-05-22T06:30:26.000Z" title="2025/5/22 14:30:26">2025-05-22</time>发表</span><span class="level-item"><time dateTime="2025-05-22T06:48:11.514Z" title="2025/5/22 14:48:11">2025-05-22</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Rust/">Rust</a><span> / </span><a class="link-muted" href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></span><span class="level-item">11 分钟读完 (大约1708个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/05/22/Rust/The%20Rust%20Programming%20Language/06.3%20if%20let%20%E5%92%8C%20let%20else%20%E7%AE%80%E6%B4%81%E6%8E%A7%E5%88%B6%E6%B5%81/">6.3 if let 和 let else 简洁控制流</a></p><div class="content"><h2 id="if-let-和-let-else-简洁控制流"><a href="#if-let-和-let-else-简洁控制流" class="headerlink" title="if let 和 let else 简洁控制流"></a><code>if let</code> 和 <code>let else</code> 简洁控制流</h2><p><code>if let</code> 语法让我们以一种不那么冗长的方式结合 <code>if</code> 和 <code>let</code>，来处理只匹配一个模式的值而忽略其他模式的情况。考虑示例 6-6 中的程序，它匹配一个 <code>config_max</code> 变量中的 <code>Option&lt;u8&gt;</code> 值并只希望当值为 <code>Some</code> 变体时执行代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">config_max</span> = <span class="title function_ invoke__">Some</span>(<span class="number">3u8</span>);</span><br><span class="line"><span class="keyword">match</span> config_max &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(max) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The maximum is configured to be &#123;max&#125;&quot;</span>),</span><br><span class="line">    _ =&gt; (),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 6-6：<code>match</code> 只关心当值为 <code>Some</code> 时执行代码</p>
<p>如果值是 <code>Some</code>，我们希望打印出 <code>Some</code> 变体中的值，这个值被绑定到模式中的 <code>max</code> 变量里。对于 <code>None</code> 值我们不希望做任何操作。为了满足 <code>match</code> 表达式（穷尽性）的要求，必须在处理完这唯一的变体后加上 <code>_ =&gt; ()</code>，这样也要增加很多繁琐的样板代码。</p>
<p>不过我们可以使用 <code>if let</code> 这种简洁的方式编写。如下代码与示例 6-6 中的 <code>match</code> 行为一致：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">config_max</span> = <span class="title function_ invoke__">Some</span>(<span class="number">3u8</span>);</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(max) = config_max &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The maximum is configured to be &#123;max&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>if let</code> 语法获取通过等号分隔的一个模式和一个表达式。它的工作方式与 <code>match</code> 相同，这里的表达式对应 <code>match</code> 而模式则对应第一个分支。在这个例子中，模式是 <code>Some(max)</code>，<code>max</code> 绑定为 <code>Some</code> 中的值。接着可以在 <code>if let</code> 代码块中使用 <code>max</code> 了，就跟在对应的 <code>match</code> 分支中一样。只有当值匹配该模式时，<code>if let</code> 块中的代码才会执行。</p>
<p>使用 <code>if let</code> 意味着编写更少代码，更少的缩进和更少的样板代码。然而，这样会失去 <code>match</code> 强制要求的穷尽性检查来确保你没有忘记处理某些情况。<code>match</code> 和 <code>if let</code> 之间的选择依赖特定的环境以及增加简洁度和失去穷尽性检查的权衡取舍。</p>
<p>换句话说，可以认为 <code>if let</code> 是 <code>match</code> 的一个语法糖，它当值匹配某一模式时执行代码而忽略所有其他值。</p>
<p>可以在 <code>if let</code> 中包含一个 <code>else</code>。<code>else</code> 块中的代码与 <code>match</code> 表达式中的 <code>_</code> 分支块中的代码相同，这样的 <code>match</code> 表达式就等同于 <code>if let</code> 和 <code>else</code>。回忆一下示例 6-4 中 <code>Coin</code> 枚举的定义，其 <code>Quarter</code> 变体也包含一个 <code>UsState</code> 值。如果想要计数所有不是 25 美分的硬币的同时也报告 25 美分硬币所属的州，可以使用这样一个 <code>match</code> 表达式：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">count</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">match</span> coin &#123;</span><br><span class="line">    Coin::<span class="title function_ invoke__">Quarter</span>(state) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;State quarter from &#123;state:?&#125;!&quot;</span>),</span><br><span class="line">    _ =&gt; count += <span class="number">1</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者可以使用这样的 <code>if let</code> 和 <code>else</code> 表达式：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">count</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Coin</span>::<span class="title function_ invoke__">Quarter</span>(state) = coin &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;State quarter from &#123;state:?&#125;!&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    count += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用-let-else-来保持在-“愉快路径”（“Happy-Path”）"><a href="#使用-let-else-来保持在-“愉快路径”（“Happy-Path”）" class="headerlink" title="使用 let...else 来保持在 “愉快路径”（“Happy Path”）"></a>使用 <code>let...else</code> 来保持在 “愉快路径”（“Happy Path”）</h2><p>当某个值存在时进行一些操作否则返回一个默认是一个常规操作。继续以处理 <code>UsState</code> 值的硬币例子来说，如果我们说一些有趣的事依赖于硬币的州有多老，我们可能会像这样在 <code>UsState</code> 上引入一个检查州龄的方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">UsState</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">existed_in</span>(&amp;<span class="keyword">self</span>, year: <span class="type">u16</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            UsState::Alabama =&gt; year &gt;= <span class="number">1819</span>,</span><br><span class="line">            UsState::Alaska =&gt; year &gt;= <span class="number">1959</span>,</span><br><span class="line">            <span class="comment">// -- snip --</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们可能使用 <code>if let</code> 来匹配硬币的类型，在条件代码中引入一个 <code>state</code>，如示例 6-7 所示。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">describe_state_quarter</span>(coin: Coin) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Coin</span>::<span class="title function_ invoke__">Quarter</span>(state) = coin &#123;</span><br><span class="line">        <span class="keyword">if</span> state.<span class="title function_ invoke__">existed_in</span>(<span class="number">1900</span>) &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;state:?&#125; is pretty old, for America!&quot;</span>))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;state:?&#125; is relatively new.&quot;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 6-7：使用嵌套在 <code>if let</code> 中的条件来检查一个州在 1900 年是否存在</p>
<p>这样固然可以完成任务，不过这将工作推进了 <code>if let</code> 语句中，如果需要完成的工作更为复杂，则可能难以追踪顶层分支是如何关联的。我们也可以利用这个表达式要么从 <code>if let</code> 中生成一个 <code>state</code> 要么提前返回的优势，如示例 6-8 所示。（使用 <code>match</code> 也可以实现类似效果。）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">describe_state_quarter</span>(coin: Coin) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">state</span> = <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Coin</span>::<span class="title function_ invoke__">Quarter</span>(state) = coin &#123;</span><br><span class="line">        state</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> state.<span class="title function_ invoke__">existed_in</span>(<span class="number">1900</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;state:?&#125; is pretty old, for America!&quot;</span>))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;state:?&#125; is relatively new.&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 6-8：使用 <code>if let</code> 来产生一个值或提前返回</p>
<p>不过这样写在某种程度上会让人觉得有些繁琐！<code>if let</code> 的一个分支产生一个值，而另一个分支则直接从函数中返回。</p>
<p>为了使这个通用模式更容易表达，Rust 提供了 <code>let...else</code>。<code>let...else</code> 语法左侧是一个模式，右侧是一个表达式，非常类似于 <code>if let</code>，不过它没有 <code>if</code> 分支，只有 <code>else</code> 分支。如果模式匹配，它会将匹配到的值绑定到外层作用域。如果模式<strong>不</strong>匹配，程序流会指向 <code>else</code> 分支，它必须从函数返回。</p>
<p>在示例 6-9 中，可以看到当在示例 6-8 中的 <code>if let</code> 替换为 <code>let...else</code> 时看起来如何。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">describe_state_quarter</span>(coin: Coin) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">Coin</span>::<span class="title function_ invoke__">Quarter</span>(state) = coin <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> state.<span class="title function_ invoke__">existed_in</span>(<span class="number">1900</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;state:?&#125; is pretty old, for America!&quot;</span>))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;state:?&#125; is relatively new.&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 6-9：使用 <code>let...else</code> 来明确函数的流向</p>
<p>注意它以这种方式在函数主体中保持了 “愉快路径”（“Happy Path”），而不用像 <code>if let</code> 那样在两个分支中拥有明显不同的控制流</p>
<p>如果你的程序遇到一个使用 <code>match</code> 表达起来过于冗长的逻辑，记住 <code>if let</code> 和 <code>let...else</code> 也在你的 Rust 工具箱中。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现在我们涉及到了如何使用枚举来创建有一系列可列举值的自定义类型。我们也展示了标准库的 <code>Option&lt;T&gt;</code> 类型是如何帮助你利用类型系统来避免出错的。当枚举值包含数据时，你可以根据需要处理多少情况来选择使用 <code>match</code> 或 <code>if let</code> 来获取并使用这些值。</p>
<p>你的 Rust 程序现在能够使用结构体和枚举在自己的作用域内表现其内容了。在你的 API 中使用自定义类型保证了类型安全：编译器会确保你的函数只会得到它期望的类型的值。</p>
<p>为了向你的用户提供一个组织良好的 API，它使用起来很直观并且只向用户暴露他们确实需要的部分，那么现在就让我们转向 Rust 的模块系统吧。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-05-22T05:50:26.000Z" title="2025/5/22 13:50:26">2025-05-22</time>发表</span><span class="level-item"><time dateTime="2025-05-22T06:01:42.832Z" title="2025/5/22 14:01:42">2025-05-22</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Rust/">Rust</a><span> / </span><a class="link-muted" href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></span><span class="level-item">27 分钟读完 (大约4047个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/05/22/Rust/The%20Rust%20Programming%20Language/06.1%20%E6%9E%9A%E4%B8%BE%E7%9A%84%E5%AE%9A%E4%B9%89/">6.1 枚举的定义</a></p><div class="content"><h2 id="枚举的定义"><a href="#枚举的定义" class="headerlink" title="枚举的定义"></a>枚举的定义</h2><p>结构体给予你将字段和数据聚合在一起的方法，像 <code>Rectangle</code> 结构体有 <code>width</code> 和 <code>height</code> 两个字段。而枚举给予你一个途径去声明某个值是一个集合中的一员。比如，我们想让 <code>Rectangle</code> 是一些形状的集合，包含 <code>Circle</code> 和 <code>Triangle</code> 。为此，Rust 允许我们将这些可能性编码为一个枚举类型。</p>
<p>让我们看看一个需要诉诸于代码的场景，来考虑为何此时使用枚举更为合适且实用。假设我们要处理 IP 地址。目前被广泛使用的两个主要 IP 标准：IPv4（version four）和 IPv6（version six）。这是我们的程序可能会遇到的所有可能的 IP 地址类型：所以可以<strong>枚举</strong>出所有可能的值，这也正是枚举一词的由来。</p>
<p>任何一个 IP 地址要么是 IPv4 的要么是 IPv6 的，而且不能两者都是。IP 地址的这个特性使得枚举数据结构非常适合这个场景，因为枚举值只可能是其中一个变体。IPv4 和 IPv6 从根本上讲仍是 IP 地址，所以当代码在处理适用于任何类型的 IP 地址的场景时应该把它们当作相同的类型。</p>
<p>可以通过在代码中定义一个 <code>IpAddrKind</code> 枚举来表现这个概念并列出可能的 IP 地址类型，<code>V4</code> 和 <code>V6</code>。这被称为枚举的<strong>变体</strong>（<em>variants</em>）：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddrKind</span> &#123;</span><br><span class="line">    V4,</span><br><span class="line">    V6,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在 <code>IpAddrKind</code> 就是一个可以在代码中使用的自定义数据类型了。</p>
<h3 id="枚举值"><a href="#枚举值" class="headerlink" title="枚举值"></a>枚举值</h3><p>可以像这样创建 <code>IpAddrKind</code> 两个不同变体的实例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">four</span> = IpAddrKind::V4;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">six</span> = IpAddrKind::V6;</span><br></pre></td></tr></table></figure>

<p>注意枚举的变体位于其标识符的命名空间中，并使用两个冒号分开。这么设计的益处是现在 <code>IpAddrKind::V4</code> 和 <code>IpAddrKind::V6</code> 都是 <code>IpAddrKind</code> 类型的。例如，接着可以定义一个函数来接收任何 <code>IpAddrKind</code>类型的参数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">route</span>(ip_kind: IpAddrKind) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>现在可以使用任一变体来调用这个函数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">route</span>(IpAddrKind::V4);</span><br><span class="line"><span class="title function_ invoke__">route</span>(IpAddrKind::V6);</span><br></pre></td></tr></table></figure>

<p>使用枚举甚至还有更多优势。进一步考虑一下我们的 IP 地址类型，目前没有一个存储实际 IP 地址<strong>数据</strong>的方法；只知道它是什么<strong>类型</strong>的。考虑到已经在第五章学习过结构体了，你可能会像示例 6-1 那样尝试用结构体来解决这个问题：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddrKind</span> &#123;</span><br><span class="line">    V4,</span><br><span class="line">    V6,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IpAddr</span> &#123;</span><br><span class="line">    kind: IpAddrKind,</span><br><span class="line">    address: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">home</span> = IpAddr &#123;</span><br><span class="line">    kind: IpAddrKind::V4,</span><br><span class="line">    address: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;127.0.0.1&quot;</span>),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">loopback</span> = IpAddr &#123;</span><br><span class="line">    kind: IpAddrKind::V6,</span><br><span class="line">    address: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;::1&quot;</span>),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>示例 6-1：将 IP 地址的数据和 <code>IpAddrKind</code> 变体存储在一个 <code>struct</code> 中</p>
<p>这里我们定义了一个有两个字段的结构体 <code>IpAddr</code>：<code>IpAddrKind</code>（之前定义的枚举）类型的 <code>kind</code> 字段和 <code>String</code> 类型 <code>address</code> 字段。我们有这个结构体的两个实例。第一个，<code>home</code>，它的 <code>kind</code> 的值是 <code>IpAddrKind::V4</code> 与之相关联的地址数据是 <code>127.0.0.1</code>。第二个实例，<code>loopback</code>，<code>kind</code> 的值是 <code>IpAddrKind</code> 的另一个变体，<code>V6</code>，关联的地址是 <code>::1</code>。我们使用了一个结构体来将 <code>kind</code> 和 <code>address</code> 打包在一起，现在枚举变体就与值相关联了。</p>
<p>我们可以使用一种更简洁的方式来表达相同的概念，仅仅使用枚举并将数据直接放进每一个枚举变体而不是将枚举作为结构体的一部分。<code>IpAddr</code> 枚举的新定义表明了 <code>V4</code> 和 <code>V6</code> 变体都关联了 <code>String</code> 值：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddr</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">V4</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">V6</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">home</span> = IpAddr::<span class="title function_ invoke__">V4</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;127.0.0.1&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">loopback</span> = IpAddr::<span class="title function_ invoke__">V6</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;::1&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>我们直接将数据附加到枚举的每个变体上，这样就不需要一个额外的结构体了。这里也很容易看出枚举工作的另一个细节：每一个我们定义的枚举变体的名字也变成了一个构建枚举的实例的函数。也就是说，<code>IpAddr::V4()</code> 是一个获取 <code>String</code> 参数并返回 <code>IpAddr</code> 类型实例的函数调用。作为定义枚举的结果，这些构造函数会自动被定义。</p>
<p>用枚举替代结构体还有另一个优势：每个变体可以处理不同类型和数量的数据。IPv4 版本的 IP 地址总是含有四个值在 0 和 255 之间的数字部分。如果我们想要将 <code>V4</code> 地址存储为四个 <code>u8</code> 值而 <code>V6</code> 地址仍然表现为一个 <code>String</code>，这就不能使用结构体了。枚举则可以轻易的处理这个情况：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddr</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">V4</span>(<span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>),</span><br><span class="line">    <span class="title function_ invoke__">V6</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">home</span> = IpAddr::<span class="title function_ invoke__">V4</span>(<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">loopback</span> = IpAddr::<span class="title function_ invoke__">V6</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;::1&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>这些代码展示了使用枚举来存储两种不同 IP 地址的几种可能的选择。然而，事实证明存储和编码 IP 地址实在是太常见了<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/net/enum.IpAddr.html">以致标准库提供了一个开箱即用的定义！</a>让我们看看标准库是如何定义 <code>IpAddr</code> 的：它正有着跟我们定义和使用的一样的枚举和变体，不过它将变体中的地址数据嵌入到了两个不同形式的结构体中，它们对不同的变体的定义是不同的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Ipv4Addr</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Ipv6Addr</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddr</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">V4</span>(Ipv4Addr),</span><br><span class="line">    <span class="title function_ invoke__">V6</span>(Ipv6Addr),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些代码展示了可以将任意类型的数据放入枚举变体中：例如字符串、数字类型或者结构体。甚至可以包含另一个枚举！另外，标准库中的类型通常并不比你设想出来的要复杂多少。</p>
<p>注意虽然标准库中包含一个 <code>IpAddr</code> 的定义，仍然可以创建和使用我们自己的定义而不会有冲突，因为我们并没有将标准库中的定义引入作用域。第七章会讲到如何导入类型。</p>
<p>来看看示例 6-2 中的另一个枚举的例子：它的变体中内嵌了多种多样的类型：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: <span class="type">i32</span>, y: <span class="type">i32</span> &#125;,</span><br><span class="line">    <span class="title function_ invoke__">Write</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">ChangeColor</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 6-2：一个 <code>Message</code> 枚举，其每个变体都存储了不同数量和类型的值</p>
<p>这个枚举有四个含有不同类型的变体：</p>
<ul>
<li><code>Quit</code> 没有关联任何数据。</li>
<li><code>Move</code> 类似结构体包含命名字段。</li>
<li><code>Write</code> 包含单独一个 <code>String</code>。</li>
<li><code>ChangeColor</code> 包含三个 <code>i32</code>。</li>
</ul>
<p>定义一个如示例 6-2 中所示那样的有关联值的枚举的方式和定义多个不同类型的结构体的方式很相像，除了枚举不使用 <code>struct</code> 关键字以及其所有变体都被组合在一起位于 <code>Message</code> 类型下。如下这些结构体可以包含与之前枚举变体中相同的数据：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">QuitMessage</span>; <span class="comment">// 类单元结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MoveMessage</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WriteMessage</span>(<span class="type">String</span>); <span class="comment">// 元组结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ChangeColorMessage</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>); <span class="comment">// 元组结构体</span></span><br></pre></td></tr></table></figure>

<p>不过，如果我们使用不同的结构体，由于它们都有不同的类型，我们将不能像使用示例 6-2 中定义的 <code>Message</code> 枚举那样，轻易的定义一个能够处理这些不同类型的结构体的函数，因为枚举是单独一个类型。</p>
<p>结构体和枚举还有另一个相似点：就像可以使用 <code>impl</code> 来为结构体定义方法那样，也可以在枚举上定义方法。这是一个定义于我们 <code>Message</code> 枚举上的叫做 <code>call</code> 的方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">call</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// 在这里定义方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">m</span> = Message::<span class="title function_ invoke__">Write</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">m.<span class="title function_ invoke__">call</span>();</span><br></pre></td></tr></table></figure>

<p>方法体使用了 <code>self</code> 来获取调用方法的值。这个例子中，创建了一个值为 <code>Message::Write(String::from(&quot;hello&quot;))</code> 的变量 <code>m</code>，而且这就是当 <code>m.call()</code> 运行时 <code>call</code> 方法中的 <code>self</code> 的值。</p>
<p>让我们看看标准库中的另一个非常常见且实用的枚举：<code>Option</code>。</p>
<h3 id="Option-枚举及其相对于空值的优势"><a href="#Option-枚举及其相对于空值的优势" class="headerlink" title="Option 枚举及其相对于空值的优势"></a><code>Option</code> 枚举及其相对于空值的优势</h3><p>这一部分会分析一个 <code>Option</code> 的案例，<code>Option</code> 是标准库定义的另一个枚举。<code>Option</code> 类型应用广泛因为它编码了一个非常普遍的场景，即一个值要么有值要么没值。</p>
<p>例如，如果请求一个非空列表的第一项，会得到一个值，如果请求一个空的列表，就什么也不会得到。从类型系统的角度来表达这个概念就意味着编译器需要检查是否处理了所有应该处理的情况，这样就可以避免在其他编程语言中非常常见的 bug。</p>
<p>编程语言的设计经常要考虑包含哪些功能，但考虑排除哪些功能也很重要。Rust 并没有很多其他语言中有的空值功能。<strong>空值</strong>（<em>Null</em> ）是一个值，它代表没有值。在有空值的语言中，变量总是这两种状态之一：空值和非空值。</p>
<p>Tony Hoare，null 的发明者，在他 2009 年的演讲 “Null References: The Billion Dollar Mistake” 中曾经说到：</p>
<blockquote>
<p>I call it my billion-dollar mistake. At that time, I was designing the first comprehensive type system for references in an object-oriented language. My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn’t resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.</p>
<p>我称之为我十亿美元的错误。当时，我在为一个面向对象语言设计第一个综合性的面向引用的类型系统。我的目标是通过编译器的自动检查来保证所有引用的使用都应该是绝对安全的。不过我未能抵抗住引入一个空引用的诱惑，仅仅是因为它是这么的容易实现。这引发了无数错误、漏洞和系统崩溃，在过去四十年里可能造成了价值十亿美元的痛苦和损失。</p>
</blockquote>
<p>空值的问题在于当你尝试像一个非空值那样使用一个空值，会出现某种形式的错误。因为空和非空的属性无处不在，非常容易出现这类错误。</p>
<p>然而，空值尝试表达的概念仍然是有意义的：空值是一个因为某种原因目前无效或缺失的值。</p>
<p>问题不在于概念而在于具体的实现。为此，Rust 并没有空值，不过它确实拥有一个可以编码存在或不存在概念的枚举。这个枚举是 <code>Option&lt;T&gt;</code>，而且它<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/option/enum.Option.html">定义于标准库中</a>，如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Option&lt;T&gt;</code> 枚举是如此有用以至于它甚至被包含在了 prelude 之中，无需将其显式引入作用域。另外，它的变体也是如此：可以不需要 <code>Option::</code> 前缀来直接使用 <code>Some</code> 和 <code>None</code>。即便如此 <code>Option&lt;T&gt;</code> 也仍是常规的枚举，<code>Some(T)</code> 和 <code>None</code> 仍是 <code>Option&lt;T&gt;</code> 的变体。</p>
<p><code>&lt;T&gt;</code> 语法是一个我们还未讲到的 Rust 功能。它是一个泛型类型参数，第十章会更详细的讲解泛型。目前，所有你需要知道的就是 <code>&lt;T&gt;</code> 意味着 <code>Option</code> 枚举的 <code>Some</code> 变体可以包含任意类型的数据，同时每一个用于 <code>T</code> 位置的具体类型使得 <code>Option&lt;T&gt;</code> 整体作为不同的类型。这里是一些包含数字类型和字符串类型 <code>Option</code> 值的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">some_number</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">some_char</span> = <span class="title function_ invoke__">Some</span>(<span class="string">&#x27;e&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">absent_number</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="literal">None</span>;</span><br></pre></td></tr></table></figure>

<p><code>some_number</code> 的类型是 <code>Option&lt;i32&gt;</code>。<code>some_char</code> 的类型是 <code>Option&lt;char&gt;</code>，是不同于 <code>some_number</code> 的类型。因为我们在 <code>Some</code> 变体中指定了值，Rust 可以推断其类型。对于 <code>absent_number</code>，Rust 需要我们指定 <code>Option</code> 整体的类型，因为编译器只通过 <code>None</code> 值无法推断出 <code>Some</code> 变体保存的值的类型。这里我们告诉 Rust 希望 <code>absent_number</code> 是 <code>Option&lt;i32&gt;</code> 类型的。</p>
<p>当有一个 <code>Some</code> 值时，我们就知道存在一个值，而这个值保存在 <code>Some</code> 中。当有个 <code>None</code> 值时，在某种意义上，它跟空值具有相同的意义：并没有一个有效的值。那么，<code>Option&lt;T&gt;</code> 为什么就比空值要好呢？</p>
<p>简而言之，因为 <code>Option&lt;T&gt;</code> 和 <code>T</code>（这里 <code>T</code> 可以是任何类型）是不同的类型，编译器不允许像一个肯定有效的值那样使用 <code>Option&lt;T&gt;</code>。例如，这段代码不能编译，因为它尝试将 <code>Option&lt;i8&gt;</code> 与 <code>i8</code> 相加：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span>: <span class="type">i8</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span>: <span class="type">Option</span>&lt;<span class="type">i8</span>&gt; = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">sum</span> = x + y;</span><br></pre></td></tr></table></figure>

<p>如果运行这些代码，将得到类似这样的错误信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">   Compiling enums v0.1.0 (file:///projects/enums)</span><br><span class="line">error[E0277]: cannot add `Option&lt;i8&gt;` to `i8`</span><br><span class="line"><span class="meta prompt_"> --&gt; </span><span class="language-bash">src/main.rs:5:17</span></span><br><span class="line">  |</span><br><span class="line">5 |     let sum = x + y;</span><br><span class="line">  |                 ^ no implementation for `i8 + Option&lt;i8&gt;`</span><br><span class="line">  |</span><br><span class="line">  = help: the trait `Add&lt;Option&lt;i8&gt;&gt;` is not implemented for `i8`</span><br><span class="line">  = help: the following other types implement trait `Add&lt;Rhs&gt;`:</span><br><span class="line">            `&amp;i8` implements `Add&lt;i8&gt;`</span><br><span class="line">            `&amp;i8` implements `Add`</span><br><span class="line">            `i8` implements `Add&lt;&amp;i8&gt;`</span><br><span class="line">            `i8` implements `Add`</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0277`.</span><br><span class="line">error: could not compile `enums` (bin &quot;enums&quot;) due to 1 previous error</span><br></pre></td></tr></table></figure>

<p>很好！事实上，错误信息意味着 Rust 不知道该如何将 <code>Option&lt;i8&gt;</code> 与 <code>i8</code> 相加，因为它们的类型不同。当在 Rust 中拥有一个像 <code>i8</code> 这样类型的值时，编译器确保它总是有一个有效的值。我们可以自信地使用而无需做空值检查。只有当使用 <code>Option&lt;i8&gt;</code>（或者任何用到的类型）的时候需要担心可能没有值，而编译器会确保我们在使用值之前处理了为空的情况。</p>
<p>换句话说，在对 <code>Option&lt;T&gt;</code> 进行运算之前必须将其转换为 <code>T</code>。通常这能帮助我们捕获到空值最常见的问题之一：假设某值不为空但实际上为空的情况。</p>
<p>消除了错误地假设一个非空值的风险，会让你对代码更加有信心。为了拥有一个可能为空的值，你必须要显式的将其放入对应类型的 <code>Option&lt;T&gt;</code> 中。接着，当使用这个值时，必须明确的处理值为空的情况。只要一个值不是 <code>Option&lt;T&gt;</code> 类型，你就<strong>可以</strong>安全的认定它的值不为空。这是 Rust 的一个经过深思熟虑的设计决策，来限制空值的泛滥以增加 Rust 代码的安全性。</p>
<p>那么当有一个 <code>Option&lt;T&gt;</code> 的值时，如何从 <code>Some</code> 变体中取出 <code>T</code> 的值来使用它呢？<code>Option&lt;T&gt;</code> 枚举拥有大量用于各种情况的方法：你可以查看<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/option/enum.Option.html">它的文档</a>。熟悉 <code>Option&lt;T&gt;</code> 的方法将对你的 Rust 之旅非常有用。</p>
<p>总的来说，为了使用 <code>Option&lt;T&gt;</code> 值，需要编写处理每个变体的代码。你想要一些代码只当拥有 <code>Some(T)</code> 值时运行，允许这些代码使用其中的 <code>T</code>。也希望一些代码只在值为 <code>None</code> 时运行，这些代码并没有一个可用的 <code>T</code> 值。<code>match</code> 表达式就是这么一个处理枚举的控制流结构：它会根据枚举的变体运行不同的代码，这些代码可以使用匹配到的值中的数据。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-05-21T14:50:26.000Z" title="2025/5/21 22:50:26">2025-05-21</time>发表</span><span class="level-item"><time dateTime="2025-05-21T14:52:56.648Z" title="2025/5/21 22:52:56">2025-05-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Rust/">Rust</a><span> / </span><a class="link-muted" href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></span><span class="level-item">19 分钟读完 (大约2865个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/05/21/Rust/The%20Rust%20Programming%20Language/05.3%20%E6%96%B9%E6%B3%95%E8%AF%AD%E6%B3%95/">5.3 方法语法</a></p><div class="content"><h2 id="方法语法"><a href="#方法语法" class="headerlink" title="方法语法"></a>方法语法</h2><p><strong>方法</strong>（method）与函数类似：它们使用 <code>fn</code> 关键字和名称声明，可以拥有参数和返回值，同时包含在某处调用该方法时会执行的代码。不过方法与函数是不同的，因为它们在结构体的上下文中被定义（或者是枚举或 trait 对象的上下文，将分别在第六章和第十八章讲解），并且它们第一个参数总是 <code>self</code>，它代表调用该方法的结构体实例。</p>
<h3 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h3><p>让我们把前面实现的获取一个 <code>Rectangle</code> 实例作为参数的 <code>area</code> 函数，改写成一个定义于 <code>Rectangle</code> 结构体上的 <code>area</code> 方法，如示例 5-13 所示：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;The area of the rectangle is &#123;&#125; square pixels.&quot;</span>,</span><br><span class="line">        rect1.<span class="title function_ invoke__">area</span>()</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 5-13：在 <code>Rectangle</code> 结构体上定义 <code>area</code> 方法</p>
<p>为了使函数定义于 <code>Rectangle</code> 的上下文中，我们开始了一个 <code>impl</code> 块（<code>impl</code> 是 <em>implementation</em> 的缩写），这个 <code>impl</code> 块中的所有内容都将与 <code>Rectangle</code> 类型相关联。接着将 <code>area</code> 函数移动到 <code>impl</code> 大括号中，并将签名中的第一个（在这里也是唯一一个）参数和函数体中其他地方的对应参数改成 <code>self</code>。然后在 <code>main</code> 中将我们先前调用 <code>area</code> 方法并传递 <code>rect1</code> 作为参数的地方，改成使用 <strong>方法语法</strong>（<em>method syntax</em>）在 <code>Rectangle</code> 实例上调用 <code>area</code> 方法。方法语法获取一个实例并加上一个点号，后跟方法名、圆括号以及任何参数。</p>
<p>在 <code>area</code> 的签名中，使用 <code>&amp;self</code> 来替代 <code>rectangle: &amp;Rectangle</code>，<code>&amp;self</code> 实际上是 <code>self: &amp;Self</code> 的缩写。在一个 <code>impl</code> 块中，<code>Self</code> 类型是 <code>impl</code> 块的类型的别名。方法的第一个参数必须有一个名为 <code>self</code> 的<code>Self</code> 类型的参数，所以 Rust 让你在第一个参数位置上只用 <code>self</code> 这个名字来简化。注意，我们仍然需要在 <code>self</code> 前面使用 <code>&amp;</code> 来表示这个方法借用了 <code>Self</code> 实例，就像我们在 <code>rectangle: &amp;Rectangle</code> 中做的那样。方法可以选择获得 <code>self</code> 的所有权，或者像我们这里一样不可变地借用 <code>self</code>，或者可变地借用 <code>self</code>，就跟其他参数一样。</p>
<p>这里选择 <code>&amp;self</code> 的理由跟在函数版本中使用 <code>&amp;Rectangle</code> 是相同的：我们并不想获取所有权，只希望能够读取结构体中的数据，而不是写入。如果想要在方法中改变调用方法的实例，需要将第一个参数改为 <code>&amp;mut self</code>。通过仅仅使用 <code>self</code> 作为第一个参数来使方法获取实例的所有权是很少见的；这种技术通常用在当方法将 <code>self</code> 转换成别的实例的时候，这时我们想要防止调用者在转换之后使用原始的实例。</p>
<p>使用方法替代函数，除了可使用方法语法和不需要在每个函数签名中重复 <code>self</code> 的类型之外，其主要好处在于组织性。我们将某个类型实例能做的所有事情都一起放入 <code>impl</code> 块中，而不是让将来的用户在我们的库中到处寻找 <code>Rectangle</code> 的功能。</p>
<p>请注意，我们可以选择将方法的名称与结构中的一个字段相同。例如，我们可以在 <code>Rectangle</code> 上定义一个方法，并命名为 <code>width</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">width</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width &gt; <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> rect1.<span class="title function_ invoke__">width</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;The rectangle has a nonzero width; it is &#123;&#125;&quot;</span>, rect1.width);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，我们选择让 <code>width</code> 方法在实例的 <code>width</code> 字段的值大于 <code>0</code> 时返回 <code>true</code>，等于 <code>0</code> 时则返回 <code>false</code>：我们可以出于任何目的，在同名的方法中使用同名的字段。在 <code>main</code> 中，当我们在 <code>rect1.width</code> 后面加上括号时。Rust 知道我们指的是方法 <code>width</code>。当我们不使用圆括号时，Rust 知道我们指的是字段 <code>width</code>。</p>
<p>通常，但并不总是如此，与字段同名的方法将被定义为只返回字段中的值，而不做其他事情。这样的方法被称为 <em>getters</em>，Rust 并不像其他一些语言那样为结构字段自动实现它们。Getters 很有用，因为你可以把字段变成私有的，但方法是公共的，这样就可以把对字段的只读访问作为该类型公共 API 的一部分。我们将在[第七章](.&#x2F;07.3 引用模块项目的路径)中讨论什么是公有和私有，以及如何将一个字段或方法指定为公有或私有。</p>
<blockquote>
<p><code>-&gt;</code> 运算符到哪去了？</p>
<p>在 C&#x2F;C++ 语言中，有两个不同的运算符来调用方法：<code>.</code> 直接在对象上调用方法，而 <code>-&gt;</code> 在一个对象的指针上调用方法，这时需要先解引用（dereference）指针。换句话说，如果 <code>object</code> 是一个指针，那么 <code>object-&gt;something()</code> 就像 <code>(*object).something()</code> 一样。</p>
<p>Rust 并没有一个与 <code>-&gt;</code> 等效的运算符；相反，Rust 有一个叫 <strong>自动引用和解引用</strong>（<em>automatic referencing and dereferencing</em>）的功能。方法调用是 Rust 中少数几个拥有这种行为的地方。</p>
<p>它是这样工作的：当使用 <code>object.something()</code> 调用方法时，Rust 会自动为 <code>object</code> 添加 <code>&amp;</code>、<code>&amp;mut</code> 或 <code>*</code> 以便使 <code>object</code> 与方法签名匹配。也就是说，这些代码是等价的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p1.<span class="title function_ invoke__">distance</span>(&amp;p2);</span><br><span class="line">(&amp;p1).<span class="title function_ invoke__">distance</span>(&amp;p2);</span><br></pre></td></tr></table></figure>

<p>第一行看起来简洁的多。这种自动引用的行为之所以有效，是因为方法有一个明确的接收者———— <code>self</code> 的类型。在给出接收者和方法名的前提下，Rust 可以明确地计算出方法是仅仅读取（<code>&amp;self</code>），做出修改（<code>&amp;mut self</code>）或者是获取所有权（<code>self</code>）。事实上，Rust 对方法接收者的隐式借用让所有权在实践中更友好。</p>
</blockquote>
<h3 id="带有更多参数的方法"><a href="#带有更多参数的方法" class="headerlink" title="带有更多参数的方法"></a>带有更多参数的方法</h3><p>让我们通过实现 <code>Rectangle</code> 结构体上的另一方法来练习使用方法。这回，我们让一个 <code>Rectangle</code> 的实例获取另一个 <code>Rectangle</code> 实例，如果 <code>self</code> （第一个 <code>Rectangle</code>）能完全包含第二个长方形则返回 <code>true</code>；否则返回 <code>false</code>。一旦我们定义了 <code>can_hold</code> 方法，就可以编写示例 5-14 中的代码。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect2</span> = Rectangle &#123;</span><br><span class="line">        width: <span class="number">10</span>,</span><br><span class="line">        height: <span class="number">40</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect3</span> = Rectangle &#123;</span><br><span class="line">        width: <span class="number">60</span>,</span><br><span class="line">        height: <span class="number">45</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Can rect1 hold rect2? &#123;&#125;&quot;</span>, rect1.<span class="title function_ invoke__">can_hold</span>(&amp;rect2));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Can rect1 hold rect3? &#123;&#125;&quot;</span>, rect1.<span class="title function_ invoke__">can_hold</span>(&amp;rect3));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 5-14：使用还未实现的 <code>can_hold</code> 方法</p>
<p>同时我们希望看到如下输出，因为 <code>rect2</code> 的两个维度都小于 <code>rect1</code>，而 <code>rect3</code> 比 <code>rect1</code> 要宽：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Can rect1 hold rect2? true</span><br><span class="line">Can rect1 hold rect3? false</span><br></pre></td></tr></table></figure>

<p>因为我们想定义一个方法，所以它应该位于 <code>impl Rectangle</code> 块中。方法名是 <code>can_hold</code>，并且它会获取另一个 <code>Rectangle</code> 的不可变借用作为参数。通过观察调用方法的代码可以看出参数是什么类型的：<code>rect1.can_hold(&amp;rect2)</code> 传入了 <code>&amp;rect2</code>，它是一个 <code>Rectangle</code> 的实例 <code>rect2</code> 的不可变借用。这是可以理解的，因为我们只需要读取 <code>rect2</code>（而不是写入，这意味着我们需要一个不可变借用），而且希望 <code>main</code> 保持 <code>rect2</code> 的所有权，这样就可以在调用这个方法后继续使用它。<code>can_hold</code> 的返回值是一个布尔值，其实现会分别检查 <code>self</code> 的宽高是否都大于另一个 <code>Rectangle</code>。让我们在示例 5-13 的 <code>impl</code> 块中增加这个新的 <code>can_hold</code> 方法，如示例 5-15 所示：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">can_hold</span>(&amp;<span class="keyword">self</span>, other: &amp;Rectangle) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width &gt; other.width &amp;&amp; <span class="keyword">self</span>.height &gt; other.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 5-15：在 <code>Rectangle</code> 上实现 <code>can_hold</code> 方法，它获取另一个 <code>Rectangle</code> 实例作为参数</p>
<p>如果结合示例 5-14 的 <code>main</code> 函数来运行，就会看到期望的输出。在方法签名中，可以在 <code>self</code> 后增加多个参数，而且这些参数就像函数中的参数一样工作。</p>
<h3 id="关联函数"><a href="#关联函数" class="headerlink" title="关联函数"></a>关联函数</h3><p>所有在 <code>impl</code> 块中定义的函数被称为 <strong>关联函数</strong>（<em>associated functions</em>），因为它们与 <code>impl</code> 后面命名的类型相关。我们可以定义不以 <code>self</code> 为第一参数的关联函数（因此不是方法），因为它们并不作用于一个结构体的实例。我们已经使用了一个这样的函数：在 <code>String</code> 类型上定义的 <code>String::from</code> 函数。</p>
<p>不是方法的关联函数经常被用作返回一个结构体新实例的构造函数。这些函数的名称通常为 <code>new</code> ，但 <code>new</code> 并不是一个关键字。例如我们可以提供一个叫做 <code>square</code> 关联函数，它接受一个维度参数并且同时作为宽和高，这样可以更轻松的创建一个正方形 <code>Rectangle</code> 而不必指定两次同样的值：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">square</span>(size: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            width: size,</span><br><span class="line">            height: size,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键字 <code>Self</code> 在函数的返回类型和函数体中，都是对 <code>impl</code> 关键字后所示类型的别名，这里是 <code>Rectangle</code>。</p>
<p>要调用这个关联函数，我们使用结构体名和 <code>::</code> 语法；比如 <code>let sq = Rectangle::square(3);</code>。这个函数位于结构体的命名空间中：<code>::</code> 语法用于关联函数和模块创建的命名空间。[第七章](.&#x2F;07.2 定义模块来控制作用域与私有性)会讲到模块。</p>
<h3 id="多个-impl-块"><a href="#多个-impl-块" class="headerlink" title="多个 impl 块"></a>多个 <code>impl</code> 块</h3><p>每个结构体都允许拥有多个 <code>impl</code> 块。例如，示例 5-15 中的代码等同于示例 5-16 中所示的代码，但后者每个方法有其自己的 <code>impl</code> 块。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">can_hold</span>(&amp;<span class="keyword">self</span>, other: &amp;Rectangle) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width &gt; other.width &amp;&amp; <span class="keyword">self</span>.height &gt; other.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 5-16：使用多个 <code>impl</code> 块重写示例 5-15</p>
<p>这里没有理由将这些方法分散在多个 <code>impl</code> 块中，不过这是有效的语法。第十章讨论泛型和 trait 时会看到实用的多 <code>impl</code> 块的用例。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>结构体让你可以创建出在你的领域中有意义的自定义类型。通过结构体，我们可以将相关联的数据片段联系起来并命名它们，这样可以使得代码更加清晰。在 <code>impl</code> 块中，你可以定义与你的类型相关联的函数，而方法是一种相关联的函数，让你指定结构体的实例所具有的行为。</p>
<p>但结构体并不是创建自定义类型的唯一方法：让我们转向 Rust 的枚举功能，为你的工具箱再添一个工具。</p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/">上一页</a></div><div class="pagination-next"><a href="/page/3/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link is-current" href="/page/2/">2</a></li><li><a class="pagination-link" href="/page/3/">3</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/7/">7</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.jpg" alt="Rossignol"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Rossignol</p><p class="is-size-6 is-block">NaN</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Mars</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives/"><p class="title">67</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories/"><p class="title">15</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags/"><p class="title">13</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/0xRossignol" target="_blank" rel="me noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/0xRossignol"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Golang/"><span class="level-start"><span class="level-item">Golang</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/Golang/basics/"><span class="level-start"><span class="level-item">basics</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/Java/basics/"><span class="level-start"><span class="level-item">basics</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/Java/basics/Thinking-in-Java/"><span class="level-start"><span class="level-item">Thinking in Java</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/Linux/Arch-Linux/"><span class="level-start"><span class="level-item">Arch Linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/OS/"><span class="level-start"><span class="level-item">OS</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Rust/"><span class="level-start"><span class="level-item">Rust</span></span><span class="level-end"><span class="level-item tag">30</span></span></a><ul><li><a class="level is-mobile" href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">Rust程序设计语言</span></span><span class="level-end"><span class="level-item tag">30</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/test/"><span class="level-start"><span class="level-item">test</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/toy-projects/"><span class="level-start"><span class="level-item">toy projects</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%85%AB%E8%82%A1/"><span class="level-start"><span class="level-item">八股</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%85%AB%E8%82%A1/JavaSE/"><span class="level-start"><span class="level-item">JavaSE</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%85%AB%E8%82%A1/Java%E9%9B%86%E5%90%88/"><span class="level-start"><span class="level-item">Java集合</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-05-27T07:00:26.000Z">2025-05-27</time></p><p class="title"><a href="/2025/05/27/Rust/The%20Rust%20Programming%20Language/10.3%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%A1%AE%E4%BF%9D%E5%BC%95%E7%94%A8%E6%9C%89%E6%95%88/">10.3 生命周期确保引用有效</a></p><p class="categories"><a href="/categories/Rust/">Rust</a> / <a href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-05-27T06:50:26.000Z">2025-05-27</time></p><p class="title"><a href="/2025/05/27/Rust/The%20Rust%20Programming%20Language/10.2%20Trait%EF%BC%9A%E5%AE%9A%E4%B9%89%E5%85%B1%E5%90%8C%E8%A1%8C%E4%B8%BA/">10.2 Trait：定义共同行为</a></p><p class="categories"><a href="/categories/Rust/">Rust</a> / <a href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-05-27T06:30:26.000Z">2025-05-27</time></p><p class="title"><a href="/2025/05/27/Rust/The%20Rust%20Programming%20Language/10.1%20%E6%B3%9B%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">10.1 泛型数据类型</a></p><p class="categories"><a href="/categories/Rust/">Rust</a> / <a href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-05-26T06:55:26.000Z">2025-05-26</time></p><p class="title"><a href="/2025/05/26/Rust/The%20Rust%20Programming%20Language/09.3%20%E8%A6%81%E4%B8%8D%E8%A6%81%20panic!/">9.3 要不要 panic!</a></p><p class="categories"><a href="/categories/Rust/">Rust</a> / <a href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-05-26T06:50:26.000Z">2025-05-26</time></p><p class="title"><a href="/2025/05/26/Rust/The%20Rust%20Programming%20Language/09.2%20%E7%94%A8%20Result%20%E5%A4%84%E7%90%86%E5%8F%AF%E6%81%A2%E5%A4%8D%E7%9A%84%E9%94%99%E8%AF%AF/">9.2 用 Result 处理可恢复的错误</a></p><p class="categories"><a href="/categories/Rust/">Rust</a> / <a href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2025/05/"><span class="level-start"><span class="level-item">五月 2025</span></span><span class="level-end"><span class="level-item tag">47</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/04/"><span class="level-start"><span class="level-item">四月 2025</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/03/"><span class="level-start"><span class="level-item">三月 2025</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/02/"><span class="level-start"><span class="level-item">二月 2025</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/12/"><span class="level-start"><span class="level-item">十二月 2024</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Arch-Linux/"><span class="tag">Arch Linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/English/"><span class="tag">English</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Golang/"><span class="tag">Golang</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OS/"><span class="tag">OS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Rust/"><span class="tag">Rust</span><span class="tag">30</span></a></div><div class="control"><a class="tags has-addons" href="/tags/git/"><span class="tag">git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/python/"><span class="tag">python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/test/"><span class="tag">test</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/toy-projects/"><span class="tag">toy projects</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%B8%AD%E6%96%87/"><span class="tag">中文</span><span class="tag">41</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%85%AB%E8%82%A1/"><span class="tag">八股</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BF%BB%E8%AF%91/"><span class="tag">翻译</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="MyBlog" height="28"></a><p class="is-size-7"><span>&copy; 2025 Rossignol</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>