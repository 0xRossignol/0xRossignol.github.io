<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>MyBlog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="MyBlog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="MyBlog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="MyBlog"><meta property="og:url" content="http://example.com/"><meta property="og:site_name" content="MyBlog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:author" content="Rossignol"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"MyBlog","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"Rossignol"},"publisher":{"@type":"Organization","name":"MyBlog","logo":{"@type":"ImageObject","url":"http://example.com/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="MyBlog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/0xRossignol"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-04-06T14:45:19.961Z" title="2025/4/6 22:45:19">2025-04-06</time>发表</span><span class="level-item"><time dateTime="2025-04-06T14:45:06.006Z" title="2025/4/6 22:45:06">2025-04-06</time>更新</span><span class="level-item">几秒读完 (大约0个字)</span></div></div><div class="content"></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-04-06T14:45:19.961Z" title="2025/4/6 22:45:19">2025-04-06</time>发表</span><span class="level-item"><time dateTime="2025-04-06T14:45:06.006Z" title="2025/4/6 22:45:06">2025-04-06</time>更新</span><span class="level-item">几秒读完 (大约0个字)</span></div></div><div class="content"></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-04-06T14:45:19.961Z" title="2025/4/6 22:45:19">2025-04-06</time>发表</span><span class="level-item"><time dateTime="2025-04-06T14:45:06.006Z" title="2025/4/6 22:45:06">2025-04-06</time>更新</span><span class="level-item">几秒读完 (大约0个字)</span></div></div><div class="content"></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-04-06T14:45:06.006Z" title="2025/4/6 22:45:06">2025-04-06</time>发表</span><span class="level-item"><time dateTime="2025-04-06T14:45:06.006Z" title="2025/4/6 22:45:06">2025-04-06</time>更新</span><span class="level-item">几秒读完 (大约0个字)</span></div></div><div class="content"></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-04-06T13:55:29.000Z" title="2025/4/6 21:55:29">2025-04-06</time>发表</span><span class="level-item"><time dateTime="2025-04-06T14:50:55.437Z" title="2025/4/6 22:50:55">2025-04-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%85%AB%E8%82%A1/">八股</a><span> / </span><a class="link-muted" href="/categories/%E5%85%AB%E8%82%A1/JavaSE/">JavaSE</a></span><span class="level-item">34 分钟读完 (大约5092个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/04/06/%E5%85%AB%E8%82%A1/Java/Java%E5%9F%BA%E7%A1%80/JavaSE%20pt.3/">JavaSE pt.3</a></p><div class="content"><h2 id="1-异常"><a href="#1-异常" class="headerlink" title="1. 异常"></a>1. 异常</h2><p><strong>Java 异常类层次结构：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">    Throwable --&gt;Exception;</span><br><span class="line">    Throwable --&gt;Error;</span><br><span class="line"></span><br><span class="line">    Exception --&gt;CheckedException;</span><br><span class="line">    Exception --&gt;UncheckedException;</span><br><span class="line"></span><br><span class="line">    Error --&gt; Errors;</span><br><span class="line"></span><br><span class="line">    subgraph CheckedException [Checked Exceptions]</span><br><span class="line">        direction TB;</span><br><span class="line">        IOException;</span><br><span class="line">        ClassNotFoundException;</span><br><span class="line">        SQLException;</span><br><span class="line">        FileNotFoundException;</span><br><span class="line">        ......;</span><br><span class="line">    end</span><br><span class="line">    CheckedException --&gt; IOException;</span><br><span class="line">    CheckedException --&gt; ClassNotFoundException;</span><br><span class="line">    CheckedException --&gt; SQLException;</span><br><span class="line">    CheckedException --&gt; FileNotFoundException;</span><br><span class="line"></span><br><span class="line">    subgraph UncheckedException [Unchecked Exceptions]</span><br><span class="line">        direction TB;</span><br><span class="line">        ArithmeticException;</span><br><span class="line">        ClassCastException;</span><br><span class="line">        IllegalThreadStateException;</span><br><span class="line">        IndexOutOfBoundsException;</span><br><span class="line">        ......;</span><br><span class="line">    end</span><br><span class="line">    UncheckedException --&gt; ArithmeticException;</span><br><span class="line">    UncheckedException --&gt; ClassCastException;</span><br><span class="line">    UncheckedException --&gt; IllegalThreadStateException;</span><br><span class="line">    UncheckedException --&gt; IndexOutOfBoundsException;</span><br><span class="line"></span><br><span class="line">    subgraph Errors [Errors]</span><br><span class="line">        direction TB;</span><br><span class="line">        OutOfMemoryError;</span><br><span class="line">        VirtualMachineError;</span><br><span class="line">        StackOverflowError;</span><br><span class="line">        AssertionError;</span><br><span class="line">        IOError;</span><br><span class="line">        ......;</span><br><span class="line">    end</span><br><span class="line">    Errors --&gt; OutOfMemoryError;</span><br><span class="line">    Errors --&gt; VirtualMachineError;</span><br><span class="line">    Errors --&gt; StackOverflowError;</span><br><span class="line">    Errors --&gt; AssertionError;</span><br><span class="line">    Errors --&gt; IOError;</span><br></pre></td></tr></table></figure>

<h3 id="1-1-Exception-和-Error-有什么区别？"><a href="#1-1-Exception-和-Error-有什么区别？" class="headerlink" title="1.1 Exception 和 Error 有什么区别？"></a>1.1 Exception 和 Error 有什么区别？</h3><p>在 Java 中， 所有的异常都有一个共同的祖先 ： <code>java.lang</code> 包下的 <code>Throwable</code> 类。 <code>Throwable</code> 类有两个重要的子类:</p>
<ul>
<li><code>Exception</code> ： 程序本身可以处理的异常，通常可以通过 <code>catch</code> 来捕获。 <code>Exception</code> 又可以分为 Checked Exception （ 受检查异常， <strong>必须处理</strong> ） 和 Unchecked Exception （ 不受检查异常， <strong>可以不处理</strong> ）。</li>
<li><code>Error</code> ： <code>Error</code> 属于程序无法处理的错误，不建议通过 <code>catch</code> 捕获。如 Java 虚拟机运行错误 （ <code>Virtural MachineError</code> ） 、 虚拟机内存不够错误 （ <code>OutOfMemoryError</code> ） 、 类定义错误 （ <code>NoClassDefFoundError</code> ） 等。这类异常发生时， JVM 一般会选择线程终止。</li>
</ul>
<h3 id="1-2-Checked-Exception-和-Unchecked-Exception-有什么区别？"><a href="#1-2-Checked-Exception-和-Unchecked-Exception-有什么区别？" class="headerlink" title="1.2 Checked Exception 和 Unchecked Exception 有什么区别？"></a>1.2 Checked Exception 和 Unchecked Exception 有什么区别？</h3><p><strong>Checked Exception</strong> 即 <strong>受检查异常</strong> ，Java 代码在编译过程中，如果受检查异常没有被 <code>catch</code> 或者 <code>throws</code> 关键字处理的话，就<strong>没办法通过编译</strong>。</p>
<p>除了 <code>RuntimeException</code> 及其子类以外，其他的 <code>Exception</code> 类及其子类都属于受检查异常 。常见的受检查异常有：<strong>IO 相关的异常、ClassNotFoundException、SQLException</strong> …。</p>
<p><code>Unchecked Exception</code> 即 <strong>不受检查异常</strong> ，Java 代码在编译过程中 ，我们即使不处理不受检查异常<strong>也可以正常通过编译</strong>。</p>
<p>RuntimeException 及其子类都统称为非受检查异常，常见的有：</p>
<ul>
<li><code>NullPointerException</code>(空指针错误)</li>
<li><code>IllegalArgumentException</code>(参数错误比如方法入参类型错误)</li>
<li><code>NumberFormatException</code>（字符串转换为数字格式错误，<code>IllegalArgumentException</code> 的子类）</li>
<li><code>ArrayIndexOutOfBoundsException</code>（数组越界错误）</li>
<li><code>ClassCastException</code>（类型转换错误）</li>
<li><code>ArithmeticException</code>（算术错误）</li>
<li><code>SecurityException</code> （安全错误比如权限不够）</li>
<li><code>UnsupportedOperationException</code> (不支持的操作错误比如重复创建同一用户)</li>
<li>……</li>
</ul>
<h3 id="1-3-Throwable-类常用方法有哪些？"><a href="#1-3-Throwable-类常用方法有哪些？" class="headerlink" title="1.3 Throwable 类常用方法有哪些？"></a>1.3 Throwable 类常用方法有哪些？</h3><ul>
<li><code>String getMessage()</code> : 返回异常发生时的详细信息</li>
<li><code>String toString()</code> : 返回异常发生时的简要描述</li>
<li><code>String getLocalizedMessage()</code> : 返回异常对象的本地化信息。使用 <code>Throwable</code> 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage()</code> 返回的结果相同</li>
<li><code>void printStackTrace()</code> : 在控制台上打印 <code>Throwable</code> 对象封装的异常信息</li>
</ul>
<h3 id="1-4-try-catch-finally-如何使用？"><a href="#1-4-try-catch-finally-如何使用？" class="headerlink" title="1.4 try-catch-finally 如何使用？"></a>1.4 try-catch-finally 如何使用？</h3><ul>
<li>try 块：用于捕获异常。其后可接零个或多个 catch 块，<strong>如果没有 catch 块，则必须跟一个 finally 块</strong>。</li>
<li>catch 块：用于处理 try 捕获到的异常。</li>
<li>finally 块：<strong>无论是否捕获或处理异常</strong>，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在<strong>方法返回之前被执行</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Try to do something&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;RuntimeException&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Catch Exception -&gt; &quot;</span> + e.getMessage());</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Finally&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Try to do something</span><br><span class="line">Catch Exception -&gt; RuntimeException</span><br><span class="line">Finally</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：**<em>不要在 finally 语句块中使用 return !</em>** 当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。这是因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(f(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value * value;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure>

<h3 id="1-5-finally-中的代码一定会执行吗？"><a href="#1-5-finally-中的代码一定会执行吗？" class="headerlink" title="1.5 finally 中的代码一定会执行吗？"></a>1.5 finally 中的代码一定会执行吗？</h3><p><strong><em>不一定。</em></strong></p>
<p>如： finally 之前虚拟机被终止， finally 中的代码就不会执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Try to do something&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;RuntimeException&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Catch Exception -&gt; &quot;</span> + e.getMessage());</span><br><span class="line">    <span class="comment">// 终止当前正在运行的Java虚拟机</span></span><br><span class="line">    System.exit(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Finally&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Try to do something</span><br><span class="line">Catch Exception -&gt; RuntimeException</span><br></pre></td></tr></table></figure>

<p>另外，在以下 2 种特殊情况下，finally 块的代码也不会被执行：</p>
<ol>
<li>程序所在线程死亡。</li>
<li>关闭 CPU 。</li>
</ol>
<h3 id="1-6-如何使用-try-with-resources-代替-try-catch-finally？"><a href="#1-6-如何使用-try-with-resources-代替-try-catch-finally？" class="headerlink" title="1.6 如何使用 try-with-resources 代替 try-catch-finally？"></a>1.6 如何使用 try-with-resources 代替 try-catch-finally？</h3><ol>
<li><strong>适用范围 （资源定义）</strong> ： 任何实现 <code>java.lang.AutoCloseable</code> 或者 <code>java.io.Closeable</code> 的对象。</li>
<li><strong>关闭资源和 finally 块的执行顺序</strong> ： 在 <code>try-catch-resources</code> 语句中，任何 catch 或 finally 块在声明的资源关闭后运行。</li>
</ol>
<p>Effective Java 中指出；</p>
<blockquote>
<p>面对必须要关闭的资源，我们总是应该优先使用 <code>try-with-resources</code> 而不是<code>try-finally</code> 。随之产生的代码更简短，更清晰，产生的异常对我们也更有用。 <code>try-with-resources</code> 语句让我们更容易编写必须要关闭的资源的代码，若采用 <code>try-finally</code> 则几乎做不到这点。</p>
</blockquote>
<p>Java 中类似于 <code>InputStream</code> 、 <code>OutputStream</code> 、 <code>Scanner</code> 、 <code>PrintWriter</code> 等的资源都需要我们调用 <code>close()</code> 方法来手动关闭，一般情况下我们都是通过 <code>try-catch-finally</code> 语句来实现这个需求，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取文本文件的内容</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    scanner = <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D://read.txt&quot;</span>));</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (scanner != <span class="literal">null</span>) &#123;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 Java 7 之后的 <code>try-with-resources</code> 语句改造上面的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>))) &#123;</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException fnfe) &#123;</span><br><span class="line">    fnfe.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多个资源需要关闭的时候，使用 <code>try-with-resources</code> 实现起来也非常简单，如果还是用 <code>try-catch-finally</code> 可能会带来很多问题。</p>
<p>通过使用分号分隔，可以在 try-with-resources 块中声明多个资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (</span><br><span class="line">    <span class="type">BufferedInputStream</span> <span class="variable">bin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>)));</span><br><span class="line">    <span class="type">BufferedOutputStream</span> <span class="variable">bout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;out.txt&quot;</span>)))</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="keyword">while</span> ((b = bin.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        bout.write(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-7-异常使用有哪些需要注意的地方？"><a href="#1-7-异常使用有哪些需要注意的地方？" class="headerlink" title="1.7 异常使用有哪些需要注意的地方？"></a>1.7 异常使用有哪些需要注意的地方？</h3><ul>
<li><strong>不要把异常定义为静态变量</strong>，因为这样会导致异常栈信息错乱。每次手动抛出异常，我们都需要手动 new 一个异常对象抛出。</li>
<li>抛出的异常信息一定要<strong>有意义</strong>。</li>
<li>建议<strong>抛出更加具体的异常</strong>，比如字符串转换为数字格式错误的时候应该抛出 NumberFormatException 而不是其父类 IllegalArgumentException。</li>
<li><strong>避免重复记录日志</strong>：如果在捕获异常的地方已经记录了足够的信息（包括异常类型、错误信息和堆栈跟踪等），那么在业务代码中再次抛出这个异常时，就不应该再次记录相同的错误信息。重复记录日志会使得日志文件膨胀，并且可能会掩盖问题的实际原因，使得问题更难以追踪和解决。</li>
<li>……</li>
</ul>
<h2 id="2-泛型"><a href="#2-泛型" class="headerlink" title="2. 泛型"></a>2. 泛型</h2><h3 id="2-1-什么是泛型？有什么作用？"><a href="#2-1-什么是泛型？有什么作用？" class="headerlink" title="2.1 什么是泛型？有什么作用？"></a>2.1 什么是泛型？有什么作用？</h3><p><strong>Java 泛型 （ Generics ）</strong> 是 JDK 5 引入的新特性。使用泛型可以增强代码的可读性和稳定性。</p>
<p>编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。比如 <code>ArrayList&lt;Person&gt; persons = new ArrayList&lt;Person&gt;()</code> 这行代码就指明了该 <code>ArrayList</code> 对象只能传入 <code>Person</code> 对象，如果传入其他类型的对象就会报错。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br></pre></td></tr></table></figure>

<p>并且，原生 List 返回类型是 Object ，需要手动转换类型才能使用，使用泛型后编译器自动转换。</p>
<h3 id="2-2-泛型的使用方式有哪几种？"><a href="#2-2-泛型的使用方式有哪几种？" class="headerlink" title="2.2 泛型的使用方式有哪几种？"></a>2.2 泛型的使用方式有哪几种？</h3><p>泛型一般有三种使用方式: <strong>泛型类、泛型接口、泛型方法</strong> 。</p>
<ol>
<li><p><strong>泛型类</strong> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line"><span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Generic</span>&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Generic</span><span class="params">(T key)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getKey</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何实例化泛型类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Generic&lt;Integer&gt; genericInteger = <span class="keyword">new</span> <span class="title class_">Generic</span>&lt;Integer&gt;(<span class="number">123456</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>泛型接口</strong> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Generator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现泛型接口，不指定类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GeneratorImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;T&gt;&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> T <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现泛型接口，指定类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GeneratorImpl</span> <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;String&gt; &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>泛型方法</strong> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt; E &gt; <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">( E[] inputArray )</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">for</span> ( E element : inputArray )&#123;</span><br><span class="line">        System.out.printf( <span class="string">&quot;%s &quot;</span>, element );</span><br><span class="line">     &#125;</span><br><span class="line">     System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建不同类型数组：Integer, Double 和 Character</span></span><br><span class="line">Integer[] intArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">String[] stringArray = &#123; <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span> &#125;;</span><br><span class="line">printArray( intArray  );</span><br><span class="line">printArray( stringArray  );</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>注意: <code>public static &lt; E &gt; void printArray( E[] inputArray )</code> 一般被称为<strong>静态泛型方法</strong>;在 java 中泛型只是一个占位符，必须在传递类型后才能使用。类在实例化时才能真正的传递类型参数，由于静态方法的加载先于类的实例化，也就是说类中的泛型还没有传递真正的类型参数，静态的方法的加载就已经完成了，所以静态泛型方法是没有办法使用类上声明的泛型的。只能使用自己声明的 <code>&lt;E&gt;</code></p>
</blockquote>
<h3 id="2-3-项目中哪里用到了泛型？"><a href="#2-3-项目中哪里用到了泛型？" class="headerlink" title="2.3 项目中哪里用到了泛型？"></a>2.3 项目中哪里用到了泛型？</h3><ul>
<li>自定义接口通用返回结果 <code>CommonResult&lt;T&gt;</code> 通过参数 T 可根据具体的返回类型动态指定结果的数据类型</li>
<li>定义 Excel 处理类 <code>ExcelUtil&lt;T&gt;</code> 用于动态指定 Excel 导出的数据类型</li>
<li>构建集合工具类（参考 Collections 中的 sort, binarySearch 方法）。</li>
<li>……</li>
</ul>
<h2 id="3-反射"><a href="#3-反射" class="headerlink" title="3. 反射"></a>3. 反射</h2><p>详细解读见 <a href="./%E5%85%B6%E4%BB%96%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9.md">其他重要知识点</a></p>
<h3 id="3-1-什么是反射？"><a href="#3-1-什么是反射？" class="headerlink" title="3.1 什么是反射？"></a>3.1 什么是反射？</h3><p>反射之所以被称为框架的灵魂，主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。</p>
<h3 id="3-2-反射的优缺点？"><a href="#3-2-反射的优缺点？" class="headerlink" title="3.2 反射的优缺点？"></a>3.2 反射的优缺点？</h3><p>反射可以让我们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利。</p>
<p>不过，反射让我们在运行时有了分析操作类的能力的同时，也增加了安全问题，比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。</p>
<p>相关阅读：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/1392351/java-reflection-why-is-it-so-slow">Java Reflection: Why is it so slow?</a> 。</p>
<h3 id="3-3-反射的应用场景？"><a href="#3-3-反射的应用场景？" class="headerlink" title="3.3 反射的应用场景？"></a>3.3 反射的应用场景？</h3><p>像 <code>Spring/Spring Boot、MyBatis</code> 等等框架中都大量使用了反射机制。</p>
<p><strong>这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。</strong></p>
<p>比如下面是通过 JDK 实现动态代理的示例代码，其中就使用了反射类 <code>Method</code> 来调用指定的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DebugInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理类中的真实对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DebugInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before method &quot;</span> + method.getName());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;after method &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外， <strong>注解</strong> 的实现也用到了反射。为什么使用 Spring 的时候 ，一个 <code>@Component</code> 注解就声明了一个类为 Spring Bean 呢？为什么通过一个 <code>@Value</code> 注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？这些都是因为你可以基于反射分析类，然后获取到类&#x2F;属性&#x2F;方法&#x2F;方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。</p>
<h2 id="4-注解"><a href="#4-注解" class="headerlink" title="4. 注解"></a>4. 注解</h2><h3 id="4-1-注解是什么？"><a href="#4-1-注解是什么？" class="headerlink" title="4.1 注解是什么？"></a>4.1 注解是什么？</h3><p><code>Annotation</code> 是 Java 5 开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类、方法或变量，提供某些信息供程序在编译或运行时使用。</p>
<p>注解本质时一个继承了 <code>Annotation</code> 的特殊接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Override</span> <span class="keyword">extends</span> <span class="title class_">Annotation</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK 提供了很多内置的注解 （ <code>@Override , @Deprecated</code> ），同时，我们还可以自定义注解。</p>
<h3 id="4-2-注解的解析方式有几种？"><a href="#4-2-注解的解析方式有几种？" class="headerlink" title="4.2 注解的解析方式有几种？"></a>4.2 注解的解析方式有几种？</h3><p>注解只有被解析之后才会生效，常见的解析方法有两种：</p>
<ul>
<li><p><strong>编译期直接扫描</strong> ：　编译器在编译 Java 代码时扫描对应的注解并处理，比如某个方法使用　<code>@Override</code> 注解，编译器在编译时就会检测当前的方法是否重写了父类对应的方法。</p>
</li>
<li><p><strong>运行期通过反射代理</strong> ： 像框架中自带的注解 （如 Spring 框架的 <code>@Value</code>, <code>@Component</code> ）都是通过反射来进行处理的。</p>
</li>
</ul>
<h2 id="5-SPI"><a href="#5-SPI" class="headerlink" title="5. SPI"></a>5. SPI</h2><p>关于 SPI 的详细解读，请看<a href="./%E5%85%B6%E4%BB%96%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9.md">其他重要知识点</a></p>
<h3 id="5-1-什么是-SPI"><a href="#5-1-什么是-SPI" class="headerlink" title="5.1 什么是 SPI"></a>5.1 什么是 SPI</h3><p>SPI 即 Service Provider Interface ， 字面意思就是“ 服务提供者的接口 ”， 可指：专门提供给服务提供者或者扩展框架功能的开发者去使用的一个接口。</p>
<p>SPI 将服务接口和具体的服务实现分离开，将服务调用方和服务实现者解耦，能提升程序的扩展性、可维护性。修改或替换服务并不需要修改调用方。</p>
<p>很多框架都使用了 Java 的 SPI 机制，如 Spring框架、数据库加载驱动、日志接口以及 Dubbo 的扩展实现等等。</p>
<h3 id="5-2-SPI-和-API-的区别？"><a href="#5-2-SPI-和-API-的区别？" class="headerlink" title="5.2 SPI 和 API 的区别？"></a>5.2 SPI 和 API 的区别？</h3><p><img src="/./asserts/JavaSE%20pt%203/01.png" alt="区别"></p>
<p>一般模块之间都是通过接口进行通讯，因此在服务调用方和服务实现方（也称服务提供者）之间引入一个“接口”。</p>
<ul>
<li><p>当<strong>实现方提供了接口和实现</strong>，我们可以通过调用实现方的接口从而拥有实现方给我们提供的能力，这就是 API。这种情况下，接口和实现都是放在实现方的包中。调用方通过接口调用实现方的功能，而不需要关心具体的实现细节。</p>
</li>
<li><p>当<strong>接口存在于调用方这边时</strong>，这就是 SPI 。由接口调用方确定接口规则，然后由不同的厂商根据这个规则对这个接口进行实现，从而提供服务。</p>
</li>
</ul>
<p>例子： 公司 H 是一家科技公司，新设计了一款芯片，然后现在需要量产了，而市面上有好几家芯片制造业公司，这个时候，只要 H 公司指定好了这芯片生产的标准（定义好了接口标准），那么这些合作的芯片公司（服务提供者）就按照标准交付自家特色的芯片（提供不同方案的实现，但是给出来的结果是一样的）。</p>
<h3 id="5-3-SPI-的优缺点"><a href="#5-3-SPI-的优缺点" class="headerlink" title="5.3 SPI 的优缺点"></a>5.3 SPI 的优缺点</h3><p>通过 SPI 机制能够大大地提高接口设计的灵活性，但是 SPI 机制也存在一些缺点，比如：</p>
<ul>
<li><p>需要遍历加载所有的实现类，不能做到按需加载，这样效率相对较低。</p>
</li>
<li><p>当多个 ServiceLoader 同时 load 时，会有并发问题。</p>
</li>
</ul>
<h2 id="6-序列化和反序列化"><a href="#6-序列化和反序列化" class="headerlink" title="6. 序列化和反序列化"></a>6. 序列化和反序列化</h2><p><a href="./%E5%85%B6%E4%BB%96%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9.md">具体介绍</a></p>
<h3 id="6-1-什么是序列化和反序列化？"><a href="#6-1-什么是序列化和反序列化？" class="headerlink" title="6.1 什么是序列化和反序列化？"></a>6.1 什么是序列化和反序列化？</h3><ul>
<li><p><strong>序列化</strong> ： 将数据或对象转换成可以存储或传输的形式 （通常是二进制字节流， 也可以是 JSON 、 XML 等文本格式）</p>
</li>
<li><p><strong>反序列化</strong> ：将序列化过程中生成的数据转换为原始数据结构或对象的过程。</p>
</li>
</ul>
<p>常见应用场景：</p>
<ul>
<li><p>对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；</p>
</li>
<li><p>将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；</p>
</li>
<li><p>将对象存储到数据库（如 Redis）之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；</p>
</li>
<li><p>将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。</p>
</li>
</ul>
<h3 id="6-2-序列化协议对应-TCP-IP-4层模型的哪一层？"><a href="#6-2-序列化协议对应-TCP-IP-4层模型的哪一层？" class="headerlink" title="6.2 序列化协议对应 TCP&#x2F;IP 4层模型的哪一层？"></a>6.2 序列化协议对应 TCP&#x2F;IP 4层模型的哪一层？</h3><p><img src="/./asserts/JavaSE%20pt%203/02.png" alt="OSI 七层协议"></p>
<p>如上图所示，OSI 七层协议模型中，表示层做的事情主要就是对应用层的用户数据进行处理转换为二进制流。反过来的话，就是将二进制流转换成应用层的用户数据。</p>
<p>OSI 七层协议模型中的应用层、表示层和会话层对应的都是 TCP&#x2F;IP 四层模型中的应用层，所以序列化协议属于 TCP&#x2F;IP 协议应用层的一部分。</p>
<h3 id="6-3-如果有些字段不想序列化怎么办？"><a href="#6-3-如果有些字段不想序列化怎么办？" class="headerlink" title="6.3 如果有些字段不想序列化怎么办？"></a>6.3 如果有些字段不想序列化怎么办？</h3><p>对于不想进行序列化的变量，使用 <code>transient</code> 关键字修饰。</p>
<p><code>transient</code> 关键词的作用是： 阻止实例中使用此关键字的变量序列化；当对象被反序列化时，被 <code>transient</code> 修饰的关键字不会被持久化和恢复。</p>
<p>注意：</p>
<ul>
<li><code>transient</code> 只能修饰变量</li>
<li><code>transient</code> 修饰的变量，在反序列化后变量值会被设置成默认值。</li>
<li><code>static</code> 变量因为不属于任何对象，所以无论有没有 <code>transient</code> 修饰都不会被序列化。</li>
</ul>
<h3 id="6-4-常见的序列化协议"><a href="#6-4-常见的序列化协议" class="headerlink" title="6.4 常见的序列化协议"></a>6.4 常见的序列化协议</h3><p>JDK 自带的序列化方法一般不用，因为序列化效率低且存在安全问题。较常用的序列化协议有 Hession , Kryo , Protobuf , protoStuff ， 这些都是基于二进制的序列化协议。</p>
<p>像 JSON 和 XML 这种属于文本类序列化方式。虽然可读性比较好，但是性能较差，一般不会选择。</p>
<h3 id="6-5-为什么不推荐-JDK-自带的序列化？"><a href="#6-5-为什么不推荐-JDK-自带的序列化？" class="headerlink" title="6.5 为什么不推荐 JDK 自带的序列化？"></a>6.5 为什么不推荐 JDK 自带的序列化？</h3><ul>
<li><strong>不支持跨语言调用</strong></li>
<li><strong>性能差</strong> ： 相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。</li>
<li><strong>存在安全问题</strong> ： 序列化和反序列化本身并不存在问题。但当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码。</li>
</ul>
<h2 id="7-I-O"><a href="#7-I-O" class="headerlink" title="7. I&#x2F;O"></a>7. I&#x2F;O</h2><p><a href="../IO/IO%20%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93.md">基础</a><br><a href="../IO/IO%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93.md">设计模式</a><br><a href="../IO/IO%20%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3.md">模型</a></p>
<h2 id="8-语法糖"><a href="#8-语法糖" class="headerlink" title="8. 语法糖"></a>8. 语法糖</h2><h3 id="8-1-什么是语法糖？"><a href="#8-1-什么是语法糖？" class="headerlink" title="8.1 什么是语法糖？"></a>8.1 什么是语法糖？</h3><p>语法糖（Syntactic sugar） 代指的是编程语言为了方便程序员开发程序而设计的一种特殊语法，这种语法对编程语言的功能并没有影响。实现相同的功能，基于语法糖写出来的代码往往更简单简洁且更易阅读。</p>
<p>JVM 其实并不能识别语法糖，Java 语法糖要想被正确执行，需要先通过编译器进行解糖，也就是在程序编译阶段将其转换成 JVM 认识的基本语法。这也侧面说明，Java 中真正支持语法糖的是 Java 编译器而不是 JVM。如果去看 <code>com.sun.tools.javac.main.JavaCompiler</code> 的源码，会发现在 <code>compile()</code> 中有一个步骤就是调用 <code>desugar()</code> ，这个方法就是负责解语法糖的实现的。</p>
<h3 id="8-2-Java-中常见的语法糖"><a href="#8-2-Java-中常见的语法糖" class="headerlink" title="8.2 Java 中常见的语法糖"></a>8.2 Java 中常见的语法糖</h3><p><a href="./%E5%85%B6%E4%BB%96%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9.md">详解</a></p>
<h2 id="NEXT"><a href="#NEXT" class="headerlink" title="NEXT"></a>NEXT</h2><p><a href="./%E5%85%B6%E4%BB%96%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9.md">下一篇</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-03-25T13:00:29.000Z" title="2025/3/25 21:00:29">2025-03-25</time>发表</span><span class="level-item"><time dateTime="2025-04-06T14:51:14.670Z" title="2025/4/6 22:51:14">2025-04-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%85%AB%E8%82%A1/">八股</a><span> / </span><a class="link-muted" href="/categories/%E5%85%AB%E8%82%A1/JavaSE/">JavaSE</a></span><span class="level-item">1 小时读完 (大约7678个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/03/25/%E5%85%AB%E8%82%A1/Java/Java%E5%9F%BA%E7%A1%80/JavaSE%20pt.2/">JavaSE pt.2</a></p><div class="content"><h2 id="1-面向对象基础"><a href="#1-面向对象基础" class="headerlink" title="1. 面向对象基础"></a>1. 面向对象基础</h2><h3 id="1-1-面向对象和面向过程的区别？"><a href="#1-1-面向对象和面向过程的区别？" class="headerlink" title="1.1 面向对象和面向过程的区别？"></a>1.1 面向对象和面向过程的区别？</h3><p>面向过程（ Procedural-Oriented Programming , POP ） 和面向对象 （ Object-Oriented Programming , OOP ） 是两种常见的编程范式，两者的区别主要是解决问题的不同：</p>
<ul>
<li><strong>面向过程</strong> ： 将解决问题的过程拆成一个一个函数，通过函数的执行解决问题。</li>
<li><strong>面向对象</strong> ： 先抽象出对象，然后用对象执行方法的方式解决问题。</li>
</ul>
<p>相较于 POP ， OOP 程序一般具有以下优点：</p>
<ul>
<li><strong>易维护</strong> ： 由于良好的结构和封装性， OOP 程序通常更容易维护。</li>
<li><strong>易复用</strong> ： 通过继承和多态， OOP 设计使得代码更具复用性，方便扩展功能。</li>
<li><strong>易扩展</strong> ： 模块化设计使系统扩展变的更加容易和灵活。</li>
</ul>
<p>POP 的编程方式通常更为简单和直接，适合处理一些较简单的任务。</p>
<p>POP 和 OOP 的性能差异主要取决于它们的运行机制，而不仅仅是编程范式本身。因此，简单比较两者性能是一个常见误区。（ <a target="_blank" rel="noopener" href="https://github.com/Snailclimb/JavaGuide/issues/431">相关 issue</a> ）</p>
<h3 id="1-2-创建一个对象用什么运算符？对象实体与对象引用有何不同？"><a href="#1-2-创建一个对象用什么运算符？对象实体与对象引用有何不同？" class="headerlink" title="1.2 创建一个对象用什么运算符？对象实体与对象引用有何不同？"></a>1.2 创建一个对象用什么运算符？对象实体与对象引用有何不同？</h3><p><code>new</code> 运算符， <code>new</code> 对象创建对象实例（对象实例在堆内存中）， 对象引用指向对象实例（对象引用存放在栈内存中）。</p>
<ul>
<li>1 个对象引用可以指向 0 个或 1 个对象</li>
<li>一个对象可以有 n 个引用指向它</li>
</ul>
<h3 id="1-3-对象相等和引用相等的区别？"><a href="#1-3-对象相等和引用相等的区别？" class="headerlink" title="1.3 对象相等和引用相等的区别？"></a>1.3 对象相等和引用相等的区别？</h3><ul>
<li>对象的相等一般比较的是内存中查询放的内容是否相等。</li>
<li>引用相等一般比较的是它们指向的内存地址是否相等。</li>
</ul>
<h3 id="1-4-如果一个类没有声明构造方法，该程序能正确执行吗？"><a href="#1-4-如果一个类没有声明构造方法，该程序能正确执行吗？" class="headerlink" title="1.4 如果一个类没有声明构造方法，该程序能正确执行吗？"></a>1.4 如果一个类没有声明构造方法，该程序能正确执行吗？</h3><p>如果一个对象没有声明构造方法，也可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果自己添加了构造方法， Java 就不会添加默认的构造方法了。</p>
<p>如果重载了有参的构造方法，<strong>记得都要把无参的构造方法也写出来</strong>（无论是否用到），因为这可以帮助我们在创建对象的时候少踩坑。</p>
<h3 id="1-5-构造方法有哪些特点？是否可以被-override-？"><a href="#1-5-构造方法有哪些特点？是否可以被-override-？" class="headerlink" title="1.5 构造方法有哪些特点？是否可以被 override ？"></a>1.5 构造方法有哪些特点？是否可以被 <code>override</code> ？</h3><p>特点：</p>
<ul>
<li><strong>名称与类名相同</strong> ： 构造方法的名称必须与类名完全一致</li>
<li><strong>没有返回值</strong> ： 构造方法没有返回类型且不能用 <code>void</code> 声明</li>
<li><strong>自动执行</strong> ： 在生成类的对象时，构造方法会自动执行，无需显式调用</li>
</ul>
<p>构造方法 <strong>不能被重写 （ override ）</strong> ， 但 <strong>可以被重载 （ overload ）</strong> 。</p>
<h3 id="1-6-面向对象三大特征？"><a href="#1-6-面向对象三大特征？" class="headerlink" title="1.6 面向对象三大特征？"></a>1.6 面向对象三大特征？</h3><h4 id="1-6-1-封装"><a href="#1-6-1-封装" class="headerlink" title="1.6.1 封装"></a>1.6.1 封装</h4><p>封装是指将对象的状态信息 （属性） 隐藏在对象内部， 不允许外部对象直接访问。都是可以提供一些可被外界访问的方法来操作属性。</p>
<h4 id="1-6-2-继承"><a href="#1-6-2-继承" class="headerlink" title="1.6.2 继承"></a>1.6.2 继承</h4><p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p>
<p>注意：</p>
<ol>
<li>子类拥有父类对象的所有属性和方法（包括私有属性和方法），但是父类的私有属性和方法子类无法访问， <strong>只是拥有</strong> 。</li>
<li>子类可以拥有自己的属性和方法。</li>
<li>子类可以用自己的方式实现父类的方法。</li>
</ol>
<h4 id="1-6-3-多态"><a href="#1-6-3-多态" class="headerlink" title="1.6.3 多态"></a>1.6.3 多态</h4><p>多态表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</p>
<p>特点：</p>
<ul>
<li>对象类型和引用类型之间具有继承（类） &#x2F; 实现（接口） 关系</li>
<li>引用类型变量发出的方法调用的到底时哪个类中的方法，必须在程序运行期间才能确定</li>
<li>多态不能调用 “只在子类存在但父类不存在的方法”</li>
<li>如果子类重写了父类的方法，真正执行的是子类重写的方法，如果没有，执行的是父类的方法。</li>
</ul>
<h3 id="1-7-接口和抽象类的共同点和区别？"><a href="#1-7-接口和抽象类的共同点和区别？" class="headerlink" title="1.7 接口和抽象类的共同点和区别？"></a>1.7 接口和抽象类的共同点和区别？</h3><p>共同点：</p>
<ul>
<li><strong>实例化</strong> ： 接口和抽象类都不能直接实例化，只能被实现 （接口） 或继承 （抽象类） 后才能创建具体的对象。</li>
<li><strong>抽象方法</strong> ： 接口和抽象类都可以包含抽象方法，抽象方法没有方法体，必须在子类或实现类中实现。</li>
</ul>
<p>区别：</p>
<ul>
<li><strong>设计目的</strong> ：<br>接口主要用于对类的行为进行约束，实现接口就具有对应的行为。<br>抽象类主要用于代码复用，强调的是所属关系。</li>
<li><strong>继承和实现</strong> ：<br>一个类只能继承一个类 （包括抽象类）<br>一个类可以实现多个接口，一个接口也可以继承多个其他接口。</li>
<li><strong>成员变量</strong> ：<br>接口中的成员变量只能是 <code>public static final</code> 类型的，不能被修改且必须有初始值。<br>抽象类的成员变量可以有任何修饰符 （ <code>private</code> , <code>protected</code> , <code>public</code> ） 可以在子类中被重新定义或赋值。</li>
<li><strong>方法</strong> ：<ul>
<li>Java 8 之前，接口中的方法默认为 <code>public abstract</code> ， 也就是只能由方法声明。 自 Java 8 起，可以在接口中定义 <code>default</code> 方法和 <code>static</code> 方法，自 Java 9 起，接口可以包含 <code>private</code> 方法。</li>
<li>抽象类可以包含抽象方法和非抽象方法。抽象方法没有方法体，必须在子类中实现。非抽象方法有具体实现，可以直接在抽象类中使用或在子类中重写。</li>
</ul>
</li>
</ul>
<p>在 Java 8 及以上版本中，接口引入了新的方法类型： <code>default</code> 方法、 <code>static</code> 方法和 <code>private</code> 方法。这些方法让接口的使用更加灵活。</p>
<p>Java 8 引入的 <code>default</code> 方法用于提供接口方法的默认实现，可以在实现类中被覆盖。这样就可以在不修改实现类的情况下向现有接口添加新功能，从而增强接口的扩展性和向后兼容性。</p>
<p>Java 8 引入的 <code>static</code> 方法无法在实现类中被覆盖，只能通过接口名直接调用，类似于类中的静态方法。static 方法通常用于定义一些通用的、与接口相关的工具方法，一般很少用。</p>
<p>Java 9 允许在接口中使用 <code>private</code> 方法。 <code>private</code> 方法可以用于在接口内部共享代码，不对外暴露。</p>
<h3 id="1-8-深拷贝和浅拷贝的区别？什么是引用拷贝？"><a href="#1-8-深拷贝和浅拷贝的区别？什么是引用拷贝？" class="headerlink" title="1.8 深拷贝和浅拷贝的区别？什么是引用拷贝？"></a>1.8 深拷贝和浅拷贝的区别？什么是引用拷贝？</h3><p>深拷贝与浅拷贝的区别：</p>
<ul>
<li><strong>浅拷贝</strong> ： 浅拷贝会在堆上创建一个新的对象（区别与深拷贝的一点），不过，如果元对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，即拷贝对象和原对象共用同一个内部对象。</li>
<li><strong>深拷贝</strong> ： 深拷贝会完全复制整个对象，包括对象所包含的内部对象。</li>
</ul>
<p>实例：</p>
<h4 id="1-8-1-浅拷贝"><a href="#1-8-1-浅拷贝" class="headerlink" title="1.8.1 浅拷贝"></a>1.8.1 浅拷贝</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 省略构造函数、Getter&amp;Setter方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Address <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Address) <span class="built_in">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">    <span class="comment">// 省略构造函数、Getter&amp;Setter方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) <span class="built_in">super</span>.clone();</span><br><span class="line">            <span class="keyword">return</span> person;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;武汉&quot;</span>));</span><br><span class="line"><span class="type">Person</span> <span class="variable">person1Copy</span> <span class="operator">=</span> person1.clone();</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">System.out.println(person1.getAddress() == person1Copy.getAddress());</span><br></pre></td></tr></table></figure>

<p>从输出结构就可以看出， <code>person1</code> 的克隆对象和 <code>person1</code> 使用的仍然是同一个 <code>Address</code> 对象。</p>
<h4 id="1-8-2-深拷贝"><a href="#1-8-2-深拷贝" class="headerlink" title="1.8.2 深拷贝"></a>1.8.2 深拷贝</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Person <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) <span class="built_in">super</span>.clone();</span><br><span class="line">        person.setAddress(person.getAddress().clone());</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;武汉&quot;</span>));</span><br><span class="line"><span class="type">Person</span> <span class="variable">person1Copy</span> <span class="operator">=</span> person1.clone();</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line">System.out.println(person1.getAddress() == person1Copy.getAddress());</span><br></pre></td></tr></table></figure>

<p>从输出结构可以看出，显然 <code>person1</code> 的克隆对象和 <code>person1</code> 包含的 <code>Address</code> 对象已经是不同的了。</p>
<h4 id="1-8-3-引用拷贝"><a href="#1-8-3-引用拷贝" class="headerlink" title="1.8.3 引用拷贝"></a>1.8.3 引用拷贝</h4><p>引用拷贝就是两个不同的引用指向同一个对象。</p>
<img src="./asserts/JavaSE pt 2/001.png">

<h2 id="2-Object"><a href="#2-Object" class="headerlink" title="2. Object"></a>2. Object</h2><h3 id="2-1-Object-类的常见方法有哪些？"><a href="#2-1-Object-类的常见方法有哪些？" class="headerlink" title="2.1 Object 类的常见方法有哪些？"></a>2.1 Object 类的常见方法有哪些？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于创建并返回当前对象的一份拷贝。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实例被垃圾回收器回收的时候触发的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-和-equals-的区别？"><a href="#2-2-和-equals-的区别？" class="headerlink" title="2.2 == 和 equals() 的区别？"></a>2.2 <code>==</code> 和 <code>equals()</code> 的区别？</h3><p><code>==</code> 对基本类型和引用类型的作用是不同的：</p>
<ul>
<li>对基本数据类型， <code>==</code> 比较的是值</li>
<li>对引用数据类型， <code>==</code> 比较的是对象的内存地址</li>
</ul>
<blockquote>
<p>Java 只有值传递，所以对 <code>==</code> 来说，不管是基本数据类型还是引用数据类型，其本质都是比较值。</p>
</blockquote>
<p><code>equals()</code> 不能用于基本数据类型的判断。 <code>equals()</code> 存在于 <code>Object</code> 类中， 因此所有的类都有 <code>equals()</code> 方法。</p>
<p><code>equals()</code> 方法存在两种使用情况：</p>
<ul>
<li>类没有重写： 等价于通过 <code>==</code> 比较对象。</li>
<li>类重写了： 一般都重写 <code>equals()</code> 方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 <code>true</code> (即认为这两个对象相等)。</li>
</ul>
<p><code>String</code> 中的 <code>equals</code> 方法是被重写过的，因为 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址，而 <code>String</code> 的 <code>equals</code> 方法比较的是对象的值。</p>
<p>当创建 <code>String</code> 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 <code>String</code> 对象。</p>
<p><code>String</code> 类 <code>equals()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object anObject)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">anotherString</span> <span class="operator">=</span> (String)anObject;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="type">char</span> v1[] = value;</span><br><span class="line">            <span class="type">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-hashcode-有什么用？"><a href="#2-3-hashcode-有什么用？" class="headerlink" title="2.3 hashcode() 有什么用？"></a>2.3 <code>hashcode()</code> 有什么用？</h3><p><code>hashcode()</code> 的作用是获取哈希值（ <code>int</code> 整形 ）， 也称为散列码，用于确定该对象在哈希表中的索引位置。</p>
<p><code>hashCode()</code> 定义在 JDK 的 <code>Object</code> 类中，这就意味着 <code>Java</code> 中的任何类都包含有 <code>hashCode()</code> 函数。另外需要注意的是： <code>Object</code> 的 <code>hashCode()</code> 方法是本地方法，也就是用 <code>C</code> 语言或 <code>C++</code> 实现的。</p>
<p>散列表存储的是键值对( key-value )，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p>
<h3 id="2-4-为什么要有-hashcode-？"><a href="#2-4-为什么要有-hashcode-？" class="headerlink" title="2.4 为什么要有 hashcode() ？"></a>2.4 为什么要有 <code>hashcode()</code> ？</h3><blockquote>
<p>当把对象加入 <code>HashSet</code> 时， <code>HashSet</code> 会先计算对象的 <code>hashCode</code> 值来判断对象加入的位置，同时也会与其他已经加入的对象的 <code>hashCode</code> 值作比较，如果没有相符的 <code>hashCode</code> ， <code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashCode</code> 值的对象，这时会调用 <code>equals()</code> 方法来检查 <code>hashCode</code> 相等的对象是否真的相同。如果两者相同， <code>HashSet</code> 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 <code>equals</code> 的次数，相应就大大提高了执行速度。<br>—— Head First Java</p>
</blockquote>
<p><code>hashCode()</code> 和 <code>equals()</code> 都是用于比较两个对象是否相等。</p>
<h4 id="2-4-1-为什么-JDK-还要同时提供这两个方法呢？"><a href="#2-4-1-为什么-JDK-还要同时提供这两个方法呢？" class="headerlink" title="2.4.1 为什么 JDK 还要同时提供这两个方法呢？"></a>2.4.1 为什么 JDK 还要同时提供这两个方法呢？</h4><p>在一些容器（比如 <code>HashMap</code> 、 <code>HashSet</code> ）中，有了 <code>hashCode()</code> 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进 <code>HashSet</code> 的过程）</p>
<p>在前面也提到了添加元素进 <code>HashSet</code> 的过程，如果 <code>HashSet</code> 在对比的时候，同样的 <code>hashCode</code> 有多个对象，它会继续使用 <code>equals()</code> 来判断是否真的相同。也就是说 <code>hashCode</code> 帮助我们大大缩小了查找成本。</p>
<h4 id="2-4-2-为什么不只提供-hashCode-方法呢？"><a href="#2-4-2-为什么不只提供-hashCode-方法呢？" class="headerlink" title="2.4.2 为什么不只提供 hashCode() 方法呢？"></a>2.4.2 为什么不只提供 <code>hashCode()</code> 方法呢？</h4><p>因为两个对象的 hashCode 值相等并不代表两个对象就相等。</p>
<p><code>hashCode()</code> 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（ 所谓哈希碰撞也就是指的是不同的对象得到相同的 <code>hashCode</code> )。</p>
<p>总结：</p>
<ul>
<li>两个对象的 <code>hashcode</code> 值相等， 两个对象不一定相等。</li>
<li>两个对象的 <code>hashcode</code> 值相等且 <code>equals()</code> 方法返回 <code>true</code> ，才认为两个对象相等。</li>
<li>两个对象的 <code>hashcode</code> 不相等， 可以直接认为两个对象不相等。</li>
</ul>
<h3 id="2-5-为什么重写-equals-方法时必须重写-hashcode-方法？"><a href="#2-5-为什么重写-equals-方法时必须重写-hashcode-方法？" class="headerlink" title="2.5 为什么重写 equals() 方法时必须重写 hashcode() 方法？"></a>2.5 为什么重写 <code>equals()</code> 方法时必须重写 <code>hashcode()</code> 方法？</h3><p>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p>
<p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象， <code>hashCode</code> 值却不相等。</p>
<p><strong>思考</strong> ： 重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话，使用 <code>HashMap</code> 可能会出现什么问题。</p>
<p>答案：</p>
<p>基础：</p>
<p>会出现 <code>equals</code> 判断相同的对象由于 <code>hashcode</code> 不同导致 <code>hashmap</code> 中存在多个相同的对象。</p>
<p>Deepseek 优化：</p>
<p>当重写 <code>equals()</code> 而未重写 <code>hashCode()</code> 时，使用 <code>HashMap</code> 可能引发以下问题：</p>
<ul>
<li><p>哈希冲突误判： <code>HashMap</code> 通过 <code>hashCode()</code> 确定键值对的存储桶位置。若两个逻辑相等的对象（ <code>equals()</code> 为 <code>true</code> ）产生不同哈希值，它们会被错误分配到不同存储桶，导致 <code>HashMap</code> 无法识别其等价性。</p>
</li>
<li><p>数据重复存储：本应覆盖的键值对会作为不同键被重复存储，例如 <code>map.put(a,1)</code> 和 <code>map.put(b,1)</code> 会形成两个独立条目（ 尽管 <code>a.equals(b) == true</code> ）。</p>
</li>
<li><p>检索数据失败：通过等价对象查询时（ 如 <code>map.get(b)</code> 查询已存入的 <code>a</code> ），由于哈希定位到错误存储桶，可能返回 <code>null</code> 而非预期值。</p>
</li>
<li><p>破坏契约原则：违反 Java 对象契约（ <code>equal</code> 对象必须有相同 <code>hashCode</code> ），导致所有依赖哈希机制的集合类（ <code>HashSet</code> 、 <code>HashTable</code> 等）行为异常。</p>
</li>
</ul>
<p><strong>总结</strong> ：</p>
<ul>
<li><p><code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p>
</li>
<li><p>两个对象有相同的 <code>hashCode</code> 值，他们也不一定是相等的（哈希碰撞）。</p>
</li>
</ul>
<h2 id="3-String"><a href="#3-String" class="headerlink" title="3. String"></a>3. String</h2><h3 id="3-1-String-StringBuffer-StringBuilder-的区别？"><a href="#3-1-String-StringBuffer-StringBuilder-的区别？" class="headerlink" title="3.1 String , StringBuffer , StringBuilder 的区别？"></a>3.1 String , StringBuffer , StringBuilder 的区别？</h3><p><strong>可变性</strong>：</p>
<p><code>String</code> 是不可变的。</p>
<p><code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，最关键的是 <code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法，比如 <code>append</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, CharSequence &#123;</span><br><span class="line">    <span class="type">char</span>[] value;</span><br><span class="line">    <span class="keyword">public</span> AbstractStringBuilder <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> appendNull();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">        ensureCapacityInternal(count + len);</span><br><span class="line">        str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">        count += len;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>线程安全性</strong> ：</p>
<p><code>String</code> 中的对象是不可变的，也就可以理解为常量，<strong>线程安全</strong>。 <code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code> 、 <code>append</code> 、 <code>insert</code> 、 <code>indexOf</code> 等公共方法。 <code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是<strong>线程安全</strong>的。 <code>StringBuilder</code> 并没有对方法进行加同步锁，所以是<strong>非线程安全</strong>的。</p>
<p><strong>性能</strong> ：</p>
<p>每次对 <code>String</code> 类型进行改变时都会生成一个新的 <code>String</code> 对象，然后将指针指向新的对象。 <code>StringBuffer</code> 每次都会对对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10% ~ 15% 的性能提升，但却要冒多线程不安全的风险。</p>
<p>总结：</p>
<ul>
<li>操作少量数据： 用 <code>String</code></li>
<li>单线程操作字符串缓冲区下操作大量数据： <code>StringBuilder</code></li>
<li>多线程操作字符串缓冲区下操作大量数据： <code>StringBuffer</code></li>
</ul>
<h3 id="3-2-String-为什么不可变？"><a href="#3-2-String-为什么不可变？" class="headerlink" title="3.2 String 为什么不可变？"></a>3.2 String 为什么不可变？</h3><p><code>String</code> 类中使用 <code>fianl</code> 关键字修饰字符数组来保存字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：<strong>被 <code>fianl</code> 修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象</strong>。<br>因此， <code>fianl</code> 修饰的数组保存字符串<strong>并不是 <code>String</code> 不可变的根本原因</strong>， 因为这个数组保存的字符串是可变的（ <code>final</code> 修饰引用类型变量的情况）。</p>
</blockquote>
<p><code>String</code> 真正不可变的原因：</p>
<ol>
<li>保存字符串的数组被 <code>final</code> 修饰且为私有的，并且 <code>String</code> 类没有提供&#x2F;暴露修改这个字符串的方法。</li>
<li><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</li>
</ol>
<blockquote>
<p>补充：<br>在 Java 9 之后， <code>String</code> <code>StringBuilder</code> 与 <code>StringBuffer</code> 的实现被改用 <code>byte</code> 数组存储字符串。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable,Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">// @Stable 注解表示变量最多被修改一次，称为“稳定的”。</span></span><br><span class="line">    <span class="meta">@Stable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, CharSequence &#123;</span><br><span class="line">    <span class="type">byte</span>[] value;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Java-9-为何要将-String-的底层实现由-char-改成了-byte"><a href="#Java-9-为何要将-String-的底层实现由-char-改成了-byte" class="headerlink" title="Java 9 为何要将 String 的底层实现由 char[] 改成了 byte[] ?"></a>Java 9 为何要将 <code>String</code> 的底层实现由 <code>char[]</code> 改成了 <code>byte[]</code> ?</h4><p>新版的 <code>String</code> 支持两个编码方案： <code>Latin-1</code> 和 <code>UTF-16</code> 。如果字符串中包含的汉字没有超过 <code>Latin-1</code> 可表示范围内的字符，那就会使用 <code>Latin-1</code> 。 <code>Latin-1</code> 编码方案下， <code>byte</code> 占一个字节（ 8 位 ）， <code>char</code> 占用 2 个字节（ 16 ）， <code>byte</code> 相较 <code>char</code> 节省一半的内存空间。</p>
<img src="./asserts/JavaSE pt 2/002.png">

<p>如果字符串中包含的汉字超过 Latin-1 可表示范围内的字符，byte 和 char 所占用的空间是一样的。</p>
<p><a target="_blank" rel="noopener" href="https://openjdk.org/jeps/254">官方介绍</a></p>
<h3 id="3-3-字符串拼接用-还是-StringBuilder-？"><a href="#3-3-字符串拼接用-还是-StringBuilder-？" class="headerlink" title="3.3 字符串拼接用 + 还是 StringBuilder ？"></a>3.3 字符串拼接用 <code>+</code> 还是 <code>StringBuilder</code> ？</h3><p>Java 语言本身不支持运算符重载， <strong>“+”和“+&#x3D;”是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的运算符</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;he&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;llo&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> str1 + str2 + str3;</span><br></pre></td></tr></table></figure>

<p>对应字节码：</p>
<img src="./asserts/JavaSE pt 2/003.png">

<p>可以看出，字符串对象通过“+”的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</p>
<p>不过，在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：<strong>编译器不会创建单个 <code>StringBuilder</code> 以复用，会导致创建过多的 <code>StringBuilder</code> 对象</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">&quot;he&quot;</span>, <span class="string">&quot;llo&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    s += arr[i];</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure>

<p><code>StringBuilder</code> 对象是在循环内部被创建的，这意味着每循环一次就会创建一个 <code>StringBuilder</code> 对象。</p>
<img src="./asserts/JavaSE pt 2/004.png">

<p>如果直接使用 <code>StringBuilder</code> 对象进行字符串拼接的话，就不会存在这个问题了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">&quot;he&quot;</span>, <span class="string">&quot;llo&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="keyword">for</span> (String value : arr) &#123;</span><br><span class="line">    s.append(value);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure>

<img src="./asserts/JavaSE pt 2/005.png">

<p>在 JDK 9 中，字符串相加“+”改为用动态方法 <code>makeConcatWithConstants()</code> 来实现，通过提前分配空间从而减少了部分临时对象的创建。然而这种优化主要针对简单的字符串拼接，如： <code>a+b+c</code> 。对于循环中的大量拼接操作，仍然会逐个动态分配内存（类似于两个两个 <code>append</code> 的概念），并不如手动使用 <code>StringBuilder</code> 来进行拼接效率高。</p>
<h3 id="3-4-String-equals-和-Object-equals-有什么区别？"><a href="#3-4-String-equals-和-Object-equals-有什么区别？" class="headerlink" title="3.4 String equals() 和 Object equals() 有什么区别？"></a>3.4 String equals() 和 Object equals() 有什么区别？</h3><p>String 中的 equals 方法是被重写过的，比较的是 String 字符串的值是否相等。 Object 的 equals 方法是比较的对象的内存地址。</p>
<h3 id="3-5-字符串常量池的作用？"><a href="#3-5-字符串常量池的作用？" class="headerlink" title="3.5 字符串常量池的作用？"></a>3.5 字符串常量池的作用？</h3><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（ <code>String</code> 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在字符串常量池中创建字符串对象 ”ab“</span></span><br><span class="line"><span class="comment">// 将字符串对象 ”ab“ 的引用赋值给 aa</span></span><br><span class="line"><span class="type">String</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象 ”ab“，赋值给引用 bb</span></span><br><span class="line"><span class="type">String</span> <span class="variable">bb</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">System.out.println(aa==bb); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="3-6-String-s1-new-String-“abc”-这句话创建了几个字符串对象？"><a href="#3-6-String-s1-new-String-“abc”-这句话创建了几个字符串对象？" class="headerlink" title="3.6 String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象？"></a>3.6 String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象？</h3><p>答案：<strong>会创建 1 或 2 个字符串对象</strong>。</p>
<ol>
<li>字符串常量池中不存在 “abc”：会创建 2 个 字符串对象。一个在字符串常量池中，由 ldc 指令触发创建。一个在堆中，由 new String() 创建，并使用常量池中的 “abc” 进行初始化。</li>
<li>字符串常量池中已存在 “abc”：会创建 1 个 字符串对象。该对象在堆中，由 new String() 创建，并使用常量池中的 “abc” 进行初始化。</li>
</ol>
<p>分析：</p>
<ol>
<li>如果字符串常量池中不存在字符串对象 “abc”，那么它首先会在字符串常量池中创建字符串对象 “abc”，然后在堆内存中再创建其中一个字符串对象 “abc”。</li>
</ol>
<p>字节码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在堆内存中分配一个尚未初始化的 String 对象。</span></span><br><span class="line"><span class="comment">// #2 是常量池中的一个符号引用，指向 java/lang/String 类。</span></span><br><span class="line"><span class="comment">// 在类加载的解析阶段，这个符号引用会被解析成直接引用，即指向实际的 java/lang/String 类。</span></span><br><span class="line"><span class="number">0</span> <span class="keyword">new</span> #<span class="number">2</span> &lt;java/lang/String&gt;</span><br><span class="line"><span class="comment">// 复制栈顶的 String 对象引用，为后续的构造函数调用做准备。</span></span><br><span class="line"><span class="comment">// 此时操作数栈中有两个相同的对象引用：一个用于传递给构造函数，另一个用于保持对新对象的引用，后续将其存储到局部变量表。</span></span><br><span class="line"><span class="number">3</span> dup</span><br><span class="line"><span class="comment">// JVM 先检查字符串常量池中是否存在 &quot;abc&quot;。</span></span><br><span class="line"><span class="comment">// 如果常量池中已存在 &quot;abc&quot;，则直接返回该字符串的引用；</span></span><br><span class="line"><span class="comment">// 如果常量池中不存在 &quot;abc&quot;，则 JVM 会在常量池中创建该字符串字面量并返回它的引用。</span></span><br><span class="line"><span class="comment">// 这个引用被压入操作数栈，用作构造函数的参数。</span></span><br><span class="line"><span class="number">4</span> ldc #<span class="number">3</span> &lt;abc&gt;</span><br><span class="line"><span class="comment">// 调用构造方法，使用从常量池中加载的 &quot;abc&quot; 初始化堆中的 String 对象</span></span><br><span class="line"><span class="comment">// 新的 String 对象将包含与常量池中的 &quot;abc&quot; 相同的内容，但它是一个独立的对象，存储于堆中。</span></span><br><span class="line"><span class="number">6</span> invokespecial #<span class="number">4</span> &lt;java/lang/String.&lt;init&gt; : (Ljava/lang/String;)V&gt;</span><br><span class="line"><span class="comment">// 将堆中的 String 对象引用存储到局部变量表</span></span><br><span class="line"><span class="number">9</span> astore_1</span><br><span class="line"><span class="comment">// 返回，结束方法</span></span><br><span class="line"><span class="number">10</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<h3 id="3-7-String-intern-方法有什么用？"><a href="#3-7-String-intern-方法有什么用？" class="headerlink" title="3.7 String intern 方法有什么用？"></a>3.7 String intern 方法有什么用？</h3><p><code>String.intern()</code> 是一个 <code>native</code> 方法，用于处理字符串常量池中的对象引用。工作流程：</p>
<ol>
<li><strong>常量池中已有相同内容的字符串对象</strong> ： 如果字符串常量池中已经有一个与调用 <code>intern()</code> 方法的字符串内容相同的对象， <code>intern()</code> 返回常量池中该对象的引用。</li>
<li><strong>常量池中没有相同内容的字符串对象</strong> ： <code>intern()</code> 方法会将当前字符串对象的引用添加到字符串常量池中，并返回该引用。</li>
</ol>
<p>总结：</p>
<ul>
<li><code>intern()</code> 方法的主要作用是确保字符串引用在常量池中的唯一性。</li>
<li>当调用 <code>intern()</code> 时，如果常量池中已经存在相同内容的字符串，则返回常量池中已有对象的引用；否则，将该字符串添加到常量池并返回其引用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s1 指向字符串常量池中的 &quot;Java&quot; 对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Java&quot;</span>;</span><br><span class="line"><span class="comment">// s2 也指向字符串常量池中的 &quot;Java&quot; 对象，和 s1 是同一个对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.intern();</span><br><span class="line"><span class="comment">// 在堆中创建一个新的 &quot;Java&quot; 对象，s3 指向它</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line"><span class="comment">// s4 指向字符串常量池中的 &quot;Java&quot; 对象，和 s1 是同一个对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s3.intern();</span><br><span class="line"><span class="comment">// s1 和 s2 指向的是同一个常量池中的对象</span></span><br><span class="line">System.out.println(s1 == s2); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// s3 指向堆中的对象，s4 指向常量池中的对象，所以不同</span></span><br><span class="line">System.out.println(s3 == s4); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// s1 和 s4 都指向常量池中的同一个对象</span></span><br><span class="line">System.out.println(s1 == s4); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="3-8-String-类型的变量和常量做-“-”-运算时发生了什么？"><a href="#3-8-String-类型的变量和常量做-“-”-运算时发生了什么？" class="headerlink" title="3.8 String 类型的变量和常量做 “+” 运算时发生了什么？"></a>3.8 String 类型的变量和常量做 “+” 运算时发生了什么？</h3><p><strong>不加 <code>final</code> 关键词</strong> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> str1 + str2;</span><br><span class="line"><span class="type">String</span> <span class="variable">str5</span> <span class="operator">=</span> <span class="string">&quot;string&quot;</span>;</span><br><span class="line">System.out.println(str3 == str4);<span class="comment">//false</span></span><br><span class="line">System.out.println(str3 == str5);<span class="comment">//true</span></span><br><span class="line">System.out.println(str4 == str5);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong> ：比较 String 字符串的值是否相等，可以使用 <code>equals()</code> 方法。 String 中的 <code>equals</code> 方法是被重写过的。 Object 的 equals 方法是比较的对象的<strong>内存地址</strong>，而 String 的 equals 方法比较的是<strong>字符串的值是否相等</strong>。如果你使用 &#x3D;&#x3D; 比较两个字符串是否相等的话，IDEA 还是提示你使用 equals() 方法替换。</p>
</blockquote>
<p><strong>对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。</strong></p>
<p>在编译过程中，Javac 编译器（下文中统称为编译器）会进行一个叫做 常量折叠(Constant Folding) 的代码优化。</p>
<p>常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。</p>
<p>对于 <code>String str3 = &quot;str&quot; + &quot;ing&quot;;</code> 编译器会优化成 <code>String str3 = &quot;string&quot;;</code> 。</p>
<p>并不是所有的常量都会进行折叠，只有编译器在程序编译期就可以确定值的常量才可以：</p>
<ul>
<li>基本数据类型( byte、boolean、short、char、int、float、long、double)以及字符串常量。</li>
<li>final 修饰的基本数据类型和字符串变量</li>
<li>字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（&lt;&lt;、&gt;&gt;、&gt;&gt;&gt; ）</li>
</ul>
<p><strong>引用的值在程序编译期是无法确定的，编译器无法对其进行优化。</strong></p>
<p>对象引用和“+”的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>().append(str1).append(str2).toString();</span><br></pre></td></tr></table></figure>

<p>在平时写代码的时候，尽量避免多个字符串对象拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 <code>StringBuilder</code> 或者 <code>StringBuffer</code> 。</p>
<p>不过，<strong>字符串使用 final 关键字声明之后</strong>，可以让编译器当做常量来处理 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"><span class="comment">// 下面两个表达式其实是等价的</span></span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;<span class="comment">// 常量池中的对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> str1 + str2; <span class="comment">// 常量池中的对象</span></span><br><span class="line">System.out.println(c == d);<span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>被 <code>final</code> 关键字修饰之后的 <code>String</code> 会被编译器当做常量来处理，编译器在程序编译期就可以确定它的值，其效果就相当于访问常量。</p>
<h2 id="NEXT"><a href="#NEXT" class="headerlink" title="NEXT"></a>NEXT</h2><p><a href="JavaSE%20pt.3.md">JavaSE pt.3</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-03-10T14:42:26.000Z" title="2025/3/10 22:42:26">2025-03-10</time>发表</span><span class="level-item"><time dateTime="2025-04-06T14:51:24.561Z" title="2025/4/6 22:51:24">2025-04-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%85%AB%E8%82%A1/">八股</a><span> / </span><a class="link-muted" href="/categories/%E5%85%AB%E8%82%A1/JavaSE/">JavaSE</a></span><span class="level-item">1 小时读完 (大约9587个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/03/10/%E5%85%AB%E8%82%A1/Java/Java%E5%9F%BA%E7%A1%80/JavaSE%20pt.1/">JavaSE pt.1</a></p><div class="content"><p>First tip：<br>根据 <strong>JavaGuide</strong> 和 <strong>Deepseek</strong> 内容整理</p>
<h2 id="1-基础概念与常识"><a href="#1-基础概念与常识" class="headerlink" title="1. 基础概念与常识"></a>1. 基础概念与常识</h2><h3 id="1-1-Java-语言有哪些特点？"><a href="#1-1-Java-语言有哪些特点？" class="headerlink" title="1.1 Java 语言有哪些特点？"></a>1.1 Java 语言有哪些特点？</h3><ol>
<li>简单易学（语法简单，容易上手）</li>
<li>面向对象（封装、继承、多态）</li>
<li>平台无关（Java 虚拟机）</li>
<li>支持多线程</li>
<li>可靠性（异常处理、GC）</li>
<li>安全性（访问权限修饰符、限制程序直接访问系统资源）</li>
<li>高效性（通过 <strong>JIT</strong>[^JIT] 编译器等技术优化）</li>
<li>支持网络编程</li>
<li>编译与解释并存</li>
</ol>
<p>[^JIT]: <strong>JIT</strong> 即 “Just in Time”</p>
<blockquote>
<p>拓展：<br>“Write once, Run everywhere” ，即跨平台这一特点已经不再是 Java 的主要特点了（ <strong>Docker</strong> 等技术的出现使跨平台相当轻松）。Java 的优势转变为了其强大的生态。</p>
</blockquote>
<h3 id="1-2-JavaSE-和-JavaEE"><a href="#1-2-JavaSE-和-JavaEE" class="headerlink" title="1.2 JavaSE 和 JavaEE"></a>1.2 JavaSE 和 JavaEE</h3><ul>
<li><p>JavaSE ( <em>Java Platform, Standard Edition</em> )： Java 编程语言的基础，包含了支持 Java 程序开发和运行的核心类库以及 JVM 等核心组件。可以用于构建桌面应用程序或简单的服务器应用程序。</p>
</li>
<li><p>JavaEE ( <em>Java Platform, Enterprise Edition</em> )：建立在 JavaSE 的基础上，包含了支持企业级应用开发和部署的标准与规范（ Servlet、 JSP、 EJB、 JDBC、 JPA、 JTA 等）。可以用于构建分布式、可移植、健壮、可伸缩和安全的服务端 Java 应用程序。</p>
</li>
</ul>
<p>简单来说，Java SE 是 Java 的基础版本，Java EE 是 Java 的高级版本。Java SE 更适合开发桌面应用程序或简单的服务器应用程序，Java EE 更适合开发复杂的企业级应用程序或 Web 应用程序。</p>
<h3 id="1-3-JVM、JDK、JRE"><a href="#1-3-JVM、JDK、JRE" class="headerlink" title="1.3 JVM、JDK、JRE"></a>1.3 JVM、JDK、JRE</h3><h4 id="1-3-1-JVM"><a href="#1-3-1-JVM" class="headerlink" title="1.3.1 JVM"></a>1.3.1 JVM</h4><p>JVM ( <em>Java Virtual Machine</em> ) 是运行 <strong>Java 字节码</strong> 的虚拟机。JVM 有针对不同系统的实现，目的是使用相同的字节码得到相同的结果。字节码和 JVM 是实现 Java 语言 “Write once, Run everywhere” 的关键。</p>
<p><strong>JVM 不止一种，只要满足 JVM 规范，每个公司、组织或者个人都可以开发自己的专属 JVM。</strong> 我们平时接触到的 <em>HotSpotVM</em> 只是 JVM 规范的一种实现。</p>
<p>除了 HotSpotVM 外，还有 <em>J9 VM, Zing VM, JRockit VM</em> 等实现。</p>
<h4 id="1-3-2-JDK-和-JRE"><a href="#1-3-2-JDK-和-JRE" class="headerlink" title="1.3.2 JDK 和 JRE"></a>1.3.2 JDK 和 JRE</h4><p>JDK( <em>Java Development Kit</em> )是 Java 开发工具包，用于创建和编译 Java 程序。它包含了 JRE ( <em>Java Runtime Environment</em> ) 以及编译器 Javac 和其他工具 ( <em>javadoc, jdb（调试器）, jconsole（监控工具）, javap(反编译工具)</em> )。</p>
<p>JRE 是运行已编译的 Java 程序所需的环境，包括：</p>
<ul>
<li>JVM</li>
<li>Java 基础类库 ( <em>Class Library</em> )：一组标准类库，提供常用的功能和 API（如 <em>I&#x2F;O 操作、 网络通信、 数据结构</em> 等）</li>
</ul>
<p>简单来说，JRE 只包含运行 Java 程序所需的环境和类库，而 JDK 不仅包含 JRE ，还包括用于开发和调试的工具。</p>
<p>不过，从 JDK 9 开始，就不需要区分 JDK 和 JRE 的关系了，取而代之的是模块系统（ JDK 被重新组织成 94 个模块）+ <a target="_blank" rel="noopener" href="https://openjdk.org/jeps/282">jlink</a> 工具 (随 Java 9 一起发布的新命令行工具，用于生成自定义 Java 运行时映像，该映像仅包含给定应用程序所需的模块) 。并且，从 JDK 11 开始，Oracle 不再提供单独的 JRE 下载。</p>
<p>可以用 jlink 根据自己的需求，创建一个更小的 runtime ，而不是都使用同样的 JRE 。</p>
<p>定制的、模块化的 Java 运行时映像有助于简化 Java 应用的部署和节省内存、增强安全性和可维护性。</p>
<h3 id="1-4-什么是字节码？采用字节码的好处是什么？"><a href="#1-4-什么是字节码？采用字节码的好处是什么？" class="headerlink" title="1.4 什么是字节码？采用字节码的好处是什么？"></a>1.4 什么是字节码？采用字节码的好处是什么？</h3><p>在 Java 中，能被 JVM 理解的代码（即扩展名为 <code>.class</code> 的文件）就是字节码，它不面向任何特定的处理器，只面向虚拟机。字节码在一定程度上解决了传统解释型语言执行效率低的问题，保留了解释型语言可移植的特点。因此 Java 程序无需重新编译便可在多种不同操作系统上运行。</p>
<img src="./asserts/JavaSE pt 1/001.png">

<p><code>.class -&gt; 机器码</code> 这一步 JVM 类加载器 首先加载字节码文件，然后通过解释器逐行解释执行，这种方式执行速度相对较慢。而且，有些方法和代码块经常需要被调用（即热点代码），所以后来引进了 <strong>JIT</strong> ( <em>Just In Time Compilation</em> )编译器， 而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。这也解释了为什么经常说 <strong>Java 是编译与解释共存的语言</strong>。</p>
<img src="./asserts/JavaSE pt 1/002.png">

<blockquote>
<p>HotSpot 采用了<strong>惰性评估 ( Lazy Evaluation )</strong> 的做法，根据二八定律，消耗大部分系统资源的只有一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。</p>
</blockquote>
<img src="./asserts/JavaSE pt 1/003.png">

<img src="./asserts/JavaSE pt 1/004.png">

<h3 id="1-5-为什么说-Java-语言-“编译与解释并存”-？"><a href="#1-5-为什么说-Java-语言-“编译与解释并存”-？" class="headerlink" title="1.5 为什么说 Java 语言 “编译与解释并存” ？"></a>1.5 为什么说 Java 语言 “编译与解释并存” ？</h3><p>该问题在 <a href="#14-%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E8%8A%82%E7%A0%81%E9%87%87%E7%94%A8%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88">上一问</a> 已经提到过。</p>
<h4 id="1-5-1-分类"><a href="#1-5-1-分类" class="headerlink" title="1.5.1 分类"></a>1.5.1 分类</h4><p>我们可以将高级语言按照程序的执行方式分为两类：</p>
<ul>
<li><p><strong>编译型</strong>： <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%B7%A8%E8%AD%AF%E8%AA%9E%E8%A8%80">编译型语言</a> 会通过 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%B7%A8%E8%AD%AF%E5%99%A8">编译器</a> 将源代码一次性翻译成机器码。一般编译型语言执行速度较快，开发效率较低。</p>
</li>
<li><p><strong>解释型</strong>： <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%9B%B4%E8%AD%AF%E8%AA%9E%E8%A8%80">解释型语言</a> 会通过 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%9B%B4%E8%AD%AF%E5%99%A8">解释器</a> 一句一句的将代码解释（interpret）为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。</p>
</li>
</ul>
<blockquote>
<p>为了改善解释语言的效率而发展出的即时编译技术，已经缩小了这两种语言间的差距。这种技术混合了编译语言与解释型语言的优点，它像编译语言一样，先把程序源代码编译成字节码。到执行期时，再将字节码直译，之后执行。Java 与 LLVM 是这种技术的代表产物。</p>
</blockquote>
<h4 id="1-5-2-为什么说-Java-语言-“编译与解释并存”-？"><a href="#1-5-2-为什么说-Java-语言-“编译与解释并存”-？" class="headerlink" title="1.5.2 为什么说 Java 语言 “编译与解释并存” ？"></a>1.5.2 为什么说 Java 语言 “编译与解释并存” ？</h4><p>这是因为 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（.class 文件），这种字节码必须由 Java 解释器来解释执行。</p>
<h3 id="1-6-AOT-有什么优点？为什么不全部使用-AOT-？"><a href="#1-6-AOT-有什么优点？为什么不全部使用-AOT-？" class="headerlink" title="1.6 AOT 有什么优点？为什么不全部使用 AOT ？"></a>1.6 AOT 有什么优点？为什么不全部使用 AOT ？</h3><p>JDK9 引入了新的编译模式 <strong>AOT</strong> ( <em>Ahead Of Time Compilation</em> ) 。 和 JIT 不同的是，这种编译模式会在程序被执行前就将其编译成机器码，属于静态编译（ C、C++、Rust、Go 等语言就是静态编译）。AOT 避免了 JIT 预热等各方面的开销，可以提高 Java 程序的启动速度，避免预热时间过长。并且， AOT 还能减少内存占用和增强 Java 程序的安全性 （ AOT 编译后的代码不容易被反编译和修改）， 特别适合云原生场景。</p>
<img src="./asserts/JavaSE pt 1/005.png">

<p>可以看出， AOT 的主要优势在于启动时间、内存占用和打包体积。 JIT 的主要优势在于具备更高的极限处理能力，可以降低请求的最大延迟。</p>
<h4 id="1-6-1-既然-AOT-有那么多优点，为什么不全部使用-AOT-？"><a href="#1-6-1-既然-AOT-有那么多优点，为什么不全部使用-AOT-？" class="headerlink" title="1.6.1 既然 AOT 有那么多优点，为什么不全部使用 AOT ？"></a>1.6.1 既然 AOT 有那么多优点，为什么不全部使用 AOT ？</h4><p>JIT 和 AOT 各有优点， AOT 更适合云原生场景，对微服务架构的支持也比较友好。除此之外， AOT 编译无法支持 Java 的一些动态特性，如反射、动态代理、动态加载、 JNI ( <em>Java Native Interface</em> ) 等。然而，很多框架和库（如 <em>Spring</em> 、 <em>CGLIB</em> ）都用到了这些特性。如果只使用 AOT 编译，那就无法使用这些库和框架了，或者说需要针对性地去做适配和优化。</p>
<h3 id="1-7-Oracle-JDK-和-OpenJDK"><a href="#1-7-Oracle-JDK-和-OpenJDK" class="headerlink" title="1.7 Oracle JDK 和 OpenJDK"></a>1.7 Oracle JDK 和 OpenJDK</h3><p>Oracle 官方在 2012 年的博客：</p>
<blockquote>
<p>问：OpenJDK 存储库中的源代码与用于构建 Oracle JDK 的代码之间有什么区别？<br>答：非常接近 - 我们的 Oracle JDK 版本构建过程基于 OpenJDK 7 构建，只添加了几个部分，例如部署代码，其中包括 Oracle 的 Java 插件和 Java WebStart 的实现，以及一些闭源的第三方组件，如图形光栅化器，一些开源的第三方组件，如 Rhino，以及一些零碎的东西，如附加文档或第三方字体。展望未来，我们的目的是开源 Oracle JDK 的所有部分，除了我们考虑商业功能的部分。</p>
</blockquote>
<p>OracleJDK 和 OpenJDK 的区别：</p>
<ol>
<li><p>是否开源： OpenJDK 是一个完全开源的参考模型，而 Oracle JDK 是基于 OpenJDK 实现的，并非完全开源。OpenJDK 开源项目：<a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk">Github</a> 。</p>
</li>
<li><p>是否免费： OracleJDK 提供免费版本，但一般有时间限制。 JDK17 之后的版本可以免费分发和商用，但仅有 3 年时间， 3 年后无法免费商用。不过，JDK8u221 之前只要不升级可以无限期免费。 OpenJDK 是完全免费的。</p>
</li>
<li><p>功能性： OracleJDK 在 OpenJDK 的基础上添加了一些特有的功能和工具，比如 <em>Java Flight Recorder ( JFR ， 一种监控工具 )</em> 、 <em>Java Mission Control ( JMC ，一种监控工具 )</em> 等工具。不过，在 Java 11 之后， OracleJDK 和 OpenJDK 的功能基本一致，之前 OracleJDK 中的私有组件大部分也已经被捐赠给开源组织。</p>
</li>
<li><p>稳定性： OpenJDK 不提供 LTS 服务， 而 OracleJDK 大概每三年都会推出一个 LTS 版本进行长期支持。不过，很多公司都基于 OpenJDK 提供了对应的和 OracleJDK 周期相同的 LTS 版本。因此，两者的稳定性其实差不多。</p>
</li>
<li><p>协议： OracleJDK 使用 BCL&#x2F;OTN 协议， 而 OpenJDK 根据 GPLv2 许可获得许可。</p>
</li>
</ol>
<blockquote>
<p>既然 Oracle JDK 这么好，那为什么还要有 OpenJDK？</p>
<ol>
<li>OpenJDK 是开源的，开源意味着你可以对它根据你自己的需要进行修改、优化，比如 Alibaba 基于 OpenJDK 开发了 <a target="_blank" rel="noopener" href="https://github.com/alibaba/dragonwell8">Dragonwell8</a>。</li>
<li>OpenJDK 是商业免费的（这也是为什么通过 yum 包管理器上默认安装的 JDK 是 OpenJDK 而不是 Oracle JDK）。虽然 Oracle JDK 也是商业免费（比如 JDK 8），但并不是所有版本都是免费的。</li>
<li>OpenJDK 更新频率更快。Oracle JDK 一般是每 6 个月发布一个新版本，而 OpenJDK 一般是每 3 个月发布一个新版本。（现在你知道为啥 Oracle JDK 更稳定了吧，先在 OpenJDK 试试水，把大部分问题都解决掉了才在 Oracle JDK 上发布）</li>
</ol>
</blockquote>
<h4 id="1-7-1-Oracle-JDK-和-OpenJDK-如何选择？"><a href="#1-7-1-Oracle-JDK-和-OpenJDK-如何选择？" class="headerlink" title="1.7.1 Oracle JDK 和 OpenJDK 如何选择？"></a>1.7.1 Oracle JDK 和 OpenJDK 如何选择？</h4><p>建议选择 OpenJDK 或者基于 OpenJDK 的发行版，比如 AWS 的 Amazon Corretto，阿里巴巴的 Alibaba Dragonwell。</p>
<h3 id="1-8-C-和-Java-的区别？"><a href="#1-8-C-和-Java-的区别？" class="headerlink" title="1.8 C++ 和 Java 的区别？"></a>1.8 C++ 和 Java 的区别？</h3><p>虽然 Java 和 C++ 都是面向对象的语言，但是它们有挺多不同的地方：</p>
<ul>
<li>Java 不提供指针直接访问内存，程序内存更安全。</li>
<li>Java 是单继承的， C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以。</li>
<li>Java 有自动内存管理垃圾回收机制（GC），不需要程序员手动释放无用内存。</li>
<li>C++ 同时支持方法重载和操作符重载， Java 只支持方法重载（操作符重载增加了复杂性）。</li>
</ul>
<h2 id="2-基本语法"><a href="#2-基本语法" class="headerlink" title="2. 基本语法"></a>2. 基本语法</h2><h3 id="2-1-注释有哪几种形式？"><a href="#2-1-注释有哪几种形式？" class="headerlink" title="2.1 注释有哪几种形式？"></a>2.1 注释有哪几种形式？</h3><ol>
<li>单行注释</li>
<li>多行注释</li>
<li>文档注释</li>
</ol>
<p>用得较多的是<strong>单行注释和文档注释</strong>，多行注释在开发中使用的相对较少。</p>
<blockquote>
<p><strong>代码的注释不是越详细越好。实际上好的代码本身就是注释，我们要尽量规范和美化自己的代码来减少不必要的注释。</strong><br><strong>若编程语言足够有表达力，就不需要注释，尽量通过代码来阐述。</strong><br>例子：<br>去掉下面复杂的注释，只需要创建一个与注释所言同一事物的函数即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// check to see if the employee is eligible for full benefits</span></span><br><span class="line"><span class="keyword">if</span> ((employee.flags &amp; HOURLY_FLAG) &amp;&amp; (employee.age &gt; <span class="number">65</span>))</span><br></pre></td></tr></table></figure>

<p>应替换为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (employee.isEligibleForFullBenefits())</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="2-2-标识符和关键字的区别是什么？"><a href="#2-2-标识符和关键字的区别是什么？" class="headerlink" title="2.2 标识符和关键字的区别是什么？"></a>2.2 标识符和关键字的区别是什么？</h3><p>简单来说，<strong>标识符就是一个名字</strong>。</p>
<p>有一些标识符， Java 语言已经赋予其特殊的含义，只能在特定的地方使用，这些标识符就是 <strong>关键字</strong> 。 简单来说， <strong>关键字就是被赋予特殊含义的标识符</strong>。</p>
<h4 id="2-2-1-Java-语言的关键字有哪些？"><a href="#2-2-1-Java-语言的关键字有哪些？" class="headerlink" title="2.2.1 Java 语言的关键字有哪些？"></a>2.2.1 Java 语言的关键字有哪些？</h4><table>
<thead>
<tr>
<th>分类</th>
<th>关键 字</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>访问控制</td>
<td>private</td>
<td>protected</td>
<td>public</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>类、方法和变量修饰符</td>
<td>abstract</td>
<td>class</td>
<td>extends</td>
<td>final</td>
<td>implements</td>
<td>interface</td>
<td>native</td>
</tr>
<tr>
<td></td>
<td>new</td>
<td>static</td>
<td>strictfp</td>
<td>synchronized</td>
<td>transient</td>
<td>volatile</td>
<td>enum</td>
</tr>
<tr>
<td>程序控制</td>
<td>break</td>
<td>continue</td>
<td>return</td>
<td>do</td>
<td>while</td>
<td>if</td>
<td>else</td>
</tr>
<tr>
<td></td>
<td>for</td>
<td>instanceof</td>
<td>switch</td>
<td>case</td>
<td>default</td>
<td>assert</td>
<td></td>
</tr>
<tr>
<td>错误处理</td>
<td>try</td>
<td>catch</td>
<td>throw</td>
<td>throws</td>
<td>finally</td>
<td></td>
<td></td>
</tr>
<tr>
<td>包相关</td>
<td>import</td>
<td>package</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>基本类型</td>
<td>boolean</td>
<td>byte</td>
<td>char</td>
<td>double</td>
<td>float</td>
<td>int</td>
<td>long</td>
</tr>
<tr>
<td></td>
<td>short</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>变量引用</td>
<td>super</td>
<td>this</td>
<td>void</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>保留字</td>
<td>goto</td>
<td>const</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>Tips: 所有的关键字都是小写的，在 IDE 中以特殊颜色显示<br><code>default</code> 这个关键字既属于程序控制，也属于类、方法和变量修饰符。</p>
<ul>
<li>在程序控制中，当在 <code>switch</code> 中匹配不到任何情况时，可以使用 <code>default</code> 编写默认匹配的情况。</li>
<li>在类、方法和变量修饰符中，从 JDK8 开始引入了默认方法，可以使用 <code>default</code> 关键字来定义一个方法的默认实现。</li>
<li>在访问控制中，如果一个方法前没有任何修饰符，则默认会有一个修饰符 <code>default</code> ，但是这个修饰符加上就会报错。</li>
</ul>
</blockquote>
<p><strong>注意</strong>： 虽然 <code>true</code> , <code>false</code> 和 <code>null</code> 看起来像关键字但实际上它们只是字面量，不可以作为标识符使用。</p>
<p>官方文档：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html">https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html</a></p>
<h3 id="2-3-自增自减运算符"><a href="#2-3-自增自减运算符" class="headerlink" title="2.3 自增自减运算符"></a>2.3 自增自减运算符</h3><p>Java 提供了自增 ( <code>++</code> ) 和自减 ( <code>--</code> ) 运算符来简化操作。</p>
<p><code>++</code> 和 <code>--</code> 运算符可以放在变量前后：</p>
<ul>
<li><strong>前缀</strong>： 先自增（减）变量的值，然后再使用该变量。</li>
<li><strong>后缀</strong>： 先使用该变量，再自增（减）。</li>
</ul>
<p>笔试题：</p>
<p>运行该代码后 <code>a</code> , <code>b</code> , <code>c</code> , <code>d</code> 和 <code>e</code> 分别为？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line"><span class="comment">// 1 --&gt; a = 9</span></span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a++;</span><br><span class="line"><span class="comment">// 2 --&gt; a = 10 , b = 9</span></span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ++a;</span><br><span class="line"><span class="comment">// 3 --&gt; a = 11 , b = 9 , c = 11</span></span><br><span class="line"><span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> c--;</span><br><span class="line"><span class="comment">// 4 --&gt; a = 11 , b = 9 , c = 10 , d = 11</span></span><br><span class="line"><span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> --d;</span><br><span class="line"><span class="comment">// 5 --&gt; a = 11 , b = 9 , c = 10 , d = 10 , e = 10</span></span><br></pre></td></tr></table></figure>

<p>答案： <code>a = 11</code> 、<code>b = 9</code> 、 <code>c = 10</code> 、 <code>d = 10</code> 、 <code>e = 10</code> 。具体过程看注释。</p>
<h3 id="2-3-移位运算符"><a href="#2-3-移位运算符" class="headerlink" title="2.3 移位运算符"></a>2.3 移位运算符</h3><p>移位运算符是最基本的运算符之一，几乎每种编程语言都包含这一运算符。移位操作中，被操作的数据被视为二进制数，移位就是将其向左或向右移动若干位的运算。</p>
<p>移位运算符在各种框架以及 JDK 自身的源码中使用还是挺广泛的，HashMap（JDK1.8） 中的 hash 方法的源码就用到了移位运算符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class="line">    <span class="comment">// ^：按位异或</span></span><br><span class="line">    <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用移位运算符的主要原因：</strong></p>
<ol>
<li><strong>高效</strong> ： 移位运算符直接对应处理器的移位指令，这些指令通常在一个时钟周期内完成。</li>
<li><strong>节省内存</strong> ： 通过移位操作可以使一个整数存储多个布尔值或标志位。</li>
</ol>
<p>移位运算符最常用于快速乘以或除以 2 的幂次方。除此之外，它还在以下方面发挥着重要作用：</p>
<ul>
<li><strong>位字段管理</strong> ： 存储和操作多个布尔值。</li>
<li><strong>哈希算法和加密算法</strong> ： 通过移位和与、或等操作来混淆数据。</li>
<li><strong>数据压缩</strong> ： 如霍夫曼编码通过移位运算符可以快速处理和操作二进制数据，已生成紧凑的压缩格式。</li>
<li><strong>数据校验</strong> ： 如 CRC （循环冗余校验）通过移位和多项式除法生成和校验数据完整性。</li>
<li><strong>内存对齐</strong> ： 通过移位操作可以计算和调整数据的对齐地址。</li>
</ul>
<p>Java 中有三种移位运算符：</p>
<ul>
<li><code>&lt;&lt;</code> ： 左移运算符，向左移若干位，高位丢弃，低位补零，相当于乘 2^n（不溢出的情况下）。</li>
<li><code>&gt;&gt;</code> ： 带符号右移，高位补符号位，低位丢弃。相当于除 2^n 。</li>
<li><code>&gt;&gt;&gt;</code> ： 无符号右移，忽略符号位，空位补零。</li>
</ul>
<p>由于 <code>double</code> ， <code>float</code> 在二进制中的表现比较特殊，因此<strong>不能来进行移位操作</strong>。</p>
<p>移位操作符实际上支持的类型只有 <code>int</code> 和 <code>long</code> ，编译器在对 <code>short</code> 、 <code>byte</code> 、 <code>char</code> 类型进行移位前，都会<strong>将其转换为 <code>int</code> 类型再操作</strong>。</p>
<h4 id="2-3-1-如果移位的位数超过数值所占的位数会怎么样？"><a href="#2-3-1-如果移位的位数超过数值所占的位数会怎么样？" class="headerlink" title="2.3.1 如果移位的位数超过数值所占的位数会怎么样？"></a>2.3.1 如果移位的位数超过数值所占的位数会怎么样？</h4><p>当 int 类型左移&#x2F;右移位数大于等于 32 位操作时，会<strong>先求余（%）后再进行左移&#x2F;右移操作</strong>。也就是说<strong>左移&#x2F;右移 32 位相当于不进行移位操作（32%32&#x3D;0）</strong>，左移&#x2F;右移 42 位相当于左移&#x2F;右移 10 位（42%32&#x3D;10）。当 long 类型进行左移&#x2F;右移操作时，由于 long 对应的二进制是 64 位，因此求余操作的基数也变成了 64。</p>
<p>也就是说： <code>x&lt;&lt;42</code> 等同于 <code>x&lt;&lt;10</code> ， <code>x&gt;&gt;42</code> 等同于 <code>x&gt;&gt;10</code> ， <code>x &gt;&gt;&gt;42</code> 等同于 <code>x &gt;&gt;&gt; 10</code> 。</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;初始数据：&quot;</span> + i);</span><br><span class="line">System.out.println(<span class="string">&quot;初始数据对应的二进制字符串：&quot;</span> + Integer.toBinaryString(i));</span><br><span class="line">i &lt;&lt;= <span class="number">10</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;左移 10 位后的数据 &quot;</span> + i);</span><br><span class="line">System.out.println(<span class="string">&quot;左移 10 位后的数据对应的二进制字符 &quot;</span> + Integer.toBinaryString(i));</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">初始数据：-1</span><br><span class="line">初始数据对应的二进制字符串：11111111111111111111111111111111</span><br><span class="line">左移 10 位后的数据 -1024</span><br><span class="line">左移 10 位后的数据对应的二进制字符 11111111111111111111110000000000</span><br></pre></td></tr></table></figure>

<p>由于左移位数大于等于 32 位操作时，会先求余（%）后再进行左移操作，所以下面的代码左移 42 位相当于左移 10 位（42%32&#x3D;10），输出结果和前面的代码一样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;初始数据：&quot;</span> + i);</span><br><span class="line">System.out.println(<span class="string">&quot;初始数据对应的二进制字符串：&quot;</span> + Integer.toBinaryString(i));</span><br><span class="line">i &lt;&lt;= <span class="number">42</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;左移 10 位后的数据 &quot;</span> + i);</span><br><span class="line">System.out.println(<span class="string">&quot;左移 10 位后的数据对应的二进制字符 &quot;</span> + Integer.toBinaryString(i));</span><br></pre></td></tr></table></figure>

<p>右移运算符使用类似。</p>
<h3 id="2-4-continue-、-break-和-return-的区别是什么？"><a href="#2-4-continue-、-break-和-return-的区别是什么？" class="headerlink" title="2.4 continue 、 break 和 return 的区别是什么？"></a>2.4 continue 、 break 和 return 的区别是什么？</h3><ol>
<li><code>continue</code> ：跳出当前一次的循环，继续下一次循环。</li>
<li><code>break</code> ： 跳出整个循环体。</li>
</ol>
<p><code>return</code> 用于跳出当前方法。一般用于：</p>
<ol>
<li><code>return</code> ： 直接结束方法执行，没有返回值。</li>
<li><code>return value</code> ： 返回一个特定值。</li>
</ol>
<p>思考：</p>
<p>下列语句的结果是什么？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 1 --&gt; i = 0 , f = f , sout 0</span></span><br><span class="line">            System.out.println(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            <span class="comment">// i++ sout xixi</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 2 --&gt; i = 1 , f = f , sout 1</span></span><br><span class="line">            System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            <span class="comment">// i++</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// 3 --&gt; i = 2 , f = f , sout 2</span></span><br><span class="line">            System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// i++ f = t sout xixi</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="comment">// 4 --&gt; i = 3 , f = t , sout 3</span></span><br><span class="line">            System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">            <span class="comment">//break</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">4</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;xixi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        <span class="comment">// 5 --&gt; sout haha</span></span><br><span class="line">        System.out.println(<span class="string">&quot;haha&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;heihei&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">xixi</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">xixi</span><br><span class="line">3</span><br><span class="line">haha</span><br></pre></td></tr></table></figure>

<h2 id="3-基本数据类型"><a href="#3-基本数据类型" class="headerlink" title="3. 基本数据类型"></a>3. 基本数据类型</h2><h3 id="3-1-Java-中的几种基本数据类型？"><a href="#3-1-Java-中的几种基本数据类型？" class="headerlink" title="3.1 Java 中的几种基本数据类型？"></a>3.1 Java 中的几种基本数据类型？</h3><ul>
<li>6 种数字类型<ul>
<li>4 种整数型： <code>byte</code> , <code>short</code> , <code>int</code> , <code>long</code></li>
<li>2 种浮点型： <code>float</code> , <code>double</code></li>
</ul>
</li>
<li>1 种字符型： <code>char</code></li>
<li>1 种布尔型： <code>boolean</code></li>
</ul>
<p>基本数据类型的默认值和所占空间：</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>位数</th>
<th>字节</th>
<th>默认值</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td><code>byte</code></td>
<td>8</td>
<td>1</td>
<td>0</td>
<td>-128 ~ 127</td>
</tr>
<tr>
<td><code>short</code></td>
<td>16</td>
<td>2</td>
<td>0</td>
<td>-2 ^ 15 ~ 2 ^ 15 - 1</td>
</tr>
<tr>
<td><code>int</code></td>
<td>32</td>
<td>4</td>
<td>0</td>
<td>-2 ^ 31 ~ 2 ^ 31 - 1</td>
</tr>
<tr>
<td><code>long</code></td>
<td>64</td>
<td>8</td>
<td>0L</td>
<td>-2 ^ 63 ~ 2 ^ 63 - 1</td>
</tr>
<tr>
<td><code>char</code></td>
<td>16</td>
<td>2</td>
<td>‘u0000’</td>
<td>0 ~ 2 ^ 16 - 1</td>
</tr>
<tr>
<td><code>float</code></td>
<td>32</td>
<td>4</td>
<td>0f</td>
<td>1.4 E -45 ~ 3.4028235 E 38</td>
</tr>
<tr>
<td><code>double</code></td>
<td>64</td>
<td>8</td>
<td>0d</td>
<td>4.9 E -324 ~ 1.7976931348623157 E 308</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td>1</td>
<td></td>
<td>false</td>
<td>true , false</td>
</tr>
</tbody></table>
<p>对于 <code>boolean</code> ，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。逻辑上理解是占用 1 位，但是实际中会考虑计算机高效存储因素。</p>
<p>Java 的每种基本类型所占存储空间的大小<strong>不会像其他大多数语言那样随机器硬件架构的变化而变化</strong>。这种所占存储空间大小的不变性是 Java 程序比用其他大多数语言编写的程序更具可移植性的原因之一。</p>
<p>注意：</p>
<ol>
<li>Java 里使用 <code>long</code> 类型的数据一定要加上 <strong>L</strong> ， 否则将作为整形解析。</li>
<li>Java 里使用 <code>float</code> 类型一定要加上 <strong>f 或 F</strong> ， 否则无法通过编译。</li>
<li><code>char = h</code> char 单引号 <code>String a = &quot;hello&quot;</code> String 双引号。</li>
</ol>
<p>这八种基本类型都有对应的包装类分别为： <code>Byte</code> 、 <code>Short</code> 、 <code>Integer</code> 、 <code>Long</code> 、 <code>Float</code> 、 <code>Double</code> 、 <code>Character</code> 、 <code>Boolean</code> 。</p>
<h3 id="3-2-基本类型和包装类型的区别？"><a href="#3-2-基本类型和包装类型的区别？" class="headerlink" title="3.2 基本类型和包装类型的区别？"></a>3.2 基本类型和包装类型的区别？</h3><ul>
<li><strong>用途</strong> ： 除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。并且，<strong>包装类型可用于泛型，而基本类型不可以</strong>。</li>
<li><strong>存储方式</strong> ： 基本数据类型的局部变量存放在 <strong>Java 虚拟机栈中的局部变量表</strong>中，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 <strong>Java 虚拟机的堆</strong>中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于<strong>堆</strong>中。</li>
<li><strong>占用空间</strong> ： 相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。</li>
<li><strong>默认值</strong> ： 成员变量包装类型不赋值就是 null ，而基本类型有默认值且不是 null。</li>
<li><strong>比较方式</strong> ： 对于基本数据类型来说，<code>==</code> 比较的是值。对于包装数据类型来说，<code>==</code> 比较的是<strong>对象的内存地址</strong>。所有整型包装类对象之间值的比较，<strong>全部使用 <code>equals()</code> 方法</strong>。</li>
</ul>
<p><strong>为什么说是几乎所有对象实例都存在于堆中呢？</strong></p>
<p>这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存</p>
<p><strong>注意：</strong></p>
<p>基本数据类型存放在栈中是一个常见的误区！ 基本数据类型的存储位置取决于它们的<strong>作用和声明方式</strong>。如果它们是<strong>局部变量</strong>，那么它们会存放在<strong>栈</strong>中；如果它们是<strong>成员变量</strong>，那么们会存放在<strong>堆&#x2F;方法区&#x2F;元空间</strong>中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="comment">// 成员变量，存放在堆中</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 被 static 修饰的成员变量，JDK 1.7 及之前位于方法区，1.8 后存放于元空间，均不存放于堆中。</span></span><br><span class="line">    <span class="comment">// 变量属于类，不属于对象。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 局部变量，存放在栈中</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">40</span>; <span class="comment">// 编译错误，不能在方法中使用 static 修饰局部变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-包装类型的缓存机制"><a href="#3-3-包装类型的缓存机制" class="headerlink" title="3.3 包装类型的缓存机制"></a>3.3 包装类型的缓存机制</h3><p><code>Byte</code> , <code>Short</code> , <code>Integer</code> , <code>Long</code> 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据， <code>Character</code> 创建了数值在 [0,127] 范围的缓存数据， <code>Boolean</code> 直接返回 <code>True</code> or <code>False</code> 。</p>
<p>Integer 缓存源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntegerCache</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Character 缓存源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Character <span class="title function_">valueOf</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c &lt;= <span class="number">127</span>) &#123; <span class="comment">// must cache</span></span><br><span class="line">      <span class="keyword">return</span> CharacterCache.cache[(<span class="type">int</span>)c];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Character</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CharacterCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">CharacterCache</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Character cache[] = <span class="keyword">new</span> <span class="title class_">Character</span>[<span class="number">127</span> + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cache.length; i++)</span><br><span class="line">            cache[i] = <span class="keyword">new</span> <span class="title class_">Character</span>((<span class="type">char</span>)i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Boolean 缓存源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title function_">valueOf</span><span class="params">(<span class="type">boolean</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (b ? TRUE : FALSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是<strong>在性能和资源之间的权衡</strong>。</p>
<p>两种浮点数类型的包装类<strong>没有实现缓存机制</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">33</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">33</span>;</span><br><span class="line">System.out.println(i1 == i2);<span class="comment">// 输出 true</span></span><br><span class="line"></span><br><span class="line"><span class="type">Float</span> <span class="variable">i11</span> <span class="operator">=</span> <span class="number">333f</span>;</span><br><span class="line"><span class="type">Float</span> <span class="variable">i22</span> <span class="operator">=</span> <span class="number">333f</span>;</span><br><span class="line">System.out.println(i11 == i22);<span class="comment">// 输出 false</span></span><br><span class="line"></span><br><span class="line"><span class="type">Double</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">1.2</span>;</span><br><span class="line"><span class="type">Double</span> <span class="variable">i4</span> <span class="operator">=</span> <span class="number">1.2</span>;</span><br><span class="line">System.out.println(i3 == i4);<span class="comment">// 输出 false</span></span><br></pre></td></tr></table></figure>

<p>问题：下面的代码的输出结果是 true 还是 false ？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">40</span>);</span><br><span class="line">System.out.println(i1==i2);</span><br></pre></td></tr></table></figure>

<p><code>Integer i1=40</code> 这一行代码会发生装箱，也就是说这行代码等价于 <code>Integer i1=Integer.valueOf(40)</code> 。因此， <code>i1</code> 直接使用的是缓存中的对象。而 <code>Integer i2 = new Integer(40)</code> 会直接创建新的对象。</p>
<p>因此，答案是 <code>false</code> 。</p>
<p><strong>所有整型包装类对象之间值的比较，全部使用 equals 方法比较。</strong></p>
<h3 id="3-4-自动装箱与自动拆箱？原理？"><a href="#3-4-自动装箱与自动拆箱？原理？" class="headerlink" title="3.4 自动装箱与自动拆箱？原理？"></a>3.4 自动装箱与自动拆箱？原理？</h3><p>自动拆装箱？</p>
<ul>
<li><strong>装箱</strong> ： 将基本类型用对应的引用类型包装起来。</li>
<li><strong>拆箱</strong> ： 将包装类型转换为基本数据类型。</li>
</ul>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;  <span class="comment">//装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i;   <span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure>

<p>字节码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">L1</span><br><span class="line"></span><br><span class="line"> LINENUMBER 8 L1</span><br><span class="line"></span><br><span class="line"> ALOAD 0</span><br><span class="line"></span><br><span class="line"> BIPUSH 10</span><br><span class="line"></span><br><span class="line"> INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;</span><br><span class="line"></span><br><span class="line"> PUTFIELD AutoBoxTest.i : Ljava/lang/Integer;</span><br><span class="line"></span><br><span class="line">L2</span><br><span class="line"></span><br><span class="line"> LINENUMBER 9 L2</span><br><span class="line"></span><br><span class="line"> ALOAD 0</span><br><span class="line"></span><br><span class="line"> ALOAD 0</span><br><span class="line"></span><br><span class="line"> GETFIELD AutoBoxTest.i : Ljava/lang/Integer;</span><br><span class="line"></span><br><span class="line"> INVOKEVIRTUAL java/lang/Integer.intValue ()I</span><br><span class="line"></span><br><span class="line"> PUTFIELD AutoBoxTest.n : I</span><br><span class="line"></span><br><span class="line"> RETURN</span><br></pre></td></tr></table></figure>

<p>从字节码中，可以发现装箱其实就是调用了包装类的 <code>valueOf()</code> 方法，拆箱其实就是调用了 <code>xxxValue()</code> 方法。</p>
<p>因此，</p>
<ul>
<li><code>Integer i = 10</code> 等价于 <code>Integer i = Integer.valueOf(10)</code></li>
<li><code>int n = i</code> 等价于 <code>int n = i.intValue()</code></li>
</ul>
<p>注意： <strong>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">sum</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 应该使用 long 而不是 Long</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= Integer.MAX_VALUE; i++)</span><br><span class="line">        sum += i;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-5-为什么浮点数运算会有精度丢失？"><a href="#3-5-为什么浮点数运算会有精度丢失？" class="headerlink" title="3.5 为什么浮点数运算会有精度丢失？"></a>3.5 为什么浮点数运算会有精度丢失？</h3><p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2.0f</span> - <span class="number">1.9f</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1.8f</span> - <span class="number">1.7f</span>;</span><br><span class="line">System.out.printf(<span class="string">&quot;%.9f&quot;</span>,a);<span class="comment">// 0.100000024</span></span><br><span class="line">System.out.println(b);<span class="comment">// 0.099999905</span></span><br><span class="line">System.out.println(a == b);<span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>精度丢失和计算机保存浮点数的机制有很大关系。计算机是二进制的，且计算机在保存一个数字时，宽度是有限的，无限循环的小数存储时只能被截断，所以会出现小数精度丢失的情况。</p>
<p>比如：<br>十进制下的 0.2 就没办法精确转化为二进制小数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0.2 转换为二进制数的过程为，不断乘以 2，直到不存在小数为止，</span></span><br><span class="line"><span class="comment">// 在这个计算过程中，得到的整数部分从上到下排列就是二进制的结果。</span></span><br><span class="line"><span class="number">0.2</span> * <span class="number">2</span> = <span class="number">0.4</span> -&gt; <span class="number">0</span></span><br><span class="line"><span class="number">0.4</span> * <span class="number">2</span> = <span class="number">0.8</span> -&gt; <span class="number">0</span></span><br><span class="line"><span class="number">0.8</span> * <span class="number">2</span> = <span class="number">1.6</span> -&gt; <span class="number">1</span></span><br><span class="line"><span class="number">0.6</span> * <span class="number">2</span> = <span class="number">1.2</span> -&gt; <span class="number">1</span></span><br><span class="line"><span class="number">0.2</span> * <span class="number">2</span> = <span class="number">0.4</span> -&gt; <span class="number">0</span>（发生循环）</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>关于浮点数，具体看 <a target="_blank" rel="noopener" href="http://kaito-kidd.com/2018/08/08/computer-system-float-point/">计算机系统基础</a> 这篇博客。</p>
<h3 id="3-6-如何解决浮点数运算精度丢失？"><a href="#3-6-如何解决浮点数运算精度丢失？" class="headerlink" title="3.6 如何解决浮点数运算精度丢失？"></a>3.6 如何解决浮点数运算精度丢失？</h3><p><code>BigDecimal</code> 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算的场景都是通过 <code>BigDecimal</code> 实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.00&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// BigDecimal 的 subtract 方法用于执行精确的减法运算。</span></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">x</span> <span class="operator">=</span> a.subtract(c);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">y</span> <span class="operator">=</span> b.subtract(c);</span><br><span class="line"></span><br><span class="line">System.out.println(x); <span class="comment">/* 0.2 */</span></span><br><span class="line">System.out.println(y); <span class="comment">/* 0.20 */</span></span><br><span class="line"><span class="comment">// 比较内容，不是比较值</span></span><br><span class="line">System.out.println(Objects.equals(x, y)); <span class="comment">/* false */</span></span><br><span class="line"><span class="comment">// 比较值相等用相等compareTo，相等返回0</span></span><br><span class="line">System.out.println(<span class="number">0</span> == x.compareTo(y)); <span class="comment">/* true */</span></span><br></pre></td></tr></table></figure>

<p><code>BigDecimal</code> 的详细介绍在 <a href="%E5%85%B6%E4%BB%96%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9.md">重要知识点</a> 里。</p>
<h3 id="3-7-超过-long-整型的数据如何表示？"><a href="#3-7-超过-long-整型的数据如何表示？" class="headerlink" title="3.7 超过 long 整型的数据如何表示？"></a>3.7 超过 <code>long</code> 整型的数据如何表示？</h3><p>在 Java 中，64 位 long 整型是最大的整数类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> Long.MAX_VALUE;</span><br><span class="line">System.out.println(l + <span class="number">1</span>); <span class="comment">// -9223372036854775808</span></span><br><span class="line">System.out.println(l + <span class="number">1</span> == Long.MIN_VALUE); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>BigInteger 内部使用 int[] 数组来存储任意大小的整形数据。</p>
<p>注意：</p>
<p>相对于常规整数类型的运算来说，BigInteger 运算的效率会相对较低。</p>
<h2 id="4-变量"><a href="#4-变量" class="headerlink" title="4. 变量"></a>4. 变量</h2><h3 id="4-1-成员变量与局部变量的区别？"><a href="#4-1-成员变量与局部变量的区别？" class="headerlink" title="4.1 成员变量与局部变量的区别？"></a>4.1 成员变量与局部变量的区别？</h3><ul>
<li><p><strong>语法形式</strong> ： 成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或参数；成员变量可以被 <code>public</code> , <code>private</code> , <code>static</code> 等修饰符修饰，而局部变量不能被访问控制修饰符及 <code>static</code> 修饰；但是成员变量和局部变量都能被 <code>final</code> 修饰。</p>
</li>
<li><p><strong>存储方式</strong> ： 如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有，这个成员变量是属于实例的。对象存储在堆内存，局部变量存储在栈内存。</p>
</li>
<li><p><strong>生存时间</strong> ： 成员变量是对象的一部分，随着对象的创建而存在，局部变量随方法的调用而自动生成，随方法的调用结束而消亡。</p>
</li>
<li><p><strong>默认值</strong> ： 成员变量如果没有被赋初值，则会自动以类型的默认值赋值（ 例外：被 <code>fianl</code> 修饰必须显式赋值 ），而局部变量不会自动赋值。</p>
</li>
</ul>
<h4 id="4-1-1-为什么成员变量有默认值？"><a href="#4-1-1-为什么成员变量有默认值？" class="headerlink" title="4.1.1 为什么成员变量有默认值？"></a>4.1.1 为什么成员变量有默认值？</h4><ol>
<li><p>如果没有默认值？ –&gt; 变量存储的是内存地址对应的任意随机值，程序读取该值运行会出现意外。</p>
</li>
<li><p>默认值有两种设置方式：手动和自动，根据第一点，没有手动赋值一定要自动赋值。成员变量在运行时可借助反射等方法手动赋值，而局部变量不行。</p>
</li>
<li><p>对于编译器（ javac ）来说，局部变量没赋值很好判断，可以直接报错。而成员变量可能是运行时赋值，无法判断，误报“没默认值”又会影响用户体验，所以采用自动赋默认值。</p>
</li>
</ol>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VariableExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员变量</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法中的局部变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 栈中分配的局部变量</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello, world!&quot;</span>; <span class="comment">// 栈中分配的局部变量</span></span><br><span class="line">        System.out.println(num1);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带参数的方法中的局部变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(<span class="type">int</span> num2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> num2 + <span class="number">10</span>; <span class="comment">// 栈中分配的局部变量</span></span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法中的局部变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">VariableExample</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name; <span class="comment">// 对成员变量进行赋值</span></span><br><span class="line">        <span class="built_in">this</span>.age = age; <span class="comment">// 对成员变量进行赋值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num3</span> <span class="operator">=</span> <span class="number">20</span>; <span class="comment">// 栈中分配的局部变量</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;Hello, &quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot;!&quot;</span>; <span class="comment">// 栈中分配的局部变量</span></span><br><span class="line">        System.out.println(num3);</span><br><span class="line">        System.out.println(str2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-静态变量有什么用？"><a href="#4-2-静态变量有什么用？" class="headerlink" title="4.2 静态变量有什么用？"></a>4.2 静态变量有什么用？</h3><p>静态变量也就是被 static 关键字修饰的变量。它可以被类的所有实例共享，无论一个类创建了多少个对象，它们都共享同一份静态变量。静态变量只会被分配一次内存，即使创建多个对象，这样可以节省内存。</p>
<p>通常情况下，静态变量会被 <code>final</code> 关键字<strong>修饰成为常量</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConstantVariableExample</span> &#123;</span><br><span class="line">    <span class="comment">// 常量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">constantVar</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-字符型常量和字符串型常量的区别？"><a href="#4-3-字符型常量和字符串型常量的区别？" class="headerlink" title="4.3 字符型常量和字符串型常量的区别？"></a>4.3 字符型常量和字符串型常量的区别？</h3><ul>
<li><p><strong>形式</strong> ： 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符。</p>
</li>
<li><p><strong>含义</strong> ： 字符常量相当于<strong>一个整型值 ( ASCII 值)</strong> ,可以参加表达式运算; 字符串常量代表<strong>一个地址值</strong> ( 该字符串在内存中存放位置 ) 。</p>
</li>
<li><p><strong>占内存大小</strong> ： 字符常量只占 2 个字节; 字符串常量占若干个字节。</p>
</li>
</ul>
<p>注意： <code>char</code> 在 Java 中占<strong>两个字节</strong>。</p>
<h2 id="5-方法"><a href="#5-方法" class="headerlink" title="5. 方法"></a>5. 方法</h2><h3 id="5-1-什么是方法的返回值？-方法有哪几种类型？"><a href="#5-1-什么是方法的返回值？-方法有哪几种类型？" class="headerlink" title="5.1 什么是方法的返回值？ 方法有哪几种类型？"></a>5.1 什么是方法的返回值？ 方法有哪几种类型？</h3><p><strong>方法的返回值</strong> 是指获取到的某个方法体执行后产生的结果。</p>
<p>可以按照方法的返回值和参数类型分类：</p>
<ol>
<li><p>无参数无返回值方法</p>
</li>
<li><p>有参数无返回值的方法</p>
</li>
<li><p>有返回值无参数的方法</p>
</li>
<li><p>有返回值有参数的方法</p>
</li>
</ol>
<h3 id="5-2-静态方法为什么不能调用非静态成员？"><a href="#5-2-静态方法为什么不能调用非静态成员？" class="headerlink" title="5.2 静态方法为什么不能调用非静态成员？"></a>5.2 静态方法为什么不能调用非静态成员？</h3><p>需要结合 JVM 的相关知识，主要原因如下：</p>
<ol>
<li><p>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</p>
</li>
<li><p>在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</p>
</li>
</ol>
<h3 id="5-3-静态方法和实例方法有何不同？"><a href="#5-3-静态方法和实例方法有何不同？" class="headerlink" title="5.3 静态方法和实例方法有何不同？"></a>5.3 静态方法和实例方法有何不同？</h3><ol>
<li><p><strong>调用方式</strong> ：<br>在外部调用静态方法时，可以使用 <code>类名.方法名</code> 的方式，也可以使用 <code>对象.方法名</code> 的方式，而实例方法只有后面这种方式。也就是说，<strong>调用静态方法可以无需创建对象</strong>。<br>不过，需要注意的是一般<strong>不建议使用 <code>对象.方法名</code> 的方式来调用静态方法</strong>。这种方式非常容易造成混淆，静态方法不属于类的某个对象而是属于这个类。<br>因此，一般建议使用 <code>类名.方法名</code> 的方式来调用静态方法。</p>
</li>
<li><p><strong>访问类成员是否存在限制</strong> ：<br>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。</p>
</li>
</ol>
<h3 id="5-4-重载和重写有什么区别？"><a href="#5-4-重载和重写有什么区别？" class="headerlink" title="5.4 重载和重写有什么区别？"></a>5.4 重载和重写有什么区别？</h3><blockquote>
<p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理<br>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，就要覆盖父类方法</p>
</blockquote>
<h4 id="5-4-1-重载"><a href="#5-4-1-重载" class="headerlink" title="5.4.1 重载"></a>5.4.1 重载</h4><p>发生在同一个类中（或者父类和子类之间），方法名<strong>必须相同</strong>，<strong>参数类型不同、个数不同、顺序不同</strong>，方法返回值和访问修饰符<strong>可以不同</strong>。</p>
<p>综上：重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</p>
<h4 id="5-4-2-重写"><a href="#5-4-2-重写" class="headerlink" title="5.4.2 重写"></a>5.4.2 重写</h4><p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p>
<ol>
<li><p><strong>方法名、参数列表必须相同</strong>，子类方法返回值类型应比父类方法返回值类型<strong>更小或相等</strong>，抛出的异常范围<strong>小于等于父类</strong>，访问修饰符范围<strong>大于等于父类</strong>。</p>
</li>
<li><p>如果父类方法访问修饰符为 <code>private</code> &#x2F; <code>final</code> &#x2F; <code>static</code> 则子类就不能重写该方法，但是被 <code>static</code> 修饰的方法能够被再次声明。</p>
</li>
<li><p>构造方法无法被重写</p>
</li>
</ol>
<h4 id="5-4-3-总结"><a href="#5-4-3-总结" class="headerlink" title="5.4.3 总结"></a>5.4.3 总结</h4><p>综上：<strong>重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。</strong></p>
<table>
<thead>
<tr>
<th>区别点</th>
<th>重载</th>
<th>重写</th>
</tr>
</thead>
<tbody><tr>
<td>发生范围</td>
<td>同一个类</td>
<td>子类</td>
</tr>
<tr>
<td>参数列表</td>
<td>必须修改</td>
<td>一定不能改</td>
</tr>
<tr>
<td>返回类型</td>
<td>可修改</td>
<td>比父类方法返回值类型更小或相等</td>
</tr>
<tr>
<td>异常</td>
<td>可修改</td>
<td>比父类方法声明抛出的异常类更小或相等</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>可修改</td>
<td>一定不能做更严格的限制（可以降低限制）</td>
</tr>
<tr>
<td>发生阶段</td>
<td>编译期</td>
<td>运行期</td>
</tr>
</tbody></table>
<p>补充： 如果方法的返回类型是 <strong><code>void</code> 和基本数据类型</strong>，则返回值重写时<strong>不可修改</strong>。但是如果方法的返回值是<strong>引用类型</strong>，重写时是<strong>可以返回该引用类型的子类</strong>的。</p>
<h3 id="5-5-什么是可变长参数？"><a href="#5-5-什么是可变长参数？" class="headerlink" title="5.5 什么是可变长参数？"></a>5.5 什么是可变长参数？</h3><p>从 Java5 开始，Java 支持定义可变长参数，可变长参数就是允许在调用方法时传入不定长度的参数。就比如下面这个方法就可以接受 0 个或者多个参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(String... args)</span> &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>可变参数<strong>只能作为函数的最后一个参数</strong>，但其前面可以有也<strong>可以没有任何其他参数</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(String arg1, String... args)</span> &#123; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-5-1-遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？"><a href="#5-5-1-遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？" class="headerlink" title="5.5.1 遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？"></a>5.5.1 遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？</h4><p>会优先匹配固定参数的方法，因为固定参数的方法匹配度更高。</p>
<p>Java 的可变参数编译后实际会被转换成一个数组，看编译后生成的 class 文件就可以看出来了。</p>
<h2 id="NEXT"><a href="#NEXT" class="headerlink" title="NEXT"></a>NEXT</h2><p><a href="JavaSE%20pt.2.md">JavaSE pt.2</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-03-10T13:55:29.000Z" title="2025/3/10 21:55:29">2025-03-10</time>发表</span><span class="level-item"><time dateTime="2025-04-22T14:17:14.345Z" title="2025/4/22 22:17:14">2025-04-22</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%85%AB%E8%82%A1/">八股</a><span> / </span><a class="link-muted" href="/categories/%E5%85%AB%E8%82%A1/JavaSE/">JavaSE</a></span><span class="level-item">1 小时读完 (大约10564个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/03/10/%E5%85%AB%E8%82%A1/Java/Java%E5%9F%BA%E7%A1%80/%E5%85%B6%E4%BB%96%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/">重要知识点</a></p><div class="content"><h2 id="1-Java-值传递"><a href="#1-Java-值传递" class="headerlink" title="1. Java 值传递"></a>1. Java 值传递</h2><h3 id="形参-实参"><a href="#形参-实参" class="headerlink" title="形参 &amp; 实参"></a>形参 &amp; 实参</h3><p>方法的定义可能会用到<strong>参数</strong> ， 参数在程序语言中分为：</p>
<ul>
<li><strong>实参</strong> （ 实际参数， Arguments ） ： 用于传递给函数 &#x2F; 方法的参数， 必须有确定的值。</li>
<li><strong>形参</strong> （ 形式参数， Paraments ） ： 用于定义函数 &#x2F; 方法，接收实参，不需要有确定的值。</li>
</ul>
<h3 id="值引用-引用传递"><a href="#值引用-引用传递" class="headerlink" title="值引用 &amp; 引用传递"></a>值引用 &amp; 引用传递</h3><ul>
<li><strong>值引用</strong> ： 方法接收的是实参的拷贝，会创建副本</li>
<li><strong>引用传递</strong> ： 方法接收的是实参所引用的对象在堆中的地址，不会创建副本， 对形参的修改将影响到实参。</li>
</ul>
<p>很多语言提供了两种参数传递的方法， 不过<strong>在 Java 中只有值传递</strong></p>
<h3 id="为什么-Java-中只有值传递"><a href="#为什么-Java-中只有值传递" class="headerlink" title="为什么 Java 中只有值传递"></a>为什么 Java 中只有值传递</h3><p>例子 1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    swap(num1, num2);</span><br><span class="line">    System.out.println(<span class="string">&quot;num1 = &quot;</span> + num1);</span><br><span class="line">    System.out.println(<span class="string">&quot;num2 = &quot;</span> + num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">    System.out.println(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">    System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>output:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = 20</span><br><span class="line">b = 10</span><br><span class="line">num1 = 10</span><br><span class="line">num2 = 20</span><br></pre></td></tr></table></figure>

<p>解析：</p>
<p>在 <code>swap()</code> 方法中，a、b 的值进行交换，并不会影响到 num1、num2。因为，a、b 的值，只是从 num1、num2 的复制过来的。也就是说，a、b 相当于 num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身</p>
<p><img src="/./asserts/others/001.png" alt="swap"></p>
<p>通过上面例子，可以知道了一个方法不能修改一个基本数据类型的参数。</p>
<p>例子 2：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    change(arr);</span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">    <span class="comment">// 将数组的第一个元素变为0</span></span><br><span class="line">    array[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>output:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>解析：</p>
<p><img src="/./asserts/others/002.png" alt="change"></p>
<p>这里传递的还是值，不过，这个<strong>值是实参的地址</strong>。</p>
<p>也就是说 <code>change</code> 方法的参数拷贝的是 <code>arr</code> （实参）的地址，因此，它和 <code>arr</code> 指向的是同一个数组对象。这也就说明了为什么方法内部对形参的修改会影响到实参。</p>
<p>例子 3：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="comment">// 省略构造函数、Getter&amp;Setter方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">xiaoZhang</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小张&quot;</span>);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">xiaoLi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小李&quot;</span>);</span><br><span class="line">    swap(xiaoZhang, xiaoLi);</span><br><span class="line">    System.out.println(<span class="string">&quot;xiaoZhang:&quot;</span> + xiaoZhang.getName());</span><br><span class="line">    System.out.println(<span class="string">&quot;xiaoLi:&quot;</span> + xiaoLi.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(Person person1, Person person2)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">temp</span> <span class="operator">=</span> person1;</span><br><span class="line">    person1 = person2;</span><br><span class="line">    person2 = temp;</span><br><span class="line">    System.out.println(<span class="string">&quot;person1:&quot;</span> + person1.getName());</span><br><span class="line">    System.out.println(<span class="string">&quot;person2:&quot;</span> + person2.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>output:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">person1:小李</span><br><span class="line">person2:小张</span><br><span class="line">xiaoZhang:小张</span><br><span class="line">xiaoLi:小李</span><br></pre></td></tr></table></figure>

<p>解析：</p>
<p><code>swap</code> 方法的参数 <code>person1</code> 和 <code>person2</code> 只是<strong>拷贝的实参 <code>xiaoZhang</code> 和 <code>xiaoLi</code> 的地址</strong>。因此， <code>person1</code> 和 <code>person2</code> 的互换只是拷贝的两个地址的互换罢了，并不会影响到实参 <code>xiaoZhang</code> 和 <code>xiaoLi</code> 。</p>
<p><img src="/./asserts/others/003.png" alt="swap"></p>
<h3 id="引用传递是什么样的"><a href="#引用传递是什么样的" class="headerlink" title="引用传递是什么样的"></a>引用传递是什么样的</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">incr</span><span class="params">(<span class="type">int</span>&amp; num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;incr before: &quot;</span> &lt;&lt; num &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    num++;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;incr after: &quot;</span> &lt;&lt; num &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> age = <span class="number">10</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;invoke before: &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="built_in">incr</span>(age);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;invoke after: &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>output:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">invoke before: 10</span><br><span class="line">incr before: 10</span><br><span class="line">incr after: 11</span><br><span class="line">invoke after: 11</span><br></pre></td></tr></table></figure>

<p>可以看到，在 <code>incr</code> 函数中对形参的修改，<strong>可以影响到实参的值</strong>。要注意：这里的 <code>incr</code> 形参的数据类型用的是 <code>int&amp;</code> 才为引用传递，如果是用 <code>int</code> 的话还是值传递！</p>
<h3 id="Java-为什么不引入引用传递？"><a href="#Java-为什么不引入引用传递？" class="headerlink" title="Java 为什么不引入引用传递？"></a>Java 为什么不引入引用传递？</h3><ol>
<li>出于安全考虑，方法内部对值进行的操作，对于调用者都是未知的（把方法定义为接口，调用方不关心具体实现）。你也想象一下，如果拿着银行卡去取钱，取的是 100，扣的是 200，是不是很可怕。</li>
<li>Java 之父 James Gosling 在设计之初就看到了 C、C++ 的许多弊端，所以才想着去设计一门新的语言 Java。在他设计 Java 的时候就遵循了简单易用的原则，摒弃了许多开发者一不留意就会造成问题的“特性”，语言本身的东西少了，开发者要学习的东西也少了。</li>
</ol>
<h3 id="值传递总结"><a href="#值传递总结" class="headerlink" title="值传递总结"></a>值传递总结</h3><p>Java 中将实参传递给方法（或函数）的方式是 <strong>值传递</strong>：</p>
<ul>
<li>如果参数是基本类型的话，很简单，传递的就是基本类型的字面量值的拷贝，会创建副本。</li>
<li>如果参数是引用类型，传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本。</li>
</ul>
<h2 id="2-Java-序列化"><a href="#2-Java-序列化" class="headerlink" title="2. Java 序列化"></a>2. Java 序列化</h2><h3 id="什么是序列化与反序列化"><a href="#什么是序列化与反序列化" class="headerlink" title="什么是序列化与反序列化"></a>什么是序列化与反序列化</h3><ul>
<li><p><strong>序列化</strong> ： 将数据或对象转换成可以存储或传输的形式 （通常是二进制字节流， 也可以是 JSON 、 XML 等文本格式）</p>
</li>
<li><p><strong>反序列化</strong> ：将序列化过程中生成的数据转换为原始数据结构或对象的过程。</p>
</li>
</ul>
<p>常见应用场景：</p>
<ul>
<li><p>对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；</p>
</li>
<li><p>将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；</p>
</li>
<li><p>将对象存储到数据库（如 Redis）之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；</p>
</li>
<li><p>将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。</p>
</li>
</ul>
<h4 id="序列化协议对应-TCP-IP-4-层模型的哪一层？"><a href="#序列化协议对应-TCP-IP-4-层模型的哪一层？" class="headerlink" title="序列化协议对应 TCP&#x2F;IP 4 层模型的哪一层？"></a>序列化协议对应 TCP&#x2F;IP 4 层模型的哪一层？</h4><p><img src="/./asserts/JavaSE%20pt%203/02.png" alt="OSI 七层协议"></p>
<p>如上图所示，OSI 七层协议模型中，表示层做的事情主要就是对应用层的用户数据进行处理转换为二进制流。反过来的话，就是将二进制流转换成应用层的用户数据。</p>
<p>OSI 七层协议模型中的应用层、表示层和会话层对应的都是 TCP&#x2F;IP 四层模型中的应用层，所以序列化协议属于 TCP&#x2F;IP 协议应用层的一部分。</p>
<h3 id="常见的序列化协议"><a href="#常见的序列化协议" class="headerlink" title="常见的序列化协议"></a>常见的序列化协议</h3><p>JDK 自带的序列化方式一般不会用 ，因为序列化效率低并且存在安全问题。比较常用的序列化协议有 Hessian、Kryo、Protobuf、ProtoStuff，这些都是基于二进制的序列化协议。</p>
<p>像 JSON 和 XML 这种属于文本类序列化方式。虽然可读性比较好，但是性能较差，一般不会选择。</p>
<h4 id="JDK-自带的序列化"><a href="#JDK-自带的序列化" class="headerlink" title="JDK 自带的序列化"></a>JDK 自带的序列化</h4><p>JDK 自带的序列化，只需实现 <code>java.io.Serializable</code> 接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcRequest</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1905122041950251207L</span>;</span><br><span class="line">    <span class="keyword">private</span> String requestId;</span><br><span class="line">    <span class="keyword">private</span> String interfaceName;</span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line">    <span class="keyword">private</span> Object[] parameters;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[] paramTypes;</span><br><span class="line">    <span class="keyword">private</span> RpcMessageTypeEnum rpcMessageTypeEnum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="serialVersionUID-有什么用"><a href="#serialVersionUID-有什么用" class="headerlink" title="serialVersionUID 有什么用"></a>serialVersionUID 有什么用</h5><p>序列化号 <code>serialVersionUID</code> 属于版本控制的作用。反序列化时，会检查 <code>serialVersionUID</code> 是否和当前类的 <code>serialVersionUID</code> 一致。如果 <code>serialVersionUID</code> 不一致则会抛出 <code>InvalidClassException</code> 异常。强烈推荐每个序列化类都手动指定其 <code>serialVersionUID</code> ，如果不手动指定，那么编译器会动态生成默认的 <code>serialVersionUID</code> 。</p>
<h5 id="serialVersionUID-不是被-static-变量修饰了吗？为什么还会被“序列化”？"><a href="#serialVersionUID-不是被-static-变量修饰了吗？为什么还会被“序列化”？" class="headerlink" title="serialVersionUID 不是被 static 变量修饰了吗？为什么还会被“序列化”？"></a>serialVersionUID 不是被 static 变量修饰了吗？为什么还会被“序列化”？</h5><p><code>static</code> 修饰的变量是静态变量，属于类而非类的实例，本身是不会被序列化的。然而， <code>serialVersionUID</code> 是一个特例， <code>serialVersionUID</code> 的序列化做了特殊处理。当一个对象被序列化时， <code>serialVersionUID</code> 会被写入到序列化的二进制流中；在反序列化时，也会解析它并做一致性判断，以此来验证序列化对象的版本一致性。如果两者不匹配，反序列化过程将抛出 <code>InvalidClassException</code> ，因为这通常意味着序列化的类的定义已经发生了更改，可能不再兼容。</p>
<p>官方说明：</p>
<blockquote>
<p>A serializable class can declare its own serialVersionUID explicitly by declaring a field named “<code>serialVersionUID</code>“ that must be <code>static</code>, <code>final</code>, and of type <code>long</code>;<br>如果想显式指定 serialVersionUID ，则需要在类中使用 <code>static</code> 和 final 关键字来修饰一个 <code>long</code> 类型的变量，变量名字必须为 “<code>serialVersionUID</code>“ 。</p>
</blockquote>
<h5 id="如果有些字段不想序列化怎么办？"><a href="#如果有些字段不想序列化怎么办？" class="headerlink" title="如果有些字段不想序列化怎么办？"></a>如果有些字段不想序列化怎么办？</h5><p>对于不想进行序列化的变量，使用 <code>transient</code> 关键字修饰。</p>
<p><code>transient</code> 关键词的作用是： 阻止实例中使用此关键字的变量序列化；当对象被反序列化时，被 <code>transient</code> 修饰的关键字不会被持久化和恢复。</p>
<p>注意：</p>
<ul>
<li><code>transient</code> 只能修饰变量</li>
<li><code>transient</code> 修饰的变量，在反序列化后变量值会被设置成默认值。</li>
<li><code>static</code> 变量因为不属于任何对象，所以无论有没有 <code>transient</code> 修饰都不会被序列化。</li>
</ul>
<h5 id="什么不推荐-JDK-自带的序列化？"><a href="#什么不推荐-JDK-自带的序列化？" class="headerlink" title="什么不推荐 JDK 自带的序列化？"></a>什么不推荐 JDK 自带的序列化？</h5><ul>
<li><strong>不支持跨语言调用</strong></li>
<li><strong>性能差</strong> ： 相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。</li>
<li><strong>存在安全问题</strong> ： 序列化和反序列化本身并不存在问题。但当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码。</li>
</ul>
<h4 id="Kryo"><a href="#Kryo" class="headerlink" title="Kryo"></a>Kryo</h4><p>Kryo 是一个高性能的序列化&#x2F;反序列化工具，由于其变长存储特性并使用了字节码生成机制，拥有较高的运行速度和较小的字节码体积。</p>
<p>另外，Kryo 已经是一种非常成熟的序列化实现了，已经在 Twitter、Groupon、Yahoo 以及多个著名开源项目（如 Hive、Storm）中广泛的使用。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Snailclimb/guide-rpc-framework">guide-rpc-framework</a> 就是使用的 kryo 进行序列化，序列化和反序列化相关的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Kryo serialization class, Kryo serialization efficiency is very high, but only compatible with Java language</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shuang.kou</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2020年05月13日 19:29:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KryoSerializer</span> <span class="keyword">implements</span> <span class="title class_">Serializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Because Kryo is not thread safe. So, use ThreadLocal to store Kryo objects</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;Kryo&gt; kryoThreadLocal = ThreadLocal.withInitial(() -&gt; &#123;</span><br><span class="line">        <span class="type">Kryo</span> <span class="variable">kryo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Kryo</span>();</span><br><span class="line">        kryo.register(RpcResponse.class);</span><br><span class="line">        kryo.register(RpcRequest.class);</span><br><span class="line">        <span class="keyword">return</span> kryo;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] serialize(Object obj) &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">             <span class="type">Output</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Output</span>(byteArrayOutputStream)) &#123;</span><br><span class="line">            <span class="type">Kryo</span> <span class="variable">kryo</span> <span class="operator">=</span> kryoThreadLocal.get();</span><br><span class="line">            <span class="comment">// Object-&gt;byte:将对象序列化为byte数组</span></span><br><span class="line">            kryo.writeObject(output, obj);</span><br><span class="line">            kryoThreadLocal.remove();</span><br><span class="line">            <span class="keyword">return</span> output.toBytes();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializeException</span>(<span class="string">&quot;Serialization failed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(<span class="type">byte</span>[] bytes, Class&lt;T&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes);</span><br><span class="line">             <span class="type">Input</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Input</span>(byteArrayInputStream)) &#123;</span><br><span class="line">            <span class="type">Kryo</span> <span class="variable">kryo</span> <span class="operator">=</span> kryoThreadLocal.get();</span><br><span class="line">            <span class="comment">// byte-&gt;Object:从byte数组中反序列化出对象</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> kryo.readObject(input, clazz);</span><br><span class="line">            kryoThreadLocal.remove();</span><br><span class="line">            <span class="keyword">return</span> clazz.cast(o);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializeException</span>(<span class="string">&quot;Deserialization failed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h4><p>Protobuf 出自 Google，性能比较优秀，也支持多种语言，同时还是跨平台的。就是在使用中过于繁琐，因为你需要自己定义 IDL 文件和生成对应的序列化代码。这样虽然不灵活，但是，另一方面导致 protobuf 没有序列化漏洞的风险。</p>
<blockquote>
<p>Protobuf 包含序列化格式的定义、各种语言的库以及一个 IDL 编译器。正常情况下你需要定义 proto 文件，然后使用 IDL 编译器编译成你需要的语言</p>
</blockquote>
<p>一个简单的 proto 文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// protobuf的版本</span><br><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line">// SearchRequest会被编译成不同的编程语言的相应对象，比如Java中的class、Go中的struct</span><br><span class="line">message Person &#123;</span><br><span class="line">  //string类型字段</span><br><span class="line">  string name = 1;</span><br><span class="line">  // int 类型字段</span><br><span class="line">  int32 age = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ProtoStuff"><a href="#ProtoStuff" class="headerlink" title="ProtoStuff"></a>ProtoStuff</h4><p>由于 Protobuf 易用性较差， ProtoStuff 诞生了。</p>
<p>protostuff 基于 Google protobuf，但是提供了更多的功能和更简易的用法。虽然更加易用，但是不代表 ProtoStuff 性能更差。</p>
<h4 id="Hessian"><a href="#Hessian" class="headerlink" title="Hessian"></a>Hessian</h4><p>Hessian 是一个轻量级的，自定义描述的二进制 RPC 协议。Hessian 是一个比较老的序列化实现了，并且同样也是跨语言的。</p>
<p><img src="/./asserts/others/004.png" alt="dubbo"></p>
<p>Dubbo2.x 默认启用的序列化方式是 Hessian2 ,但是，Dubbo 对 Hessian2 进行了修改，不过大体结构还是差不多。</p>
<h3 id="序列化总结"><a href="#序列化总结" class="headerlink" title="序列化总结"></a>序列化总结</h3><p>Kryo 是专门针对 Java 语言序列化方式并且性能非常好，如果应用是专门针对 Java 语言的话可以考虑使用，并且 Dubbo 官网的一篇文章中提到说推荐使用 Kryo 作为生产环境的序列化方式。</p>
<p>像 Protobuf、 ProtoStuff、hessian 这类都是跨语言的序列化方式，如果有跨语言需求的话可以考虑使用。</p>
<p>除了上面介绍到的序列化方式，还有像 Thrift，Avro 这些。</p>
<h2 id="3-泛型-通配符"><a href="#3-泛型-通配符" class="headerlink" title="3. 泛型&amp;通配符"></a>3. 泛型&amp;通配符</h2><h2 id="4-反射"><a href="#4-反射" class="headerlink" title="4. 反射"></a>4. 反射</h2><h3 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h3><p>反射之所以被称为框架的灵魂，主要是因为它赋予了在运行时分析类以及执行类中方法的能力。</p>
<p>通过反射可以获取任意一个类的所有属性和方法，还可以调用这些方法和属性。</p>
<h3 id="反射的应用场景"><a href="#反射的应用场景" class="headerlink" title="反射的应用场景"></a>反射的应用场景</h3><p>像平时大部分时候都是在写业务代码，很少会接触到直接使用反射机制的场景。</p>
<p>但是，这并不代表反射没有用。相反，正是因为反射，你才能这么轻松地使用各种框架。像 Spring&#x2F;Spring Boot、MyBatis 等框架中都大量使用了反射机制。</p>
<p><strong>这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。</strong></p>
<p>例子（通过 JDK 实现动态代理）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DebugInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理类中的真实对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DebugInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before method &quot;</span> + method.getName());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;after method &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外， Java 中的一大利器 <strong>注解</strong> 的实现也用到了反射。</p>
<p>为什么使用 Spring 的时候 ，一个 <code>@Component</code> 注解就声明了一个类为 Spring Bean 呢？为什么你通过一个 <code>@Value</code> 注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？</p>
<p>这些都是因为你可以基于反射分析类，然后获取到类&#x2F;属性&#x2F;方法&#x2F;方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。</p>
<h3 id="反射的优缺点"><a href="#反射的优缺点" class="headerlink" title="反射的优缺点"></a>反射的优缺点</h3><p><strong>优点</strong> ： 使代码更灵活、为各种框架提供开箱即用的功能提供了便利。</p>
<p><strong>缺点</strong> ： 在运行时有了操作类的能力，增加了安全问题。如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也稍差（对于框架的实际影响不大）。</p>
<h3 id="反射实战"><a href="#反射实战" class="headerlink" title="反射实战"></a>反射实战</h3><h4 id="获取-Class-对象的四种方式"><a href="#获取-Class-对象的四种方式" class="headerlink" title="获取 Class 对象的四种方式"></a>获取 Class 对象的四种方式</h4><ol>
<li><p>知道具体类的情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">alunbarClass</span> <span class="operator">=</span> TargetObject.class;</span><br></pre></td></tr></table></figure>

<p>但是一般是不知道具体类的，基本都是通过遍历包下面的类来获取 Class 对象，通过此方法获取 Class 对象不会进行初始化。</p>
</li>
<li><p>通过 <code>Class.forName()</code> 传入类的全路径：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">alunbarClass1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;cn.javaguide.TargetObject&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过对象实例 <code>instance.getClass()</code> 获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TargetObject</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TargetObject</span>();</span><br><span class="line"><span class="type">Class</span> <span class="variable">alunbarClass2</span> <span class="operator">=</span> o.getClass();</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过类加载器 <code>xxxClassLoader.loadClass()</code> 传入类路径获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader.getSystemClassLoader().loadClass(<span class="string">&quot;cn.javaguide.TargetObject&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>通过类加载器获取 Class 对象不会进行初始化，意味着不进行包括初始化等一系列步骤，静态代码块和静态对象不会得到执行。</p>
</li>
</ol>
<h4 id="反射的一些基本操作"><a href="#反射的一些基本操作" class="headerlink" title="反射的一些基本操作"></a>反射的一些基本操作</h4><ol>
<li><p>创建一个要使用反射操作的类 <code>TargetObject</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TargetObject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TargetObject</span><span class="params">()</span> &#123;</span><br><span class="line">        value = <span class="string">&quot;JavaGuide&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publicMethod</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I love &quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">privateMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;value is &quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用反射操作这个类的方法和属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span>     ClassNotFoundException, NoSuchMethodException,     IllegalAccessException, InstantiationException,     InvocationTargetException, NoSuchFieldException &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取 TargetObject 类的 Class 对象并且创建     TargetObject 类实例</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Class&lt;?&gt; targetClass = Class.forName(<span class="string">&quot;cn.javaguide.TargetObject&quot;</span>);</span><br><span class="line">        <span class="type">TargetObject</span> <span class="variable">targetObject</span> <span class="operator">=</span> (TargetObject) targetClass.newInstance();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取 TargetObject 类中定义的所有方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Method[] methods = targetClass.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            System.out.println(method.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取指定方法并调用</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">publicMethod</span> <span class="operator">=</span> targetClass.getDeclaredMethod    (<span class="string">&quot;publicMethod&quot;</span>,</span><br><span class="line">                String.class);</span><br><span class="line"></span><br><span class="line">        publicMethod.invoke(targetObject, <span class="string">&quot;JavaGuide&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取指定参数并对参数进行修改</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> targetClass.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">        <span class="comment">//为了对类中的参数进行修改我们取消安全检查</span></span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(targetObject, <span class="string">&quot;JavaGuide&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用 private 方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">privateMethod</span> <span class="operator">=</span> targetClass.getDeclaredMethod    (<span class="string">&quot;privateMethod&quot;</span>);</span><br><span class="line">        <span class="comment">//为了调用private方法我们取消安全检查</span></span><br><span class="line">        privateMethod.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        privateMethod.invoke(targetObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>output:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">publicMethod</span><br><span class="line">privateMethod</span><br><span class="line">I love JavaGuide</span><br><span class="line">value is JavaGuide</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="5-代理模式"><a href="#5-代理模式" class="headerlink" title="5. 代理模式"></a>5. 代理模式</h2><h3 id="什么是代理模式"><a href="#什么是代理模式" class="headerlink" title="什么是代理模式"></a>什么是代理模式</h3><p>代理模式是一种比较好理解的设计模式。简单来说就是 <strong>使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</strong></p>
<p>代理模式的主要作用是<strong>扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。</strong></p>
<p>例子：新娘找来了自己的姨妈来代替自己处理新郎的提问，新娘收到的提问都是经过姨妈处理过滤之后的。姨妈在这里就可以看作是代理你的代理对象，代理的行为（方法）是接收和回复新郎的提问。</p>
<p>代理模式有静态代理和动态代理两种实现方式。</p>
<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>静态代理中，<strong>对目标的每个方法的增强都是手动完成的</strong>，非常不灵活（如：接口一旦新增加方法，目标对象和代理对象都要进行修改），且麻烦（需要对每个目标类都单独写一个代理类）。实际应用场景非常少，日常开发几乎看不到使用静态代理的场景。</p>
<p>以上是从实现和应用角度来说的，从 JVM 层面，<strong>静态代理在编译时就将接口、实现类、代理类都变成实际的 class 文件</strong>。</p>
<p>静态代理实现步骤：</p>
<ol>
<li>定义一个接口及其实现类；</li>
<li>创建一个代理类同样实现这个接口；</li>
<li>将目标对象注入进代理类， 然后在代理类的对应方法调用目标类的对应方法。这样就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。</li>
</ol>
<p>例子：</p>
<ol>
<li><p><strong>定义发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line">    String <span class="title function_">send</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>实现发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;send message:&quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>创建代理类并同样实现发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsProxy</span> <span class="keyword">implements</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SmsService smsService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SmsProxy</span><span class="params">(SmsService smsService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.smsService = smsService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before method send()&quot;</span>);</span><br><span class="line">        smsService.send(message);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after method send()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>实际使用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SmsService</span> <span class="variable">smsService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmsServiceImpl</span>();</span><br><span class="line">        <span class="type">SmsProxy</span> <span class="variable">smsProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmsProxy</span>(smsService);</span><br><span class="line">        smsProxy.send(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before method send()</span><br><span class="line">send message:java</span><br><span class="line">after method send()</span><br></pre></td></tr></table></figure>

<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>相比于静态代理来说，动态代理更加灵活。不需要针对每个目标类都单独创建一个代理类，并且也不需要必须实现接口，可以直接代理实现类( <em>CGLIB</em> 动态代理机制)。</p>
<p><strong>从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</strong></p>
<p>Spring AOP、RPC 框架的实现都依赖了动态代理。</p>
<p><strong>动态代理在日常开发中使用相对较少，但是在框架中几乎是必用的技术。学习动态代理后，对于理解和学习各种框架的原理很有帮助。</strong></p>
<p>就 Java 来说， 动态代理的实现方式有很多，如 <strong>JDK 动态代理、 GGLIB 动态代理</strong>等。</p>
<h4 id="JDK-动态代理机制"><a href="#JDK-动态代理机制" class="headerlink" title="JDK 动态代理机制"></a>JDK 动态代理机制</h4><h5 id="JDK-动态代理介绍"><a href="#JDK-动态代理介绍" class="headerlink" title="JDK 动态代理介绍"></a>JDK 动态代理介绍</h5><p>在 Java 动态代理机制中， <strong><code>InvocationHandler</code> 接口和 <code>Proxy</code> 类是核心。</strong></p>
<p><code>Proxy</code> 类中使用频率最高的方法是 <code>newProxyInstance()</code> ，这个方法主要用于生成一个代理对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span><br><span class="line"><span class="params">                                      Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="params">                                      InvocationHandler h)</span></span><br><span class="line">    <span class="keyword">throws</span> IllegalArgumentException</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法一共有 3 个参数：</p>
<ol>
<li><strong>loader</strong> ： 类加载器，用于加载代理对象。</li>
<li><strong>interfaces</strong> ： 被代理类实现的接口。</li>
<li><strong>h</strong> ： 实现了 <code>InvocationHandler</code> 接口的对象。</li>
</ol>
<p>要实现动态代理， 还必须实现 <code>InvocationHandler</code> 来自定义处理逻辑。当动态代理对象调用一个方法时，这个方法的调用就会被转发到实现 <code>InvocationHandler</code> 接口类的 <code>invoke</code> 方法来调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当你使用代理对象调用方法的时候实际会调用到这个方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>invoke()</code> 方法有三个参数：</p>
<ol>
<li><strong>Proxy</strong> ： 动态生成的代理类</li>
<li><strong>method</strong> ： 与代理类对象调用的方法相对应</li>
<li><strong>args</strong> ： 当前 method 方法的参数</li>
</ol>
<p>也就是说，<strong>通过 <code>Proxy</code> 类的 <code>newProxyInstance()</code> 创建的代理对象在调用方法时，实际会调用实现 <code>InvocationHandler</code> 接口的类的 <code>invoke()</code> 方法</strong>。可以在 <code>invoke()</code> 方法中自定义处理逻辑，如在方法执行前后做什么。</p>
<h5 id="JDK-动态代理类使用步骤"><a href="#JDK-动态代理类使用步骤" class="headerlink" title="JDK 动态代理类使用步骤"></a>JDK 动态代理类使用步骤</h5><ol>
<li>定义一个接口及其实现类；</li>
<li>自定义 <code>InvovationHandler</code> 并重写 <code>invoke</code> 方法， 在 <code>invoke</code> 方法中调用原生方法（被代理类的方法）并自定义一些处理逻辑；</li>
<li>通过 <code>Proxy.newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</code> 方法创建代理对象。</li>
</ol>
<h5 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h5><ol>
<li><p>定义发送短信的接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line">    String <span class="title function_">send</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现发送短信的接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;send message:&quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义一个 JDK 动态代理类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DebugInvocationHandler</span> <span class="keyword">implements</span>     <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理类中的真实对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DebugInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[]     args)</span> <span class="keyword">throws</span> InvocationTargetException,     IllegalAccessException &#123;</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before method &quot;</span> + method.getName());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after method &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>invoke()</code> 方法: 当动态代理对象调用原生方法的时候，最终实际上调用到的 是 <code>invoke()</code> 方法，然后 <code>invoke()</code> 方法去调用了被代理对象的原生方 法。</p>
</li>
<li><p>获取代理对象的工厂类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdkProxyFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getProxy</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                target.getClass().getClassLoader(), <span class="comment">// 目标类的    类加载器</span></span><br><span class="line">                target.getClass().getInterfaces(),  <span class="comment">// 代理需要    实现的接口，可指定多个</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">DebugInvocationHandler</span>(target)   <span class="comment">// 代理对象    对应的自定义 InvocationHandler</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getProxy()</code> ：主要通过 <code>Proxy.newProxyInstance（）</code> 方法获取某个类的代理对象</p>
</li>
<li><p>实际使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SmsService</span> <span class="variable">smsService</span> <span class="operator">=</span> (SmsService) JdkProxyFactory.getProxy    (<span class="keyword">new</span> <span class="title class_">SmsServiceImpl</span>());</span><br><span class="line">smsService.send(<span class="string">&quot;java&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>output:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before method send</span><br><span class="line">send message:java</span><br><span class="line">after method send</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="CGLIB-动态代理机制"><a href="#CGLIB-动态代理机制" class="headerlink" title="CGLIB 动态代理机制"></a>CGLIB 动态代理机制</h4><h5 id="CGLIB-动态代理介绍"><a href="#CGLIB-动态代理介绍" class="headerlink" title="CGLIB 动态代理介绍"></a>CGLIB 动态代理介绍</h5><p>JDK 动态代理有一个最致命的问题是其<strong>只能代理实现了接口的类</strong>。</p>
<p>为了解决这个问题，我们可以用 CGLIB 动态代理机制来避免。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/cglib/cglib">CGLIB</a> (Code Generation Library)是一个基于 <a target="_blank" rel="noopener" href="https://www.baeldung.com/java-asm">ASM</a> 的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB 通过继承方式实现代理。很多知名的开源框架都使用到了 CGLIB， 例如 Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。</p>
<p>在 CGLIB 动态代理机制中 <strong><code>MethodInterceptor</code> 接口和 <code>Enhancer</code> 类是核心。</strong></p>
<p>需要自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> <code>方法，intercept</code> 用于拦截增强被代理类的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MethodInterceptor</span></span><br><span class="line"><span class="keyword">extends</span> <span class="title class_">Callback</span>&#123;</span><br><span class="line">    <span class="comment">// 拦截被代理类中的方法</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, java.lang.reflect.Method method, Object[] args,MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>obj : 被代理的对象（需要增强的对象）</li>
<li>method : 被拦截的方法（需要增强的方法）</li>
<li>args : 方法入参</li>
<li>proxy : 用于调用原始方法</li>
</ol>
<p>可以通过 <code>Enhancer</code> 类来动态获取被代理类，当代理类调用方法的时候，实际调用的是 <code>MethodInterceptor</code> 中的 <code>intercept</code> 方法。</p>
<h5 id="CGLIB-动态代理类使用步骤"><a href="#CGLIB-动态代理类使用步骤" class="headerlink" title="CGLIB 动态代理类使用步骤"></a>CGLIB 动态代理类使用步骤</h5><ol>
<li>定义一个类；</li>
<li>自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> <code>方法，intercept</code> 用于拦截增强被代理类的方法，和 JDK 动态代理中的 <code>invoke</code> 方法类似；</li>
<li>通过 <code>Enhancer</code> 类的 <code>create()</code> 创建代理类；</li>
</ol>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p>不同于 JDK 动态代理不需要额外的依赖。CGLIB(Code Generation Library) 实际是属于一个开源项目，如果你要使用它的话，需要手动添加相关依赖。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>实现一个使用阿里云发送短信的类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliSmsService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;send message:&quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义 <code>MethodInterceptor</code> （方法拦截器）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义MethodInterceptor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DebugMethodInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o           被代理的对象（需要增强的对象）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method      被拦截的方法（需要增强的方法）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args        方法入参</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodProxy 用于调用原始方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before method &quot;</span> + method.getName());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> methodProxy.invokeSuper(o, args);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after method &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取代理类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxyFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getProxy</span><span class="params">(Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建动态代理增强类</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">// 设置类加载器</span></span><br><span class="line">        enhancer.setClassLoader(clazz.getClassLoader());</span><br><span class="line">        <span class="comment">// 设置被代理类</span></span><br><span class="line">        enhancer.setSuperclass(clazz);</span><br><span class="line">        <span class="comment">// 设置方法拦截器</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">DebugMethodInterceptor</span>());</span><br><span class="line">        <span class="comment">// 创建代理类</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AliSmsService</span> <span class="variable">aliSmsService</span> <span class="operator">=</span> (AliSmsService) CglibProxyFactory.getProxy(AliSmsService.class);</span><br><span class="line">aliSmsService.send(<span class="string">&quot;java&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>output</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before method send</span><br><span class="line">send message:java</span><br><span class="line">after method send</span><br></pre></td></tr></table></figure>

<h4 id="JDK-动态代理和-CGLIB-动态代理对比"><a href="#JDK-动态代理和-CGLIB-动态代理对比" class="headerlink" title="JDK 动态代理和 CGLIB 动态代理对比"></a>JDK 动态代理和 CGLIB 动态代理对比</h4><ol>
<li><strong>JDK 动态代理只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。</strong> 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此<strong>不能代理声明为 final 类型的类和方法。</strong></li>
<li>就二者的效率来说，大部分情况都是 <strong>JDK 动态代理更优秀</strong>，随着 JDK 版本的升级，这个优势更加明显。</li>
</ol>
<h3 id="静态代理和动态代理的对比"><a href="#静态代理和动态代理的对比" class="headerlink" title="静态代理和动态代理的对比"></a>静态代理和动态代理的对比</h3><ol>
<li><strong>灵活性</strong>：<strong>动态代理更加灵活</strong>，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！</li>
<li><strong>JVM 层面</strong>：静态代理在<strong>编译时</strong>就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在<strong>运行时</strong>动态生成类字节码，并加载到 JVM 中的。</li>
</ol>
<h2 id="6-BigDecimal"><a href="#6-BigDecimal" class="headerlink" title="6. BigDecimal"></a>6. BigDecimal</h2><h3 id="BigDecimal-介绍"><a href="#BigDecimal-介绍" class="headerlink" title="BigDecimal 介绍"></a>BigDecimal 介绍</h3><p><code>BigDecimal</code> 可以实现对小数的运算，不会造成精度丢失。</p>
<p>通常情况下，大部分需要小数精确运算结果的业务 （如涉及到钱的场景） 都是通过 <code>BigDecimal</code> 做的。</p>
<h3 id="BigDecimal-常见方法"><a href="#BigDecimal-常见方法" class="headerlink" title="BigDecimal 常见方法"></a>BigDecimal 常见方法</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>在使用 <code>BigDecimal</code> 时，为了防止精度丢失，推荐使用它的 <code>BigDecimal(String val)</code> 构造方法或者 <code>BigDecimal.valueOf(double val)</code> 静态方法来创建对象。</p>
<h4 id="加减乘除"><a href="#加减乘除" class="headerlink" title="加减乘除"></a>加减乘除</h4><p><code>add</code> 方法用于将两个 <code>BigDecimal</code> 对象相加， <code>subtract</code> 方法用于将两个 <code>BigDecimal</code> 对象相减。 <code>multiply</code> 方法用于将两个 <code>BigDecimal</code> 对象相乘，<code>divide</code> 方法用于将两个 <code>BigDecimal</code> 对象相除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line">System.out.println(a.add(b));<span class="comment">// 1.9</span></span><br><span class="line">System.out.println(a.subtract(b));<span class="comment">// 0.1</span></span><br><span class="line">System.out.println(a.multiply(b));<span class="comment">// 0.90</span></span><br><span class="line">System.out.println(a.divide(b));<span class="comment">// 无法除尽，抛出 ArithmeticException 异常</span></span><br><span class="line">System.out.println(a.divide(b, <span class="number">2</span>, RoundingMode.HALF_UP));<span class="comment">// 1.11</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，在使用 <code>divide</code> 方法的时候尽量使用 3 个参数版本，并且 <code>RoundingMode</code> 不要选择 <code>UNNECESSARY</code> ，否则很可能会遇到 <code>ArithmeticException</code> （无法除尽出现无限循环小数的时候），其中 <code>scale</code> 表示要保留几位小数，<code>roundingMode</code> 代表保留规则。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BigDecimal <span class="title function_">divide</span><span class="params">(BigDecimal divisor, <span class="type">int</span> scale, RoundingMode roundingMode)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> divide(divisor, scale, roundingMode.oldMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>保留规则非常多，这里列举几种:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">RoundingMode</span> &#123;</span><br><span class="line">   <span class="comment">// 2.5 -&gt; 3 , 1.6 -&gt; 2</span></span><br><span class="line">   <span class="comment">// -1.6 -&gt; -2 , -2.5 -&gt; -3</span></span><br><span class="line">   UP(BigDecimal.ROUND_UP),</span><br><span class="line">   <span class="comment">// 2.5 -&gt; 2 , 1.6 -&gt; 1</span></span><br><span class="line">   <span class="comment">// -1.6 -&gt; -1 , -2.5 -&gt; -2</span></span><br><span class="line">   DOWN(BigDecimal.ROUND_DOWN),</span><br><span class="line">   <span class="comment">// 2.5 -&gt; 3 , 1.6 -&gt; 2</span></span><br><span class="line">   <span class="comment">// -1.6 -&gt; -1 , -2.5 -&gt; -2</span></span><br><span class="line">   CEILING(BigDecimal.ROUND_CEILING),</span><br><span class="line">   <span class="comment">// 2.5 -&gt; 2 , 1.6 -&gt; 1</span></span><br><span class="line">   <span class="comment">// -1.6 -&gt; -2 , -2.5 -&gt; -3</span></span><br><span class="line">   FLOOR(BigDecimal.ROUND_FLOOR),</span><br><span class="line">   <span class="comment">// 2.5 -&gt; 3 , 1.6 -&gt; 2</span></span><br><span class="line">   <span class="comment">// -1.6 -&gt; -2 , -2.5 -&gt; -3</span></span><br><span class="line">   HALF_UP(BigDecimal.ROUND_HALF_UP),</span><br><span class="line">   <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="大小比较"><a href="#大小比较" class="headerlink" title="大小比较"></a>大小比较</h4><p><code>a.compareTo(b)</code> : 返回 -1 表示 a 小于 b，0 表示 a 等于 b ， 1 表示 a 大于 b。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line">System.out.println(a.compareTo(b));<span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h4 id="保留几位小数"><a href="#保留几位小数" class="headerlink" title="保留几位小数"></a>保留几位小数</h4><p>通过 <code>setScale</code> 方法设置保留几位小数以及保留规则。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.255433&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">n</span> <span class="operator">=</span> m.setScale(<span class="number">3</span>,RoundingMode.HALF_DOWN);</span><br><span class="line">System.out.println(n);<span class="comment">// 1.255</span></span><br></pre></td></tr></table></figure>

<h3 id="BigDecimal-等值比较问题"><a href="#BigDecimal-等值比较问题" class="headerlink" title="BigDecimal 等值比较问题"></a>BigDecimal 等值比较问题</h3><p><img src="/./asserts/others/006.png" alt="006"></p>
<p><code>BigDecimal</code> 使用 <code>equals()</code> 方法进行等值比较出现问题的代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line">System.out.println(a.equals(b));<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>这是因为 <code>equals()</code> 方法不仅仅会比较值的大小（value）还会比较精度（scale），而 <code>compareTo()</code> 方法比较的时候会忽略精度。</p>
<p>1.0 的 scale 是 1，1 的 scale 是 0，因此 <code>a.equals(b)</code> 的结果是 false。</p>
<p><code>compareTo()</code> 方法可以比较两个 <code>BigDecimal</code> 的值，如果相等就返回 0，如果第 1 个数比第 2 个数大则返回 1，反之返回-1。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line">System.out.println(a.compareTo(b));<span class="comment">//0</span></span><br></pre></td></tr></table></figure>

<h3 id="BigDecimal-总结"><a href="#BigDecimal-总结" class="headerlink" title="BigDecimal 总结"></a>BigDecimal 总结</h3><p>浮点数没有办法用二进制精确表示，因此存在精度丢失的风险。</p>
<p>不过，Java 提供了 <code>BigDecimal</code> 来操作浮点数。 <code>BigDecimal</code> 的实现利用到了 <code>BigInteger</code> （用来操作大整数）, 所不同的是 <code>BigDecimal</code> 加入了小数位的概念。</p>
<h2 id="7-Java-魔法类-Unsafe"><a href="#7-Java-魔法类-Unsafe" class="headerlink" title="7. Java 魔法类 Unsafe"></a>7. Java 魔法类 Unsafe</h2><h3 id="Unsafe-介绍"><a href="#Unsafe-介绍" class="headerlink" title="Unsafe 介绍"></a>Unsafe 介绍</h3><p><code>Unsafe</code> 是位于 <code>sun.misc</code> 包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在<strong>提升 Java 运行效率、增强 Java 语言底层资源操作能力</strong>方面起到了很大的作用。但由于 <code>Unsafe</code> 类使 Java 语言拥有了类似 C 语言指针一样操作内存空间的能力，这无疑也<strong>增加了程序发生相关指针问题的风险</strong>。在程序中过度、不正确使用 Unsafe 类会使得程序出错的概率变大，使得 Java 这种安全的语言变得不再“安全”，因此对 Unsafe 的使用一定要慎重。</p>
<p>另外，Unsafe 提供的这些功能的实现需要<strong>依赖本地方法（Native Method）</strong>。你可以将本地方法看作是 Java 中使用其他编程语言编写的方法。本地方法使用 native 关键字修饰，Java 代码中只是声明方法头，具体的实现则交给 本地代码。</p>
<h4 id="为什么要使用本地方法呢？"><a href="#为什么要使用本地方法呢？" class="headerlink" title="为什么要使用本地方法呢？"></a>为什么要使用本地方法呢？</h4><ol>
<li>需要用到 Java 中不具备的<strong>依赖于操作系统的特性</strong>，Java 在实现跨平台的同时要实现对底层的控制，需要借助其他语言发挥作用。</li>
<li>对于其他语言<strong>已经完成的一些现成功能</strong>，可以使用 Java 直接调用。</li>
<li>程序对<strong>时间敏感或对性能要求非常高</strong>时，有必要使用更加底层的语言，例如 C&#x2F;C++甚至是汇编。</li>
</ol>
<h3 id="Unsafe-创建"><a href="#Unsafe-创建" class="headerlink" title="Unsafe 创建"></a>Unsafe 创建</h3><p><code>sun.misc.Unsafe</code> 部分源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Unsafe</span> &#123;</span><br><span class="line">  <span class="comment">// 单例对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe theUnsafe;</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Unsafe</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@CallerSensitive</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title function_">getUnsafe</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">var0</span> <span class="operator">=</span> Reflection.getCallerClass();</span><br><span class="line">    <span class="comment">// 仅在引导类加载器`BootstrapClassLoader`加载时才合法</span></span><br><span class="line">    <span class="keyword">if</span>(!VM.isSystemDomainLoader(var0.getClassLoader())) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(<span class="string">&quot;Unsafe&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> theUnsafe;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Unsafe</code> 类为一单例实现，提供静态方法 <code>getUnsafe</code> 获取 <code>Unsafe</code> 实例。这个看上去貌似可以用来获取 <code>Unsafe</code> 实例。但是，当我们直接调用这个静态方法的时候，会抛出 <code>SecurityException</code> 异常：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception <span class="keyword">in</span> thread <span class="string">&quot;main&quot;</span> java.lang.SecurityException: Unsafe</span><br><span class="line"> at sun.misc.Unsafe.getUnsafe(Unsafe.java:90)</span><br><span class="line"> at com.cn.test.GetUnsafeTest.main(GetUnsafeTest.java:12)</span><br></pre></td></tr></table></figure>

<h4 id="为什么-public-static-方法无法被直接调用呢？"><a href="#为什么-public-static-方法无法被直接调用呢？" class="headerlink" title="为什么 public static 方法无法被直接调用呢？"></a>为什么 public static 方法无法被直接调用呢？</h4><p>这是因为在 <code>getUnsafe</code> 方法中，会对调用者的 <code>classLoader</code> 进行检查，判断当前类是否由 <code>Bootstrap classLoader</code> 加载，如果不是的话那么就会抛出一个 <code>SecurityException</code> 异常。也就是说，只有启动类加载器加载的类才能够调用 <code>Unsafe</code> 类中的方法，来防止这些方法在不可信的代码中被调用。</p>
<h4 id="为什么要对-Unsafe-类进行这么谨慎的使用限制呢"><a href="#为什么要对-Unsafe-类进行这么谨慎的使用限制呢" class="headerlink" title="为什么要对 Unsafe 类进行这么谨慎的使用限制呢?"></a>为什么要对 Unsafe 类进行这么谨慎的使用限制呢?</h4><p><code>Unsafe</code> 提供的功能过于底层（如直接访问系统内存资源、自主管理内存资源等），安全隐患也比较大，使用不当的话，很容易出现很严重的问题。</p>
<h4 id="如若想使用-Unsafe-这个类的话，应该如何获取其实例呢？"><a href="#如若想使用-Unsafe-这个类的话，应该如何获取其实例呢？" class="headerlink" title="如若想使用 Unsafe 这个类的话，应该如何获取其实例呢？"></a>如若想使用 Unsafe 这个类的话，应该如何获取其实例呢？</h4><ol>
<li><p>利用反射获得 <code>Unsafe</code> 类中已经实例化完成的单例对象 <code>theUnsafe</code> 。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Unsafe <span class="title function_">reflectGetUnsafe</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> Unsafe.class.getDeclaredField    (<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">      field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">      <span class="keyword">return</span> (Unsafe) field.get(<span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      log.error(e.getMessage(), e);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>从 <code>getUnsafe</code> 方法的使用限制条件出发，通过 Java 命令行命令 <code>-Xbootclasspath/a</code> 把调用 <code>Unsafe</code> 相关方法的类 A 所在 jar 包路径追加到默认的 <code>bootstrap</code> 路径中，使得 A 被引导类加载器加载，从而通过 <code>Unsafe.getUnsafe</code> 方法安全的获取 <code>Unsafe</code> 实例。</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xbootclasspath/a: <span class="variable">$&#123;path&#125;</span>   // 其中path为调用Unsafe相关方法的类所在jar包路径</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Unsafe-功能"><a href="#Unsafe-功能" class="headerlink" title="Unsafe 功能"></a>Unsafe 功能</h3><p>概括的来说，Unsafe 类实现功能可以被分为下面 8 类：</p>
<ol>
<li>内存操作</li>
<li>内存屏障</li>
<li>对象操作</li>
<li>数据操作</li>
<li>CAS 操作</li>
<li>线程调度</li>
<li>Class 操作</li>
<li>系统信息</li>
</ol>
<h4 id="内存操作"><a href="#内存操作" class="headerlink" title="内存操作"></a>内存操作</h4><h5 id="内存操作介绍"><a href="#内存操作介绍" class="headerlink" title="内存操作介绍"></a>内存操作介绍</h5><p>如果你是一个写过 C 或者 C++ 的程序员，一定对内存操作不会陌生，而在 Java 中是不允许直接对内存进行操作的，对象内存的分配和回收都是由 JVM 自己实现的。但是在 <code>Unsafe</code> 中，提供的下列接口可以直接进行内存操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分配新的本地空间</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">allocateMemory</span><span class="params">(<span class="type">long</span> bytes)</span>;</span><br><span class="line"><span class="comment">//重新调整内存空间的大小</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">reallocateMemory</span><span class="params">(<span class="type">long</span> address, <span class="type">long</span> bytes)</span>;</span><br><span class="line"><span class="comment">//将内存设置为指定值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">setMemory</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">long</span> bytes, <span class="type">byte</span> value)</span>;</span><br><span class="line"><span class="comment">//内存拷贝</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">copyMemory</span><span class="params">(Object srcBase, <span class="type">long</span> srcOffset,Object destBase, <span class="type">long</span> destOffset,<span class="type">long</span> bytes)</span>;</span><br><span class="line"><span class="comment">//清除内存</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">freeMemory</span><span class="params">(<span class="type">long</span> address)</span>;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">memoryTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">addr</span> <span class="operator">=</span> unsafe.allocateMemory(size);</span><br><span class="line">    <span class="type">long</span> <span class="variable">addr3</span> <span class="operator">=</span> unsafe.reallocateMemory(addr, size * <span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;addr: &quot;</span>+addr);</span><br><span class="line">    System.out.println(<span class="string">&quot;addr3: &quot;</span>+addr3);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        unsafe.setMemory(<span class="literal">null</span>,addr ,size,(<span class="type">byte</span>)<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            unsafe.copyMemory(<span class="literal">null</span>,addr,<span class="literal">null</span>,addr3+size*i,<span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(unsafe.getInt(addr));</span><br><span class="line">        System.out.println(unsafe.getLong(addr3));</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        unsafe.freeMemory(addr);</span><br><span class="line">        unsafe.freeMemory(addr3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>output:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">addr: 2433733895744</span><br><span class="line">addr3: 2433733894944</span><br><span class="line">16843009</span><br><span class="line">72340172838076673</span><br></pre></td></tr></table></figure>

<h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><p>首先使用 <code>allocateMemory</code> 方法申请 4 字节长度的内存空间，调用 <code>setMemory</code> 方法向每个字节写入内容为 byte 类型的 1，当使用 <code>Unsafe</code> 调用 <code>getInt</code> 方法时，因为一个 int 型变量占 4 个字节，会一次性读取 4 个字节，组成一个 int 的值，对应的十进制结果为 16843009。</p>
<p><img src="/./asserts/others/007.png" alt="007"></p>
<p>在代码中调用 <code>reallocateMemory</code> 方法重新分配了一块 8 字节长度的内存空间，通过比较 <code>addr</code> 和 <code>addr3</code> 可以看到和之前申请的内存地址是不同的。在代码中的第二个 for 循环里，调用 <code>copyMemory</code> 方法进行了两次内存的拷贝，每次拷贝内存地址addr开始的 4 个字节，分别拷贝到以 <code>addr3</code> 和 <code>addr3+4</code> 开始的内存空间上：</p>
<p><img src="/./asserts/others/008.png" alt="008"></p>
<p>拷贝完成后，使用getLong方法一次性读取 8 个字节，得到long类型的值为 72340172838076673。</p>
<p>需要注意，通过这种方式分配的内存属于 堆外内存 ，是<strong>无法进行垃圾回收</strong>的，需要我们把这些内存当做一种资源去<strong>手动调用 <code>freeMemory</code> 方法进行释放</strong>，否则会产生内存泄漏。通用的操作内存方式是在 try 中执行对内存的操作，最终在 finally 块中进行内存的释放。</p>
<h5 id="为什么要使用堆外内存？"><a href="#为什么要使用堆外内存？" class="headerlink" title="为什么要使用堆外内存？"></a>为什么要使用堆外内存？</h5><ul>
<li><strong>对垃圾回收停顿的改善</strong>。由于堆外内存是直接受操作系统管理而不是 JVM，所以当我们使用堆外内存时，即可保持较小的堆内内存规模。从而在 GC 时减少回收停顿对于应用的影响。</li>
<li><strong>提升程序 I&#x2F;O 操作的性能</strong>。通常在 I&#x2F;O 通信过程中，会存在堆内内存到堆外内存的数据拷贝操作，对于需要频繁进行内存间数据拷贝且生命周期较短的暂存数据，都建议存储到堆外内存。</li>
</ul>
<h5 id="内存操作典型应用"><a href="#内存操作典型应用" class="headerlink" title="内存操作典型应用"></a>内存操作典型应用</h5><p><code>DirectByteBuffer</code> 是 Java 用于实现堆外内存的一个重要类，通常用在通信过程中做缓冲池，如在 Netty、MINA 等 NIO 框架中应用广泛。 <code>DirectByteBuffer</code> 对于堆外内存的创建、使用、销毁等逻辑均由 <code>Unsafe</code> 提供的堆外内存 API 来实现。</p>
<p>下例为 <code>DirectByteBuffer</code> 构造函数，创建 <code>DirectByteBuffer</code> 的时候，通过 <code>Unsafe.allocateMemory</code> 分配内存、 <code>Unsafe.setMemory</code> 进行内存初始化，而后构建 <code>Cleaner</code> 对象用于跟踪 <code>DirectByteBuffer</code> 对象的垃圾回收，以实现当 <code>DirectByteBuffer</code> 被垃圾回收时，分配的堆外内存一起被释放。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">DirectByteBuffer(<span class="type">int</span> cap) &#123;                   <span class="comment">// package-private</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">super</span>(-<span class="number">1</span>, <span class="number">0</span>, cap, cap);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">pa</span> <span class="operator">=</span> VM.isDirectMemoryPageAligned();</span><br><span class="line">    <span class="type">int</span> <span class="variable">ps</span> <span class="operator">=</span> Bits.pageSize();</span><br><span class="line">    <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> Math.max(<span class="number">1L</span>, (<span class="type">long</span>)cap + (pa ? ps : <span class="number">0</span>));</span><br><span class="line">    Bits.reserveMemory(size, cap);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 分配内存并返回基地址</span></span><br><span class="line">        base = unsafe.allocateMemory(size);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">        Bits.unreserveMemory(size, cap);</span><br><span class="line">        <span class="keyword">throw</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内存初始化</span></span><br><span class="line">    unsafe.setMemory(base, size, (<span class="type">byte</span>) <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pa &amp;&amp; (base % ps != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// Round up to page boundary</span></span><br><span class="line">        address = base + ps - (base &amp; (ps - <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        address = base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 跟踪 DirectByteBuffer 对象的垃圾回收，以实现堆外内存释放</span></span><br><span class="line">    cleaner = Cleaner.create(<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">Deallocator</span>(base, size, cap));</span><br><span class="line">    att = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h4><h5 id="内存屏障介绍"><a href="#内存屏障介绍" class="headerlink" title="内存屏障介绍"></a>内存屏障介绍</h5><p>在介绍内存屏障前，需要知道编译器和 CPU 会在保证程序输出结果一致的情况下，会对代码进行重排序，从指令优化角度提升性能。而指令重排序可能会带来一个不好的结果，导致 CPU 的高速缓存和内存中数据的不一致，而内存屏障（Memory Barrier）就是<strong>通过阻止屏障两边的指令重排序从而避免编译器和硬件的不正确优化情况</strong>。</p>
<p>在硬件层面上，内存屏障是 CPU 为了防止代码进行重排序而提供的指令，不同的硬件平台上实现内存屏障的方法可能并不相同。在 Java8 中，引入了 3 个内存屏障的函数，它屏蔽了操作系统底层的差异，允许在代码中定义、并统一由 JVM 来生成内存屏障指令，来实现内存屏障的功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内存屏障，禁止load操作重排序。屏障前的load操作不能被重排序到屏障后，屏障后的load操作不能被重排序到屏障前</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">loadFence</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//内存屏障，禁止store操作重排序。屏障前的store操作不能被重排序到屏障后，屏障后的store操作不能被重排序到屏障前</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">storeFence</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//内存屏障，禁止load、store操作重排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">fullFence</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>内存屏障可以看做对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作。以 <code>loadFence</code> 方法为例，它会禁止读操作重排序，保证在这个屏障之前的所有读操作都已经完成，并且将缓存数据设为无效，重新从主存中进行加载。</p>
<h5 id="内存屏障典型应用"><a href="#内存屏障典型应用" class="headerlink" title="内存屏障典型应用"></a>内存屏障典型应用</h5><p>在 Java 8 中引入了一种锁的新机制—— <code>StampedLock</code> ，它可以看成是读写锁的一个改进版本。 <code>StampedLock</code> 提供了一种乐观读锁的实现，这种乐观读锁类似于无锁的操作，完全不会阻塞写线程获取写锁，从而缓解读多写少时写线程“饥饿”现象。由于 <code>StampedLock</code> 提供的乐观读锁不阻塞写线程获取读锁，当线程共享变量从主内存 <code>load</code> 到线程工作内存时，会存在数据不一致问题。</p>
<p>为了解决这个问题， <code>StampedLock</code> 的 <code>validate</code> 方法会通过 <code>Unsafe</code> 的 <code>loadFence</code> 方法加入一个 <code>load</code> 内存屏障。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validate</span><span class="params">(<span class="type">long</span> stamp)</span> &#123;</span><br><span class="line">   U.loadFence();</span><br><span class="line">   <span class="keyword">return</span> (stamp &amp; SBITS) == (state &amp; SBITS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-02-24T08:24:55.000Z" title="2025/2/24 16:24:55">2025-02-24</time>发表</span><span class="level-item"><time dateTime="2025-02-25T09:29:17.389Z" title="2025/2/25 17:29:17">2025-02-25</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/OS/">OS</a><span> / </span><a class="link-muted" href="/categories/Linux/">Linux</a><span> / </span><a class="link-muted" href="/categories/Linux/Arch-Linux/">Arch Linux</a></span><span class="level-item">41 分钟读完 (大约6212个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/02/24/Arch%20Linux/arch-install/">Arch Install</a></p><div class="content"><h1 id="1-安装前的准备"><a href="#1-安装前的准备" class="headerlink" title="1. 安装前的准备"></a>1. 安装前的准备</h1><p>根据 <strong>Arch Wiki</strong> 和 <strong>ChatGPT</strong> 所给的内容安装 <strong>Arch Linux</strong></p>
<h2 id="1-1-配置控制台键盘布局和字体"><a href="#1-1-配置控制台键盘布局和字体" class="headerlink" title="1.1 配置控制台键盘布局和字体"></a>1.1 配置控制台键盘布局和字体</h2><p>由于默认字体太小，本次安装使用适合 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/HiDPI#Linux_console_(tty)">HiDPI 屏幕</a>[^hdpi]的最大字体之一 —— <code>ter-132b</code> 进行安装</p>
<p>[^hdpi]:HiDPI（High Dots Per Inch）显示器，指的是在较小尺寸下却拥有较高分辨率的显示器。Apple 将其称作“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Retina_Display">视网膜屏幕</a>”，这项技术主要存在于高端笔记本电脑和显示器中。</p>
<p>要修改控制台字体，只需运行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">setfont ter-132b</span></span><br></pre></td></tr></table></figure>

<p>命令即可。</p>
<h2 id="1-2-切换UEFI模式安装"><a href="#1-2-切换UEFI模式安装" class="headerlink" title="1.2 切换UEFI模式安装"></a>1.2 切换UEFI模式安装</h2><p>VMware默认安装模式为 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/BIOS"><em>Legacy BIOS</em></a> ，与Arch Wiki不符，故改为 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%B5%B1%E4%B8%80%E5%8F%AF%E5%BB%B6%E4%BC%B8%E9%9F%8C%E9%AB%94%E4%BB%8B%E9%9D%A2"><em>UEFI模式</em></a> 进行安装。</p>
<p>只需在VMware设置中修改即可。</p>
<p>以下内容由ChatGPT提供：</p>
<h3 id="如何确认引导模式？"><a href="#如何确认引导模式？" class="headerlink" title="如何确认引导模式？"></a><strong>如何确认引导模式？</strong></h3><p>你可以使用以下方法确认系统是以 <strong>BIOS</strong> 还是 <strong>UEFI</strong> 启动的：</p>
<h4 id="方法-1：检查-sys-firmware-efi"><a href="#方法-1：检查-sys-firmware-efi" class="headerlink" title="方法 1：检查 /sys/firmware/efi/"></a><strong>方法 1：检查 <code>/sys/firmware/efi/</code></strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /sys/firmware/efi</span><br></pre></td></tr></table></figure>

<p>如果目录不存在，就说明是 <strong>Legacy BIOS 模式</strong>。</p>
<h4 id="方法-2：使用-efivar-命令（仅适用于-UEFI）"><a href="#方法-2：使用-efivar-命令（仅适用于-UEFI）" class="headerlink" title="方法 2：使用 efivar 命令（仅适用于 UEFI）"></a><strong>方法 2：使用 <code>efivar</code> 命令（仅适用于 UEFI）</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">efivar -l</span><br></pre></td></tr></table></figure>

<p>如果 <code>efivar</code> 命令不可用，或者返回 **”No such file or directory”**，说明系统是 <strong>Legacy BIOS 模式</strong>。</p>
<h4 id="方法-3：使用-dmesg-命令"><a href="#方法-3：使用-dmesg-命令" class="headerlink" title="方法 3：使用 dmesg 命令"></a><strong>方法 3：使用 <code>dmesg</code> 命令</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | grep -i efi</span><br></pre></td></tr></table></figure>

<p>如果系统是 <strong>UEFI</strong>，会输出一些 EFI 相关的日志。如果没有任何输出，则是 <strong>Legacy BIOS</strong>。</p>
<h2 id="1-3-验证引导模式"><a href="#1-3-验证引导模式" class="headerlink" title="1.3 验证引导模式"></a>1.3 验证引导模式</h2><p>要验证系统目前的引导模式，请检查 UEFI 位数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> /sys/firmware/efi/fw_platform_size</span></span><br></pre></td></tr></table></figure>

<p>如果命令结果为 <code>64</code>，则系统是以 UEFI 模式引导且使用 64 位 x64 UEFI。如果命令结果为 <code>32</code>，则系统是以 UEFI 模式引导且使用 32 位 IA32 UEFI，虽然其受支持，但引导加载程序只能使用 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Systemd-boot">systemd-boot</a>和<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/GRUB">GRUB</a>。如果文件不存在，则系统可能是以<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/BIOS">BIOS</a>模式（或 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Compatibility_Support_Module">CSM</a> 模式）(这两种模式通常出现在<strong>老旧</strong>的电脑或<strong>未经配置的虚拟机</strong>上）引导。如果系统没有以您想要的模式（UEFI 或 BIOS）引导启动，请您参考自己的计算机或主板说明书。</p>
<h2 id="1-4-连接到互联网"><a href="#1-4-连接到互联网" class="headerlink" title="1.4 连接到互联网"></a>1.4 连接到互联网</h2><p>要在 Live 环境中配置网络连接，请遵循以下步骤：</p>
<ol>
<li><p>确保系统已经列出并启用了</p>
<p>网络接口，用 <a target="_blank" rel="noopener" href="https://man.archlinux.org/man/ip-link.8">ip-link(8) </a>检查：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ip <span class="built_in">link</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对于无线局域网（Wi-Fi）和无线广域网（WWAN），请确保网卡未被 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Rfkill">rfkill</a> 禁用。</p>
</li>
<li><p>连接到网络：</p>
<ul>
<li>有线以太网——连接网线。</li>
<li>WiFi——使用 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Iwd#iwctl">iwctl</a> 认证无线网络。</li>
<li>移动宽带调制解调器（移动网卡） - 使用 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wzh/index.php?title=Mmcli&action=edit&redlink=1">mmcli</a> 连接到移动网络。</li>
</ul>
</li>
<li><p>配置网络连接：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE#DHCP">DHCP</a>：对于有线以太网、无线局域网（WLAN）和无线广域网（WWAN）网络接口来说，动态 IP 地址和 DNS 服务器分配（由 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Systemd-networkd">systemd-networkd</a> 和 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Systemd-resolved">systemd-resolved</a> 提供功能）能够开箱即用。</li>
<li>静态 IP 地址：按照<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE#%E9%9D%99%E6%80%81_IP_%E5%9C%B0%E5%9D%80">网络配置#静态 IP 地址</a>进行操作。</li>
</ul>
</li>
<li><p>用 <strong>ping</strong> 检查网络连接：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ping archlinux.org</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>由于是通过VMware安装，网络连接已经配置好了。</p>
<h2 id="1-5-更新系统时间"><a href="#1-5-更新系统时间" class="headerlink" title="1.5 更新系统时间"></a>1.5 更新系统时间</h2><p>在 Live 环境中 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Systemd-timesyncd">systemd-timesyncd</a> 默认启用，也就是说当系统已经创建互联网连接后，系统时间将自动同步。</p>
<p>使用 <a target="_blank" rel="noopener" href="https://man.archlinux.org/man/timedatectl.1">timedatectl(1)</a> 确保系统时间是同步的，建议提前执行 <code>timedatectl set-timezone *地区/城市*</code>（中国用户可以使用 <code>timedatectl set-timezone Asia/Shanghai</code> 以设置北京时间）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">timedatectl</span></span><br></pre></td></tr></table></figure>

<h2 id="1-6-创建硬盘分区"><a href="#1-6-创建硬盘分区" class="headerlink" title="1.6 创建硬盘分区"></a>1.6 创建硬盘分区</h2><p>在 Arch Linux 安装过程中，你需要先对硬盘进行分区。你可以使用 <code>fdisk</code> 或 <code>cfdisk</code> 等工具。</p>
<h3 id="方法-1：使用-fdisk（推荐）"><a href="#方法-1：使用-fdisk（推荐）" class="headerlink" title="方法 1：使用 fdisk（推荐）"></a><strong>方法 1：使用 <code>fdisk</code>（推荐）</strong></h3><p><code>fdisk</code> 是命令行工具，适合对磁盘进行精确控制。</p>
<h4 id="1-查看磁盘"><a href="#1-查看磁盘" class="headerlink" title="1. 查看磁盘"></a><strong>1. 查看磁盘</strong></h4><p>先列出所有磁盘：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsblk</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l</span><br></pre></td></tr></table></figure>

<p>找到你的目标磁盘，例如 <code>/dev/sda</code>（注意：<strong>不要选错磁盘</strong>）。</p>
<h4 id="2-进入-fdisk"><a href="#2-进入-fdisk" class="headerlink" title="2. 进入 fdisk"></a><strong>2. 进入 <code>fdisk</code></strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk /dev/sda</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li><code>/dev/sda</code> 是你的目标磁盘，可能需要改成 <code>/dev/nvme0n1</code> 或 <code>/dev/vda</code>，根据实际情况调整。</li>
</ul>
<h4 id="3-删除现有分区（如果需要）"><a href="#3-删除现有分区（如果需要）" class="headerlink" title="3. 删除现有分区（如果需要）"></a><strong>3. 删除现有分区（如果需要）</strong></h4><p>如果磁盘上已有分区，可以输入 <code>d</code> 并选择要删除的分区，重复此操作直到所有旧分区删除完毕。</p>
<h4 id="4-创建新分区"><a href="#4-创建新分区" class="headerlink" title="4. 创建新分区"></a><strong>4. 创建新分区</strong></h4><p>按照 UEFI 或 BIOS 模式进行分区：</p>
<h5 id="UEFI-模式（推荐）"><a href="#UEFI-模式（推荐）" class="headerlink" title="UEFI 模式（推荐）"></a><strong>UEFI 模式（推荐）</strong></h5><ol>
<li><p>创建 </p>
<p>EFI 分区</p>
<p>（512MB，类型 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EFI System</span><br></pre></td></tr></table></figure>

<p>）：</p>
<ul>
<li>输入 <code>n</code>（新建分区）</li>
<li>选择 <code>1</code></li>
<li><code>First sector</code>：默认回车</li>
<li><code>Last sector</code>：输入 <code>+512M</code></li>
<li>输入 <code>t</code>（修改类型），然后输入 <code>1</code>（EFI System）</li>
</ul>
</li>
<li><p>创建 </p>
<p>Swap 分区</p>
<p>（可选，4GB+）：</p>
<ul>
<li>输入 <code>n</code>，选择 <code>2</code></li>
<li><code>First sector</code>：默认回车</li>
<li><code>Last sector</code>：输入 <code>+4G</code>（根据需要调整）</li>
<li>输入 <code>t</code>，选择 <code>2</code>，然后输入 <code>19</code>（Linux swap）</li>
</ul>
</li>
<li><p>创建 </p>
<p>根分区（剩余空间）</p>
<p>：</p>
<ul>
<li>输入 <code>n</code>，选择 <code>3</code></li>
<li><code>First sector</code>：默认回车</li>
<li><code>Last sector</code>：默认回车（使用剩余空间）</li>
</ul>
</li>
</ol>
<h5 id="Legacy-BIOS-模式"><a href="#Legacy-BIOS-模式" class="headerlink" title="Legacy BIOS 模式"></a><strong>Legacy BIOS 模式</strong></h5><ol>
<li><p>创建 </p>
<p>主分区（整个磁盘）</p>
<p>：</p>
<ul>
<li>输入 <code>n</code>，选择 <code>1</code></li>
<li><code>First sector</code>：默认回车</li>
<li><code>Last sector</code>：默认回车（使用整个磁盘）</li>
</ul>
</li>
<li><p>创建 </p>
<p>Swap 分区（可选，4GB+）</p>
<p>：</p>
<ul>
<li>输入 <code>n</code>，选择 <code>2</code></li>
<li><code>First sector</code>：默认回车</li>
<li><code>Last sector</code>：输入 <code>+4G</code></li>
<li>输入 <code>t</code>，选择 <code>2</code>，然后输入 <code>82</code>（Linux swap）</li>
</ul>
</li>
</ol>
<h4 id="5-写入分区表并退出"><a href="#5-写入分区表并退出" class="headerlink" title="5. 写入分区表并退出"></a><strong>5. 写入分区表并退出</strong></h4><p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CopyEdit</span><br><span class="line">w</span><br></pre></td></tr></table></figure>

<p>这样磁盘分区就完成了！</p>
<hr>
<h3 id="方法-2：使用-cfdisk（简单易用）"><a href="#方法-2：使用-cfdisk（简单易用）" class="headerlink" title="方法 2：使用 cfdisk（简单易用）"></a><strong>方法 2：使用 <code>cfdisk</code>（简单易用）</strong></h3><p>如果你更喜欢图形界面：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cfdisk /dev/sda</span><br></pre></td></tr></table></figure>

<ol>
<li><p>选择 </p>
<p>分区表类型</p>
<p>：</p>
<ul>
<li><strong>UEFI 模式</strong> 选择 <code>gpt</code></li>
<li><strong>BIOS 模式</strong> 选择 <code>dos</code></li>
</ul>
</li>
<li><p>选择 <code>New</code> 创建分区，按照上面的 UEFI 或 BIOS 分区方案进行操作。</p>
</li>
<li><p>选择 <code>Write</code> 并确认写入分区表。</p>
</li>
<li><p>选择 <code>Quit</code> 退出。</p>
</li>
</ol>
<hr>
<h3 id="格式化分区"><a href="#格式化分区" class="headerlink" title="格式化分区"></a><strong>格式化分区</strong></h3><p>分区完成后，需要格式化：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkfs.fat -F32 /dev/sda1      # EFI 分区（UEFI 模式）</span><br><span class="line">mkfs.ext4 /dev/sda2          # 根分区</span><br><span class="line">mkswap /dev/sda3             # Swap 分区</span><br><span class="line">swapon /dev/sda3             # 启用 Swap</span><br></pre></td></tr></table></figure>

<p>如果是 BIOS 模式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkfs.ext4 /dev/sda1</span><br><span class="line">mkswap /dev/sda2</span><br><span class="line">swapon /dev/sda2</span><br></pre></td></tr></table></figure>

<h3 id="分区方案示例"><a href="#分区方案示例" class="headerlink" title="分区方案示例"></a>分区方案示例</h3><table>
<thead>
<tr>
<th align="center">已安装系统上的挂载点</th>
<th align="center">分区</th>
<th align="center"><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/GUID_Partition_Table#Partition_type_GUIDs">分区类型</a></th>
<th align="center">建议大小</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>/boot</code>1</td>
<td align="center"><code>/dev/*efi_system_partition*</code></td>
<td align="center"><a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/EFI_system_partition">EFI system partition</a></td>
<td align="center">1 GiB。</td>
</tr>
<tr>
<td align="center"><code>[SWAP]</code></td>
<td align="center"><code>/dev/*swap_partition*</code></td>
<td align="center">Linux <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Swap">swap</a> (交换空间)</td>
<td align="center">至少 4GiB</td>
</tr>
<tr>
<td align="center"><code>/</code></td>
<td align="center"><code>/dev/*root_partition*</code></td>
<td align="center">Linux x86-64 根目录 (&#x2F;)</td>
<td align="center">设备剩余空间，至少23-32GiB</td>
</tr>
</tbody></table>
<h2 id="1-7-格式化分区"><a href="#1-7-格式化分区" class="headerlink" title="1.7 格式化分区"></a>1.7 格式化分区</h2><h3 id="为什么要格式化分区？"><a href="#为什么要格式化分区？" class="headerlink" title="为什么要格式化分区？"></a><strong>为什么要格式化分区？</strong></h3><ol>
<li><strong>创建文件系统</strong>：分区本身只是划分磁盘的区域，而格式化会在分区上创建具体的文件系统，使操作系统能存储和管理文件。</li>
<li><strong>确保数据结构一致</strong>：不同的操作系统和用途需要不同的文件系统，比如 Linux 用 <code>ext4</code>，UEFI 需要 <code>FAT32</code>。</li>
<li><strong>清除已有数据</strong>：格式化会清空原有数据，防止磁盘上的旧数据影响新系统。</li>
</ol>
<hr>
<h3 id="各个命令的解释"><a href="#各个命令的解释" class="headerlink" title="各个命令的解释"></a><strong>各个命令的解释</strong></h3><p>在 Arch Linux 安装过程中，我们会用到以下格式化命令：</p>
<h4 id="1-格式化-EFI-分区（仅适用于-UEFI-模式）"><a href="#1-格式化-EFI-分区（仅适用于-UEFI-模式）" class="headerlink" title="1. 格式化 EFI 分区（仅适用于 UEFI 模式）"></a><strong>1. 格式化 EFI 分区（仅适用于 UEFI 模式）</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs.fat -F32 /dev/sda1</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>mkfs.fat</code>：创建 FAT 文件系统。</li>
<li><code>-F32</code>：指定使用 <strong>FAT32</strong> 格式，这是 UEFI 规范要求的格式。</li>
<li><code>/dev/sda1</code>：要格式化的分区（UEFI 下 <code>/dev/sda1</code> 通常是 EFI 分区）。</li>
</ul>
<p><strong>为什么要用 FAT32？</strong><br>UEFI 固件只能识别 <strong>FAT 文件系统</strong>，因此 EFI 分区必须使用 FAT32，否则引导失败。</p>
<hr>
<h4 id="2-格式化-Linux-根分区"><a href="#2-格式化-Linux-根分区" class="headerlink" title="2. 格式化 Linux 根分区"></a><strong>2. 格式化 Linux 根分区</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs.ext4 /dev/sda2</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>mkfs.ext4</code>：创建 <strong>ext4</strong> 文件系统（Linux 常用的文件系统）。</li>
<li><code>/dev/sda2</code>：要格式化的分区（这里假设 <code>/dev/sda2</code> 是根分区）。</li>
</ul>
<p><strong>为什么要用 ext4？</strong></p>
<ul>
<li><code>ext4</code> 是 Linux 默认的文件系统，稳定可靠，支持大文件和日志功能。</li>
<li>你也可以选择 <code>btrfs</code>、<code>xfs</code> 或 <code>f2fs</code>，但 <code>ext4</code> 兼容性最好。</li>
</ul>
<hr>
<h4 id="3-格式化并启用-Swap-分区"><a href="#3-格式化并启用-Swap-分区" class="headerlink" title="3. 格式化并启用 Swap 分区"></a><strong>3. 格式化并启用 Swap 分区</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkswap /dev/sda3</span><br><span class="line">swapon /dev/sda3</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>mkswap /dev/sda3</code>：将 <code>/dev/sda3</code> 分区格式化为 Swap 分区（交换空间）。</li>
<li><code>swapon /dev/sda3</code>：启用 Swap 分区，使其生效。</li>
</ul>
<p><strong>为什么需要 Swap？</strong><br>Swap 主要用于：</p>
<ul>
<li><strong>内存不足时使用</strong>（比如你的物理内存 4GB，但程序需要 6GB，系统会用 Swap 临时存储数据）。</li>
<li><strong>休眠（hibernate）支持</strong>（如果你的 Swap 够大，Linux 可以将内存数据写入 Swap 并休眠）。</li>
<li><strong>防止 OOM（Out of Memory）</strong>（Swap 让系统在内存不足时还能继续运行，而不是直接崩溃）。</li>
</ul>
<p><strong>Swap 该分多大？</strong></p>
<ul>
<li><strong>无特殊需求</strong>：分配和物理内存一样大（4GB 内存 → 4GB Swap）。</li>
<li><strong>想用休眠（Hibernate）</strong>：Swap 至少等于 <strong>物理内存大小</strong>。</li>
<li><strong>服务器或高内存机器</strong>：可以少分甚至不分 Swap。</li>
</ul>
<h2 id="1-8-挂载分区"><a href="#1-8-挂载分区" class="headerlink" title="1.8 挂载分区"></a>1.8 挂载分区</h2><h3 id="挂载-UEFI-分区方案"><a href="#挂载-UEFI-分区方案" class="headerlink" title="挂载 UEFI 分区方案"></a><strong>挂载 UEFI 分区方案</strong></h3><p>假设你的分区结构如下：</p>
<ul>
<li><code>/dev/sda1</code> → <strong>EFI 分区</strong>（FAT32，512MB）</li>
<li><code>/dev/sda2</code> → <strong>根分区</strong>（ext4）</li>
<li><code>/dev/sda3</code> → <strong>Swap 分区</strong>（可选）</li>
</ul>
<h4 id="1-挂载根分区（-）"><a href="#1-挂载根分区（-）" class="headerlink" title="1. 挂载根分区（/）"></a><strong>1. 挂载根分区（<code>/</code>）</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/sda2 /mnt</span><br></pre></td></tr></table></figure>

<ul>
<li>这会把 <code>/dev/sda2</code>（根分区）挂载到 <code>/mnt</code>，后续的 Arch Linux 安装都将在 <code>/mnt</code> 目录下进行。</li>
</ul>
<h4 id="2-创建-boot-efi-目录并挂载-EFI-分区"><a href="#2-创建-boot-efi-目录并挂载-EFI-分区" class="headerlink" title="2. 创建 /boot/efi 目录并挂载 EFI 分区"></a><strong>2. 创建 <code>/boot/efi</code> 目录并挂载 EFI 分区</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /mnt/boot/efi</span><br><span class="line">mount /dev/sda1 /mnt/boot/efi</span><br></pre></td></tr></table></figure>

<ul>
<li><code>mkdir -p /mnt/boot/efi</code>：创建 EFI 挂载点。</li>
<li><code>mount /dev/sda1 /mnt/boot/efi</code>：挂载 EFI 分区到 <code>/mnt/boot/efi</code>，使系统能正确安装引导程序（如 <code>systemd-boot</code> 或 <code>grub</code>）。</li>
</ul>
<h4 id="3-启用-Swap-分区（如果有）"><a href="#3-启用-Swap-分区（如果有）" class="headerlink" title="3. 启用 Swap 分区（如果有）"></a><strong>3. 启用 Swap 分区（如果有）</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swapon /dev/sda3</span><br></pre></td></tr></table></figure>

<ul>
<li>这会让 Swap 分区生效，提高内存不足时的稳定性。</li>
</ul>
<hr>
<h3 id="检查挂载情况"><a href="#检查挂载情况" class="headerlink" title="检查挂载情况"></a><strong>检查挂载情况</strong></h3><p>可以用以下命令确认分区是否正确挂载：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsblk</span><br></pre></td></tr></table></figure>

<p>你应该能看到类似的输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda      8:0    0    20G  0 disk  </span><br><span class="line">├─sda1   8:1    0   512M  0 part /mnt/boot/efi</span><br><span class="line">├─sda2   8:2    0    19G  0 part /mnt</span><br><span class="line">└─sda3   8:3    0     1G  0 part [SWAP]</span><br></pre></td></tr></table></figure>

<p>这样，你的 UEFI 分区方案就正确挂载完成了！</p>
<h1 id="2-开始安装系统"><a href="#2-开始安装系统" class="headerlink" title="2. 开始安装系统"></a>2. 开始安装系统</h1><h2 id="2-1-选择镜像站"><a href="#2-1-选择镜像站" class="headerlink" title="2.1 选择镜像站"></a>2.1 选择镜像站</h2><p>系统的文件 <code>/etc/pacman.d/mirrorlist</code> 中定义了软件包会从哪个<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E9%95%9C%E5%83%8F">镜像</a>站下载。在 LiveCD 启动的系统上，且在连接到互联网后，<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Reflector">reflector</a> 会通过选择 20 个最新同步的 HTTPS 镜像站并按下载速率对其进行排序来更新镜像列表（<strong>由于只考虑最新的 20 个镜像站，其结果常不佳</strong>）。</p>
<p>在列表中，越靠前的镜像站在下载软件包时，就会有越高的优先级。<strong>请您检查 <code>/etc/pacman.d/mirrorlist</code> 文件</strong>，看看列出的镜像站的顺序是否合适。如果不合适，可以手动<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E7%BC%96%E8%BE%91">编辑</a>文件，将离您所处地理位置最近的镜像移到文件的头部，同时也应该考虑一些其他的评判标准。</p>
<p>如果 <code>/etc/pacman.d/mirrorlist</code> 文件中没有合适的镜像站，可以手动从 <a target="_blank" rel="noopener" href="https://archlinux.org/mirrorlist/">archlinux 官方网站的镜像站列表</a>下载一份。这需要您所在的网络能够正常访问 archlinux 官方网站。例如，使用 <a target="_blank" rel="noopener" href="https://man.archlinux.org/man/curl.1">curl(1)</a> 下载位于中国大陆的 HTTPS 镜像站：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># curl -L &#x27;https://archlinux.org/mirrorlist/?country=CN&amp;protocol=https&#x27; -o /etc/pacman.d/mirrorlist</span><br></pre></td></tr></table></figure>

<p>或者，也可以通过安装 <a target="_blank" rel="noopener" href="https://archlinux.org/packages/?name=pacman-mirrorlist">pacman-mirrorlist</a>包 来获取按国家分列的原始镜像列表。这么做的缺点是，pacman 仍然会使用当前配置中的镜像站来下载软件包数据库和 <a target="_blank" rel="noopener" href="https://archlinux.org/packages/?name=pacman-mirrorlist">pacman-mirrorlist</a>包，这可能会很慢。在挑选了能用的镜像之后，可以执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># pacman -Sy pacman-mirrorlist</span><br></pre></td></tr></table></figure>

<p>再将 <code>/etc/pacman.d/mirrorlist.pacnew</code> 复制到 <code>/etc/pacman.d/mirrorlist</code> 并进行编辑。</p>
<p>或者，如果您记得想要使用的镜像站的 URL，那么可以手动编辑 <code>/etc/pacman.d/mirrorlist</code> 文件并手动输入 URL。</p>
<p>这个文件接下来还会被 <em>pacstrap</em> 拷贝到新系统里，所以请您确保设置正确。</p>
<h2 id="2-2-更新密钥环"><a href="#2-2-更新密钥环" class="headerlink" title="2.2 更新密钥环"></a>2.2 更新密钥环</h2><p>过时的Live 系统内置密钥环会导致在 <em>pacstrap</em> 的时候无法正常安装软件包（提示为文件签名损坏）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># pacman -Syu archlinux-keyring</span><br></pre></td></tr></table></figure>

<p>使用上面的命令更新当前 Live 系统的密钥环，也可以防止因为意外导致开发者私钥被盗用造成的安全问题。</p>
<p>如果您在 Live 系统里启用了<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Arch_Linux_%E4%B8%AD%E6%96%87%E7%A4%BE%E5%8C%BA%E4%BB%93%E5%BA%93">中文社区仓库</a>或其他<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E9%9D%9E%E5%AE%98%E6%96%B9%E7%94%A8%E6%88%B7%E4%BB%93%E5%BA%93">非官方用户仓库</a>，也不要忘了一同更新其密钥环。</p>
<p>参见 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Pacman/%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AD%BE%E5%90%8D">pacman&#x2F;软件包签名</a>。</p>
<h2 id="2-3-安装必需的软件包"><a href="#2-3-安装必需的软件包" class="headerlink" title="2.3 安装必需的软件包"></a>2.3 安装必需的软件包</h2><p>使用 <a target="_blank" rel="noopener" href="https://man.archlinux.org/man/pacstrap.8">pacstrap(8)</a> 脚本，安装 <a target="_blank" rel="noopener" href="https://archlinux.org/packages/?name=base">base</a>包 软件包和 Linux <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E5%86%85%E6%A0%B8">内核</a>以及常规硬件的固件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># pacstrap -K /mnt base linux linux-firmware</span><br></pre></td></tr></table></figure>

<p>这时候可以同时额外安装计算机的 CPU 微码包。如果计算机是 Intel 的 CPU ，使用 <a target="_blank" rel="noopener" href="https://archlinux.org/packages/?name=intel-ucode">intel-ucode</a>包，AMD CPU 则使用 <a target="_blank" rel="noopener" href="https://archlinux.org/packages/?name=amd-ucode">amd-ucode</a>包。也可以暂时都不安装，等到进入系统后再安装。</p>
<p><a target="_blank" rel="noopener" href="https://archlinux.org/packages/?name=base">base</a>包 软件包并没有包含 Live 环境中的全部程序。因此要获得一个功能齐全的基本系统，可能需要安装更多软件包。要安装其他软件包或软件包组（比如 <a target="_blank" rel="noopener" href="https://archlinux.org/groups/x86_64/base-devel/">base-devel</a>包组），请将它们的名字追加到下面的 <em>pacstrap</em> 命令后（以空格分隔），或者也可以在 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97#Chroot">Chroot 进入新系统</a>后使用 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Pacman">pacman</a> 手动<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E5%AE%89%E8%A3%85">安装</a>。特别要考虑安装：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Pacman/%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AD%BE%E5%90%8D">GPG 密钥环</a>（如 <a target="_blank" rel="noopener" href="https://github.com/archlinuxcn/repo/tree/master/archlinuxcn/archlinuxcn-keyring">archlinuxcn-keyring</a>CNRepo，若启用了某些<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E9%9D%9E%E5%AE%98%E6%96%B9%E7%94%A8%E6%88%B7%E4%BB%93%E5%BA%93">非官方用户仓库</a>。）</li>
<li><a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%88%97%E8%A1%A8/%E6%96%87%E6%A1%A3#%E6%8E%A7%E5%88%B6%E5%8F%B0">控制台文本编辑器</a>（如 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Nano">nano</a>、<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Vim">vim</a> 和 <a target="_blank" rel="noopener" href="https://archlinux.org/packages/?name=emacs">emacs</a>包）以便从控制台<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E7%BC%96%E8%BE%91">编辑</a>配置文件（如<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E7%82%B9%E6%96%87%E4%BB%B6">点文件</a>）。</li>
<li>访问和管理 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/RAID#%E5%AE%89%E8%A3%85">RAID</a> 或 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/LVM#%E5%87%86%E5%A4%87">LVM</a> 分区的工具。</li>
<li><a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE">联网</a>所需要的程序（例如<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE#%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%99%A8">网络管理器或 DHCP 客户端</a>，Wi-Fi <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE#%E8%AE%A4%E8%AF%81">认证软件</a>和移动宽带连接所需的 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wzh/index.php?title=ModemManager&action=edit&redlink=1">ModemManager</a>，以及部分 USB 无线网卡需要的 <a target="_blank" rel="noopener" href="https://archlinux.org/packages/?name=usb_modeswitch">usb_modeswitch</a>包）。</li>
<li><a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">文件系统的用户工具</a>（比如 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/XFS">XFS</a> 和 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Btrfs">Btrfs</a> 文件系统对应的管理工具），可用于创建和管理<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">文件系统</a>以及 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Fsck">fsck</a>。</li>
<li>CPU <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E5%BE%AE%E7%A0%81">微码</a>更新 —— <a target="_blank" rel="noopener" href="https://archlinux.org/packages/?name=amd-ucode">amd-ucode</a>包 或 <a target="_blank" rel="noopener" href="https://archlinux.org/packages/?name=intel-ucode">intel-ucode</a>包 —— 用于硬件错误和安全修复。</li>
<li>未包含在 <a target="_blank" rel="noopener" href="https://archlinux.org/packages/?name=linux-firmware">linux-firmware</a>包 中的额外必需固件（如用于<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/ALSA#%E5%9B%BA%E4%BB%B6">内建音频</a>的 <a target="_blank" rel="noopener" href="https://archlinux.org/packages/?name=sof-firmware">sof-firmware</a>包、用于 Marvell 无线的 <a target="_blank" rel="noopener" href="https://archlinux.org/packages/?name=linux-firmware-marvell">linux-firmware-marvell</a>包 以及<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E5%8D%9A%E9%80%9A%E6%97%A0%E7%BA%BF%E7%BD%91%E5%8D%A1">博通无线网卡</a>的固件包)。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://geo.mirror.pkgbuild.com/iso/latest/arch/pkglist.x86_64.txt">文件 pkglist.x86_64.txt</a> 中包含 Live 系统安装的软件包列表。</p>
<h1 id="3-配置系统"><a href="#3-配置系统" class="headerlink" title="3. 配置系统"></a>3. 配置系统</h1><h2 id="3-1-生成-fstab-文件"><a href="#3-1-生成-fstab-文件" class="headerlink" title="3.1 生成 fstab 文件"></a>3.1 生成 fstab 文件</h2><p>通过以下命令生成 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Fstab">fstab</a> 文件 (用 <code>-U</code> 或 <code>-L</code> 选项设置 UUID 或卷标)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># genfstab -U /mnt &gt; /mnt/etc/fstab</span><br></pre></td></tr></table></figure>

<p><strong>强烈建议</strong>在执行完以上命令后，检查一下生成的 <code>/mnt/etc/fstab</code> 文件是否正确。如果有问题，最好在现在手动修改。对于熟练者，可以自行编辑 <code>/mnt/etc/fstab</code> 文件。</p>
<p>可以手动修改 <code>/mnt/etc/fstab</code> 添加挂载选项（参见 <a target="_blank" rel="noopener" href="https://man.archlinux.org/man/mount.8#FILESYSTEM-INDEPENDENT_MOUNT_OPTIONS">mount(8) § FILESYSTEM-INDEPENDENT_MOUNT_OPTIONS</a> 和 <a target="_blank" rel="noopener" href="https://man.archlinux.org/man/ext4.5#MOUNT_OPTIONS">ext4(5) § MOUNT_OPTIONS</a>）。例如，给<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98">固态硬盘</a>的 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Ext4">ext4</a> 文件系统添加 <code>discard</code> 选项以启用 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/TRIM">TRIM</a>。</p>
<h2 id="3-2-chroot-到新安装的系统"><a href="#3-2-chroot-到新安装的系统" class="headerlink" title="3.2 chroot 到新安装的系统"></a>3.2 chroot 到新安装的系统</h2><p>通过以下命令 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Change_root">chroot</a> 到新安装的系统：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># arch-chroot /mnt</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong>此处使用的是<code>arch-chroot</code>而不是直接使用<code>chroot</code>，注意不要输错了。</p>
<h2 id="3-3-设置时区"><a href="#3-3-设置时区" class="headerlink" title="3.3 设置时区"></a>3.3 设置时区</h2><p>通过以下命令设置<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4#%E6%97%B6%E5%8C%BA">时区</a>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ln -sf /usr/share/zoneinfo/Region（地区名）/City（城市名） /etc/localtime</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong>例如，在中国大陆需要将时区设置为北京时间，那么请运行 <code># ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</code>。时区名称是上海而非北京，是因为上海是该时区内人口最多的城市（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Time_in_China#IANA_time_zone_database">参考来源</a>）。</p>
<p>然后运行 <a target="_blank" rel="noopener" href="https://man.archlinux.org/man/hwclock.8">hwclock(8)</a> 以生成 <code>/etc/adjtime</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># hwclock --systohc</span><br></pre></td></tr></table></figure>

<p>这个命令假定已设置硬件时间为 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/UTC">UTC 时间</a>。详细信息请查看<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4#%E6%97%B6%E9%97%B4%E6%A0%87%E5%87%86">系统时间#时间标准</a>。</p>
<p>为了防止时钟漂移并确保时间准确，请使用 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E6%97%B6%E9%97%B4%E5%8D%8F%E8%AE%AE">NTP</a>（网络时间协议，Network Time Protocol）客户端（例如 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Systemd-timesyncd">systemd-timesyncd</a>）设置<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4#%E6%97%B6%E9%92%9F%E5%90%8C%E6%AD%A5">时间同步</a>。</p>
<h2 id="3-4-区域和本地化设置"><a href="#3-4-区域和本地化设置" class="headerlink" title="3.4 区域和本地化设置"></a>3.4 区域和本地化设置</h2><p>程序和库如果需要本地化文本，都依赖<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Locale">区域设置</a>，后者明确规定了地域、货币、时区日期的格式、字符排列方式和其他本地化标准。</p>
<p>需要设置这两个文件：<code>locale.gen</code> 与 <code>locale.conf</code>。</p>
<p><a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E7%BC%96%E8%BE%91">编辑</a> <code>/etc/locale.gen</code>，然后取消掉 <code>en_US.UTF-8 UTF-8</code> 和其他需要的 UTF-8 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Locale">区域设置</a>前的注释（**#**）。</p>
<p>接着执行 <code>locale-gen</code> 以生成 locale 信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># locale-gen</span><br></pre></td></tr></table></figure>

<p>然后创建 <a target="_blank" rel="noopener" href="https://man.archlinux.org/man/locale.conf.5">locale.conf(5)</a> 文件，并<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Locale#%E7%B3%BB%E7%BB%9F%E5%8C%BA%E5%9F%9F%E8%AE%BE%E7%BD%AE">编辑设定 LANG 变量</a>，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc/locale.conf</span><br><span class="line">LANG=en_US.UTF-8</span><br></pre></td></tr></table></figure>

<p>另外对于中文用户：</p>
<p><strong>提示：</strong></p>
<ul>
<li>用户可以设置自己的 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Locale">locale</a>，详情请参阅 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Locale#%E5%9C%A8%E7%94%A8%E6%88%B7%E4%BC%9A%E8%AF%9D%E4%B8%AD%E8%A6%86%E7%9B%96%E7%B3%BB%E7%BB%9F%E5%8C%BA%E5%9F%9F%E8%AE%BE%E7%BD%AE">在用户会话中覆盖系统区域设置</a> 或 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Locale#%E8%AE%BE%E7%BD%AE%E5%BD%93%E5%89%8D%E5%8C%BA%E5%9F%9F">设置当前区域</a>；</li>
<li>将系统 locale 设置为<code>en_US.UTF-8</code>，系统的日志就会用英文显示，这样更容易判断和处理问题；<ul>
<li>也可以设置为 <code>en_GB.UTF-8</code> ［英语（英国）］或 <code>en_SG.UTF-8</code> ［英语（新加坡）］，附带以下特点：<ul>
<li>进入桌面环境后以 24 小时制显示时间；</li>
<li><a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/LibreOffice">LibreOffice</a> 等办公软件的纸张尺寸会默认为 <code>A4</code> 而非 <code>Letter(US)</code>；</li>
<li>可尽量避免不必要且可能造成处理麻烦的英制单位。</li>
</ul>
</li>
<li>设置的 LANG 变量需与 locale 设置一致，否则会出现以下错误：</li>
</ul>
</li>
</ul>
<p><strong>警告：</strong>并不推荐在此设置任何中文 locale，这可能会导致 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Getty">tty</a> 上中文显示为方块（因为 TTY 下没有 CJK 字体）。如果您不经常使用 tty ，或是稍后需要安装<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E6%A1%8C%E9%9D%A2%E7%8E%AF%E5%A2%83">桌面环境</a>，则在不使用 tty 后可以设置为中文的 locale 。为了使 TTY 显示中文，也可以使用打了补丁的<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E5%86%85%E6%A0%B8">内核</a>，如 <a target="_blank" rel="noopener" href="https://github.com/archlinuxcn/repo/tree/master/archlinuxcn/linux-lily">linux-lily</a>CNRepo。</p>
<p>如果需要修改<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97#%E6%8E%A7%E5%88%B6%E5%8F%B0%E9%94%AE%E7%9B%98%E5%B8%83%E5%B1%80%E5%92%8C%E5%AD%97%E4%BD%93">#控制台键盘布局和字体</a>，可编辑 <a target="_blank" rel="noopener" href="https://man.archlinux.org/man/vconsole.conf.5">vconsole.conf(5)</a> 使其长期生效，以德语键盘（qwertz）为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc/vconsole.conf</span><br><span class="line">KEYMAP=de-latin1</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>如果键盘为标准美式键盘（中国最常见的键盘布局），请勿照抄如上设置。</p>
<h2 id="3-5-网络配置"><a href="#3-5-网络配置" class="headerlink" title="3.5 网络配置"></a>3.5 网络配置</h2><p><a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E5%88%9B%E5%BB%BA">创建</a> <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE#%E8%AE%BE%E7%BD%AE%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%8D">hostname</a> 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc/hostname</span><br><span class="line">主机名</span><br></pre></td></tr></table></figure>

<p>请接着完成新安装的环境的<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE">网络配置</a>，配置过程中可能需要安装合适的<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE#%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86">网络管理</a>软件。</p>
<p><strong>警告：</strong>请按上述网络配置指引正确配置好网络后再重新启动，否则系统重新启动后可能无法连接网络（不过可以用 LiveCD 重新进入 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Chroot#%E4%BD%BF%E7%94%A8_arch-chroot">arch-chroot</a> 进行配置）。例如在虚拟机软件 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/VirtualBox">VirtualBox</a> <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/VirtualBox/%E5%9C%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E5%AE%89%E8%A3%85_Arch_Linux">安装</a>并使用桥接模式时就需要配置 DHCP 。</p>
<h2 id="3-6-关于-initramfs"><a href="#3-6-关于-initramfs" class="headerlink" title="3.6 关于 initramfs"></a>3.6 关于 initramfs</h2><p>通常不需要自己创建新的 <em>initramfs</em>，因为在执行 <em>pacstrap</em> 时已经安装 <a target="_blank" rel="noopener" href="https://archlinux.org/packages/?name=linux">linux</a>包，这时已经运行过 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Mkinitcpio">mkinitcpio</a> 了。</p>
<p>如果是 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wzh/index.php?title=%E5%9C%A8_LVM_%E4%B8%8A%E5%AE%89%E8%A3%85_Arch_Linux&action=edit&redlink=1">LVM</a>、<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Dm-crypt">系统加密</a>或 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/RAID#%E9%85%8D%E7%BD%AE_mkinitcpio">RAID</a> 等分区配置，请修改 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Mkinitcpio">mkinitcpio.conf</a> 并用以下命令重新创建一个 Initramfs：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># mkinitcpio -P</span><br></pre></td></tr></table></figure>

<h2 id="3-7-设置-root-密码"><a href="#3-7-设置-root-密码" class="headerlink" title="3.7 设置 root 密码"></a>3.7 设置 root 密码</h2><p>使用以下命令设置 root <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E7%94%A8%E6%88%B7%E5%92%8C%E7%94%A8%E6%88%B7%E7%BB%84#%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E5%AD%98%E5%82%A8">密码</a>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># passwd</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong>建议为 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Root">root</a> 用户选择一个<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E5%AE%89%E5%85%A8#%E9%80%89%E6%8B%A9%E5%AE%89%E5%85%A8%E7%9A%84%E5%AF%86%E7%A0%81">强密码</a>并<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E5%AE%89%E5%85%A8#%E7%BB%B4%E6%8A%A4%E5%AF%86%E7%A0%81%E5%AE%89%E5%85%A8">保护其安全</a>。</p>
<h2 id="3-8-安装引导程序"><a href="#3-8-安装引导程序" class="headerlink" title="3.8 安装引导程序"></a>3.8 安装引导程序</h2><p>需要安装 Linux 引导加载程序，才能在安装后启动系统，可以使用的的引导程序已在<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E5%BC%95%E5%AF%BC%E5%8A%A0%E8%BD%BD%E7%A8%8B%E5%BA%8F">引导加载程序</a>中列出，请选择一个安装并配置它，<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/GRUB">GRUB</a> 是一个比较常见且通用的选择。</p>
<p><strong>警告：</strong>这是安装的最后一步也是关键的一步，请点击上述链接并按指引正确安装好引导加载程序后再重新启动。否则计算机重新启动后将无法正常进入 Arch Linux 系统。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-02-17T02:02:45.000Z" title="2025/2/17 10:02:45">2025-02-17</time>发表</span><span class="level-item"><time dateTime="2025-02-24T07:11:37.266Z" title="2025/2/24 15:11:37">2025-02-24</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/toy-projects/">toy projects</a></span><span class="level-item">3 小时读完 (大约28070个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/02/17/Write%20yourself%20a%20Git!/Write%20yourself%20a%20Git!/">Write yourself a Git!</a></p><div class="content"><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>本文尝试从底层开始解释 <a target="_blank" rel="noopener" href="https://git-scm.com/">Git 版本控制系统</a>，也就是从底至上逐步讲解。这听起来并不容易，而且他人已经尝试多次，但效果可能都不理想（ <em>with questionable succes</em> ）。但有一种简单的方法：要理解 Git 的内部原理，只需要从零开始重新实现 Git 即可。</p>
<p>不，别跑。（No, don’t run.）</p>
<p>这不是玩笑，而且真的并不复杂：如果你从头到尾阅读这篇文章并亲自编写代码（或者直接<a target="_blank" rel="noopener" href="https://wyag.thb.lt/wyag.zip">下载 ZIP 文件</a>——但你真的应该自己写代码），最终你将得到一个名为 <strong>wyag</strong> 的程序，它将实现 Git 的所有基本功能：<code>init</code>、<code>add</code>、<code>rm</code>、<code>status</code>、<code>commit</code>、<code>log</code>…… 这些功能与 Git 本身完全兼容，兼容到（ <em>compatible enough that</em> ）在本教程中最后添加关于 <code>commit</code> 章节的提交，实际上是<a target="_blank" rel="noopener" href="https://github.com/thblt/write-yourself-a-git/commit/ed26daffb400b2be5f30e044c3237d220226d867">由 <strong>wyag</strong> 生成的，而不是 Git</a>。而且，整个实现仅用 <strong>972 行</strong> 非常简单的 Python 代码完成。</p>
<p>但是，Git 对实现来说不是太复杂了吗？（ <em>But isn’t Git too complex for that?</em> ）在我看来，认为 Git 复杂是一种误解。没错，Git 确实是一个庞大的程序，功能众多，但它的核心其实非常简单。Git 之所以显得复杂，首先是（ <em>stems first from</em> ）因为它的工作方式通常非常反直觉（而那些<a target="_blank" rel="noopener" href="https://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/">“Git 是墨西哥卷饼”的博客文章</a>可能并没有帮助）。但真正让 Git 变得令人困惑的，或许是它核心模型的极端<strong>简单性</strong>和<strong>强大性</strong>。</p>
<p>核心概念既简单又强大的组合（ <em>The combination of core simplicity and powerful applications</em> ），往往会让人难以理解，因为要从基本抽象的简单性<strong>跳跃性地</strong>推导出各种复杂应用，这种思维转换并不容易（比如单子（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Monad_(functional_programming)">monads</a>（函数式编程用语）），有人懂吗？）。</p>
<p>实现 Git 的过程将彻底揭示它的基本原理，让它的本质一览无遗。</p>
<p>我们可以期待去实现什么？本文将<strong>详细</strong>实现并解释 Git 核心命令的一个极简版本（如果有不清楚的地方，请<a target="_blank" rel="noopener" href="https://wyag.thb.lt/#feedback">反馈！</a>）。我会保持代码<strong>简洁明了</strong>，因此 <strong>wyag</strong> 远远无法与真正的 Git 命令行相比——但缺失的部分将非常明显，并且对任何想尝试实现的人来说，都很容易补充。正如他们常说的：“<strong>将 wyag 升级为完整的 Git 库和 CLI是留给读者的一个练习</strong>。”</p>
<p>更具体地说，我们将实现：</p>
<ul>
<li><code>add</code>(<a target="_blank" rel="noopener" href="https://wyag.thb.lt/#cmd-add">wyag source</a>) <a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-add">git man page</a></li>
<li><code>cat-file</code> (<a target="_blank" rel="noopener" href="https://wyag.thb.lt/#cmd-cat-file">wyag source</a>) <a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-cat-file">git man page</a></li>
<li><code>check-ignore</code> (<a target="_blank" rel="noopener" href="https://wyag.thb.lt/#cmd-check-ignore">wyag source</a>) <a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-check-ignore">git man page</a></li>
<li><code>checkout</code> (<a target="_blank" rel="noopener" href="https://wyag.thb.lt/#cmd-checkout">wyag source</a>) <a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-checkout">git man page</a></li>
<li><code>commit</code> (<a target="_blank" rel="noopener" href="https://wyag.thb.lt/#cmd-commit">wyag source</a>) <a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-commit">git man page</a></li>
<li><code>hash-object</code> (<a target="_blank" rel="noopener" href="https://wyag.thb.lt/#cmd-hash-object">wyag source</a>) <a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-hash-object">git man page</a></li>
<li><code>init</code> (<a target="_blank" rel="noopener" href="https://wyag.thb.lt/#cmd-init">wyag source</a>) <a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-init">git man page</a></li>
<li><code>log</code> (<a target="_blank" rel="noopener" href="https://wyag.thb.lt/#cmd-log">wyag source</a>) <a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-log">git man page</a></li>
<li><code>ls-files</code> (<a target="_blank" rel="noopener" href="https://wyag.thb.lt/#cmd-ls-files">wyag source</a>) <a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-ls-files">git man page</a></li>
<li><code>ls-tree</code> (<a target="_blank" rel="noopener" href="https://wyag.thb.lt/#cmd-ls-tree">wyag source</a>) <a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-ls-tree">git man page</a></li>
<li><code>rev-parse</code> (<a target="_blank" rel="noopener" href="https://wyag.thb.lt/#cmd-rev-parse">wyag source</a>) <a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-rev-parse">git man page</a></li>
<li><code>rm</code> (<a target="_blank" rel="noopener" href="https://wyag.thb.lt/#cmd-rm">wyag source</a>) <a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-rm">git man page</a></li>
<li><code>show-ref</code> (<a target="_blank" rel="noopener" href="https://wyag.thb.lt/#cmd-show-ref">wyag source</a>) <a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-show-ref">git man page</a></li>
<li><code>status</code> (<a target="_blank" rel="noopener" href="https://wyag.thb.lt/#cmd-status">wyag source</a>) <a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-status">git man page</a></li>
<li><code>tag</code> (<a target="_blank" rel="noopener" href="https://wyag.thb.lt/#cmd-tag">wyag source</a>) <a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-tag">git man page</a></li>
</ul>
<p>要跟上本文的内容，你并不需要太多前置知识：只需了解一些<strong>基本的 Git 指令</strong>（显然）、<strong>基本的 Python</strong>，以及<strong>基本的 Shell</strong> 知识即可。</p>
<ul>
<li>首先，我只假设你对 <strong>Git 的基本命令</strong> 有一定的了解——不需要是专家级别，但如果你从未使用过 <code>init</code>、<code>add</code>、<code>rm</code>、<code>commit</code> 或 <code>checkout</code>，那你可能会感到困惑。</li>
<li><strong>关于编程语言</strong>，<strong>wyag</strong> 将使用 <strong>Python</strong> 实现。同样，我不会使用任何花哨的特性，而且 Python 本身就很接近伪代码，因此会很容易理解。（讽刺的是，最复杂的部分可能是命令行参数解析逻辑，不过你其实并不需要完全理解它。）如果你有编程基础但从未接触过 Python，建议先在网上找个快速入门教程熟悉一下。</li>
<li><strong>wyag 和 Git 都是终端程序</strong>，我默认你熟悉 <strong>Unix 终端</strong> 的基本操作。你不需要是个 <strong>l33t h4x0r</strong>（精英黑客，见[补充1](#1. l33t h4x0r)），但至少应该会使用 <code>cd</code>、<code>ls</code>、<code>rm</code>、<code>tree</code> 这些常见命令。</li>
</ul>
<table>
<thead>
<tr>
<th><strong>Warning</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Windows 用户注意：<br /><strong>wyag</strong> 应该能在任何类 Unix 系统上运行，并且需要有 Python 解释器，但我完全不确定它在 Windows 上的表现。测试套件明确要求使用一个兼容 bash 的 shell，我假设 <strong>WSL</strong>（Windows Subsystem for Linux）可以提供这个功能。另外，如果你使用 WSL，确保你的 <strong>wyag</strong> 文件使用 Unix 风格的换行符（如果你用的是 VS Code，可以参考<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/48692741/how-can-i-make-all-line-endings-eols-in-all-files-in-visual-studio-code-unix">这个 StackOverflow 解决方案</a>）。欢迎 Windows 用户提供反馈！</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><strong>Note</strong></th>
</tr>
</thead>
<tbody><tr>
<td>致谢：<br />本文得到了许多人重要的贡献，我对他们表示感谢。特别感谢以下几位：<br />- GitHub 用户 <a target="_blank" rel="noopener" href="https://github.com/tammoippen"><strong>tammoippen</strong></a>，他首次草拟了我忘记写的 <code>tag_create</code> 函数（那是 <a target="_blank" rel="noopener" href="https://github.com/thblt/write-yourself-a-git/issues/9">#9</a>）。<br />- GitHub 用户 <a target="_blank" rel="noopener" href="https://github.com/hjlarry"><strong>hjlarry</strong></a>，在 <a target="_blank" rel="noopener" href="https://github.com/thblt/write-yourself-a-git/pull/22">#22</a> 中修复了多个问题。<br />- GitHub 用户 <a target="_blank" rel="noopener" href="https://github.com/cutebbb"><strong>cutebbb</strong></a>，在 <a target="_blank" rel="noopener" href="https://github.com/thblt/write-yourself-a-git/pull/32/">#32</a> 中实现了 <code>ls-files</code> 的第一个版本，凭借此功能，<strong>wyag</strong> 最终实现了“暂存区”的奇妙功能！</td>
</tr>
</tbody></table>
<h2 id="2-Getting-started"><a href="#2-Getting-started" class="headerlink" title="2. Getting started"></a>2. Getting started</h2><p>你将需要 <strong>Python 3.10</strong> 或更高版本，以及你喜欢的文本编辑器。我们不需要第三方包、虚拟环境或其他任何东西，除了常规的 Python 解释器：我们所需的一切都可以通过 Python 的标准库来实现。</p>
<p>我们会将代码分成两个文件：</p>
<ul>
<li>一个可执行文件，名为 <strong>wyag</strong>；</li>
<li>一个 Python 库文件，名为 <strong>libwyag.py</strong>。</li>
</ul>
<p>现在，每个软件项目开始时都会有一大堆模板代码，我们先把这些简单的部分搞定吧。</p>
<p>我们将从创建一个非常简短的可执行文件开始。在你的文本编辑器中创建一个新的文件，命名为 <strong>wyag</strong>，然后复制以下几行代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> libwyag</span><br><span class="line">libwyag.main()</span><br></pre></td></tr></table></figure>

<p>代码解释见[补充2](#2. code 1)</p>
<p>然后，使其变为可执行文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> +x wyag</span></span><br></pre></td></tr></table></figure>

<p>完成了！</p>
<p>接下来是库文件的创建。它必须命名为 <strong>libwyag.py</strong>，并且与 <strong>wyag</strong> 可执行文件位于同一目录下。</p>
<p>开始时，打开空的 <strong>libwyag.py</strong> 文件，准备编写代码。</p>
<p>首先，我们需要导入一系列模块（可以逐个复制每个导入语句，或者将它们合并为一行）。</p>
<ul>
<li><p>Git 是一个命令行应用程序，因此我们需要一些工具来解析命令行参数。Python 提供了一个很有用的模块叫做 <strong>argparse</strong>，它可以为我们完成 99% 的工作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br></pre></td></tr></table></figure>
</li>
<li><p>Git 使用的配置文件格式基本上是 Microsoft 的 INI 格式。Python 的 <strong>configparser</strong> 模块可以用来读取和写入这些文件。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> configparser</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们将进行一些日期&#x2F;时间操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们只需要一次，读取 Unix 上的用户&#x2F;组数据库（<code>grp</code> 用于组，<code>pwd</code> 用于用户）。这是因为 Git 保存文件的数字所有者&#x2F;组 ID，我们希望将其以文本形式友好地显示出来。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> grp, pwd</span><br></pre></td></tr></table></figure>
</li>
<li><p>为了支持 <code>.gitignore</code>，我们需要将文件名与诸如 <code>*.txt</code> 之类的模式进行匹配。文件名匹配在 <strong>fnmatch</strong> 模块中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fnmatch <span class="keyword">import</span> fnmatch</span><br></pre></td></tr></table></figure>
</li>
<li><p>Git 广泛使用 SHA-1 函数。在 Python 中，它位于 <a target="_blank" rel="noopener" href="https://docs.python.org/3/library/hashlib.html"><strong>hashlib</strong></a> 模块中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br></pre></td></tr></table></figure>
</li>
<li><p>仅需要从 <strong>math</strong> 模块中导入一个函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> ceil</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>os</strong> 和 <strong>os.path</strong> 提供了一些很好的文件系统抽象函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们只使用了一些正则表达式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们还需要 <strong>sys</strong> 来访问实际的命令行参数（在 <strong>sys.argv</strong> 中）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br></pre></td></tr></table></figure>
</li>
<li><p>Git 使用 zlib 压缩所有内容。Python 也有这个模块：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zlib</span><br></pre></td></tr></table></figure></li>
</ul>
<p>导入完成。我们将频繁处理命令行参数。Python 提供了一个简单而功能强大的解析库 <strong>argparse</strong>。它是一个很好的库，但它的接口可能不是最直观的；如果有需要，可以参考它的<a target="_blank" rel="noopener" href="https://docs.python.org/3/library/argparse.html">文档</a>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">argparser = argparse.ArgumentParser(description=<span class="string">&quot;The stupidest content tracker&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>我们需要处理子命令（如 git 中的 <code>init</code>、<code>commit</code> 等）。在 <code>argparse</code> 的术语中，这些被称为“子解析器”（subparsers）。此时，我们只需要声明我们的命令行界面（CLI）将使用一些子命令，并且所有调用实际上都需要一个子命令——你不能仅仅调用 <code>git</code>，你需要调用 <code>git COMMAND</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">argsubparsers = argparser.add_subparsers(title=<span class="string">&quot;Commands&quot;</span>, dest=<span class="string">&quot;command&quot;</span>)</span><br><span class="line">argsubparsers.required = <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p><code>dest=&quot;command&quot;</code> 参数表示所选择的子解析器的名称将作为字符串返回，并存储在一个名为 <code>command</code> 的字段中。因此，我们只需要读取这个字符串，并根据它调用正确的函数。按照惯例，我将这些函数称为“桥接函数”，并在函数名前加上 <code>cmd_</code> 前缀。桥接函数将解析后的参数作为唯一的参数，并负责在执行实际命令之前处理和验证这些参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">argv=sys.argv[<span class="number">1</span>:]</span>):</span><br><span class="line">    args = argparser.parse_args(argv)</span><br><span class="line">    <span class="keyword">match</span> args.command:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;add&quot;</span>          : cmd_add(args)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;cat-file&quot;</span>     : cmd_cat_file(args)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;check-ignore&quot;</span> : cmd_check_ignore(args)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;checkout&quot;</span>     : cmd_checkout(args)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;commit&quot;</span>       : cmd_commit(args)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;hash-object&quot;</span>  : cmd_hash_object(args)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;init&quot;</span>         : cmd_init(args)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;log&quot;</span>          : cmd_log(args)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;ls-files&quot;</span>     : cmd_ls_files(args)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;ls-tree&quot;</span>      : cmd_ls_tree(args)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;rev-parse&quot;</span>    : cmd_rev_parse(args)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;rm&quot;</span>           : cmd_rm(args)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;show-ref&quot;</span>     : cmd_show_ref(args)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;status&quot;</span>       : cmd_status(args)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;tag&quot;</span>          : cmd_tag(args)</span><br><span class="line">        <span class="keyword">case</span> _              : <span class="built_in">print</span>(<span class="string">&quot;Bad command.&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="3-Creating-repositories-init"><a href="#3-Creating-repositories-init" class="headerlink" title="3. Creating repositories: init"></a>3. Creating repositories: init</h2><p>显然，按时间顺序和逻辑顺序，第一个 Git 命令是 <code>git init</code>，因此我们将从创建 <code>wyag init</code> 开始。为了实现这一点，我们首先需要一些非常基础的仓库抽象。</p>
<h3 id="3-1-The-Repository-object"><a href="#3-1-The-Repository-object" class="headerlink" title="3.1. The Repository object"></a>3.1. The Repository object</h3><p>显然，我们需要对仓库进行一些抽象：几乎每次运行 Git 命令时，我们都是在尝试对仓库做某些操作，创建它、读取它或修改它。</p>
<p>一个 Git 仓库由两部分组成：一个“工作树”，存放着要进行版本控制的文件；一个“git 目录”，Git 用来存储自己的数据。在大多数情况下，工作树是一个普通目录，git 目录是工作树的子目录，名为 <code>.git</code>。</p>
<p>Git 支持更多的情况（裸仓库、分离的 gitdir 等），但我们不需要考虑这些情况：我们将坚持使用工作树&#x2F; <code>.git</code> 的基本结构。我们的仓库对象将只包含两个路径：工作树路径和 git 目录路径。</p>
<p>要创建一个新的 <strong>Repository</strong> 对象，我们只需要进行几个检查：</p>
<ul>
<li>必须验证目录是否存在，并且包含一个名为 <code>.git</code> 的子目录。</li>
<li>然后读取 <code>.git/config</code> 中的配置文件（它只是一个 INI 文件），并检查 <code>core.repositoryformatversion</code> 是否为 0。稍后会详细介绍这个字段。</li>
</ul>
<p>我们的构造函数接受一个可选的 <code>force</code> 参数，用于禁用所有检查。这是因为稍后我们将创建的 <code>repo_create()</code> 函数会使用 <strong>Repository</strong> 对象来创建仓库。因此，我们需要一种方法，即使在（仍然）无效的文件系统位置，也能创建这样的对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GitRepository</span> (<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;A git repository&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    worktree = <span class="literal">None</span></span><br><span class="line">    gitdir = <span class="literal">None</span></span><br><span class="line">    conf = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, path, force=<span class="literal">False</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.worktree = path</span><br><span class="line">        <span class="variable language_">self</span>.gitdir = os.path.join(path, <span class="string">&quot;.git&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (force <span class="keyword">or</span> os.path.isdir(<span class="variable language_">self</span>.gitdir)):</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">f&quot;Not a Git repository <span class="subst">&#123;path&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Read configuration file in .git/config</span></span><br><span class="line">        <span class="variable language_">self</span>.conf = configparser.ConfigParser()</span><br><span class="line">        cf = repo_file(<span class="variable language_">self</span>, <span class="string">&quot;config&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> cf <span class="keyword">and</span> os.path.exists(cf):</span><br><span class="line">            <span class="variable language_">self</span>.conf.read([cf])</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> force:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;Configuration file missing&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> force:</span><br><span class="line">            vers = <span class="built_in">int</span>(<span class="variable language_">self</span>.conf.get(<span class="string">&quot;core&quot;</span>, <span class="string">&quot;repositoryformatversion&quot;</span>))</span><br><span class="line">            <span class="keyword">if</span> vers != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">raise</span> Exception(<span class="string">&quot;Unsupported repositoryformatversion: &#123;vers&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>我们将处理仓库中的许多路径。我们不妨创建一些实用函数来计算这些路径，并在需要时创建缺失的目录结构。首先，创建一个通用的路径构建函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">repo_path</span>(<span class="params">repo, *path</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Compute path under repo&#x27;s gitdir.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> os.path.join(repo.gitdir, *path)</span><br></pre></td></tr></table></figure>

<p>（关于 Python 语法的说明：<code>*path</code> 使得这个函数变为可变参数函数，因此可以将多个路径组件作为单独的参数传入。例如，<code>repo_path(repo, &quot;objects&quot;, &quot;df&quot;, &quot;4ec9fc2ad990cb9da906a95a6eda6627d7b7b0&quot;)</code> 是一个有效的调用。函数接收到的 <code>path</code> 是一个列表。）</p>
<p>接下来的两个函数，<code>repo_file()</code> 和 <code>repo_dir()</code>，分别返回并可选择性地创建文件或目录的路径。它们之间的区别在于，文件版本(<code>repo_file()</code>)只会创建到最后一个组件的目录。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">repo_file</span>(<span class="params">repo, *path, mkdir=<span class="literal">False</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Same as repo_path, but create dirname(*path) if absent.  For</span></span><br><span class="line"><span class="string">example, repo_file(r, \&quot;refs\&quot;, \&quot;remotes\&quot;, \&quot;origin\&quot;, \&quot;HEAD\&quot;) will create</span></span><br><span class="line"><span class="string">.git/refs/remotes/origin.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> repo_dir(repo, *path[:-<span class="number">1</span>], mkdir=mkdir):</span><br><span class="line">        <span class="keyword">return</span> repo_path(repo, *path)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">repo_dir</span>(<span class="params">repo, *path, mkdir=<span class="literal">False</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Same as repo_path, but mkdir *path if absent if mkdir.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    path = repo_path(repo, *path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(path):</span><br><span class="line">        <span class="keyword">if</span> (os.path.isdir(path)):</span><br><span class="line">            <span class="keyword">return</span> path</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">f&quot;Not a directory <span class="subst">&#123;path&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> mkdir:</span><br><span class="line">        os.makedirs(path)</span><br><span class="line">        <span class="keyword">return</span> path</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>（关于语法的第二个也是最后一个说明：由于 <code>*path</code> 使得函数成为可变参数函数，因此 <code>mkdir</code> 参数必须通过名称显式传递。例如，<code>repo_file(repo, &quot;objects&quot;, mkdir=True)</code>。）</p>
<p>要创建一个新的仓库，我们首先从一个目录开始（如果该目录不存在，我们会创建它），然后在其中创建 git 目录（该目录必须不存在或为空）。这个目录叫做 <code>.git</code>（前导的点使其在 Unix 系统中成为“隐藏”目录），并包含：</p>
<ul>
<li><code>.git/objects/</code>：对象存储，我们将在下一节介绍。</li>
<li><code>.git/refs/</code>：引用存储，稍后会讨论。它包含两个子目录，<code>heads</code> 和 <code>tags</code>。</li>
<li><code>.git/HEAD</code>：当前 HEAD 的引用（稍后会详细讲解！）。</li>
<li><code>.git/config</code>：仓库的配置文件。</li>
<li><code>.git/description</code>：包含一个自由格式的仓库描述，供人类使用，且很少使用。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">repo_create</span>(<span class="params">path</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Create a new repository at path.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    repo = GitRepository(path, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># First, we make sure the path either doesn&#x27;t exist or is an</span></span><br><span class="line">    <span class="comment"># empty dir.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(repo.worktree):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(repo.worktree):</span><br><span class="line">            <span class="keyword">raise</span> Exception (<span class="string">f&quot;<span class="subst">&#123;path&#125;</span> is not a directory!&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> os.path.exists(repo.gitdir) <span class="keyword">and</span> os.listdir(repo.gitdir):</span><br><span class="line">            <span class="keyword">raise</span> Exception (<span class="string">f&quot;<span class="subst">&#123;path&#125;</span> is not empty!&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        os.makedirs(repo.worktree)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> repo_dir(repo, <span class="string">&quot;branches&quot;</span>, mkdir=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">assert</span> repo_dir(repo, <span class="string">&quot;objects&quot;</span>, mkdir=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">assert</span> repo_dir(repo, <span class="string">&quot;refs&quot;</span>, <span class="string">&quot;tags&quot;</span>, mkdir=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">assert</span> repo_dir(repo, <span class="string">&quot;refs&quot;</span>, <span class="string">&quot;heads&quot;</span>, mkdir=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># .git/description</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(repo_file(repo, <span class="string">&quot;description&quot;</span>), <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(<span class="string">&quot;Unnamed repository; edit this file &#x27;description&#x27; to name the repository.\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># .git/HEAD</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(repo_file(repo, <span class="string">&quot;HEAD&quot;</span>), <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(<span class="string">&quot;ref: refs/heads/master\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(repo_file(repo, <span class="string">&quot;config&quot;</span>), <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        config = repo_default_config()</span><br><span class="line">        config.write(f)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> repo</span><br></pre></td></tr></table></figure>

<p>配置文件非常简单，它是一个类似 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/INI_file">INI</a> 的文件，包含一个部分（<code>[core]</code>）和三个字段：</p>
<ul>
<li><code>repositoryformatversion = 0</code>：gitdir 格式的版本。0 表示初始格式，1 表示带扩展的相同格式。如果大于 1，Git 会 panic；wyag 只接受 0。</li>
<li><code>filemode = false</code>：禁用在工作树中跟踪文件模式（权限）更改。</li>
<li><code>bare = false</code>：指示该仓库有一个工作树。Git 支持一个可选的 <code>worktree</code> 键，用于指示工作树的位置（如果不是 <code>..</code>）；wyag 不支持此功能。</li>
</ul>
<p>我们使用 Python 的 <code>configparser</code> 库来创建这个文件：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">repo_default_config</span>():</span><br><span class="line">    ret = configparser.ConfigParser()</span><br><span class="line"></span><br><span class="line">    ret.add_section(<span class="string">&quot;core&quot;</span>)</span><br><span class="line">    ret.<span class="built_in">set</span>(<span class="string">&quot;core&quot;</span>, <span class="string">&quot;repositoryformatversion&quot;</span>, <span class="string">&quot;0&quot;</span>)</span><br><span class="line">    ret.<span class="built_in">set</span>(<span class="string">&quot;core&quot;</span>, <span class="string">&quot;filemode&quot;</span>, <span class="string">&quot;false&quot;</span>)</span><br><span class="line">    ret.<span class="built_in">set</span>(<span class="string">&quot;core&quot;</span>, <span class="string">&quot;bare&quot;</span>, <span class="string">&quot;false&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<h3 id="3-2-The-init-command"><a href="#3-2-The-init-command" class="headerlink" title="3.2. The init command"></a>3.2. The init command</h3><p>现在我们有了用于读取和创建仓库的代码，让我们通过创建 <code>wyag init</code> 命令来使这些代码可以从命令行使用。<code>wyag init</code> 的行为与 <code>git init</code> 完全相同——当然，自定义性要少得多。<code>wyag init</code> 的语法将是：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wyag init [path]</span><br></pre></td></tr></table></figure>

<p>我们已经有了完整的仓库创建逻辑。为了创建这个命令，我们只需要再添加两件事：</p>
<ol>
<li><p>我们需要创建一个 <code>argparse</code> 子解析器来处理我们命令的参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">argsp = argsubparsers.add_parser(<span class="string">&quot;init&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;Initialize a new, empty repository.&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>对于 <code>init</code> 命令，有一个单一的可选位置参数：初始化仓库的路径。默认为当前目录 :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">argsp.add_argument(<span class="string">&quot;path&quot;</span>,</span><br><span class="line">                   metavar=<span class="string">&quot;directory&quot;</span>,</span><br><span class="line">                   nargs=<span class="string">&quot;?&quot;</span>,</span><br><span class="line">                   default=<span class="string">&quot;.&quot;</span>,</span><br><span class="line">                   <span class="built_in">help</span>=<span class="string">&quot;Where to create the repository.&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>我们还需要一个“桥接”函数，它将从 <code>argparse</code> 返回的对象中读取参数值，并使用正确的值调用实际的函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cmd_init</span>(<span class="params">args</span>):</span><br><span class="line">    repo_create(args.path)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>完成了！如果你按照这些步骤操作，你现在应该能够在任何地方使用 <code>wyag init</code> 创建一个 Git 仓库了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wyag init <span class="built_in">test</span></span></span><br></pre></td></tr></table></figure>

<p>（<code>wyag</code> 可执行文件通常不在你的 <code>$PATH</code> 中：你需要通过它的完整路径来调用它，例如 <code>~/projects/wyag/wyag init .</code>。）</p>
<h3 id="3-3-The-repo-find-function"><a href="#3-3-The-repo-find-function" class="headerlink" title="3.3. The repo_find() function"></a>3.3. The repo_find() function</h3><p>在我们实现仓库功能时，我们需要一个函数来找到当前仓库的根目录。我们将频繁使用这个函数，因为几乎所有 Git 功能都需要在现有仓库上工作（当然，<code>init</code> 除外！）。有时根目录就是当前目录，但也可能是父目录：比如你的仓库根目录可能在 <code>~/Documents/MyProject</code>，但你当前可能在 <code>~/Documents/MyProject/src/tui/frames/mainview/</code> 工作。我们现在将创建的 <code>repo_find()</code> 函数将从当前目录开始查找仓库根目录，并递归向上查找，直到根目录 <code>/</code>。要识别一个路径是否为仓库，它将检查该路径是否存在 <code>.git</code> 目录。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">repo_find</span>(<span class="params">path=<span class="string">&quot;.&quot;</span>, required=<span class="literal">True</span></span>):</span><br><span class="line">    path = os.path.realpath(path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> os.path.isdir(os.path.join(path, <span class="string">&quot;.git&quot;</span>)):</span><br><span class="line">        <span class="keyword">return</span> GitRepository(path)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># If we haven&#x27;t returned, recurse in parent, if w</span></span><br><span class="line">    parent = os.path.realpath(os.path.join(path, <span class="string">&quot;..&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> parent == path:</span><br><span class="line">        <span class="comment"># Bottom case</span></span><br><span class="line">        <span class="comment"># os.path.join(&quot;/&quot;, &quot;..&quot;) == &quot;/&quot;:</span></span><br><span class="line">        <span class="comment"># If parent==path, then path is root.</span></span><br><span class="line">        <span class="keyword">if</span> required:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;No git directory.&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Recursive case</span></span><br><span class="line">    <span class="keyword">return</span> repo_find(parent, required)</span><br></pre></td></tr></table></figure>

<p>仓库部分完成了！</p>
<h2 id="4-Reading-and-writing-objects-hash-object-and-cat-file"><a href="#4-Reading-and-writing-objects-hash-object-and-cat-file" class="headerlink" title="4. Reading and writing objects: hash-object and cat-file"></a>4. Reading and writing objects: hash-object and cat-file</h2><h3 id="4-1-What-are-objects"><a href="#4-1-What-are-objects" class="headerlink" title="4.1. What are objects?"></a>4.1. What are objects?</h3><p>既然我们已经有了仓库，接下来就是往其中放东西。与此同时，仓库本身也很单调，编写 Git 实现不应该仅仅是写一堆 <code>mkdir</code>。让我们来谈谈对象，并实现 <code>git hash-object</code> 和 <code>git cat-file</code>。</p>
<p>也许你不太了解这两个命令——它们并不是 Git 日常工具箱的一部分，而且实际上是非常底层的命令（在 Git 术语中叫做“管道命令”）。它们的功能其实非常简单：<code>hash-object</code> 将一个现有的文件转换成一个 Git 对象，而 <code>cat-file</code> 将一个现有的 Git 对象打印到标准输出。</p>
<p>那么，什么是 Git 对象呢？从本质上来说，Git 是一个“内容寻址文件系统”。这意味着，与普通的文件系统不同，文件名是任意的，与文件内容无关，而 Git 存储的文件名是通过文件内容的数学计算得出的。这有一个非常重要的含义：如果一个文件的内容（例如文本文件）发生了一点变化，它的内部名称也会发生变化。简单来说，你在 Git 中不是修改文件，而是创建一个新文件并将其存储在一个不同的位置。Git 对象就是这样：在 Git 仓库中的文件，它们的路径由文件内容决定。</p>
<table>
<thead>
<tr>
<th><strong>Warning</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Git 并不是真正的键值存储<br />一些文档，包括优秀的 <a target="_blank" rel="noopener" href="https://git-scm.com/book/id/v2/Git-Internals-Git-Objects">Pro Git</a> ，将 Git 称为“键值存储”。这并不完全错误，但可能会引起误解。普通的文件系统实际上比 Git 更接近键值存储。因为 Git 是根据数据计算键，所以更准确的说法是，Git 应该被称为“值-值存储”。</td>
</tr>
</tbody></table>
<p>Git 使用对象来存储许多内容：首先是它保持版本控制的实际文件——例如源代码。提交也是对象，标签也是。除了少数几个例外（稍后我们会看到！），在 Git 中，几乎所有的内容都是以对象的形式存储的。</p>
<p>Git 存储给定对象的路径是通过计算其内容的 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/SHA-1">SHA-1</a> <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Cryptographic_hash_function">哈希</a>来确定的。更精确地说，Git 将哈希值转换为小写十六进制字符串，并将其拆分为两部分：前两位字符和其余部分。它使用前两位作为目录名，其余部分作为文件名（这是因为大多数文件系统不喜欢在单个目录中存储太多文件，否则会导致系统变慢。Git 的方法创建了 256 个可能的中间目录，从而将每个目录中的平均文件数量减少了 256 倍）。</p>
<table>
<thead>
<tr>
<th><strong>Note</strong></th>
</tr>
</thead>
<tbody><tr>
<td>哈希函数是什么？<br />SHA-1 就是我们所说的“哈希函数”。简单来说，哈希函数是一种单向数学函数：计算一个值的哈希值很容易，但无法反推出哪个值产生了该哈希值。<br />一个非常简单的哈希函数例子是经典的 <code>len</code>（或 <code>strlen</code>）函数，它返回字符串的长度。计算一个字符串的长度非常容易，并且给定一个字符串，它的长度永远不会改变（当然，除非字符串本身改变！），但是仅凭长度是无法恢复原始字符串的。加密哈希函数是同样原理的更复杂版本，且具有额外的特性：计算一个输入值来产生给定哈希值的难度足够大，以至于实际上几乎不可能做到。（比如，要产生一个长度为 12 的字符串 <code>i</code>，你只需要随便输入 12 个字符。但对于像 SHA-1 这样的算法，需要的时间要长得多——足够长，以至于在实际中几乎不可能做到。[^1]</td>
</tr>
</tbody></table>
<p>[^1]: You may know that <a target="_blank" rel="noopener" href="https://shattered.io/">collisions have been discovered in SHA-1</a>. Git actually doesn’t use SHA-1 anymore: it uses a <a target="_blank" rel="noopener" href="https://github.com/git/git/blob/26e47e261e969491ad4e3b6c298450c061749c9e/Documentation/technical/hash-function-transition.txt#L34-L36">hardened variant</a> which is not SHA, but which applies the same hash to every known input but the two PDF files known to collide.</p>
<p>在我们开始实现对象存储系统之前，必须了解它们的确切存储格式。一个对象以一个头部开始，该头部指定其类型：<code>blob</code>、<code>commit</code>、<code>tag </code>或 <code>tree</code>（稍后会详细讲解）。这个头部后面跟着一个 ASCII 空格（0x20），然后是对象大小的 ASCII 数字，接着是一个空字符（0x00），最后是对象的内容。在 Wyag 的仓库中，一个 commit 对象的前 48 个字节看起来像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00000000  63 6f 6d 6d 69 74 20 31  30 38 36 00 74 72 65 65  |commit 1086.tree|</span><br><span class="line">00000010  20 32 39 66 66 31 36 63  39 63 31 34 65 32 36 35  | 29ff16c9c14e265|</span><br><span class="line">00000020  32 62 32 32 66 38 62 37  38 62 62 30 38 61 35 61  |2b22f8b78bb08a5a|</span><br></pre></td></tr></table></figure>

<p>在第一行中，我们可以看到类型头部，一个空格（<code>0x20</code>），大小的 ASCII 表示（1086）和 null 分隔符 <code>0x00</code>。第一行的最后四个字节是该对象内容的开头，单词“tree”——我们稍后会在讨论 commit 时进一步讲解。</p>
<p>这些对象（包括头部和内容）都是使用 <code>zlib</code> 压缩存储的。</p>
<h3 id="4-2-A-generic-object-object"><a href="#4-2-A-generic-object-object" class="headerlink" title="4.2. A generic object object"></a>4.2. A generic object object</h3><p>对象可以有多种类型，但它们都共享相同的存储&#x2F;检索机制以及相同的通用头部格式。在深入了解各种类型的对象之前，我们需要对这些共同特性进行抽象。最简单的方法是创建一个通用的 <code>GitObject</code> 类，具有两个未实现的方法：<code>serialize()</code> 和 <code>deserialize()</code>，并提供一个默认的 <code>init()</code> 方法，用于在需要时创建一个新的空对象（抱歉，Python 用户，这不是非常好的设计，但它可能比使用超级构造器更容易理解）。我们的 <code>__init__</code> 方法要么从提供的数据中加载对象，要么调用子类提供的 <code>init()</code> 方法来创建一个新的空对象。</p>
<p>稍后，我们将对子类化这个通用类，为每种对象格式实际实现这些函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GitObject</span> (<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> data != <span class="literal">None</span>:</span><br><span class="line">            <span class="variable language_">self</span>.deserialize(data)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="variable language_">self</span>.init()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">serialize</span>(<span class="params">self, repo</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;This function MUST be implemented by subclasses.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">It must read the object&#x27;s contents from self.data, a byte string, and</span></span><br><span class="line"><span class="string">do whatever it takes to convert it into a meaningful representation.</span></span><br><span class="line"><span class="string">What exactly that means depend on each subclass.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&quot;Unimplemented!&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deserialize</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&quot;Unimplemented!&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">init</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span> <span class="comment"># Just do nothing. This is a reasonable default!</span></span><br></pre></td></tr></table></figure>

<h3 id="4-3-Reading-objects"><a href="#4-3-Reading-objects" class="headerlink" title="4.3. Reading objects"></a>4.3. Reading objects</h3><p>为了读取一个对象，我们需要知道它的 SHA-1 哈希值。然后，我们根据这个哈希值计算其路径（按照之前解释的公式：前两个字符，然后是目录分隔符“&#x2F;”，然后是剩余部分），并在 gitdir 的“objects”目录中查找它。也就是说，<code>e673d1b7eaa0aa01b5bc2442d570a765bdaae751 </code>的路径是 <code>.git/objects/e6/73d1b7eaa0aa01b5bc2442d570a765bdaae751</code>。</p>
<p>接着，我们将该文件作为二进制文件读取，并使用 <code>zlib </code>解压它。</p>
<p>从解压后的数据中，我们提取两个头部组件：对象类型和大小。通过类型，我们确定实际使用的类。我们将大小转换为 Python 整数，并进行匹配检查。</p>
<p>完成所有步骤后，我们只需调用该对象格式的正确构造函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">object_read</span>(<span class="params">repo, sha</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Read object sha from Git repository repo.  Return a</span></span><br><span class="line"><span class="string">    GitObject whose exact type depends on the object.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    path = repo_file(repo, <span class="string">&quot;objects&quot;</span>, sha[<span class="number">0</span>:<span class="number">2</span>], sha[<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.isfile(path):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span> (path, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        raw = zlib.decompress(f.read())</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Read object type</span></span><br><span class="line">        x = raw.find(<span class="string">b&#x27; &#x27;</span>)</span><br><span class="line">        fmt = raw[<span class="number">0</span>:x]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Read and validate object size</span></span><br><span class="line">        y = raw.find(<span class="string">b&#x27;\x00&#x27;</span>, x)</span><br><span class="line">        size = <span class="built_in">int</span>(raw[x:y].decode(<span class="string">&quot;ascii&quot;</span>))</span><br><span class="line">        <span class="keyword">if</span> size != <span class="built_in">len</span>(raw)-y-<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">f&quot;Malformed object <span class="subst">&#123;sha&#125;</span>: bad length&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Pick constructor</span></span><br><span class="line">        <span class="keyword">match</span> fmt:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">b&#x27;commit&#x27;</span> : c=GitCommit</span><br><span class="line">            <span class="keyword">case</span> <span class="string">b&#x27;tree&#x27;</span>   : c=GitTree</span><br><span class="line">            <span class="keyword">case</span> <span class="string">b&#x27;tag&#x27;</span>    : c=GitTag</span><br><span class="line">            <span class="keyword">case</span> <span class="string">b&#x27;blob&#x27;</span>   : c=GitBlob</span><br><span class="line">            <span class="keyword">case</span> _:</span><br><span class="line">                <span class="keyword">raise</span> Exception(<span class="string">f&quot;Unknown type <span class="subst">&#123;fmt.decode(<span class="string">&quot;ascii&quot;</span>)&#125;</span> for object <span class="subst">&#123;sha&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Call constructor and return object</span></span><br><span class="line">        <span class="keyword">return</span> c(raw[y+<span class="number">1</span>:])</span><br></pre></td></tr></table></figure>

<h3 id="4-4-Writing-objects"><a href="#4-4-Writing-objects" class="headerlink" title="4.4. Writing objects"></a>4.4. Writing objects</h3><p>写入对象的过程实际上是读取过程的逆操作：我们先计算哈希值，接着添加头部，然后使用 zlib 压缩所有数据，并将结果写入正确的位置。这里不需要太多解释，值得注意的是哈希值是在添加头部后计算的（因此它是对象本身的哈希值，包括未压缩的头部，而不仅仅是内容的哈希）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">object_write</span>(<span class="params">obj, repo=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="comment"># Serialize object data</span></span><br><span class="line">    data = obj.serialize()</span><br><span class="line">    <span class="comment"># Add header</span></span><br><span class="line">    result = obj.fmt + <span class="string">b&#x27; &#x27;</span> + <span class="built_in">str</span>(<span class="built_in">len</span>(data)).encode() + <span class="string">b&#x27;\x00&#x27;</span> + data</span><br><span class="line">    <span class="comment"># Compute hash</span></span><br><span class="line">    sha = hashlib.sha1(result).hexdigest()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> repo:</span><br><span class="line">        <span class="comment"># Compute path</span></span><br><span class="line">        path=repo_file(repo, <span class="string">&quot;objects&quot;</span>, sha[<span class="number">0</span>:<span class="number">2</span>], sha[<span class="number">2</span>:], mkdir=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path):</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(path, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                <span class="comment"># Compress and write</span></span><br><span class="line">                f.write(zlib.compress(result))</span><br><span class="line">    <span class="keyword">return</span> sha</span><br></pre></td></tr></table></figure>

<h3 id="4-5-Working-with-blobs"><a href="#4-5-Working-with-blobs" class="headerlink" title="4.5. Working with blobs"></a>4.5. Working with blobs</h3><p>正如之前所说，类型头可以是四种之一：<code>blob</code>、<code>commit</code>、<code>tag</code> 和 <code>tree </code>— 因此 Git 有四种对象类型。</p>
<p>Blobs 是这四种类型中最简单的，因为它们没有实际的格式。Blobs 是用户数据：你放入 Git 中的每个文件（如 main.c、logo.png、README.md）的内容都作为一个 Blob 存储。这使得它们易于操作，因为除了基本的对象存储机制外，它们没有实际的语法或约束：它们只是未指定的数据。因此，创建一个 GitBlob 类是微不足道的，<code>serialize </code>和 <code>deserialize </code>函数只需存储和返回它们的输入，不做任何修改。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GitBlob</span>(<span class="title class_ inherited__">GitObject</span>):</span><br><span class="line">    fmt=<span class="string">b&#x27;blob&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">serialize</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.blobdata</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deserialize</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="variable language_">self</span>.blobdata = data</span><br></pre></td></tr></table></figure>

<h3 id="4-6-The-cat-file-command"><a href="#4-6-The-cat-file-command" class="headerlink" title="4.6. The cat-file command"></a>4.6. The cat-file command</h3><p>我们现在可以创建 <code>wyag cat-file</code> 了。<code>git cat-file</code> 只是将对象的原始内容打印到标准输出，解压缩并去除 Git 头部信息。在 <a target="_blank" rel="noopener" href="https://github.com/thblt/write-yourself-a-git">Wyag 的源代码仓库</a>中，运行：<code>git cat-file blob e0695f14a412c29e252c998c81de1dde59658e4a</code>将会显示某个 README 文件的版本内容。</p>
<p>我们的简化版本只需要两个位置参数：一个类型和一个对象标识符。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wyag cat-file TYPE OBJECT</span><br></pre></td></tr></table></figure>

<p>子解析器非常简单：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">argsp = argsubparsers.add_parser(<span class="string">&quot;cat-file&quot;</span>,</span><br><span class="line">                                 <span class="built_in">help</span>=<span class="string">&quot;Provide content of repository objects&quot;</span>)</span><br><span class="line"></span><br><span class="line">argsp.add_argument(<span class="string">&quot;type&quot;</span>,</span><br><span class="line">                   metavar=<span class="string">&quot;type&quot;</span>,</span><br><span class="line">                   choices=[<span class="string">&quot;blob&quot;</span>, <span class="string">&quot;commit&quot;</span>, <span class="string">&quot;tag&quot;</span>, <span class="string">&quot;tree&quot;</span>],</span><br><span class="line">                   <span class="built_in">help</span>=<span class="string">&quot;Specify the type&quot;</span>)</span><br><span class="line"></span><br><span class="line">argsp.add_argument(<span class="string">&quot;object&quot;</span>,</span><br><span class="line">                   metavar=<span class="string">&quot;object&quot;</span>,</span><br><span class="line">                   <span class="built_in">help</span>=<span class="string">&quot;The object to display&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>我们可以实现这些函数，它们只是调用我们之前编写的现有代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cmd_cat_file</span>(<span class="params">args</span>):</span><br><span class="line">    repo = repo_find()</span><br><span class="line">    cat_file(repo, args.<span class="built_in">object</span>, fmt=args.<span class="built_in">type</span>.encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cat_file</span>(<span class="params">repo, obj, fmt=<span class="literal">None</span></span>):</span><br><span class="line">    obj = object_read(repo, object_find(repo, obj, fmt=fmt))</span><br><span class="line">    sys.stdout.buffer.write(obj.serialize())</span><br></pre></td></tr></table></figure>

<p>这个函数调用了一个尚未介绍的 <code>object_find</code> 函数。目前，它只是返回其中一个参数，像这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">object_find</span>(<span class="params">repo, name, fmt=<span class="literal">None</span>, follow=<span class="literal">True</span></span>):</span><br><span class="line">    <span class="keyword">return</span> name</span><br></pre></td></tr></table></figure>

<p>之所以需要这个奇怪的小函数，是因为 Git 有许多方式来引用对象：完整哈希、短哈希、标签……<code>object_find()</code> 将作为我们的名称解析函数。我们稍后才会实现它，因此这里只是一个临时占位符。这意味着在实现真正的 <code>object_find()</code> 之前，我们只能通过完整哈希来引用对象。</p>
<h3 id="4-7-The-hash-object-command"><a href="#4-7-The-hash-object-command" class="headerlink" title="4.7. The hash-object command"></a>4.7. The hash-object command</h3><p>我们希望能够将自己的数据存入仓库中。<code>hash-object</code> 基本上是 <code>cat-file</code> 的反向操作：它读取一个文件，将其计算为对象的哈希值，并在仓库中存储该对象（如果传递了 <code>-w</code> 标志），或者只是打印其哈希值。</p>
<p><code>wyag hash-object</code> 的语法是 <code>git hash-object</code> 的简化版本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wyag hash-object [-w] [-t TYPE] FILE</span><br></pre></td></tr></table></figure>

<p>这转换为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">argsp = argsubparsers.add_parser(</span><br><span class="line">    <span class="string">&quot;hash-object&quot;</span>,</span><br><span class="line">    <span class="built_in">help</span>=<span class="string">&quot;Compute object ID and optionally creates a blob from a file&quot;</span>)</span><br><span class="line"></span><br><span class="line">argsp.add_argument(<span class="string">&quot;-t&quot;</span>,</span><br><span class="line">                   metavar=<span class="string">&quot;type&quot;</span>,</span><br><span class="line">                   dest=<span class="string">&quot;type&quot;</span>,</span><br><span class="line">                   choices=[<span class="string">&quot;blob&quot;</span>, <span class="string">&quot;commit&quot;</span>, <span class="string">&quot;tag&quot;</span>, <span class="string">&quot;tree&quot;</span>],</span><br><span class="line">                   default=<span class="string">&quot;blob&quot;</span>,</span><br><span class="line">                   <span class="built_in">help</span>=<span class="string">&quot;Specify the type&quot;</span>)</span><br><span class="line"></span><br><span class="line">argsp.add_argument(<span class="string">&quot;-w&quot;</span>,</span><br><span class="line">                   dest=<span class="string">&quot;write&quot;</span>,</span><br><span class="line">                   action=<span class="string">&quot;store_true&quot;</span>,</span><br><span class="line">                   <span class="built_in">help</span>=<span class="string">&quot;Actually write the object into the database&quot;</span>)</span><br><span class="line"></span><br><span class="line">argsp.add_argument(<span class="string">&quot;path&quot;</span>,</span><br><span class="line">                   <span class="built_in">help</span>=<span class="string">&quot;Read object from &lt;file&gt;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>实际实现非常简单。像往常一样，我们创建一个小的桥接函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cmd_hash_object</span>(<span class="params">args</span>):</span><br><span class="line">    <span class="keyword">if</span> args.write:</span><br><span class="line">        repo = repo_find()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        repo = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(args.path, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> fd:</span><br><span class="line">        sha = object_hash(fd, args.<span class="built_in">type</span>.encode(), repo)</span><br><span class="line">        <span class="built_in">print</span>(sha)</span><br></pre></td></tr></table></figure>

<p>实际实现也很简单。<code>repo</code> 参数是可选的，如果它是 <code>None</code>，对象就不会被写入（这一点在上面的 <code>object_write()</code> 中处理）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">object_hash</span>(<span class="params">fd, fmt, repo=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; Hash object, writing it to repo if provided.&quot;&quot;&quot;</span></span><br><span class="line">    data = fd.read()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Choose constructor according to fmt argument</span></span><br><span class="line">    <span class="keyword">match</span> fmt:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">b&#x27;commit&#x27;</span> : obj=GitCommit(data)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">b&#x27;tree&#x27;</span>   : obj=GitTree(data)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">b&#x27;tag&#x27;</span>    : obj=GitTag(data)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">b&#x27;blob&#x27;</span>   : obj=GitBlob(data)</span><br><span class="line">        <span class="keyword">case</span> _: <span class="keyword">raise</span> Exception(<span class="string">f&quot;Unknown type <span class="subst">&#123;fmt&#125;</span>!&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> object_write(obj, repo)</span><br></pre></td></tr></table></figure>

<h3 id="4-8-Aside-what-about-packfiles"><a href="#4-8-Aside-what-about-packfiles" class="headerlink" title="4.8. Aside: what about packfiles?"></a>4.8. Aside: what about packfiles?</h3><p>我们刚刚实现的被称为“松散对象”（loose objects）。Git 还有另一种对象存储机制，称为 packfiles。Packfiles 比松散对象更高效，但也更复杂。简单来说，packfile 是松散对象的一个集合（类似于 tar 文件），但其中一些对象以增量（delta）的形式存储，即作为另一个对象的变体。Packfiles 过于复杂，wyag 无法支持它们。</p>
<p>Packfile 存储在 <code>.git/objects/pack/</code> 目录下，扩展名为 <code>.pack</code>，并附带一个同名的索引文件，扩展名为 <code>.idx</code>。如果你想将 packfile 转换为松散对象格式（例如，在现有的仓库上使用 wyag），可以使用以下方法：</p>
<p>首先，将 packfile 移出 gitdir（仅仅复制是无效的）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv .git/objects/pack/pack-d9ef004d4ca729287f12aaaacf36fee39baa7c9d.pack .</span><br></pre></td></tr></table></figure>

<p>你可以忽略 <code>.idx</code> 文件。然后，在工作区中，只需使用 <code>cat</code> 命令输出 packfile 并通过管道传递给 <code>git unpack-objects</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat pack-d9ef004d4ca729287f12aaaacf36fee39baa7c9d.pack | git unpack-objects</span><br></pre></td></tr></table></figure>

<h2 id="5-Reading-commit-history-log"><a href="#5-Reading-commit-history-log" class="headerlink" title="5. Reading commit history: log"></a>5. Reading commit history: log</h2><h3 id="5-1-Parsing-commits"><a href="#5-1-Parsing-commits" class="headerlink" title="5.1. Parsing commits"></a>5.1. Parsing commits</h3><p>现在我们已经可以读取和写入对象，我们应该考虑提交对象。一个提交对象（未压缩且不含头部）看起来像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">tree 29ff16c9c14e2652b22f8b78bb08a5a07930c147</span><br><span class="line">parent 206941306e8a8af65b66eaaaea388a7ae24d49a0</span><br><span class="line">author Thibault Polge &lt;thibault@thb.lt&gt; 1527025023 +0200</span><br><span class="line">committer Thibault Polge &lt;thibault@thb.lt&gt; 1527025044 +0200</span><br><span class="line">gpgsig -----BEGIN PGP SIGNATURE-----</span><br><span class="line"></span><br><span class="line"> iQIzBAABCAAdFiEExwXquOM8bWb4Q2zVGxM2FxoLkGQFAlsEjZQACgkQGxM2FxoL</span><br><span class="line"> kGQdcBAAqPP+ln4nGDd2gETXjvOpOxLzIMEw4A9gU6CzWzm+oB8mEIKyaH0UFIPh</span><br><span class="line"> rNUZ1j7/ZGFNeBDtT55LPdPIQw4KKlcf6kC8MPWP3qSu3xHqx12C5zyai2duFZUU</span><br><span class="line"> wqOt9iCFCscFQYqKs3xsHI+ncQb+PGjVZA8+jPw7nrPIkeSXQV2aZb1E68wa2YIL</span><br><span class="line"> 3eYgTUKz34cB6tAq9YwHnZpyPx8UJCZGkshpJmgtZ3mCbtQaO17LoihnqPn4UOMr</span><br><span class="line"> V75R/7FjSuPLS8NaZF4wfi52btXMSxO/u7GuoJkzJscP3p4qtwe6Rl9dc1XC8P7k</span><br><span class="line"> NIbGZ5Yg5cEPcfmhgXFOhQZkD0yxcJqBUcoFpnp2vu5XJl2E5I/quIyVxUXi6O6c</span><br><span class="line"> /obspcvace4wy8uO0bdVhc4nJ+Rla4InVSJaUaBeiHTW8kReSFYyMmDCzLjGIu1q</span><br><span class="line"> doU61OM3Zv1ptsLu3gUE6GU27iWYj2RWN3e3HE4Sbd89IFwLXNdSuM0ifDLZk7AQ</span><br><span class="line"> WBhRhipCCgZhkj9g2NEk7jRVslti1NdN5zoQLaJNqSwO1MtxTmJ15Ksk3QP6kfLB</span><br><span class="line"> Q52UWybBzpaP9HEd4XnR+HuQ4k2K0ns2KgNImsNvIyFwbpMUyUWLMPimaV1DWUXo</span><br><span class="line"> 5SBjDB/V/W2JBFR+XKHFJeFwYhj7DD/ocsGr4ZMx/lgc8rjIBkI=</span><br><span class="line"> =lgTX</span><br><span class="line"> -----END PGP SIGNATURE-----</span><br><span class="line"></span><br><span class="line">Create first draft</span><br></pre></td></tr></table></figure>

<p>该格式是 RFC 2822 规定的邮件消息的简化版本。它以一系列键值对开头，使用空格作为键和值的分隔符，并以提交消息结束，提交消息可能会跨多行。值可能会延续到多行，后续行以空格开头，解析器必须忽略这些空格（例如上面的 <code>gpgsig</code> 字段，它跨越了 16 行）。</p>
<p>让我们来看一下这些字段的含义：</p>
<ul>
<li><p><strong>tree</strong>：指向一个树（tree）对象，我们将在接下来介绍它。树对象将 blob ID 映射到文件系统位置，并描述工作区的状态。简单来说，它代表了提交的实际内容：文件内容以及它们的位置。</p>
</li>
<li><p><strong>parent</strong>：指向该提交的父提交。该字段可以重复，例如合并提交（merge commit）通常有多个父提交。但它也可能不存在，例如一个仓库中的第一个提交显然没有父提交。</p>
</li>
<li><p><strong>author</strong> 和 <strong>committer</strong>：它们是分开的，因为提交的作者不一定是最终提交的人（对于 GitHub 用户来说，这可能并不明显，但许多项目是通过电子邮件进行 Git 操作的）。</p>
</li>
<li><p><strong>gpgsig</strong>：该对象的 PGP 签名。</p>
</li>
</ul>
<p>我们将从编写一个简单的解析器开始，代码很直观。我们即将创建的函数名 <strong><code>kvlm_parse()</code></strong> 可能会让人困惑：它不叫 <strong><code>commit_parse()</code><strong>，因为 <strong>tag</strong> 对象使用的是完全相同的格式，因此我们会将它用于这两种对象类型。我使用 <strong>KVLM</strong> 来表示“</strong>Key-Value List with Message</strong>”（键值列表加消息）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">kvlm_parse</span>(<span class="params">raw, start=<span class="number">0</span>, dct=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> dct:</span><br><span class="line">        dct = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="comment"># You CANNOT declare the argument as dct=dict() or all call to</span></span><br><span class="line">        <span class="comment"># the functions will endlessly grow the same dict.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># This function is recursive: it reads a key/value pair, then call</span></span><br><span class="line">    <span class="comment"># itself back with the new position.  So we first need to know</span></span><br><span class="line">    <span class="comment"># where we are: at a keyword, or already in the messageQ</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># We search for the next space and the next newline.</span></span><br><span class="line">    spc = raw.find(<span class="string">b&#x27; &#x27;</span>, start)</span><br><span class="line">    nl = raw.find(<span class="string">b&#x27;\n&#x27;</span>, start)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># If space appears before newline, we have a keyword.  Otherwise,</span></span><br><span class="line">    <span class="comment"># it&#x27;s the final message, which we just read to the end of the file.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Base case</span></span><br><span class="line">    <span class="comment"># =========</span></span><br><span class="line">    <span class="comment"># If newline appears first (or there&#x27;s no space at all, in which</span></span><br><span class="line">    <span class="comment"># case find returns -1), we assume a blank line.  A blank line</span></span><br><span class="line">    <span class="comment"># means the remainder of the data is the message.  We store it in</span></span><br><span class="line">    <span class="comment"># the dictionary, with None as the key, and return.</span></span><br><span class="line">    <span class="keyword">if</span> (spc &lt; <span class="number">0</span>) <span class="keyword">or</span> (nl &lt; spc):</span><br><span class="line">        <span class="keyword">assert</span> nl == start</span><br><span class="line">        dct[<span class="literal">None</span>] = raw[start+<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">return</span> dct</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Recursive case</span></span><br><span class="line">    <span class="comment"># ==============</span></span><br><span class="line">    <span class="comment"># we read a key-value pair and recurse for the next.</span></span><br><span class="line">    key = raw[start:spc]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Find the end of the value.  Continuation lines begin with a</span></span><br><span class="line">    <span class="comment"># space, so we loop until we find a &quot;\n&quot; not followed by a space.</span></span><br><span class="line">    end = start</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        end = raw.find(<span class="string">b&#x27;\n&#x27;</span>, end+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> raw[end+<span class="number">1</span>] != <span class="built_in">ord</span>(<span class="string">&#x27; &#x27;</span>): <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Grab the value</span></span><br><span class="line">    <span class="comment"># Also, drop the leading space on continuation lines</span></span><br><span class="line">    value = raw[spc+<span class="number">1</span>:end].replace(<span class="string">b&#x27;\n &#x27;</span>, <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Don&#x27;t overwrite existing data contents</span></span><br><span class="line">    <span class="keyword">if</span> key <span class="keyword">in</span> dct:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(dct[key]) == <span class="built_in">list</span>:</span><br><span class="line">            dct[key].append(value)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dct[key] = [ dct[key], value ]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        dct[key]=value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> kvlm_parse(raw, start=end+<span class="number">1</span>, dct=dct)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>Note</strong></th>
</tr>
</thead>
<tbody><tr>
<td>对象标识规则<br />我们使用 <strong>字典（HashMap）</strong> 来存储键&#x2F;值关联，但我们依赖于 <strong>Python 字典的一个特性</strong>：它会保留插入顺序。这意味着当我们将对象写回时，我们会按字典中字段的添加顺序进行迭代，并以完全相同的顺序输出字段。这一点很重要，因为 Git 对对象标识有两个严格的规则：<br />1. <strong>相同的名称始终引用相同的对象</strong><br/>我们之前已经看到过这个规则，它是 Git 计算对象名称的方法的直接结果 —— <strong>对象的名称是其内容的哈希值</strong>。<br />2. <strong>相同的对象始终具有相同的名称</strong><br/>这条规则稍微复杂一些：它意味着 <strong>不应该存在两个等效但名称不同的对象</strong>。<br/>例如，在 Git 中，如果我们更改提交对象中字段的顺序（比如将 <code>tree</code> 字段放在 <code>parent</code> 之后），那么提交对象的 <strong>SHA-1 哈希值</strong> 也会改变，从而创建出两个 <strong>等效但哈希不同</strong> 的提交对象。<br />例如，在比较 <strong>tree 对象</strong> 时，Git 会假设 <strong>哈希不同的两个 tree 是不同的</strong>，这就是为什么在存储 tree 对象时，我们必须确保 <strong>其中的元素按正确顺序排序</strong>，以防止生成 <strong>等效但哈希不同的 tree</strong>。</td>
</tr>
</tbody></table>
<p>我们还需要写类似的对象，因此让我们向工具包中添加一个 <code>kvlm_serialize()</code> 函数。这非常简单：我们先写所有的字段，然后是一个换行符，接着是消息内容，最后再是一个换行符。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">kvlm_serialize</span>(<span class="params">kvlm</span>):</span><br><span class="line">    ret = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Output fields</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> kvlm.keys():</span><br><span class="line">        <span class="comment"># Skip the message itself</span></span><br><span class="line">        <span class="keyword">if</span> k == <span class="literal">None</span>: <span class="keyword">continue</span></span><br><span class="line">        val = kvlm[k]</span><br><span class="line">        <span class="comment"># Normalize to a list</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(val) != <span class="built_in">list</span>:</span><br><span class="line">            val = [ val ]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> val:</span><br><span class="line">            ret += k + <span class="string">b&#x27; &#x27;</span> + (v.replace(<span class="string">b&#x27;\n&#x27;</span>, <span class="string">b&#x27;\n &#x27;</span>)) + <span class="string">b&#x27;\n&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Append message</span></span><br><span class="line">    ret += <span class="string">b&#x27;\n&#x27;</span> + kvlm[<span class="literal">None</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<h3 id="5-2-The-Commit-object"><a href="#5-2-The-Commit-object" class="headerlink" title="5.2. The Commit object"></a>5.2. The Commit object</h3><p>现在我们有了解析器，我们可以创建 <code>GitCommit</code> 类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GitCommit</span>(<span class="title class_ inherited__">GitObject</span>):</span><br><span class="line">    fmt=<span class="string">b&#x27;commit&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deserialize</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="variable language_">self</span>.kvlm = kvlm_parse(data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">serialize</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> kvlm_serialize(<span class="variable language_">self</span>.kvlm)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">init</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.kvlm = <span class="built_in">dict</span>()</span><br></pre></td></tr></table></figure>

<h3 id="5-3-The-log-command"><a href="#5-3-The-log-command" class="headerlink" title="5.3. The log command"></a>5.3. The log command</h3><p>我们将实现一个比 Git 提供的版本简单得多的日志功能。最重要的是，我们不会处理日志的表示。相反，我们将输出 Graphviz 数据，让用户使用 dot 来渲染实际的日志。（如果你不知道如何使用 Graphviz，只需将原始输出粘贴到<a target="_blank" rel="noopener" href="https://dreampuf.github.io/GraphvizOnline/">这个网站</a>中。如果该链接无法访问，可以在你喜欢的搜索引擎中搜索“graphviz online”）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">argsp = argsubparsers.add_parser(<span class="string">&quot;log&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;Display history of a given commit.&quot;</span>)</span><br><span class="line">argsp.add_argument(<span class="string">&quot;commit&quot;</span>,</span><br><span class="line">                   default=<span class="string">&quot;HEAD&quot;</span>,</span><br><span class="line">                   nargs=<span class="string">&quot;?&quot;</span>,</span><br><span class="line">                   <span class="built_in">help</span>=<span class="string">&quot;Commit to start at.&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cmd_log</span>(<span class="params">args</span>):</span><br><span class="line">    repo = repo_find()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;digraph wyaglog&#123;&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;  node[shape=rect]&quot;</span>)</span><br><span class="line">    log_graphviz(repo, object_find(repo, args.commit), <span class="built_in">set</span>())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log_graphviz</span>(<span class="params">repo, sha, seen</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> sha <span class="keyword">in</span> seen:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    seen.add(sha)</span><br><span class="line"></span><br><span class="line">    commit = object_read(repo, sha)</span><br><span class="line">    message = commit.kvlm[<span class="literal">None</span>].decode(<span class="string">&quot;utf8&quot;</span>).strip()</span><br><span class="line">    message = message.replace(<span class="string">&quot;\\&quot;</span>, <span class="string">&quot;\\\\&quot;</span>)</span><br><span class="line">    message = message.replace(<span class="string">&quot;\&quot;&quot;</span>, <span class="string">&quot;\\\&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;\n&quot;</span> <span class="keyword">in</span> message: <span class="comment"># Keep only the first line</span></span><br><span class="line">        message = message[:message.index(<span class="string">&quot;\n&quot;</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;  c_<span class="subst">&#123;sha&#125;</span> [label=\&quot;<span class="subst">&#123;sha[<span class="number">0</span>:<span class="number">7</span>]&#125;</span>: <span class="subst">&#123;message&#125;</span>\&quot;]&quot;</span>)</span><br><span class="line">    <span class="keyword">assert</span> commit.fmt==<span class="string">b&#x27;commit&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="string">b&#x27;parent&#x27;</span> <span class="keyword">in</span> commit.kvlm.keys():</span><br><span class="line">        <span class="comment"># Base case: the initial commit.</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    parents = commit.kvlm[<span class="string">b&#x27;parent&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(parents) != <span class="built_in">list</span>:</span><br><span class="line">        parents = [ parents ]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> parents:</span><br><span class="line">        p = p.decode(<span class="string">&quot;ascii&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">f&quot;  c_<span class="subst">&#123;sha&#125;</span> -&gt; c_<span class="subst">&#123;p&#125;</span>;&quot;</span>)</span><br><span class="line">        log_graphviz(repo, p, seen)</span><br></pre></td></tr></table></figure>

<p>你现在可以像这样使用我们的 log 命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wyag log e03158242ecab460f31b0d6ae1642880577ccbe8 &gt; log.dot</span><br><span class="line">dot -O -Tpdf log.dot</span><br></pre></td></tr></table></figure>

<h3 id="5-4-Anatomy-of-a-commit"><a href="#5-4-Anatomy-of-a-commit" class="headerlink" title="5.4. Anatomy of a commit"></a>5.4. Anatomy of a commit</h3><p>你现在可能注意到了一些事情。</p>
<p>首先也是最重要的一点，我们一直在处理提交，浏览和遍历提交对象，构建提交历史的图形，而从未触及工作树中的任何文件或 Blob。我们做了很多关于提交的事情，但没有考虑它们的内容。这一点很重要：工作树的内容只是提交的一部分。但一个提交由它所包含的一切组成：它的内容、它的作者，还有它的父提交。如果你记得提交的 ID（SHA-1 哈希）是从整个提交对象计算出来的，你就会明白为什么提交是不可变的：如果你更改了作者、父提交或单个文件，你实际上创建了一个新的、不同的对象。每一个提交都与其所在的位置及其与整个仓库的关系绑定，直到第一个提交。换句话说，一个给定的提交 ID 不仅标识了一些文件内容，它还将提交与其完整的历史和整个仓库绑定在一起。</p>
<p>还值得注意的是，从提交的角度来看，时间似乎是倒流的：我们通常是从项目的谦逊起步开始考虑历史，最初可能是作为一种消磨时间的活动，开始时只有几行代码，一些初步的提交，随后逐渐发展到现在的状态（成千上万行代码，几十个贡献者等等）。但是每个提交完全不知未来的情况，它只与过去相连接。提交有“记忆”，但没有预感。</p>
<p>那么，是什么构成了一个提交呢？总结一下：</p>
<ul>
<li>一个树对象，即工作树的内容，文件和目录；</li>
<li>零个、一个或多个父提交；</li>
<li>一个作者身份（姓名和电子邮件），以及一个时间戳；</li>
<li>一个提交者身份（姓名和电子邮件），以及一个时间戳；</li>
<li>一个可选的 PGP 签名；</li>
<li>一条消息；</li>
<li>所有这些内容哈希在一起，生成一个唯一的 SHA-1 标识符。</li>
</ul>
<table>
<thead>
<tr>
<th><strong>Note</strong></th>
</tr>
</thead>
<tbody><tr>
<td>等一下，这是否意味着 Git 是区块链？<br />因为加密货币的原因，区块链现在非常火。确实，在某种程度上，Git 可以被视为一个区块链：它是一系列由加密手段连接在一起的区块（提交），以确保每一个元素都与整个历史关联起来。不过，不必太认真地对比这两者：我们不需要 GitCoin，真的。</td>
</tr>
</tbody></table>
<h2 id="6-Reading-commit-data-checkout"><a href="#6-Reading-commit-data-checkout" class="headerlink" title="6. Reading commit data: checkout"></a>6. Reading commit data: checkout</h2><p>虽然提交包含了比文件和目录更丰富的信息，但这并不意味着它们就很有用。现在可能是时候开始实现树对象了，这样我们才能将提交检出到工作树中。</p>
<h3 id="6-1-What’s-in-a-tree"><a href="#6-1-What’s-in-a-tree" class="headerlink" title="6.1. What’s in a tree?"></a>6.1. What’s in a tree?</h3><p>非正式地说，树描述了工作树的内容，也就是说，它将 blobs 与路径关联起来。它是由三元组组成的数组，每个三元组包含一个文件模式、一个路径（相对于工作树）和一个 SHA-1。一个典型的树内容可能如下所示：</p>
<table>
<thead>
<tr>
<th><strong>Mode</strong></th>
<th>SHA-1</th>
<th><strong>Path</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>100644</code></td>
<td><code>894a44cc066a027465cd26d634948d56d13af9af</code></td>
<td><code>.gitignore</code></td>
</tr>
<tr>
<td><code>100644</code></td>
<td><code>94a9ed024d3859793618152ea559a168bbcbb5e2</code></td>
<td><code>LICENSE</code></td>
</tr>
<tr>
<td><code>100644</code></td>
<td><code>bab489c4f4600a38ce6dbfd652b90383a4aa3e45</code></td>
<td><code>README.md</code></td>
</tr>
<tr>
<td><code>100644</code></td>
<td><code>6d208e47659a2a10f5f8640e0155d9276a2130a9</code></td>
<td><code>src</code></td>
</tr>
<tr>
<td><code>040000</code></td>
<td><code>e7445b03aea61ec801b20d6ab62f076208b7d097</code></td>
<td><code>tests</code></td>
</tr>
<tr>
<td><code>040000</code></td>
<td><code>d5ec863f17f3a2e92aa8f6b66ac18f7b09fd1b38</code></td>
<td><code>main.c</code></td>
</tr>
</tbody></table>
<p>模式只是文件的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/File-system_permissions">模式</a>，路径是其位置。SHA-1 引用的是 blob 或另一个树对象。如果是 blob，路径是文件；如果是树，它是目录。为了在文件系统中实例化这棵树，我们将从加载与第一个路径（.gitignore）相关的对象开始，并检查它的类型。由于它是一个 blob，我们将创建一个名为 .gitignore 的文件，并填充该 blob 的内容；LICENSE 和 README.md 也按同样的方法处理。但是与 src 相关联的对象不是一个 blob，而是另一棵树：我们将创建目录 src，并在该目录中对新的树重复相同的操作。</p>
<table>
<thead>
<tr>
<th><strong>Warning</strong></th>
</tr>
</thead>
<tbody><tr>
<td>路径是一个单一的文件系统条目<br />路径准确地标识一个文件或目录。不是两个，也不是三个。如果你有五级嵌套的目录，即使其中四个除了下一个目录外都是空的，你也需要五个树对象，递归地相互引用。你不能通过将一个完整的路径放在单个树条目中来走捷径，比如 dir1&#x2F;dir2&#x2F;dir3&#x2F;dir4&#x2F;dir5。</td>
</tr>
</tbody></table>
<h3 id="6-2-Parsing-trees"><a href="#6-2-Parsing-trees" class="headerlink" title="6.2. Parsing trees"></a>6.2. Parsing trees</h3><p>与标签和提交不同，树对象是二进制对象，但它们的格式实际上非常简单。一个树是由以下格式的记录连接而成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[mode] space [path] 0x00 [sha-1]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>[mode] 是最多六个字节，是文件模式的八进制表示，以 ASCII 存储。例如，100644 使用字节值 49（ASCII “1”），48（ASCII “0”），48，54，52，54 来编码。前两位数字编码文件类型（文件、目录、符号链接或子模块），最后四位是权限。</p>
</li>
<li><p>它后面跟着 0x20，一个 ASCII 空格；</p>
</li>
<li><p>接下来是以 null 终止的（0x00）路径；</p>
</li>
<li><p>然后是对象的 SHA-1，以二进制编码，长度为 20 字节。</p>
</li>
</ul>
<p>解析器将非常简单。首先，为单个记录（叶子，单个路径）创建一个小的对象封装器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GitTreeLeaf</span> (<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, mode, path, sha</span>):</span><br><span class="line">        <span class="variable language_">self</span>.mode = mode</span><br><span class="line">        <span class="variable language_">self</span>.path = path</span><br><span class="line">        <span class="variable language_">self</span>.sha = sha</span><br></pre></td></tr></table></figure>

<p>因为树对象只是相同基本数据结构的重复，我们将解析器写成两个函数。首先，编写一个解析单个记录的函数，返回解析的数据和它在输入数据中到达的位置：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tree_parse_one</span>(<span class="params">raw, start=<span class="number">0</span></span>):</span><br><span class="line">    <span class="comment"># Find the space terminator of the mode</span></span><br><span class="line">    x = raw.find(<span class="string">b&#x27; &#x27;</span>, start)</span><br><span class="line">    <span class="keyword">assert</span> x-start == <span class="number">5</span> <span class="keyword">or</span> x-start==<span class="number">6</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Read the mode</span></span><br><span class="line">    mode = raw[start:x]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(mode) == <span class="number">5</span>:</span><br><span class="line">        <span class="comment"># Normalize to six bytes.</span></span><br><span class="line">        mode = <span class="string">b&quot;0&quot;</span> + mode</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Find the NULL terminator of the path</span></span><br><span class="line">    y = raw.find(<span class="string">b&#x27;\x00&#x27;</span>, x)</span><br><span class="line">    <span class="comment"># and read the path</span></span><br><span class="line">    path = raw[x+<span class="number">1</span>:y]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Read the SHA…</span></span><br><span class="line">    raw_sha = <span class="built_in">int</span>.from_bytes(raw[y+<span class="number">1</span>:y+<span class="number">21</span>], <span class="string">&quot;big&quot;</span>)</span><br><span class="line">    <span class="comment"># and convert it into an hex string, padded to 40 chars</span></span><br><span class="line">    <span class="comment"># with zeros if needed.</span></span><br><span class="line">    sha = <span class="built_in">format</span>(raw_sha, <span class="string">&quot;040x&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> y+<span class="number">21</span>, GitTreeLeaf(mode, path.decode(<span class="string">&quot;utf8&quot;</span>), sha)</span><br></pre></td></tr></table></figure>

<p>然后是“真正的”解析器，它只是循环调用前一个解析器，直到输入数据耗尽。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tree_parse</span>(<span class="params">raw</span>):</span><br><span class="line">    pos = <span class="number">0</span></span><br><span class="line">    <span class="built_in">max</span> = <span class="built_in">len</span>(raw)</span><br><span class="line">    ret = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">while</span> pos &lt; <span class="built_in">max</span>:</span><br><span class="line">        pos, data = tree_parse_one(raw, pos)</span><br><span class="line">        ret.append(data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<p>最终，我们需要一个序列化器来将树对象写回去。由于我们可能已经添加或修改了条目，因此需要对它们重新排序。保持一致的排序很重要，因为我们需要遵守 Git 的<a target="_blank" rel="noopener" href="https://wyag.thb.lt/#org2616760">身份规则</a>，该规则规定不能有两个等效的对象具有不同的哈希值——但是如果相同内容的树对象排序不同，它们仍然是等效的（描述相同的目录结构），但在数值上是不同的（不同的 SHA-1 标识符）。不正确排序的树对象是无效的，但 Git 并不会强制执行这一点。我在编写 wyag 时意外创建了一些无效的树对象，结果导致 Git 状态显示奇怪的错误（具体来说，<code>git status</code> 会报告一个实际上是干净的工作区被完全修改）。我们不希望发生这种情况。</p>
<p>排序函数非常简单，但有一个意想不到的细节。条目是按名称按字母顺序排序的，但目录（即树对象的条目）会在末尾添加一个 <code>/</code> 进行排序。这一点很重要，因为这意味着如果 <code>whatever</code> 是一个普通文件，它将在 <code>whatever.c</code> 之前排序，但如果 <code>whatever</code> 是一个目录，它将作为 <code>whatever/</code> 排序在后。（我不确定 Git 为什么这样做。如果你感兴趣，可以查看 Git 源码中 <code>tree.c</code> 文件里的 <code>base_name_compare</code> 函数。）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Notice this isn&#x27;t a comparison function, but a conversion function.</span></span><br><span class="line"><span class="comment"># Python&#x27;s default sort doesn&#x27;t accept a custom comparison function,</span></span><br><span class="line"><span class="comment"># like in most languages, but a `key` arguments that returns a new</span></span><br><span class="line"><span class="comment"># value, which is compared using the default rules.  So we just return</span></span><br><span class="line"><span class="comment"># the leaf name, with an extra / if it&#x27;s a directory.</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tree_leaf_sort_key</span>(<span class="params">leaf</span>):</span><br><span class="line">    <span class="keyword">if</span> leaf.mode.startswith(<span class="string">b&quot;10&quot;</span>):</span><br><span class="line">        <span class="keyword">return</span> leaf.path</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> leaf.path + <span class="string">&quot;/&quot;</span></span><br></pre></td></tr></table></figure>

<p>然后是序列化器本身。这部分非常简单：我们使用新创建的转换函数对项进行排序，然后按顺序写入。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tree_serialize</span>(<span class="params">obj</span>):</span><br><span class="line">    obj.items.sort(key=tree_leaf_sort_key)</span><br><span class="line">    ret = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> obj.items:</span><br><span class="line">        ret += i.mode</span><br><span class="line">        ret += <span class="string">b&#x27; &#x27;</span></span><br><span class="line">        ret += i.path.encode(<span class="string">&quot;utf8&quot;</span>)</span><br><span class="line">        ret += <span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line">        sha = <span class="built_in">int</span>(i.sha, <span class="number">16</span>)</span><br><span class="line">        ret += sha.to_bytes(<span class="number">20</span>, byteorder=<span class="string">&quot;big&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<p>现在，我们只需要将所有内容组合到一个类中即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GitTree</span>(<span class="title class_ inherited__">GitObject</span>):</span><br><span class="line">    fmt=<span class="string">b&#x27;tree&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deserialize</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="variable language_">self</span>.items = tree_parse(data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">serialize</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> tree_serialize(<span class="variable language_">self</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">init</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.items = <span class="built_in">list</span>()</span><br></pre></td></tr></table></figure>

<h3 id="6-3-Showing-trees-ls-tree"><a href="#6-3-Showing-trees-ls-tree" class="headerlink" title="6.3. Showing trees: ls-tree"></a>6.3. Showing trees: ls-tree</h3><p>既然如此，我们顺便给 wyag 添加 <code>ls-tree</code> 命令吧。这么简单的功能，没有理由不加。<code>git ls-tree [-r] TREE</code> 只是打印树的内容，带 <code>-r</code> 标志时会递归打印。在递归模式下，它不会显示子树，而是仅显示最终对象及其完整路径。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">argsp = argsubparsers.add_parser(<span class="string">&quot;ls-tree&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;Pretty-print a tree object.&quot;</span>)</span><br><span class="line">argsp.add_argument(<span class="string">&quot;-r&quot;</span>,</span><br><span class="line">                   dest=<span class="string">&quot;recursive&quot;</span>,</span><br><span class="line">                   action=<span class="string">&quot;store_true&quot;</span>,</span><br><span class="line">                   <span class="built_in">help</span>=<span class="string">&quot;Recurse into sub-trees&quot;</span>)</span><br><span class="line"></span><br><span class="line">argsp.add_argument(<span class="string">&quot;tree&quot;</span>,</span><br><span class="line">                   <span class="built_in">help</span>=<span class="string">&quot;A tree-ish object.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd_ls_tree</span>(<span class="params">args</span>):</span><br><span class="line">    repo = repo_find()</span><br><span class="line">    ls_tree(repo, args.tree, args.recursive)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ls_tree</span>(<span class="params">repo, ref, recursive=<span class="literal">None</span>, prefix=<span class="string">&quot;&quot;</span></span>):</span><br><span class="line">    sha = object_find(repo, ref, fmt=<span class="string">b&quot;tree&quot;</span>)</span><br><span class="line">    obj = object_read(repo, sha)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> obj.items:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(item.mode) == <span class="number">5</span>:</span><br><span class="line">            <span class="built_in">type</span> = item.mode[<span class="number">0</span>:<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">type</span> = item.mode[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">match</span> <span class="built_in">type</span>: <span class="comment"># Determine the type.</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">b&#x27;04&#x27;</span>: <span class="built_in">type</span> = <span class="string">&quot;tree&quot;</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">b&#x27;10&#x27;</span>: <span class="built_in">type</span> = <span class="string">&quot;blob&quot;</span> <span class="comment"># A regular file.</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">b&#x27;12&#x27;</span>: <span class="built_in">type</span> = <span class="string">&quot;blob&quot;</span> <span class="comment"># A symlink. Blob contents is link target.</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">b&#x27;16&#x27;</span>: <span class="built_in">type</span> = <span class="string">&quot;commit&quot;</span> <span class="comment"># A submodule</span></span><br><span class="line">            <span class="keyword">case</span> _: <span class="keyword">raise</span> Exception(<span class="string">f&quot;Weird tree leaf mode <span class="subst">&#123;item.mode&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (recursive <span class="keyword">and</span> <span class="built_in">type</span>==<span class="string">&#x27;tree&#x27;</span>): <span class="comment"># This is a leaf</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;<span class="string">&#x27;0&#x27;</span> * (<span class="number">6</span> - <span class="built_in">len</span>(item.mode)) + item.mode.decode(<span class="string">&quot;ascii&quot;</span>)&#125;</span> <span class="subst">&#123;<span class="built_in">type</span>&#125;</span> <span class="subst">&#123;item.sha&#125;</span>\t<span class="subst">&#123;os.path.join(prefix, item.path)&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># This is a branch, recurse</span></span><br><span class="line">            ls_tree(repo, item.sha, recursive, os.path.join(prefix, item.path))</span><br></pre></td></tr></table></figure>

<h3 id="6-4-The-checkout-command"><a href="#6-4-The-checkout-command" class="headerlink" title="6.4. The checkout command"></a>6.4. The checkout command</h3><p><code>git checkout</code> 只是将某个提交实例化到工作区。为了让我们的实现清晰易懂，我们将对实际的 <code>git checkout</code> 命令进行简化，同时添加一些安全措施。我们的 <code>checkout</code> 版本将按以下方式工作：</p>
<ul>
<li>它需要两个参数：一个提交（commit）和一个目录（directory）。Git 的 <code>checkout</code> 命令只需要一个提交。</li>
<li>它会在指定目录中实例化该提交的树，但<strong>仅当该目录为空</strong>时才进行操作。Git 具有许多安全机制来防止数据丢失，而在 wyag 中尝试完全复现这些机制既复杂又不安全。由于 wyag 的目的是演示 Git，而不是提供完整的实现，这一限制是可以接受的。</li>
</ul>
<p>让我们开始实现。如往常一样，我们需要一个子解析器（subparser）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">argsp = argsubparsers.add_parser(<span class="string">&quot;checkout&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;Checkout a commit inside of a directory.&quot;</span>)</span><br><span class="line"></span><br><span class="line">argsp.add_argument(<span class="string">&quot;commit&quot;</span>,</span><br><span class="line">                   <span class="built_in">help</span>=<span class="string">&quot;The commit or tree to checkout.&quot;</span>)</span><br><span class="line"></span><br><span class="line">argsp.add_argument(<span class="string">&quot;path&quot;</span>,</span><br><span class="line">                   <span class="built_in">help</span>=<span class="string">&quot;The EMPTY directory to checkout on.&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>一个包装函数（wrapper function）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cmd_checkout</span>(<span class="params">args</span>):</span><br><span class="line">    repo = repo_find()</span><br><span class="line"></span><br><span class="line">    obj = object_read(repo, object_find(repo, args.commit))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># If the object is a commit, we grab its tree</span></span><br><span class="line">    <span class="keyword">if</span> obj.fmt == <span class="string">b&#x27;commit&#x27;</span>:</span><br><span class="line">        obj = object_read(repo, obj.kvlm[<span class="string">b&#x27;tree&#x27;</span>].decode(<span class="string">&quot;ascii&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Verify that path is an empty directory</span></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(args.path):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(args.path):</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">f&quot;Not a directory <span class="subst">&#123;args.path&#125;</span>!&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> os.listdir(args.path):</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">f&quot;Not empty <span class="subst">&#123;args.path&#125;</span>!&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        os.makedirs(args.path)</span><br><span class="line"></span><br><span class="line">    tree_checkout(repo, obj, os.path.realpath(args.path))</span><br></pre></td></tr></table></figure>

<p>以及一个执行实际工作的函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tree_checkout</span>(<span class="params">repo, tree, path</span>):</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> tree.items:</span><br><span class="line">        obj = object_read(repo, item.sha)</span><br><span class="line">        dest = os.path.join(path, item.path)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> obj.fmt == <span class="string">b&#x27;tree&#x27;</span>:</span><br><span class="line">            os.mkdir(dest)</span><br><span class="line">            tree_checkout(repo, obj, dest)</span><br><span class="line">        <span class="keyword">elif</span> obj.fmt == <span class="string">b&#x27;blob&#x27;</span>:</span><br><span class="line">            <span class="comment"># @TODO Support symlinks (identified by mode 12****)</span></span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(dest, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(obj.blobdata)</span><br></pre></td></tr></table></figure>

<h2 id="7-Refs-tags-and-branches"><a href="#7-Refs-tags-and-branches" class="headerlink" title="7. Refs, tags and branches"></a>7. Refs, tags and branches</h2><h3 id="7-1-What-a-ref-is-and-the-show-ref-command"><a href="#7-1-What-a-ref-is-and-the-show-ref-command" class="headerlink" title="7.1. What a ref is, and the show-ref command"></a>7.1. What a ref is, and the show-ref command</h3><p>到目前为止，我们唯一可以引用对象的方式是使用完整的十六进制标识符。然而，在 git 中，我们实际上很少看到这些标识符，除了在讨论特定提交时。通常，我们会使用 HEAD，或者某个名为 main 或 feature&#x2F;more-bombs 的分支名称等。这是通过一个简单的机制——引用（references）来处理的。</p>
<p>Git 引用（refs）可能是 git 存储的最简单的内容。它们位于 <code>.git/refs</code> 的子目录中，并且是包含对象哈希值的文本文件，使用 ASCII 编码。它们实际上就是这样简单：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6071c08bcb4757d8c89a30d9755d2466cef8c1de</span><br></pre></td></tr></table></figure>

<p>引用（Refs）也可以间接地引用对象，即引用另一个引用，在这种情况下，它们看起来像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ref: refs/remotes/origin/master</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>Note</strong></th>
</tr>
</thead>
<tbody><tr>
<td>直接和间接引用<br />从现在开始，我将把形式为 <code>ref: path/to/other/ref</code> 的引用称为间接引用，而把包含 SHA-1 对象 ID 的引用称为直接引用。</td>
</tr>
</tbody></table>
<p>这一部分将描述引用（refs）的用途。目前，最重要的是：</p>
<ul>
<li>它们是文本文件，位于 <code>.git/refs</code> 目录结构中；</li>
<li>它们保存一个对象的 SHA-1 标识符，或者引用另一个引用，最终指向一个 SHA-1（没有循环！）</li>
</ul>
<p>为了操作引用，我们首先需要一个简单的递归解析器，它将接受一个引用名称，跟踪可能存在的递归引用（即以 <code>ref:</code> 开头的引用，如上所示），并返回最终的 SHA-1 标识符：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">ref_resolve</span>(<span class="params">repo, ref</span>):</span><br><span class="line">    path = repo_file(repo, ref)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Sometimes, an indirect reference may be broken.  This is normal</span></span><br><span class="line">    <span class="comment"># in one specific case: we&#x27;re looking for HEAD on a new repository</span></span><br><span class="line">    <span class="comment"># with no commits.  In that case, .git/HEAD points to &quot;ref:</span></span><br><span class="line">    <span class="comment"># refs/heads/main&quot;, but .git/refs/heads/main doesn&#x27;t exist yet</span></span><br><span class="line">    <span class="comment"># (since there&#x27;s no commit for it to refer to).</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.isfile(path):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        data = fp.read()[:-<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># Drop final \n ^^^^^</span></span><br><span class="line">    <span class="keyword">if</span> data.startswith(<span class="string">&quot;ref: &quot;</span>):</span><br><span class="line">        <span class="keyword">return</span> ref_resolve(repo, data[<span class="number">5</span>:])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>

<p>让我们创建两个小函数，并实现 <code>show-refs</code> 命令——它仅列出仓库中的所有引用。首先，创建一个简单的递归函数来收集引用，并将它们作为字典返回：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">ref_list</span>(<span class="params">repo, path=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> path:</span><br><span class="line">        path = repo_dir(repo, <span class="string">&quot;refs&quot;</span>)</span><br><span class="line">    ret = <span class="built_in">dict</span>()</span><br><span class="line">    <span class="comment"># Git shows refs sorted.  To do the same, we sort the output of</span></span><br><span class="line">    <span class="comment"># listdir</span></span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> <span class="built_in">sorted</span>(os.listdir(path)):</span><br><span class="line">        can = os.path.join(path, f)</span><br><span class="line">        <span class="keyword">if</span> os.path.isdir(can):</span><br><span class="line">            ret[f] = ref_list(repo, can)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ret[f] = ref_resolve(repo, can)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<p>以及，像往常一样，一个子解析器，一个桥接函数和一个（递归）工作函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">argsp = argsubparsers.add_parser(<span class="string">&quot;show-ref&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;List references.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd_show_ref</span>(<span class="params">args</span>):</span><br><span class="line">    repo = repo_find()</span><br><span class="line">    refs = ref_list(repo)</span><br><span class="line">    show_ref(repo, refs, prefix=<span class="string">&quot;refs&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_ref</span>(<span class="params">repo, refs, with_hash=<span class="literal">True</span>, prefix=<span class="string">&quot;&quot;</span></span>):</span><br><span class="line">    <span class="keyword">if</span> prefix:</span><br><span class="line">        prefix = prefix + <span class="string">&#x27;/&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> refs.items():</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(v) == <span class="built_in">str</span> <span class="keyword">and</span> with_hash:</span><br><span class="line">            <span class="built_in">print</span> (<span class="string">f&quot;<span class="subst">&#123;v&#125;</span> <span class="subst">&#123;prefix&#125;</span><span class="subst">&#123;k&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">type</span>(v) == <span class="built_in">str</span>:</span><br><span class="line">            <span class="built_in">print</span> (<span class="string">f&quot;<span class="subst">&#123;prefix&#125;</span><span class="subst">&#123;k&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            show_ref(repo, v, with_hash=with_hash, prefix=<span class="string">f&quot;<span class="subst">&#123;prefix&#125;</span><span class="subst">&#123;k&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="7-2-Tags-as-references"><a href="#7-2-Tags-as-references" class="headerlink" title="7.2. Tags as references"></a>7.2. Tags as references</h3><p>refs的最简单用途是标签。标签只是一个用户定义的对象名称，通常是一个提交。标签的一个非常常见的用途是标识软件版本：例如，您刚刚合并了程序的版本12.78.52的最后一个提交，所以您最近的提交（我们称之为<code>6071c08</code>）就是您的版本12.78.52。为了使这种关联显式化，您只需要这样做：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag v12.78.52 6071c08</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">the object <span class="built_in">hash</span> ^here^^ is optional and defaults to HEAD.</span></span><br></pre></td></tr></table></figure>

<p>这会创建一个新的标签，叫做 <code>v12.78.52</code>，指向 <code>6071c08</code>。标签就像别名：标签为现有对象引入了一种新的引用方式。标签创建之后，<code>v12.78.52</code> 这个名称就指向了 <code>6071c08</code>。例如，下面这两个命令现在是完全等价的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout v12.78.52</span><br><span class="line">git checkout 6071c08</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>Note</strong></th>
</tr>
</thead>
<tbody><tr>
<td>版本是标签的一个常见用途，但像 Git 中几乎所有东西一样，标签没有预定义的语义：它们的意义由你决定，并且可以指向你想指向的任何对象，甚至可以为 blobs 打标签！</td>
</tr>
</tbody></table>
<h3 id="7-3-Lightweight-tags-and-tag-objects-and-parsing-the-latter"><a href="#7-3-Lightweight-tags-and-tag-objects-and-parsing-the-latter" class="headerlink" title="7.3. Lightweight tags and tag objects, and parsing the latter"></a>7.3. Lightweight tags and tag objects, and parsing the latter</h3><p>你可能已经猜到了，标签实际上就是 refs。它们位于 <code>.git/refs/tags/</code> 层级。唯一需要注意的地方是，它们有两种类型：轻量标签和标签对象。</p>
<p>“轻量级”标签只是指向提交、树或 Blob 的常规 refs。 标签对象是指向类型为 tag 的对象的常规 refs。与轻量标签不同，标签对象具有作者、日期、可选的 PGP 签名和可选的注释。它们的格式与提交对象相同。</p>
<p>我们甚至不需要实现标签对象，可以重用 <code>GitCommit</code> 类，只需更改 <code>fmt</code> 字段即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GitTag</span>(<span class="title class_ inherited__">GitCommit</span>):</span><br><span class="line">    fmt = <span class="string">b&#x27;tag&#x27;</span></span><br></pre></td></tr></table></figure>

<p>现在我们支持标签了。</p>
<h3 id="7-4-The-tag-command"><a href="#7-4-The-tag-command" class="headerlink" title="7.4. The tag command"></a>7.4. The tag command</h3><p>让我们添加 <code>tag</code> 命令。在 Git 中，它做两件事：创建一个新的标签或列出现有标签（默认情况下）。所以你可以用以下方式调用它：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git tag                  # List all tags</span><br><span class="line">git tag NAME [OBJECT]    # create a new *lightweight* tag NAME, pointing</span><br><span class="line">                         # at HEAD (default) or OBJECT</span><br><span class="line">git tag -a NAME [OBJECT] # create a new tag *object* NAME, pointing at</span><br><span class="line">                         # HEAD (default) or OBJECT</span><br></pre></td></tr></table></figure>

<p>这在 argparse 中的实现如下。请注意，我们忽略了 <code>--list</code> 和 <code>[-a] name [object]</code> 之间的互斥关系，因为对于 argparse 来说，这看起来太复杂了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">argsp = argsubparsers.add_parser(</span><br><span class="line">    <span class="string">&quot;tag&quot;</span>,</span><br><span class="line">    <span class="built_in">help</span>=<span class="string">&quot;List and create tags&quot;</span>)</span><br><span class="line"></span><br><span class="line">argsp.add_argument(<span class="string">&quot;-a&quot;</span>,</span><br><span class="line">                   action=<span class="string">&quot;store_true&quot;</span>,</span><br><span class="line">                   dest=<span class="string">&quot;create_tag_object&quot;</span>,</span><br><span class="line">                   <span class="built_in">help</span>=<span class="string">&quot;Whether to create a tag object&quot;</span>)</span><br><span class="line"></span><br><span class="line">argsp.add_argument(<span class="string">&quot;name&quot;</span>,</span><br><span class="line">                   nargs=<span class="string">&quot;?&quot;</span>,</span><br><span class="line">                   <span class="built_in">help</span>=<span class="string">&quot;The new tag&#x27;s name&quot;</span>)</span><br><span class="line"></span><br><span class="line">argsp.add_argument(<span class="string">&quot;object&quot;</span>,</span><br><span class="line">                   default=<span class="string">&quot;HEAD&quot;</span>,</span><br><span class="line">                   nargs=<span class="string">&quot;?&quot;</span>,</span><br><span class="line">                   <span class="built_in">help</span>=<span class="string">&quot;The object the new tag will point to&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><code>cmd_tag</code> 函数将根据是否提供了 <code>name</code> 来分派行为（列出或创建）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cmd_tag</span>(<span class="params">args</span>):</span><br><span class="line">    repo = repo_find()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> args.name:</span><br><span class="line">        tag_create(repo,</span><br><span class="line">                   args.name,</span><br><span class="line">                   args.<span class="built_in">object</span>,</span><br><span class="line">                   create_tag_object = args.create_tag_object)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        refs = ref_list(repo)</span><br><span class="line">        show_ref(repo, refs[<span class="string">&quot;tags&quot;</span>], with_hash=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>我们只需要一个函数来实际创建标签：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tag_create</span>(<span class="params">repo, name, ref, create_tag_object=<span class="literal">False</span></span>):</span><br><span class="line">    <span class="comment"># get the GitObject from the object reference</span></span><br><span class="line">    sha = object_find(repo, ref)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> create_tag_object:</span><br><span class="line">        <span class="comment"># create tag object (commit)</span></span><br><span class="line">        tag = GitTag()</span><br><span class="line">        tag.kvlm = <span class="built_in">dict</span>()</span><br><span class="line">        tag.kvlm[<span class="string">b&#x27;object&#x27;</span>] = sha.encode()</span><br><span class="line">        tag.kvlm[<span class="string">b&#x27;type&#x27;</span>] = <span class="string">b&#x27;commit&#x27;</span></span><br><span class="line">        tag.kvlm[<span class="string">b&#x27;tag&#x27;</span>] = name.encode()</span><br><span class="line">        <span class="comment"># Feel free to let the user give their name!</span></span><br><span class="line">        <span class="comment"># Notice you can fix this after commit, read on!</span></span><br><span class="line">        tag.kvlm[<span class="string">b&#x27;tagger&#x27;</span>] = <span class="string">b&#x27;Wyag &lt;wyag@example.com&gt;&#x27;</span></span><br><span class="line">        <span class="comment"># …and a tag message!</span></span><br><span class="line">        tag.kvlm[<span class="literal">None</span>] = <span class="string">b&quot;A tag generated by wyag, which won&#x27;t let you customize the message!\n&quot;</span></span><br><span class="line">        tag_sha = object_write(tag, repo)</span><br><span class="line">        <span class="comment"># create reference</span></span><br><span class="line">        ref_create(repo, <span class="string">&quot;tags/&quot;</span> + name, tag_sha)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># create lightweight tag (ref)</span></span><br><span class="line">        ref_create(repo, <span class="string">&quot;tags/&quot;</span> + name, sha)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ref_create</span>(<span class="params">repo, ref_name, sha</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(repo_file(repo, <span class="string">&quot;refs/&quot;</span> + ref_name), <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        fp.write(sha + <span class="string">&quot;\n&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="7-5-What’s-a-branch"><a href="#7-5-What’s-a-branch" class="headerlink" title="7.5. What’s a branch?"></a>7.5. What’s a branch?</h3><p>标签已完成，现在是另一个大块内容：分支。</p>
<p>是时候处理问题了：像大多数 Git 用户一样，wyag 仍然没有任何关于分支的概念。它目前将一个仓库视为一堆杂乱无章的对象，其中一些是提交对象，而完全没有表示提交是如何在分支中组织的，也没有表示在任何时候都有一个提交是 HEAD，即活跃分支的头部提交（或“尖端”）。</p>
<p>那么，什么是分支呢？答案其实出奇地简单，但也可能让人惊讶：分支就是对某个提交的引用。你甚至可以说分支是对某个提交的别名。在这方面，分支和标签完全一样。标签是引用，存在于 <code>.git/refs/tags</code> 中，而分支是引用，存在于 <code>.git/refs/heads</code> 中。</p>
<p>当然，分支和标签之间是有区别的：</p>
<ul>
<li>分支是对一个提交的引用，标签可以引用任何对象；</li>
<li>最重要的是，分支引用在每次提交时会被更新。这意味着每当你提交时，Git 实际上会执行以下操作：<ul>
<li>创建一个新的提交对象，当前分支的提交 ID 作为其父提交；</li>
<li>提交对象被哈希并存储；</li>
<li>分支引用被更新，指向新提交的哈希值。</li>
</ul>
</li>
</ul>
<p>仅此而已。</p>
<p>但当前分支又是什么呢？实际上，它更简单。它是一个位于 <code>refs</code> 层级外的引用文件，存在于 <code>.git/HEAD</code> 中，它是一个间接引用（即它是类似 <code>ref: path/to/other/ref</code> 的形式，而不是简单的哈希值）。</p>
<table>
<thead>
<tr>
<th><strong>Note</strong></th>
</tr>
</thead>
<tbody><tr>
<td>分离的 HEAD<br />当你仅仅检出一个随机的提交时，Git 会警告你它处于“分离的 HEAD 状态”。这意味着你不再处于任何分支上。在这种情况下，<code>.git/HEAD</code> 是一个直接引用：它包含一个 SHA-1 值。</td>
</tr>
</tbody></table>
<h3 id="7-6-Referring-to-objects-the-object-find-function"><a href="#7-6-Referring-to-objects-the-object-find-function" class="headerlink" title="7.6. Referring to objects: the object_find function"></a>7.6. Referring to objects: the <code>object_find</code> function</h3><h4 id="7-6-1-Resolving-names"><a href="#7-6-1-Resolving-names" class="headerlink" title="7.6.1. Resolving names"></a>7.6.1. Resolving names</h4><p>记得我们创建的 [愚蠢的 <code>object_find</code> 函数](#4.6. The cat-file command) 吗？它接受四个参数，返回第二个参数不变，并忽略其他三个参数。现在是时候用一个更有用的函数来替换它了。我们将实现 Git 名称解析算法的一个小而实用的子集。新的 <code>object_find()</code> 将分为两步：首先，给定一个名称，它将返回一个完整的 sha-1 哈希。例如，对于 <code>HEAD</code>，它将返回当前分支的头部提交的哈希，等等。更精确地说，这个名称解析函数将按以下方式工作：</p>
<ol>
<li>如果名称是 HEAD，它将解析为 .git&#x2F;HEAD；</li>
<li>如果名称是完整的哈希，则直接返回该哈希；</li>
<li>如果名称看起来像是短哈希，它将收集所有完整哈希以该短哈希为前缀的对象；</li>
<li>最后，它将解析与名称匹配的标签和分支。</li>
</ol>
<p>请注意，最后两步是收集值：前两步是绝对引用，因此我们可以安全地返回结果。但短哈希或分支名称可能是模糊的，我们希望列举出所有可能的含义，并在找到多个结果时抛出错误。</p>
<h5 id="短哈希"><a href="#短哈希" class="headerlink" title="短哈希"></a>短哈希</h5><p>为了方便，Git 允许通过哈希值的前缀来引用哈希。例如，<code>5bd254aa973646fa16f66d702a5826ea14a3eb45</code> 可以简称为 <code>5bd254</code>。这被称为“短哈希”。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">object_resolve</span>(<span class="params">repo, name</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Resolve name to an object hash in repo.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">This function is aware of:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> - the HEAD literal</span></span><br><span class="line"><span class="string">    - short and long hashes</span></span><br><span class="line"><span class="string">    - tags</span></span><br><span class="line"><span class="string">    - branches</span></span><br><span class="line"><span class="string">    - remote branches&quot;&quot;&quot;</span></span><br><span class="line">    candidates = <span class="built_in">list</span>()</span><br><span class="line">    hashRE = re.<span class="built_in">compile</span>(<span class="string">r&quot;^[0-9A-Fa-f]&#123;4,40&#125;$&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Empty string?  Abort.</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> name.strip():</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Head is nonambiguous</span></span><br><span class="line">    <span class="keyword">if</span> name == <span class="string">&quot;HEAD&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> [ ref_resolve(repo, <span class="string">&quot;HEAD&quot;</span>) ]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># If it&#x27;s a hex string, try for a hash.</span></span><br><span class="line">    <span class="keyword">if</span> hashRE.<span class="keyword">match</span>(name):</span><br><span class="line">        <span class="comment"># This may be a hash, either small or full.  4 seems to be the</span></span><br><span class="line">        <span class="comment"># minimal length for git to consider something a short hash.</span></span><br><span class="line">        <span class="comment"># This limit is documented in man git-rev-parse</span></span><br><span class="line">        name = name.lower()</span><br><span class="line">        prefix = name[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">        path = repo_dir(repo, <span class="string">&quot;objects&quot;</span>, prefix, mkdir=<span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">if</span> path:</span><br><span class="line">            rem = name[<span class="number">2</span>:]</span><br><span class="line">            <span class="keyword">for</span> f <span class="keyword">in</span> os.listdir(path):</span><br><span class="line">                <span class="keyword">if</span> f.startswith(rem):</span><br><span class="line">                    <span class="comment"># Notice a string startswith() itself, so this</span></span><br><span class="line">                    <span class="comment"># works for full hashes.</span></span><br><span class="line">                    candidates.append(prefix + f)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Try for references.</span></span><br><span class="line">    as_tag = ref_resolve(repo, <span class="string">&quot;refs/tags/&quot;</span> + name)</span><br><span class="line">    <span class="keyword">if</span> as_tag: <span class="comment"># Did we find a tag?</span></span><br><span class="line">        candidates.append(as_tag)</span><br><span class="line"></span><br><span class="line">    as_branch = ref_resolve(repo, <span class="string">&quot;refs/heads/&quot;</span> + name)</span><br><span class="line">    <span class="keyword">if</span> as_branch: <span class="comment"># Did we find a branch?</span></span><br><span class="line">        candidates.append(as_branch)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> candidates</span><br></pre></td></tr></table></figure>

<p>第二步是，如果提供了类型参数，我们将找到的对象跟踪到所需类型的对象。这是一个非常简单的迭代过程，因为我们只需要处理简单的情况：</p>
<ol>
<li>如果我们有一个标签，并且 <code>fmt</code> 不是我们期望的类型（例如 commit 或其他），则我们跟踪该标签。</li>
<li>如果我们有一个 commit 并且 <code>fmt</code> 是 <code>tree</code>，则返回该 commit 的树对象。</li>
<li>在所有其他情况下，我们中止操作：因为没有其他合理的情况需要处理。</li>
</ol>
<p>这个过程是迭代的，因为它可能需要不确定的步骤，原因在于标签本身也可以被标记。这意味着如果一个标签指向另一个标签，我们需要继续解析，直到最终找到一个直接指向某个对象（如 commit 或 tree）的标签。这个递归过程确保我们能够跟踪所有引用，直到找到所需类型的对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">object_find</span>(<span class="params">repo, name, fmt=<span class="literal">None</span>, follow=<span class="literal">True</span></span>):</span><br><span class="line">    sha = object_resolve(repo, name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> sha:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">f&quot;No such reference <span class="subst">&#123;name&#125;</span>.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sha) &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&quot;Ambiguous reference &#123;name&#125;: Candidates are:\n - &#123;&#x27;\n - &#x27;.join(sha)&#125;.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    sha = sha[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> fmt:</span><br><span class="line">        <span class="keyword">return</span> sha</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        obj = object_read(repo, sha)</span><br><span class="line">        <span class="comment">#     ^^^^^^^^^^^ &lt; this is a bit agressive: we&#x27;re reading</span></span><br><span class="line">        <span class="comment"># the full object just to get its type.  And we&#x27;re doing</span></span><br><span class="line">        <span class="comment"># that in a loop, albeit normally short.  Don&#x27;t expect</span></span><br><span class="line">        <span class="comment"># high performance here.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> obj.fmt == fmt:</span><br><span class="line">            <span class="keyword">return</span> sha</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> follow:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Follow tags</span></span><br><span class="line">        <span class="keyword">if</span> obj.fmt == <span class="string">b&#x27;tag&#x27;</span>:</span><br><span class="line">            sha = obj.kvlm[<span class="string">b&#x27;object&#x27;</span>].decode(<span class="string">&quot;ascii&quot;</span>)</span><br><span class="line">        <span class="keyword">elif</span> obj.fmt == <span class="string">b&#x27;commit&#x27;</span> <span class="keyword">and</span> fmt == <span class="string">b&#x27;tree&#x27;</span>:</span><br><span class="line">            sha = obj.kvlm[<span class="string">b&#x27;tree&#x27;</span>].decode(<span class="string">&quot;ascii&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>通过新的 <code>object_find()</code> 函数，CLI <code>wyag</code> 变得更加易用。你现在可以执行以下操作：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wyag checkout v3.11 <span class="comment"># A tag</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wyag checkout feature/explosions <span class="comment"># A branch</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wyag ls-tree -r HEAD <span class="comment"># The active branch or commit.  There&#x27;s also a</span></span></span><br><span class="line">                       # follow here: HEAD is actually a commit.</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wyag cat-file blob e0695f <span class="comment"># A short hash</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wyag cat-file tree master <span class="comment"># A branch, as a tree (another &quot;follow&quot;)</span></span></span><br></pre></td></tr></table></figure>

<h4 id="7-6-2-The-rev-parse-command"><a href="#7-6-2-The-rev-parse-command" class="headerlink" title="7.6.2. The rev-parse command"></a>7.6.2. The rev-parse command</h4><p>让我们实现 <code>wyag rev-parse</code>。<code>git rev-parse</code> 命令的功能很多，但我们要克隆的用例之一是解析引用。为了进一步测试 <code>object_find</code> 的“跟随”功能，我们将在其接口中添加一个可选的 <code>wyag-type</code> 参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">argsp = argsubparsers.add_parser(</span><br><span class="line">    <span class="string">&quot;rev-parse&quot;</span>,</span><br><span class="line">    <span class="built_in">help</span>=<span class="string">&quot;Parse revision (or other objects) identifiers&quot;</span>)</span><br><span class="line"></span><br><span class="line">argsp.add_argument(<span class="string">&quot;--wyag-type&quot;</span>,</span><br><span class="line">                   metavar=<span class="string">&quot;type&quot;</span>,</span><br><span class="line">                   dest=<span class="string">&quot;type&quot;</span>,</span><br><span class="line">                   choices=[<span class="string">&quot;blob&quot;</span>, <span class="string">&quot;commit&quot;</span>, <span class="string">&quot;tag&quot;</span>, <span class="string">&quot;tree&quot;</span>],</span><br><span class="line">                   default=<span class="literal">None</span>,</span><br><span class="line">                   <span class="built_in">help</span>=<span class="string">&quot;Specify the expected type&quot;</span>)</span><br><span class="line"></span><br><span class="line">argsp.add_argument(<span class="string">&quot;name&quot;</span>,</span><br><span class="line">                   <span class="built_in">help</span>=<span class="string">&quot;The name to parse&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>桥接函数完成所有工作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cmd_rev_parse</span>(<span class="params">args</span>):</span><br><span class="line">    <span class="keyword">if</span> args.<span class="built_in">type</span>:</span><br><span class="line">        fmt = args.<span class="built_in">type</span>.encode()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        fmt = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    repo = repo_find()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> (object_find(repo, args.name, fmt, follow=<span class="literal">True</span>))</span><br></pre></td></tr></table></figure>

<p>并且它可以正常运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wyag rev-parse --wyag-type commit HEAD</span></span><br><span class="line">6c22393f5e3830d15395fd8d2f8b0cf8eb40dd58</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wyag rev-parse --wyag-type tree HEAD</span></span><br><span class="line">11d33fad71dbac72840aff1447e0d080c7484361</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wyag rev-parse --wyag-type tag HEAD</span></span><br><span class="line">None</span><br></pre></td></tr></table></figure>

<h2 id="8-Working-with-the-staging-area-and-the-index-file"><a href="#8-Working-with-the-staging-area-and-the-index-file" class="headerlink" title="8. Working with the staging area and the index file"></a>8. Working with the staging area and the index file</h2><h3 id="8-1-What’s-the-index-file"><a href="#8-1-What’s-the-index-file" class="headerlink" title="8.1. What’s the index file?"></a>8.1. What’s the index file?</h3><p>这最后一步将带我们进入提交的过程（尽管实际创建提交的部分将在下一节进行！）。</p>
<p>你可能知道，在 Git 中进行提交之前，首先需要使用 <code>git add</code> 和 <code>git rm</code> 来“暂存”一些更改，然后才能执行提交。这种介于上一次提交和下一次提交之间的中间状态被称为 <strong>暂存区（staging area）</strong>。</p>
<p>看起来用提交对象（commit object）或树对象（tree object）来表示暂存区似乎是合乎逻辑的，但 Git 实际上使用了一种完全不同的机制，即所谓的 <strong>索引文件（index file）</strong>。</p>
<p>在一次提交之后，索引文件可以看作是该提交的一种副本：它存储了与对应树相同的“路径-Blob”关联信息。但除此之外，它还保存了工作区文件的额外信息，比如文件的创建&#x2F;修改时间，因此 <code>git status</code> 通常不需要实际对比文件内容，而是仅检查文件的修改时间是否与索引文件中存储的时间相同，只有当两者不匹配时，它才会进行真正的内容比较。</p>
<p>因此，你可以将索引文件视为一个 <strong>三方关联表（three-way association list）</strong>：不仅包含路径与 Blob 的映射关系，还包含路径与实际文件系统条目的映射关系。</p>
<p>索引文件的另一个重要特点是：<strong>它可以表示不一致的状态</strong>，比如合并冲突，而树对象总是完整且明确的表示一个文件系统状态。</p>
<p>当你执行提交（commit）时，Git 实际上会将索引文件转换为一个新的 <strong>树对象（tree object）</strong>。总结如下：</p>
<ul>
<li><p>当仓库处于“干净”状态（即没有未提交的更改）时，索引文件的内容与 <code>HEAD</code> 指向的提交完全相同，同时还包含关于对应文件系统条目的元数据。例如，它可能包含如下信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">There’s a file called src/disp.c whose contents are blob 797441c76e59e28794458b39b0f1eff4c85f4fa0. The real src/disp.c file, in the worktree, was created on 2023-07-15 15:28:29.168572151, and last modified 2023-07-15 15:28:29.1689427709. It is stored on device 65026, inode 8922881.</span><br></pre></td></tr></table></figure>
</li>
<li><p>当你执行 <code>git add</code> 或 <code>git rm</code> 时，索引文件会相应地被修改。在上面的示例中，如果你修改了 <code>src/disp.c</code> 并添加你的更改，索引文件将使用新的 blob ID 进行更新（当然，blob 本身也会在此过程中被创建），并且各种文件元数据也会被更新，以便 <code>git status</code> 知道何时不需要比较文件内容。</p>
</li>
<li><p>当你 <code>git commit</code> 这些更改时，一个新的树对象将从索引文件中生成，一个新的提交对象将使用该树创建，分支将被更新，然后操作完成。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th><strong>Note</strong></th>
</tr>
</thead>
<tbody><tr>
<td>关于术语的说明<br />暂存区（staging area）和索引（index）实际上是同一回事，但“暂存区”更侧重于 Git 面向用户的功能名称（这一功能本可以通过其他方式实现），可以理解为一种抽象概念；而“索引文件”（index file）则特指 Git 实际实现该抽象功能的方式。</td>
</tr>
</tbody></table>
<h3 id="8-2-Parsing-the-index"><a href="#8-2-Parsing-the-index" class="headerlink" title="8.2. Parsing the index"></a>8.2. Parsing the index</h3><p>索引文件是 Git 仓库中最复杂的数据结构。其完整文档可以在 Git 源代码树的 <code>Documentation/gitformat-index.txt</code> 中找到，你也可以在 <a target="_blank" rel="noopener" href="https://github.com/git/git/tree/master/Documentation">GitHub 镜像</a>上浏览。索引文件由三部分组成：</p>
<ul>
<li><p>一个包含格式版本号和索引中条目数量的头部；</p>
</li>
<li><p>一系列按排序存储的条目，每个条目代表一个文件，并填充至 8 字节的倍数；</p>
</li>
<li><p>一系列可选扩展，我们将在此忽略。</p>
</li>
</ul>
<p>我们需要表示的第一个部分是一个条目。它实际上包含了很多信息，我会在注释中留下详细说明。值得注意的是，一个条目存储了与其关联的 blob 的 SHA-1 值，以及关于实际文件在实际文件系统上的大量元数据。再次强调，这是因为 <code>git/wyag status</code> 需要确定索引中哪些文件已经被修改：最有效的做法是先检查最后修改的时间戳，并将其与已知值进行比较，而不是直接比较文件内容。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GitIndexEntry</span> (<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, ctime=<span class="literal">None</span>, mtime=<span class="literal">None</span>, dev=<span class="literal">None</span>, ino=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">                 mode_type=<span class="literal">None</span>, mode_perms=<span class="literal">None</span>, uid=<span class="literal">None</span>, gid=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">                 fsize=<span class="literal">None</span>, sha=<span class="literal">None</span>, flag_assume_valid=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">                 flag_stage=<span class="literal">None</span>, name=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="comment"># The last time a file&#x27;s metadata changed.  This is a pair</span></span><br><span class="line">        <span class="comment"># (timestamp in seconds, nanoseconds)</span></span><br><span class="line">        <span class="variable language_">self</span>.ctime = ctime</span><br><span class="line">        <span class="comment"># The last time a file&#x27;s data changed.  This is a pair</span></span><br><span class="line">        <span class="comment"># (timestamp in seconds, nanoseconds)</span></span><br><span class="line">        <span class="variable language_">self</span>.mtime = mtime</span><br><span class="line">        <span class="comment"># The ID of device containing this file</span></span><br><span class="line">        <span class="variable language_">self</span>.dev = dev</span><br><span class="line">        <span class="comment"># The file&#x27;s inode number</span></span><br><span class="line">        <span class="variable language_">self</span>.ino = ino</span><br><span class="line">        <span class="comment"># The object type, either b1000 (regular), b1010 (symlink),</span></span><br><span class="line">        <span class="comment"># b1110 (gitlink).</span></span><br><span class="line">        <span class="variable language_">self</span>.mode_type = mode_type</span><br><span class="line">        <span class="comment"># The object permissions, an integer.</span></span><br><span class="line">        <span class="variable language_">self</span>.mode_perms = mode_perms</span><br><span class="line">        <span class="comment"># User ID of owner</span></span><br><span class="line">        <span class="variable language_">self</span>.uid = uid</span><br><span class="line">        <span class="comment"># Group ID of ownner</span></span><br><span class="line">        <span class="variable language_">self</span>.gid = gid</span><br><span class="line">        <span class="comment"># Size of this object, in bytes</span></span><br><span class="line">        <span class="variable language_">self</span>.fsize = fsize</span><br><span class="line">        <span class="comment"># The object&#x27;s SHA</span></span><br><span class="line">        <span class="variable language_">self</span>.sha = sha</span><br><span class="line">        <span class="variable language_">self</span>.flag_assume_valid = flag_assume_valid</span><br><span class="line">        <span class="variable language_">self</span>.flag_stage = flag_stage</span><br><span class="line">        <span class="comment"># Name of the object (full path this time!)</span></span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br></pre></td></tr></table></figure>

<p>索引文件是一个二进制文件，可能是出于性能原因。不过格式相对简单。它以一个包含 DIRC 魔术字节、版本号和索引文件中条目总数的头部开始。我们创建 <code>GitIndex</code> 类来存储这些内容：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GitIndex</span> (<span class="title class_ inherited__">object</span>):</span><br><span class="line">    version = <span class="literal">None</span></span><br><span class="line">    entries = []</span><br><span class="line">    <span class="comment"># ext = None</span></span><br><span class="line">    <span class="comment"># sha = None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, version=<span class="number">2</span>, entries=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> entries:</span><br><span class="line">            entries = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.version = version</span><br><span class="line">        <span class="variable language_">self</span>.entries = entries</span><br></pre></td></tr></table></figure>

<p>并且我们需要一个解析器，将索引文件读入这些对象。在读取完 12 字节的头部后，我们按照出现顺序解析条目。每个条目以一组固定长度的数据开头，后面跟着一个可变长度的文件名。</p>
<p>这段代码相当直接，但由于它在读取二进制格式，它比我们之前的代码稍显杂乱。我们频繁使用 <code>int.from_bytes(bytes, endianness)</code> 来将原始字节转换成整数，并且进行少量的位运算来分离共享同一字节的数据。</p>
<p>（这种格式可能是为了让索引文件能够直接映射到内存（<code>mmapp()</code>），并像 C 结构体一样直接读取，通常在大多数情况下构建索引的时间复杂度为 O(n)。这种方法在 C 中往往能产生比 Python 更优雅的代码……）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">index_read</span>(<span class="params">repo</span>):</span><br><span class="line">    index_file = repo_file(repo, <span class="string">&quot;index&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># New repositories have no index!</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(index_file):</span><br><span class="line">        <span class="keyword">return</span> GitIndex()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(index_file, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        raw = f.read()</span><br><span class="line"></span><br><span class="line">    header = raw[:<span class="number">12</span>]</span><br><span class="line">    signature = header[:<span class="number">4</span>]</span><br><span class="line">    <span class="keyword">assert</span> signature == <span class="string">b&quot;DIRC&quot;</span> <span class="comment"># Stands for &quot;DirCache&quot;</span></span><br><span class="line">    version = <span class="built_in">int</span>.from_bytes(header[<span class="number">4</span>:<span class="number">8</span>], <span class="string">&quot;big&quot;</span>)</span><br><span class="line">    <span class="keyword">assert</span> version == <span class="number">2</span>, <span class="string">&quot;wyag only supports index file version 2&quot;</span></span><br><span class="line">    count = <span class="built_in">int</span>.from_bytes(header[<span class="number">8</span>:<span class="number">12</span>], <span class="string">&quot;big&quot;</span>)</span><br><span class="line"></span><br><span class="line">    entries = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line">    content = raw[<span class="number">12</span>:]</span><br><span class="line">    idx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, count):</span><br><span class="line">        <span class="comment"># Read creation time, as a unix timestamp (seconds since</span></span><br><span class="line">        <span class="comment"># 1970-01-01 00:00:00, the &quot;epoch&quot;)</span></span><br><span class="line">        ctime_s =  <span class="built_in">int</span>.from_bytes(content[idx: idx+<span class="number">4</span>], <span class="string">&quot;big&quot;</span>)</span><br><span class="line">        <span class="comment"># Read creation time, as nanoseconds after that timestamps,</span></span><br><span class="line">        <span class="comment"># for extra precision.</span></span><br><span class="line">        ctime_ns = <span class="built_in">int</span>.from_bytes(content[idx+<span class="number">4</span>: idx+<span class="number">8</span>], <span class="string">&quot;big&quot;</span>)</span><br><span class="line">        <span class="comment"># Same for modification time: first seconds from epoch.</span></span><br><span class="line">        mtime_s = <span class="built_in">int</span>.from_bytes(content[idx+<span class="number">8</span>: idx+<span class="number">12</span>], <span class="string">&quot;big&quot;</span>)</span><br><span class="line">        <span class="comment"># Then extra nanoseconds</span></span><br><span class="line">        mtime_ns = <span class="built_in">int</span>.from_bytes(content[idx+<span class="number">12</span>: idx+<span class="number">16</span>], <span class="string">&quot;big&quot;</span>)</span><br><span class="line">        <span class="comment"># Device ID</span></span><br><span class="line">        dev = <span class="built_in">int</span>.from_bytes(content[idx+<span class="number">16</span>: idx+<span class="number">20</span>], <span class="string">&quot;big&quot;</span>)</span><br><span class="line">        <span class="comment"># Inode</span></span><br><span class="line">        ino = <span class="built_in">int</span>.from_bytes(content[idx+<span class="number">20</span>: idx+<span class="number">24</span>], <span class="string">&quot;big&quot;</span>)</span><br><span class="line">        <span class="comment"># Ignored.</span></span><br><span class="line">        unused = <span class="built_in">int</span>.from_bytes(content[idx+<span class="number">24</span>: idx+<span class="number">26</span>], <span class="string">&quot;big&quot;</span>)</span><br><span class="line">        <span class="keyword">assert</span> <span class="number">0</span> == unused</span><br><span class="line">        mode = <span class="built_in">int</span>.from_bytes(content[idx+<span class="number">26</span>: idx+<span class="number">28</span>], <span class="string">&quot;big&quot;</span>)</span><br><span class="line">        mode_type = mode &gt;&gt; <span class="number">12</span></span><br><span class="line">        <span class="keyword">assert</span> mode_type <span class="keyword">in</span> [<span class="number">0b1000</span>, <span class="number">0b1010</span>, <span class="number">0b1110</span>]</span><br><span class="line">        mode_perms = mode &amp; <span class="number">0b0000000111111111</span></span><br><span class="line">        <span class="comment"># User ID</span></span><br><span class="line">        uid = <span class="built_in">int</span>.from_bytes(content[idx+<span class="number">28</span>: idx+<span class="number">32</span>], <span class="string">&quot;big&quot;</span>)</span><br><span class="line">        <span class="comment"># Group ID</span></span><br><span class="line">        gid = <span class="built_in">int</span>.from_bytes(content[idx+<span class="number">32</span>: idx+<span class="number">36</span>], <span class="string">&quot;big&quot;</span>)</span><br><span class="line">        <span class="comment"># Size</span></span><br><span class="line">        fsize = <span class="built_in">int</span>.from_bytes(content[idx+<span class="number">36</span>: idx+<span class="number">40</span>], <span class="string">&quot;big&quot;</span>)</span><br><span class="line">        <span class="comment"># SHA (object ID).  We&#x27;ll store it as a lowercase hex string</span></span><br><span class="line">        <span class="comment"># for consistency.</span></span><br><span class="line">        sha = <span class="built_in">format</span>(<span class="built_in">int</span>.from_bytes(content[idx+<span class="number">40</span>: idx+<span class="number">60</span>], <span class="string">&quot;big&quot;</span>), <span class="string">&quot;040x&quot;</span>)</span><br><span class="line">        <span class="comment"># Flags we&#x27;re going to ignore</span></span><br><span class="line">        flags = <span class="built_in">int</span>.from_bytes(content[idx+<span class="number">60</span>: idx+<span class="number">62</span>], <span class="string">&quot;big&quot;</span>)</span><br><span class="line">        <span class="comment"># Parse flags</span></span><br><span class="line">        flag_assume_valid = (flags &amp; <span class="number">0b1000000000000000</span>) != <span class="number">0</span></span><br><span class="line">        flag_extended = (flags &amp; <span class="number">0b0100000000000000</span>) != <span class="number">0</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="keyword">not</span> flag_extended</span><br><span class="line">        flag_stage =  flags &amp; <span class="number">0b0011000000000000</span></span><br><span class="line">        <span class="comment"># Length of the name.  This is stored on 12 bits, some max</span></span><br><span class="line">        <span class="comment"># value is 0xFFF, 4095.  Since names can occasionally go</span></span><br><span class="line">        <span class="comment"># beyond that length, git treats 0xFFF as meaning at least</span></span><br><span class="line">        <span class="comment"># 0xFFF, and looks for the final 0x00 to find the end of the</span></span><br><span class="line">        <span class="comment"># name --- at a small, and probably very rare, performance</span></span><br><span class="line">        <span class="comment"># cost.</span></span><br><span class="line">        name_length = flags &amp; <span class="number">0b0000111111111111</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># We&#x27;ve read 62 bytes so far.</span></span><br><span class="line">        idx += <span class="number">62</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> name_length &lt; <span class="number">0xFFF</span>:</span><br><span class="line">            <span class="keyword">assert</span> content[idx + name_length] == <span class="number">0x00</span></span><br><span class="line">            raw_name = content[idx:idx+name_length]</span><br><span class="line">            idx += name_length + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Notice: Name is 0x<span class="subst">&#123;name_length:X&#125;</span> bytes long.&quot;</span>)</span><br><span class="line">            <span class="comment"># This probably wasn&#x27;t tested enough.  It works with a</span></span><br><span class="line">            <span class="comment"># path of exactly 0xFFF bytes.  Any extra bytes broke</span></span><br><span class="line">            <span class="comment"># something between git, my shell and my filesystem.</span></span><br><span class="line">            null_idx = content.find(<span class="string">b&#x27;\x00&#x27;</span>, idx + <span class="number">0xFFF</span>)</span><br><span class="line">            raw_name = content[idx: null_idx]</span><br><span class="line">            idx = null_idx + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Just parse the name as utf8.</span></span><br><span class="line">        name = raw_name.decode(<span class="string">&quot;utf8&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Data is padded on multiples of eight bytes for pointer</span></span><br><span class="line">        <span class="comment"># alignment, so we skip as many bytes as we need for the next</span></span><br><span class="line">        <span class="comment"># read to start at the right position.</span></span><br><span class="line"></span><br><span class="line">        idx = <span class="number">8</span> * ceil(idx / <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># And we add this entry to our list.</span></span><br><span class="line">        entries.append(GitIndexEntry(ctime=(ctime_s, ctime_ns),</span><br><span class="line">                                     mtime=(mtime_s,  mtime_ns),</span><br><span class="line">                                     dev=dev,</span><br><span class="line">                                     ino=ino,</span><br><span class="line">                                     mode_type=mode_type,</span><br><span class="line">                                     mode_perms=mode_perms,</span><br><span class="line">                                     uid=uid,</span><br><span class="line">                                     gid=gid,</span><br><span class="line">                                     fsize=fsize,</span><br><span class="line">                                     sha=sha,</span><br><span class="line">                                     flag_assume_valid=flag_assume_valid,</span><br><span class="line">                                     flag_stage=flag_stage,</span><br><span class="line">                                     name=name))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> GitIndex(version=version, entries=entries)</span><br></pre></td></tr></table></figure>

<h3 id="8-3-The-ls-files-command"><a href="#8-3-The-ls-files-command" class="headerlink" title="8.3. The ls-files command"></a>8.3. The ls-files command</h3><p><code>git ls-files</code> 显示暂存区中文件的名称，并且通常会有许多选项。我们的 <code>ls-files</code> 会简单得多，但我们会添加一个 <code>--verbose</code> 选项，虽然在 git 中并没有这个选项，但为了能够显示索引文件中的每一项信息，我们会加上它。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">argsp = argsubparsers.add_parser(<span class="string">&quot;ls-files&quot;</span>, <span class="built_in">help</span> = <span class="string">&quot;List all the stage files&quot;</span>)</span><br><span class="line">argsp.add_argument(<span class="string">&quot;--verbose&quot;</span>, action=<span class="string">&quot;store_true&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;Show everything.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd_ls_files</span>(<span class="params">args</span>):</span><br><span class="line">    repo = repo_find()</span><br><span class="line">    index = index_read(repo)</span><br><span class="line">    <span class="keyword">if</span> args.verbose:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Index file format v<span class="subst">&#123;index.version&#125;</span>, containing <span class="subst">&#123;<span class="built_in">len</span>(index.entries)&#125;</span> entries.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> index.entries:</span><br><span class="line">        <span class="built_in">print</span>(e.name)</span><br><span class="line">        <span class="keyword">if</span> args.verbose:</span><br><span class="line">            entry_type = &#123; <span class="number">0b1000</span>: <span class="string">&quot;regular file&quot;</span>,</span><br><span class="line">                           <span class="number">0b1010</span>: <span class="string">&quot;symlink&quot;</span>,</span><br><span class="line">                           <span class="number">0b1110</span>: <span class="string">&quot;git link&quot;</span> &#125;[e.mode_type]</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;  <span class="subst">&#123;entry_type&#125;</span> with perms: <span class="subst">&#123;e.mode_perms:o&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;  on blob: <span class="subst">&#123;e.sha&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;  created: <span class="subst">&#123;datetime.fromtimestamp(e.ctime[<span class="number">0</span>])&#125;</span>.<span class="subst">&#123;e.ctime[<span class="number">1</span>]&#125;</span>, modified: <span class="subst">&#123;datetime.fromtimestamp(e.mtime[<span class="number">0</span>])&#125;</span>.<span class="subst">&#123;e.mtime[<span class="number">1</span>]&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;  device: <span class="subst">&#123;e.dev&#125;</span>, inode: <span class="subst">&#123;e.ino&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;  user: <span class="subst">&#123;pwd.getpwuid(e.uid).pw_name&#125;</span> (<span class="subst">&#123;e.uid&#125;</span>)  group: <span class="subst">&#123;grp.getgrgid(e.gid).gr_name&#125;</span> (<span class="subst">&#123;e.gid&#125;</span>)&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;  flags: stage=<span class="subst">&#123;e.flag_stage&#125;</span> assume_valid=<span class="subst">&#123;e.flag_assume_valid&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>如果运行 <code>ls-files</code>，你会注意到在一个“干净”的工作区（一个未修改的 HEAD 检出）中，它列出了 HEAD 上的所有文件。同样，索引文件并不是从 HEAD 提交的增量（即差异集），而是以不同的格式作为 HEAD 的副本开始的。</p>
<h3 id="8-4-A-detour-the-check-ignore-command"><a href="#8-4-A-detour-the-check-ignore-command" class="headerlink" title="8.4. A detour: the check-ignore command"></a>8.4. A detour: the check-ignore command</h3><p>我们想要实现 <code>status</code> 命令，但 <code>status</code> 需要了解忽略规则，这些规则存储在各种 <code>.gitignore</code> 文件中。因此，我们首先需要在 wyag 中添加一些基本的对忽略文件的支持。我们将通过 <code>check-ignore</code> 命令来暴露这一支持，该命令接受一组路径并返回那些应该被忽略的路径。</p>
<p>同样，命令解析器是非常简单的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">argsp = argsubparsers.add_parser(<span class="string">&quot;check-ignore&quot;</span>, <span class="built_in">help</span> = <span class="string">&quot;Check path(s) against ignore rules.&quot;</span>)</span><br><span class="line">argsp.add_argument(<span class="string">&quot;path&quot;</span>, nargs=<span class="string">&quot;+&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;Paths to check&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>而这个函数也同样简单：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cmd_check_ignore</span>(<span class="params">args</span>):</span><br><span class="line">    repo = repo_find()</span><br><span class="line">    rules = gitignore_read(repo)</span><br><span class="line">    <span class="keyword">for</span> path <span class="keyword">in</span> args.path:</span><br><span class="line">        <span class="keyword">if</span> check_ignore(rules, path):</span><br><span class="line">            <span class="built_in">print</span>(path)</span><br></pre></td></tr></table></figure>

<p>当然，许多我们调用的函数在 wyag 中还不存在。我们将首先编写一个用于读取忽略文件规则的函数 <code>gitignore_read()</code>。这些规则的语法相当简单：忽略文件中的每一行都是一个排除模式，匹配此模式的文件会被 status、add -A 等操作忽略。然而，有三种特殊情况：</p>
<ul>
<li>以感叹号 <code>!</code> 开头的行会否定该模式（即使之前的模式已经忽略了文件，这些文件也会被包括在内）。</li>
<li>以井号 <code>#</code> 开头的行是注释，会被跳过。</li>
<li>行首的反斜杠 <code>\</code> 会将 <code>!</code> 和 <code>#</code> 视为普通字符。</li>
</ul>
<p>首先，我们需要编写一个解析单个模式的函数。这个解析器返回一个元组：模式本身，以及一个布尔值，用于指示匹配该模式的文件是应该被排除（<code>True</code>）还是包括（<code>False</code>）。换句话说，如果模式是以 <code>!</code> 开头的，返回 <code>False</code>，否则返回 <code>True</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gitignore_parse1</span>(<span class="params">raw</span>):</span><br><span class="line">    raw = raw.strip() <span class="comment"># Remove leading/trailing spaces</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> raw <span class="keyword">or</span> raw[<span class="number">0</span>] == <span class="string">&quot;#&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">elif</span> raw[<span class="number">0</span>] == <span class="string">&quot;!&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> (raw[<span class="number">1</span>:], <span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">elif</span> raw[<span class="number">0</span>] == <span class="string">&quot;\\&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> (raw[<span class="number">1</span>:], <span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> (raw, <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>解析文件就是收集文件中的所有规则。注意，这个函数并不直接解析文件，而是解析行的列表：这是因为我们不仅需要从常规文件中读取规则，还需要从 Git 的 blob 中读取规则。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gitignore_parse</span>(<span class="params">lines</span>):</span><br><span class="line">    ret = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        parsed = gitignore_parse1(line)</span><br><span class="line">        <span class="keyword">if</span> parsed:</span><br><span class="line">            ret.append(parsed)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<p>最后我们需要做的是收集各种忽略文件。它们有两种类型：</p>
<ol>
<li>一些文件存在于索引中：它们是各种 gitignore 文件。强调一下复数形式；虽然通常只有一个这样的文件，位于根目录，但每个目录下都可以有一个，这个文件适用于该目录及其子目录。我将这些称为“作用域”，因为它们仅适用于其所在目录及其子目录。</li>
<li>另一些文件存在于索引之外。它们是全局忽略文件（通常位于 <code>~/.config/git/ignore</code>）和存储在 <code>.git/info/exclude</code> 中的仓库特定忽略文件。我将这些称为“绝对”，因为它们适用于整个仓库，但优先级较低。</li>
</ol>
<p>再次创建一个类来持有这些文件的信息：包括一个绝对规则的列表和一个相对规则的字典。这个字典的键是相对于工作区根目录的目录路径。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GitIgnore</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    absolute = <span class="literal">None</span></span><br><span class="line">    scoped = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, absolute, scoped</span>):</span><br><span class="line">        <span class="variable language_">self</span>.absolute = absolute</span><br><span class="line">        <span class="variable language_">self</span>.scoped = scoped</span><br></pre></td></tr></table></figure>

<p>最后，我们编写一个函数来收集仓库中所有的 gitignore 规则，并返回一个 <code>GitIgnore</code> 对象。需要注意的是，它从索引中读取作用域文件，而不是从工作区读取：只有已暂存的 <code>.gitignore</code> 文件才有意义（还要记住：<code>HEAD</code> 已经被暂存——暂存区是一个副本，而不是增量）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gitignore_read</span>(<span class="params">repo</span>):</span><br><span class="line">    ret = GitIgnore(absolute=<span class="built_in">list</span>(), scoped=<span class="built_in">dict</span>())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Read local configuration in .git/info/exclude</span></span><br><span class="line">    repo_file = os.path.join(repo.gitdir, <span class="string">&quot;info/exclude&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> os.path.exists(repo_file):</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(repo_file, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            ret.absolute.append(gitignore_parse(f.readlines()))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Global configuration</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;XDG_CONFIG_HOME&quot;</span> <span class="keyword">in</span> os.environ:</span><br><span class="line">        config_home = os.environ[<span class="string">&quot;XDG_CONFIG_HOME&quot;</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        config_home = os.path.expanduser(<span class="string">&quot;~/.config&quot;</span>)</span><br><span class="line">    global_file = os.path.join(config_home, <span class="string">&quot;git/ignore&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(global_file):</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(global_file, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            ret.absolute.append(gitignore_parse(f.readlines()))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># .gitignore files in the index</span></span><br><span class="line">    index = index_read(repo)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> entry <span class="keyword">in</span> index.entries:</span><br><span class="line">        <span class="keyword">if</span> entry.name == <span class="string">&quot;.gitignore&quot;</span> <span class="keyword">or</span> entry.name.endswith(<span class="string">&quot;/.gitignore&quot;</span>):</span><br><span class="line">            dir_name = os.path.dirname(entry.name)</span><br><span class="line">            contents = object_read(repo, entry.sha)</span><br><span class="line">            lines = contents.blobdata.decode(<span class="string">&quot;utf8&quot;</span>).splitlines()</span><br><span class="line">            ret.scoped[dir_name] = gitignore_parse(lines)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<p>我们快完成了。为了将所有内容结合在一起，我们需要一个 <code>check_ignore</code> 函数，它将路径与一组规则进行匹配，这些路径是相对于工作树的根目录的。这个函数的工作方式如下：</p>
<ol>
<li><strong>作用域规则匹配</strong>：它首先尝试将路径与作用域规则进行匹配。匹配的顺序是从路径的最深父级开始，逐级向上查找。例如，如果路径是 <code>src/support/w32/legacy/sound.c~</code>，它会先查找 <code>src/support/w32/legacy/.gitignore</code> 中的规则，然后是 <code>src/support/w32/.gitignore</code>，再是 <code>src/support/.gitignore</code>，直到根目录下的 <code>.gitignore</code>。</li>
<li><strong>绝对规则匹配</strong>：如果作用域规则没有匹配，它将继续使用绝对规则进行匹配。</li>
</ol>
<p>我们将编写三个小的支持函数。第一个是用来将路径与规则集进行匹配的，并返回最后一个匹配规则的结果。注意，这不是一个真正的布尔函数，因为它有三个可能的返回值：<code>True</code>、<code>False</code> 和 <code>None</code>。如果没有匹配，它将返回 <code>None</code>，这样调用者就知道应该继续尝试更一般的忽略文件（例如，向上移动一个目录级别）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">check_ignore1</span>(<span class="params">rules, path</span>):</span><br><span class="line">    result = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> (pattern, value) <span class="keyword">in</span> rules:</span><br><span class="line">        <span class="keyword">if</span> fnmatch(path, pattern):</span><br><span class="line">            result = value</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p>这是一个用于匹配作用域规则字典（即各种 <code>.gitignore</code> 文件）的函数。它从路径所在的目录开始，逐级向上递归查找父目录，直到测试到根目录。请注意，这个函数（以及接下来的两个函数）在处理每个 <code>.gitignore</code> 文件时不会提前停止。即使某个规则匹配，它们会继续扫描整个文件，因为该文件中的其他规则可能会反转之前的效果（规则是按顺序处理的，因此如果你想排除 <code>*.c</code> 但不排除 <code>generator.c</code>，通用规则必须放在特定规则之前）。但是，一旦在某个文件中至少匹配到一个规则，我们就停止继续检查该文件的剩余规则，因为更一般的文件永远不会取消更具体规则的效果（这就是为什么 <code>check_ignore1</code> 是三值而不是布尔的原因）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">check_ignore_scoped</span>(<span class="params">rules, path</span>):</span><br><span class="line">    parent = os.path.dirname(path)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> parent <span class="keyword">in</span> rules:</span><br><span class="line">            result = check_ignore1(rules[parent], path)</span><br><span class="line">            <span class="keyword">if</span> result != <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">if</span> parent == <span class="string">&quot;&quot;</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        parent = os.path.dirname(parent)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>这是一个用于匹配绝对规则列表的简单函数。请注意，我们将这些规则推送到列表的顺序很重要（因为我们确实先读取了仓库规则，再读取了全局规则！）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">check_ignore_absolute</span>(<span class="params">rules, path</span>):</span><br><span class="line">    parent = os.path.dirname(path)</span><br><span class="line">    <span class="keyword">for</span> ruleset <span class="keyword">in</span> rules:</span><br><span class="line">        result = check_ignore1(ruleset, path)</span><br><span class="line">        <span class="keyword">if</span> result != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span> <span class="comment"># This is a reasonable default at this point.</span></span><br></pre></td></tr></table></figure>

<p>最后，我们需要一个函数将它们全部绑定在一起。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">check_ignore</span>(<span class="params">rules, path</span>):</span><br><span class="line">    <span class="keyword">if</span> os.path.isabs(path):</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&quot;This function requires path to be relative to the repository&#x27;s root&quot;</span>)</span><br><span class="line"></span><br><span class="line">    result = check_ignore_scoped(rules.scoped, path)</span><br><span class="line">    <span class="keyword">if</span> result != <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> check_ignore_absolute(rules.absolute, path)</span><br></pre></td></tr></table></figure>

<p>现在，您可以在其源代码树上调用 <code>wyag check-ignore</code>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wyag check-ignore hello.el hello.elc hello.html wyag.zip wyag.tar</span></span><br><span class="line">hello.elc</span><br><span class="line">hello.html</span><br><span class="line">wyag.zip</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>Warning</strong></th>
</tr>
</thead>
<tbody><tr>
<td>这只是一个近似实现<br />这并不是一个完美的重新实现。特别是，通过仅使用目录名称（例如 <code>__pycache__</code>）的规则排除整个目录将不起作用，因为 <code>fnmatch</code> 需要的模式是 <code>__pycache__/**</code>。如果你真的想深入了解忽略规则，这可能是一个很好的起点。</td>
</tr>
</tbody></table>
<h3 id="8-5-The-status-command"><a href="#8-5-The-status-command" class="headerlink" title="8.5. The status command"></a>8.5. The status command</h3><p><code>status</code> 比 <code>ls-files</code> 更复杂，因为它需要同时比较索引（index）与 <code>HEAD</code> 以及实际的文件系统（worktree）。当你运行 <code>git status</code> 时，它会告诉你哪些文件自上次提交以来被添加、删除或修改，以及这些更改中哪些已经被暂存，并将出现在下一次提交中。因此，<code>status</code> 实际上是在比较 <code>HEAD</code> 与暂存区（staging area），以及暂存区与工作区（worktree）。它的输出格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)</span><br><span class="line">	modified:   write-yourself-a-git.org</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">	modified:   write-yourself-a-git.org</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">	org-html-themes/</span><br><span class="line">	wl-copy</span><br></pre></td></tr></table></figure>

<p>我们将实现 status 的三个部分：首先是活动分支或“分离的 HEAD”，然后是索引和工作区之间的差异（“未暂存的更改”），最后是 HEAD 和索引之间的差异（“已暂存的更改”和“未跟踪的文件”）。</p>
<p>公共接口非常简单，我们的 status 将不接受任何参数:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">argsp = argsubparsers.add_parser(<span class="string">&quot;status&quot;</span>, <span class="built_in">help</span> = <span class="string">&quot;Show the working tree status.&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>桥接函数只是按顺序调用这三个组件函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cmd_status</span>(<span class="params">_</span>):</span><br><span class="line">    repo = repo_find()</span><br><span class="line">    index = index_read(repo)</span><br><span class="line"></span><br><span class="line">    cmd_status_branch(repo)</span><br><span class="line">    cmd_status_head_index(repo, index)</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">    cmd_status_index_worktree(repo, index) </span><br></pre></td></tr></table></figure>

<h4 id="8-5-1-Finding-the-active-branch"><a href="#8-5-1-Finding-the-active-branch" class="headerlink" title="8.5.1. Finding the active branch"></a>8.5.1. Finding the active branch</h4><p>首先，我们需要知道当前是否位于某个分支上，如果是的话，确定是哪一个分支。我们可以通过检查 <code>.git/HEAD</code> 来实现这一点。该文件应该包含一个十六进制 ID（在分离的 HEAD 状态下指向某个提交），或者是一个间接引用，指向 <code>refs/heads/</code> 目录中的某个分支。如果是分支，我们返回其名称；如果不是，则返回 <code>False</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">branch_get_active</span>(<span class="params">repo</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(repo_file(repo, <span class="string">&quot;HEAD&quot;</span>), <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        head = f.read()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> head.startswith(<span class="string">&quot;ref: refs/heads/&quot;</span>):</span><br><span class="line">        <span class="keyword">return</span>(head[<span class="number">16</span>:-<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>基于此，我们可以编写 <code>cmd_status_*</code> 函数中的第一个，该函数由桥接函数调用。它的作用是打印当前活动分支的名称，或者在处于分离的 HEAD 状态时，打印其哈希值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cmd_status_branch</span>(<span class="params">repo</span>):</span><br><span class="line">    branch = branch_get_active(repo)</span><br><span class="line">    <span class="keyword">if</span> branch:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;On branch <span class="subst">&#123;branch&#125;</span>.&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;HEAD detached at <span class="subst">&#123;object_find(repo, <span class="string">&#x27;HEAD&#x27;</span>)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="8-5-2-Finding-changes-between-HEAD-and-index"><a href="#8-5-2-Finding-changes-between-HEAD-and-index" class="headerlink" title="8.5.2. Finding changes between HEAD and index"></a>8.5.2. Finding changes between HEAD and index</h4><p>状态输出的第二块是“待提交的更改”，即暂存区与 HEAD 的差异。为此，我们将首先读取 HEAD 的树，并将其展平为一个单一的字典（哈希映射），键为完整路径，这样它就更接近于将路径与 blob 关联的（扁平化的）索引。然后，我们只需对比它们并输出差异。</p>
<p>首先，编写一个函数，将树（递归的，记得哦）转换为一个（扁平化的）字典。由于树是递归的，所以该函数本身也是递归的——抱歉，理解这一点需要点耐心 :)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tree_to_dict</span>(<span class="params">repo, ref, prefix=<span class="string">&quot;&quot;</span></span>):</span><br><span class="line">    ret = <span class="built_in">dict</span>()</span><br><span class="line">    tree_sha = object_find(repo, ref, fmt=<span class="string">b&quot;tree&quot;</span>)</span><br><span class="line">    tree = object_read(repo, tree_sha)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> leaf <span class="keyword">in</span> tree.items:</span><br><span class="line">        full_path = os.path.join(prefix, leaf.path)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># We read the object to extract its type (this is uselessly</span></span><br><span class="line">        <span class="comment"># expensive: we could just open it as a file and read the</span></span><br><span class="line">        <span class="comment"># first few bytes)</span></span><br><span class="line">        is_subtree = leaf.mode.startswith(<span class="string">b&#x27;04&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Depending on the type, we either store the path (if it&#x27;s a</span></span><br><span class="line">        <span class="comment"># blob, so a regular file), or recurse (if it&#x27;s another tree,</span></span><br><span class="line">        <span class="comment"># so a subdir)</span></span><br><span class="line">        <span class="keyword">if</span> is_subtree:</span><br><span class="line">            ret.update(tree_to_dict(repo, leaf.sha, full_path))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ret[full_path] = leaf.sha</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<p>以及命令本身：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cmd_status_head_index</span>(<span class="params">repo, index</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Changes to be committed:&quot;</span>)</span><br><span class="line"></span><br><span class="line">    head = tree_to_dict(repo, <span class="string">&quot;HEAD&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> entry <span class="keyword">in</span> index.entries:</span><br><span class="line">        <span class="keyword">if</span> entry.name <span class="keyword">in</span> head:</span><br><span class="line">            <span class="keyword">if</span> head[entry.name] != entry.sha:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;  modified:&quot;</span>, entry.name)</span><br><span class="line">            <span class="keyword">del</span> head[entry.name] <span class="comment"># Delete the key</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;  added:   &quot;</span>, entry.name)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Keys still in HEAD are files that we haven&#x27;t met in the index,</span></span><br><span class="line">    <span class="comment"># and thus have been deleted.</span></span><br><span class="line">    <span class="keyword">for</span> entry <span class="keyword">in</span> head.keys():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;  deleted: &quot;</span>, entry)</span><br></pre></td></tr></table></figure>

<h4 id="8-5-3-Finding-changes-between-index-and-worktree"><a href="#8-5-3-Finding-changes-between-index-and-worktree" class="headerlink" title="8.5.3. Finding changes between index and worktree"></a>8.5.3. Finding changes between index and worktree</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cmd_status_index_worktree</span>(<span class="params">repo, index</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Changes not staged for commit:&quot;</span>)</span><br><span class="line"></span><br><span class="line">    ignore = gitignore_read(repo)</span><br><span class="line"></span><br><span class="line">    gitdir_prefix = repo.gitdir + os.path.sep</span><br><span class="line"></span><br><span class="line">    all_files = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># We begin by walking the filesystem</span></span><br><span class="line">    <span class="keyword">for</span> (root, _, files) <span class="keyword">in</span> os.walk(repo.worktree, <span class="literal">True</span>):</span><br><span class="line">        <span class="keyword">if</span> root==repo.gitdir <span class="keyword">or</span> root.startswith(gitdir_prefix):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">for</span> f <span class="keyword">in</span> files:</span><br><span class="line">            full_path = os.path.join(root, f)</span><br><span class="line">            rel_path = os.path.relpath(full_path, repo.worktree)</span><br><span class="line">            all_files.append(rel_path)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># We now traverse the index, and compare real files with the cached</span></span><br><span class="line">    <span class="comment"># versions.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> entry <span class="keyword">in</span> index.entries:</span><br><span class="line">        full_path = os.path.join(repo.worktree, entry.name)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># That file *name* is in the index</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(full_path):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;  deleted: &quot;</span>, entry.name)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            stat = os.stat(full_path)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Compare metadata</span></span><br><span class="line">            ctime_ns = entry.ctime[<span class="number">0</span>] * <span class="number">10</span>**<span class="number">9</span> + entry.ctime[<span class="number">1</span>]</span><br><span class="line">            mtime_ns = entry.mtime[<span class="number">0</span>] * <span class="number">10</span>**<span class="number">9</span> + entry.mtime[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> (stat.st_ctime_ns != ctime_ns) <span class="keyword">or</span> (stat.st_mtime_ns != mtime_ns):</span><br><span class="line">                <span class="comment"># If different, deep compare.</span></span><br><span class="line">                <span class="comment"># @FIXME This *will* crash on symlinks to dir.</span></span><br><span class="line">                <span class="keyword">with</span> <span class="built_in">open</span>(full_path, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> fd:</span><br><span class="line">                    new_sha = object_hash(fd, <span class="string">b&quot;blob&quot;</span>, <span class="literal">None</span>)</span><br><span class="line">                    <span class="comment"># If the hashes are the same, the files are actually the same.</span></span><br><span class="line">                    same = entry.sha == new_sha</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> same:</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">&quot;  modified:&quot;</span>, entry.name)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> entry.name <span class="keyword">in</span> all_files:</span><br><span class="line">            all_files.remove(entry.name)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Untracked files:&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> all_files:</span><br><span class="line">        <span class="comment"># @TODO If a full directory is untracked, we should display</span></span><br><span class="line">        <span class="comment"># its name without its contents.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> check_ignore(ignore, f):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot; &quot;</span>, f)</span><br></pre></td></tr></table></figure>

<p>我们的 <code>status</code> 函数完成了。它应该输出类似于：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wyag status</span></span><br><span class="line">On branch main.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  added:    src/main.c</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  modified: build.py</span><br><span class="line">  deleted:  README.org</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  src/cli.c</span><br></pre></td></tr></table></figure>

<p>真正的 <code>status</code> 更智能：例如，它可以检测重命名，而我们的实现无法做到这一点。另一个值得提到的重要区别是，<code>git status</code> 实际上会在文件的元数据被修改但内容未改变时将索引文件写回。如果用我们特别的 <code>ls-files</code> 来查看，你可以看到这一点：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wyag ls-files --verbose</span></span><br><span class="line">Index file format v2, containing 1 entries.</span><br><span class="line">file</span><br><span class="line">  regular file with perms: 644</span><br><span class="line">  on blob: f2f279981ce01b095c42ee7162aadf60185c8f67</span><br><span class="line">  created: 2023-07-18 18:26:15.771460869, modified: 2023-07-18 18:26:15.771460869</span><br><span class="line">  ...</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">touch</span> file</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status &gt; /dev/null</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wyag ls-files --verbose</span></span><br><span class="line">Index file format v2, containing 1 entries.</span><br><span class="line">file</span><br><span class="line">  regular file with perms: 644</span><br><span class="line">  on blob: f2f279981ce01b095c42ee7162aadf60185c8f67</span><br><span class="line">  created: 2023-07-18 18:26:41.421743098, modified: 2023-07-18 18:26:41.421743098</span><br></pre></td></tr></table></figure>

<p>请注意，<code>git status</code> 如何更新了索引文件中的两个时间戳，以反映实际文件元数据的变化。</p>
<h2 id="9-Staging-area-and-index-part-2-staging-and-committing"><a href="#9-Staging-area-and-index-part-2-staging-and-committing" class="headerlink" title="9. Staging area and index, part 2: staging and committing"></a>9. Staging area and index, part 2: staging and committing</h2><p>好的，让我们创建提交。</p>
<p>我们几乎已经准备好了，但还差最后三样东西：</p>
<ul>
<li>需要修改索引的命令，以便我们的提交不是仅仅复制其父提交。这些命令是 <code>add</code> 和 <code>rm</code>。</li>
<li>这些命令需要将修改后的索引写回，因为提交是基于索引进行的。</li>
<li>当然，我们还需要 <code>commit</code> 函数及其对应的 <code>wyag commit</code> 命令。</li>
</ul>
<h3 id="9-1-Writing-the-index"><a href="#9-1-Writing-the-index" class="headerlink" title="9.1. Writing the index"></a>9.1. Writing the index</h3><p>我们将从写入索引开始。本质上，我们只是将所有内容序列化回二进制格式。这虽然有些繁琐，但代码应该很直观。我会在注释中详细说明具体细节，但实际上，这只是 <code>index_read</code> 的反向操作——如果需要，可以参考它以及 <code>GitIndexEntry</code> 类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">index_write</span>(<span class="params">repo, index</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(repo_file(repo, <span class="string">&quot;index&quot;</span>), <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># HEADER</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Write the magic bytes.</span></span><br><span class="line">        f.write(<span class="string">b&quot;DIRC&quot;</span>)</span><br><span class="line">        <span class="comment"># Write version number.</span></span><br><span class="line">        f.write(index.version.to_bytes(<span class="number">4</span>, <span class="string">&quot;big&quot;</span>))</span><br><span class="line">        <span class="comment"># Write the number of entries.</span></span><br><span class="line">        f.write(<span class="built_in">len</span>(index.entries).to_bytes(<span class="number">4</span>, <span class="string">&quot;big&quot;</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># ENTRIES</span></span><br><span class="line"></span><br><span class="line">        idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> index.entries:</span><br><span class="line">            f.write(e.ctime[<span class="number">0</span>].to_bytes(<span class="number">4</span>, <span class="string">&quot;big&quot;</span>))</span><br><span class="line">            f.write(e.ctime[<span class="number">1</span>].to_bytes(<span class="number">4</span>, <span class="string">&quot;big&quot;</span>))</span><br><span class="line">            f.write(e.mtime[<span class="number">0</span>].to_bytes(<span class="number">4</span>, <span class="string">&quot;big&quot;</span>))</span><br><span class="line">            f.write(e.mtime[<span class="number">1</span>].to_bytes(<span class="number">4</span>, <span class="string">&quot;big&quot;</span>))</span><br><span class="line">            f.write(e.dev.to_bytes(<span class="number">4</span>, <span class="string">&quot;big&quot;</span>))</span><br><span class="line">            f.write(e.ino.to_bytes(<span class="number">4</span>, <span class="string">&quot;big&quot;</span>))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Mode</span></span><br><span class="line">            mode = (e.mode_type &lt;&lt; <span class="number">12</span>) | e.mode_perms</span><br><span class="line">            f.write(mode.to_bytes(<span class="number">4</span>, <span class="string">&quot;big&quot;</span>))</span><br><span class="line"></span><br><span class="line">            f.write(e.uid.to_bytes(<span class="number">4</span>, <span class="string">&quot;big&quot;</span>))</span><br><span class="line">            f.write(e.gid.to_bytes(<span class="number">4</span>, <span class="string">&quot;big&quot;</span>))</span><br><span class="line"></span><br><span class="line">            f.write(e.fsize.to_bytes(<span class="number">4</span>, <span class="string">&quot;big&quot;</span>))</span><br><span class="line">            <span class="comment"># @FIXME Convert back to int.</span></span><br><span class="line">            f.write(<span class="built_in">int</span>(e.sha, <span class="number">16</span>).to_bytes(<span class="number">20</span>, <span class="string">&quot;big&quot;</span>))</span><br><span class="line"></span><br><span class="line">            flag_assume_valid = <span class="number">0x1</span> &lt;&lt; <span class="number">15</span> <span class="keyword">if</span> e.flag_assume_valid <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            name_bytes = e.name.encode(<span class="string">&quot;utf8&quot;</span>)</span><br><span class="line">            bytes_len = <span class="built_in">len</span>(name_bytes)</span><br><span class="line">            <span class="keyword">if</span> bytes_len &gt;= <span class="number">0xFFF</span>:</span><br><span class="line">                name_length = <span class="number">0xFFF</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                name_length = bytes_len</span><br><span class="line"></span><br><span class="line">            <span class="comment"># We merge back three pieces of data (two flags and the</span></span><br><span class="line">            <span class="comment"># length of the name) on the same two bytes.</span></span><br><span class="line">            f.write((flag_assume_valid | e.flag_stage | name_length).to_bytes(<span class="number">2</span>, <span class="string">&quot;big&quot;</span>))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Write back the name, and a final 0x00.</span></span><br><span class="line">            f.write(name_bytes)</span><br><span class="line">            f.write((<span class="number">0</span>).to_bytes(<span class="number">1</span>, <span class="string">&quot;big&quot;</span>))</span><br><span class="line"></span><br><span class="line">            idx += <span class="number">62</span> + <span class="built_in">len</span>(name_bytes) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Add padding if necessary.</span></span><br><span class="line">            <span class="keyword">if</span> idx % <span class="number">8</span> != <span class="number">0</span>:</span><br><span class="line">                pad = <span class="number">8</span> - (idx % <span class="number">8</span>)</span><br><span class="line">                f.write((<span class="number">0</span>).to_bytes(pad, <span class="string">&quot;big&quot;</span>))</span><br><span class="line">                idx += pad</span><br></pre></td></tr></table></figure>

<h3 id="9-2-The-rm-command"><a href="#9-2-The-rm-command" class="headerlink" title="9.2. The rm command"></a>9.2. The rm command</h3><p>对索引进行的最简单的更改就是从中删除一个条目，这意味着下一个提交将不会包含该文件。这正是 <code>git rm</code> 命令的作用。</p>
<table>
<thead>
<tr>
<th><strong>Danger</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>git rm</code> 是一个破坏性操作，<code>wyag rm</code> 也是如此。该命令不仅修改索引，还会从工作区中删除文件。与 <code>git</code> 不同，<code>wyag rm</code> 不会在删除文件前检查其是否已保存。因此，请谨慎操作。</td>
</tr>
</tbody></table>
<p><code>rm</code> 接受一个参数，即要删除的路径列表：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">argsp = argsubparsers.add_parser(<span class="string">&quot;rm&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;Remove files from the working tree and the index.&quot;</span>)</span><br><span class="line">argsp.add_argument(<span class="string">&quot;path&quot;</span>, nargs=<span class="string">&quot;+&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;Files to remove&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd_rm</span>(<span class="params">args</span>):</span><br><span class="line">    repo = repo_find()</span><br><span class="line">    rm(repo, args.path)</span><br></pre></td></tr></table></figure>

<p><code>rm</code> 函数虽然有点长，但它非常简单。它接受一个仓库和一个路径列表，读取该仓库的索引，并从索引中删除与该列表匹配的条目。可选参数控制函数是否实际删除文件，以及如果某些路径在索引中不存在是否应中止（这两个参数供 <code>add</code> 使用，并不会在 <code>wyag rm</code> 命令中暴露）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rm</span>(<span class="params">repo, paths, delete=<span class="literal">True</span>, skip_missing=<span class="literal">False</span></span>):</span><br><span class="line">    <span class="comment"># Find and read the index</span></span><br><span class="line">    index = index_read(repo)</span><br><span class="line"></span><br><span class="line">    worktree = repo.worktree + os.sep</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Make paths absolute</span></span><br><span class="line">    abspaths = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">for</span> path <span class="keyword">in</span> paths:</span><br><span class="line">        abspath = os.path.abspath(path)</span><br><span class="line">        <span class="keyword">if</span> abspath.startswith(worktree):</span><br><span class="line">            abspaths.add(abspath)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">f&quot;Cannot remove paths outside of worktree: <span class="subst">&#123;paths&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># The list of entries to *keep*, which we will write back to the</span></span><br><span class="line">    <span class="comment"># index.</span></span><br><span class="line">    kept_entries = <span class="built_in">list</span>()</span><br><span class="line">    <span class="comment"># The list of removed paths, which we&#x27;ll use after index update</span></span><br><span class="line">    <span class="comment"># to physically remove the actual paths from the filesystem.</span></span><br><span class="line">    remove = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Now iterate over the list of entries, and remove those whose</span></span><br><span class="line">    <span class="comment"># paths we find in abspaths.  Preserve the others in kept_entries.</span></span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> index.entries:</span><br><span class="line">        full_path = os.path.join(repo.worktree, e.name)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> full_path <span class="keyword">in</span> abspaths:</span><br><span class="line">            remove.append(full_path)</span><br><span class="line">            abspaths.remove(full_path)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            kept_entries.append(e) <span class="comment"># Preserve entry</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># If abspaths is empty, it means some paths weren&#x27;t in the index.</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(abspaths) &gt; <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> skip_missing:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">f&quot;Cannot remove paths not in the index: <span class="subst">&#123;abspaths&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Physically delete paths from filesystem.</span></span><br><span class="line">    <span class="keyword">if</span> delete:</span><br><span class="line">        <span class="keyword">for</span> path <span class="keyword">in</span> remove:</span><br><span class="line">            os.unlink(path)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Update the list of entries in the index, and write it back.</span></span><br><span class="line">    index.entries = kept_entries</span><br><span class="line">    index_write(repo, index)</span><br></pre></td></tr></table></figure>

<p>现在，我们可以使用 <code>wyag rm</code> 来删除文件了。</p>
<h3 id="9-3-The-add-command"><a href="#9-3-The-add-command" class="headerlink" title="9.3. The add command"></a>9.3. The add command</h3><p>添加文件比删除稍微复杂一些，但我们已经掌握了所需的知识。将文件暂存（stage）到索引是一个三步操作：</p>
<ol>
<li>先从索引中删除已有的条目（如果存在），但不删除文件本身（这也是我们在 <code>rm</code> 函数中添加可选参数的原因）。</li>
<li>计算文件的哈希值，将其存储为 blob 对象。</li>
<li>创建相应的索引条目，并将修改后的索引写回。</li>
</ol>
<p>首先，我们来看命令的接口。没有什么特别之处，<code>wyag add PATH ...</code>，其中 <code>PATH</code> 是要暂存的一个或多个文件。这个桥接函数（bridge function）和之前的一样简单无趣。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">argsp = argsubparsers.add_parser(<span class="string">&quot;add&quot;</span>, <span class="built_in">help</span> = <span class="string">&quot;Add files contents to the index.&quot;</span>)</span><br><span class="line">argsp.add_argument(<span class="string">&quot;path&quot;</span>, nargs=<span class="string">&quot;+&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;Files to add&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd_add</span>(<span class="params">args</span>):</span><br><span class="line">    repo = repo_find()</span><br><span class="line">    add(repo, args.path)</span><br></pre></td></tr></table></figure>

<p><code>add</code> 与 <code>rm</code> 的主要区别在于，<code>add</code> 需要创建一个索引条目（index entry）。这并不难：我们只需对文件调用 <code>stat()</code>，然后将文件的元数据复制到索引的相应字段中（<code>stat()</code> 返回的元数据包括创建&#x2F;修改时间等，这些信息会存储在索引中）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">repo, paths, delete=<span class="literal">True</span>, skip_missing=<span class="literal">False</span></span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># First remove all paths from the index, if they exist.</span></span><br><span class="line">    rm (repo, paths, delete=<span class="literal">False</span>, skip_missing=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    worktree = repo.worktree + os.sep</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Convert the paths to pairs: (absolute, relative_to_worktree).</span></span><br><span class="line">    <span class="comment"># Also delete them from the index if they&#x27;re present.</span></span><br><span class="line">    clean_paths = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">for</span> path <span class="keyword">in</span> paths:</span><br><span class="line">        abspath = os.path.abspath(path)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (abspath.startswith(worktree) <span class="keyword">and</span> os.path.isfile(abspath)):</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">f&quot;Not a file, or outside the worktree: <span class="subst">&#123;paths&#125;</span>&quot;</span>)</span><br><span class="line">        relpath = os.path.relpath(abspath, repo.worktree)</span><br><span class="line">        clean_paths.add((abspath,  relpath))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Find and read the index.  It was modified by rm.  (This isn&#x27;t</span></span><br><span class="line">    <span class="comment"># optimal, good enough for wyag!)</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># @FIXME, though: we could just move the index through</span></span><br><span class="line">    <span class="comment"># commands instead of reading and writing it over again.</span></span><br><span class="line">    index = index_read(repo)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (abspath, relpath) <span class="keyword">in</span> clean_paths:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(abspath, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> fd:</span><br><span class="line">            sha = object_hash(fd, <span class="string">b&quot;blob&quot;</span>, repo)</span><br><span class="line"></span><br><span class="line">            stat = os.stat(abspath)</span><br><span class="line"></span><br><span class="line">            ctime_s = <span class="built_in">int</span>(stat.st_ctime)</span><br><span class="line">            ctime_ns = stat.st_ctime_ns % <span class="number">10</span>**<span class="number">9</span></span><br><span class="line">            mtime_s = <span class="built_in">int</span>(stat.st_mtime)</span><br><span class="line">            mtime_ns = stat.st_mtime_ns % <span class="number">10</span>**<span class="number">9</span></span><br><span class="line"></span><br><span class="line">            entry = GitIndexEntry(ctime=(ctime_s, ctime_ns), mtime=(mtime_s, mtime_ns), dev=stat.st_dev, ino=stat.st_ino,</span><br><span class="line">                                  mode_type=<span class="number">0b1000</span>, mode_perms=<span class="number">0o644</span>, uid=stat.st_uid, gid=stat.st_gid,</span><br><span class="line">                                  fsize=stat.st_size, sha=sha, flag_assume_valid=<span class="literal">False</span>,</span><br><span class="line">                                  flag_stage=<span class="literal">False</span>, name=relpath)</span><br><span class="line">            index.entries.append(entry)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Write the index back</span></span><br><span class="line">    index_write(repo, index)</span><br></pre></td></tr></table></figure>

<h3 id="9-4-The-commit-command"><a href="#9-4-The-commit-command" class="headerlink" title="9.4. The commit command"></a>9.4. The commit command</h3><p>现在，我们已经修改了索引并实际暂存了更改，接下来只需要将这些更改转换为一个提交（commit）。这正是 <code>commit</code> 命令的作用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">argsp = argsubparsers.add_parser(<span class="string">&quot;commit&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;Record changes to the repository.&quot;</span>)</span><br><span class="line"></span><br><span class="line">argsp.add_argument(<span class="string">&quot;-m&quot;</span>,</span><br><span class="line">                   metavar=<span class="string">&quot;message&quot;</span>,</span><br><span class="line">                   dest=<span class="string">&quot;message&quot;</span>,</span><br><span class="line">                   <span class="built_in">help</span>=<span class="string">&quot;Message to associate with this commit.&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>为了做到这一点，我们首先需要将索引转换为一个树对象，生成并存储相应的提交对象，并将 HEAD 分支更新为新的提交（记住：分支仅仅是对提交的引用）。</p>
<p>在进入有趣的细节之前，我们需要读取 Git 的配置，以获取用户的姓名，并将其用作作者和提交者的名字。我们将使用与读取仓库配置时相同的 <code>configparser</code> 库。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gitconfig_read</span>():</span><br><span class="line">    xdg_config_home = os.environ[<span class="string">&quot;XDG_CONFIG_HOME&quot;</span>] <span class="keyword">if</span> <span class="string">&quot;XDG_CONFIG_HOME&quot;</span> <span class="keyword">in</span> os.environ <span class="keyword">else</span> <span class="string">&quot;~/.config&quot;</span></span><br><span class="line">    configfiles = [</span><br><span class="line">        os.path.expanduser(os.path.join(xdg_config_home, <span class="string">&quot;git/config&quot;</span>)),</span><br><span class="line">        os.path.expanduser(<span class="string">&quot;~/.gitconfig&quot;</span>)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    config = configparser.ConfigParser()</span><br><span class="line">    config.read(configfiles)</span><br><span class="line">    <span class="keyword">return</span> config</span><br></pre></td></tr></table></figure>

<p>以及一个简单的函数来获取并格式化用户身份：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gitconfig_user_get</span>(<span class="params">config</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;user&quot;</span> <span class="keyword">in</span> config:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;name&quot;</span> <span class="keyword">in</span> config[<span class="string">&quot;user&quot;</span>] <span class="keyword">and</span> <span class="string">&quot;email&quot;</span> <span class="keyword">in</span> config[<span class="string">&quot;user&quot;</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;config[<span class="string">&#x27;user&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]&#125;</span> &lt;<span class="subst">&#123;config[<span class="string">&#x27;user&#x27;</span>][<span class="string">&#x27;email&#x27;</span>]&#125;</span>&gt;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>现在是有趣的部分。我们首先需要根据索引构建一个树对象。这并不难，但需要注意的是，虽然索引是扁平的（它存储了工作区中所有文件的完整路径），而树是递归结构：它列出了文件或其他树。为了将索引“解扁平”成树，我们将按照以下步骤进行：</p>
<ol>
<li><strong>构建目录字典（哈希映射）</strong>：键是从工作区根目录开始的完整路径（例如 <code>assets/sprites/monsters/</code>），值是包含在该目录中的 <code>GitIndexEntry</code> 对象的列表。此时，字典仅包含文件：目录仅作为其键存在。</li>
<li><strong>遍历目录列表，按照从最深的目录到根目录的顺序进行</strong>：即从最深的目录开始，逐步向上遍历。这意味着我们将按完整路径的长度对目录进行排序，从最长的路径到最短的路径（父目录的路径显然总是比子目录短）。举个例子，假设我们从 <code>assets/sprites/monsters/</code> 开始：<ul>
<li>对于 <code>assets/sprites/monsters/</code>，我们创建一个树对象，包含 <code>cacodemon.png</code>、<code>imp.png</code> 和 <code>baron-of-hell.png</code>。</li>
<li>我们将新创建的树写入仓库，并将该树添加到父目录中。也就是说，此时 <code>assets/sprites/</code> 中将包含该树对象的 SHA-1 ID，树的名称为 <code>monsters</code>。</li>
</ul>
</li>
<li><strong>继续迭代下一个目录</strong>：比如我们到 <code>assets/sprites/keys</code>，在其中找到 <code>red.png</code>、<code>blue.png</code> 和 <code>yellow.png</code>，创建树、存储树、将树的 SHA-1 添加到 <code>assets/sprites/</code> 中，依此类推。</li>
</ol>
<p>最终，通过这个过程，我们将索引中的文件和目录重新组织成一个树结构，并能够将其保存为一个 Git 树对象。</p>
<p>因为树是递归的，所以我们最后构建的树，必定是根目录的树（因为它的键的长度为 0），它最终会引用所有其他的树，因此它将是我们需要的唯一一棵树。我们只需返回它的 SHA-1，就可以完成。</p>
<p>由于这个过程可能看起来有点复杂，让我们通过一个完整的示例来详细演示——如果你愿意，随时可以跳过。最初，我们从索引中构建的字典看起来是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">contents[&quot;assets/sprites/monsters&quot;] =</span><br><span class="line">  [ cacodemon.png : GitIndexEntry</span><br><span class="line">  , imp.png : GitIndexEntry</span><br><span class="line">  , baron-of-hell.png : GitIndexEntry ]</span><br><span class="line">contents[&quot;assets/sprites/keys&quot;] =</span><br><span class="line">  [ red.png : GitIndexEntry</span><br><span class="line">  , blue.png : GitIndexEntry</span><br><span class="line">  , yellow.png : GitIndexEntry ]</span><br><span class="line">contents[&quot;assets/sprites/&quot;] =</span><br><span class="line">  [ hero.png : GitIndexEntry ]</span><br><span class="line">contents[&quot;assets/&quot;] = [] # No files in here</span><br><span class="line">contents[&quot;&quot;] = # Root!</span><br><span class="line">  [ README: GitIndexEntry ]</span><br></pre></td></tr></table></figure>

<p>我们按键长度降序遍历它。我们遇到的第一个键是最长的，也就是 <code>assets/sprites/monsters</code>。我们从它的内容构建一个新的树对象，将三个文件名（<code>cacodemon.png</code>、<code>imp.png</code>、<code>baron-of-hell.png</code>）与它们相应的 blob 关联起来（树叶存储的数据比索引少——只是路径、模式和 blob。因此，将条目转换成这种方式很容易）。</p>
<p>请注意，我们不需要关心存储这些文件的内容：<code>wyag add </code>会在需要时创建相应的 blobs。我们需要将我们创建的树存储到对象库中，但可以假设 blobs 已经存在了。</p>
<p>假设我们新创建的树的哈希值，从直接位于 <code>assets/sprites/monsters</code> 中的索引条目生成，哈希值是 <code>426f894781bc3c38f1d26f8fd2c7f38ab8d21763</code>。我们修改字典，将这个新的树对象添加到该目录的父级，就像这样，现在剩下需要遍历的部分看起来是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">contents[&quot;assets/sprites/keys&quot;] = # &lt;- unmodified.</span><br><span class="line">  [ red.png : GitIndexEntry</span><br><span class="line">  , blue.png : GitIndexEntry</span><br><span class="line">  , yellow.png : GitIndexEntry ]</span><br><span class="line">contents[&quot;assets/sprites/&quot;] =</span><br><span class="line">  [ hero.png : GitIndexEntry</span><br><span class="line">  , monsters : Tree 426f894781bc3c38f1d26f8fd2c7f38ab8d21763 ] &lt;- look here</span><br><span class="line">contents[&quot;assets/&quot;] = [] # empty</span><br><span class="line">contents[&quot;&quot;] = # Root!</span><br><span class="line">  [ README: GitIndexEntry ]</span><br></pre></td></tr></table></figure>

<p>我们对下一个最长的键 <code>assets/sprites/keys</code> 做同样的操作，生成一个哈希值为 <code>b42788e087b1e94a0e69dcb7a4a243eaab802bb2 </code>的树，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">contents[&quot;assets/sprites/&quot;] =</span><br><span class="line">  [ hero.png : GitIndexEntry</span><br><span class="line">  ,  monsters : Tree 426f894781bc3c38f1d26f8fd2c7f38ab8d21763</span><br><span class="line">  , keys : Tree b42788e087b1e94a0e69dcb7a4a243eaab802bb2 ]</span><br><span class="line">contents[&quot;assets/&quot;] = [] # empty</span><br><span class="line">contents[&quot;&quot;] = # Root!</span><br><span class="line">  [ README: GitIndexEntry ]</span><br></pre></td></tr></table></figure>

<p>然后，我们从 <code>assets/sprites </code> 生成哈希值为 <code>6364113557ed681d775ccbd3c90895ed276956a2</code> 的树，该树现在包含我们的两个子树和 hero.png 文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">contents[&quot;assets/&quot;] = [</span><br><span class="line">  sprites: Tree 6364113557ed681d775ccbd3c90895ed276956a2 ]</span><br><span class="line">contents[&quot;&quot;] = # Root!</span><br><span class="line">  [ README: GitIndexEntry ]</span><br></pre></td></tr></table></figure>

<p>接着，<code>assets</code> 变成了哈希值为 <code>4d35513cb6d2a816bc00505be926624440ebbddd </code>的树，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contents[&quot;&quot;] = # Root!</span><br><span class="line">  [ README: GitIndexEntry,</span><br><span class="line">    assets: 4d35513cb6d2a816bc00505be926624440ebbddd]</span><br></pre></td></tr></table></figure>

<p>我们从最后一个键（包含 README blob 和 <code>assets</code> 子树）创建一个树，哈希值为 <code>9352e52ff58fa9bf5a750f090af64c09fa6a3d93</code>。这就是我们的返回值：包含与索引内容相同的树。</p>
<p>这是实际的函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tree_from_index</span>(<span class="params">repo, index</span>):</span><br><span class="line">    contents = <span class="built_in">dict</span>()</span><br><span class="line">    contents[<span class="string">&quot;&quot;</span>] = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Enumerate entries, and turn them into a dictionary where keys</span></span><br><span class="line">    <span class="comment"># are directories, and values are lists of directory contents.</span></span><br><span class="line">    <span class="keyword">for</span> entry <span class="keyword">in</span> index.entries:</span><br><span class="line">        dirname = os.path.dirname(entry.name)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># We create all dictonary entries up to root (&quot;&quot;).  We need</span></span><br><span class="line">        <span class="comment"># them *all*, because even if a directory holds no files it</span></span><br><span class="line">        <span class="comment"># will contain at least a tree.</span></span><br><span class="line">        key = dirname</span><br><span class="line">        <span class="keyword">while</span> key != <span class="string">&quot;&quot;</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> key <span class="keyword">in</span> contents:</span><br><span class="line">                contents[key] = <span class="built_in">list</span>()</span><br><span class="line">            key = os.path.dirname(key)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># For now, simply store the entry in the list.</span></span><br><span class="line">        contents[dirname].append(entry)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Get keys (= directories) and sort them by length, descending.</span></span><br><span class="line">    <span class="comment"># This means that we&#x27;ll always encounter a given path before its</span></span><br><span class="line">    <span class="comment"># parent, which is all we need, since for each directory D we&#x27;ll</span></span><br><span class="line">    <span class="comment"># need to modify its parent P to add D&#x27;s tree.</span></span><br><span class="line">    sorted_paths = <span class="built_in">sorted</span>(contents.keys(), key=<span class="built_in">len</span>, reverse=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># This variable will store the current tree&#x27;s SHA-1.  After we&#x27;re</span></span><br><span class="line">    <span class="comment"># done iterating over our dict, it will contain the hash for the</span></span><br><span class="line">    <span class="comment"># root tree.</span></span><br><span class="line">    sha = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># We ge through the sorted list of paths (dict keys)</span></span><br><span class="line">    <span class="keyword">for</span> path <span class="keyword">in</span> sorted_paths:</span><br><span class="line">        <span class="comment"># Prepare a new, empty tree object</span></span><br><span class="line">        tree = GitTree()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Add each entry to our new tree, in turn</span></span><br><span class="line">        <span class="keyword">for</span> entry <span class="keyword">in</span> contents[path]:</span><br><span class="line">            <span class="comment"># An entry can be a normal GitIndexEntry read from the</span></span><br><span class="line">            <span class="comment"># index, or a tree we&#x27;ve created.</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(entry, GitIndexEntry): <span class="comment"># Regular entry (a file)</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># We transcode the mode: the entry stores it as integers,</span></span><br><span class="line">                <span class="comment"># we need an octal ASCII representation for the tree.</span></span><br><span class="line">                leaf_mode = <span class="string">f&quot;<span class="subst">&#123;entry.mode_type:02o&#125;</span><span class="subst">&#123;entry.mode_perms:04o&#125;</span>&quot;</span>.encode(<span class="string">&quot;ascii&quot;</span>)</span><br><span class="line">                leaf = GitTreeLeaf(mode = leaf_mode, path=os.path.basename(entry.name), sha=entry.sha)</span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># Tree.  We&#x27;ve stored it as a pair: (basename, SHA)</span></span><br><span class="line">                leaf = GitTreeLeaf(mode = <span class="string">b&quot;040000&quot;</span>, path=entry[<span class="number">0</span>], sha=entry[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">            tree.items.append(leaf)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Write the new tree object to the store.</span></span><br><span class="line">        sha = object_write(tree, repo)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Add the new tree hash to the current dictionary&#x27;s parent, as</span></span><br><span class="line">        <span class="comment"># a pair (basename, SHA)</span></span><br><span class="line">        parent = os.path.dirname(path)</span><br><span class="line">        base = os.path.basename(path) <span class="comment"># The name without the path, eg main.go for src/main.go</span></span><br><span class="line">        contents[parent].append((base, sha))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sha</span><br></pre></td></tr></table></figure>

<p>这部分是最难的；希望讲解足够清楚。从这里开始，创建提交对象并更新 HEAD 就会简单得多。请记住，这个函数的作用是构建并存储尽可能多的树对象，以表示索引的状态，并返回根树的 SHA-1 哈希值。</p>
<p>创建提交对象的函数非常简单，它只需要几个参数：树的哈希值、父提交的哈希值、作者身份（字符串）、时间戳和时区偏移量，以及提交消息：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">commit_create</span>(<span class="params">repo, tree, parent, author, timestamp, message</span>):</span><br><span class="line">    commit = GitCommit() <span class="comment"># Create the new commit object.</span></span><br><span class="line">    commit.kvlm[<span class="string">b&quot;tree&quot;</span>] = tree.encode(<span class="string">&quot;ascii&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> parent:</span><br><span class="line">        commit.kvlm[<span class="string">b&quot;parent&quot;</span>] = parent.encode(<span class="string">&quot;ascii&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Trim message and add a trailing \n</span></span><br><span class="line">    message = message.strip() + <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="comment"># Format timezone</span></span><br><span class="line">    offset = <span class="built_in">int</span>(timestamp.astimezone().utcoffset().total_seconds())</span><br><span class="line">    hours = offset // <span class="number">3600</span></span><br><span class="line">    minutes = (offset % <span class="number">3600</span>) // <span class="number">60</span></span><br><span class="line">    tz = <span class="string">&quot;&#123;&#125;&#123;:02&#125;&#123;:02&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;+&quot;</span> <span class="keyword">if</span> offset &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="string">&quot;-&quot;</span>, hours, minutes)</span><br><span class="line"></span><br><span class="line">    author = author + timestamp.strftime(<span class="string">&quot; %s &quot;</span>) + tz</span><br><span class="line"></span><br><span class="line">    commit.kvlm[<span class="string">b&quot;author&quot;</span>] = author.encode(<span class="string">&quot;utf8&quot;</span>)</span><br><span class="line">    commit.kvlm[<span class="string">b&quot;committer&quot;</span>] = author.encode(<span class="string">&quot;utf8&quot;</span>)</span><br><span class="line">    commit.kvlm[<span class="literal">None</span>] = message.encode(<span class="string">&quot;utf8&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> object_write(commit, repo)</span><br></pre></td></tr></table></figure>

<p>剩下要编写的就是 <code>cmd_commit</code>，它是 <code>wyag commit</code> 命令的桥接函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cmd_commit</span>(<span class="params">args</span>):</span><br><span class="line">    repo = repo_find()</span><br><span class="line">    index = index_read(repo)</span><br><span class="line">    <span class="comment"># Create trees, grab back SHA for the root tree.</span></span><br><span class="line">    tree = tree_from_index(repo, index)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Create the commit object itself</span></span><br><span class="line">    commit = commit_create(repo,</span><br><span class="line">                           tree,</span><br><span class="line">                           object_find(repo, <span class="string">&quot;HEAD&quot;</span>),</span><br><span class="line">                           gitconfig_user_get(gitconfig_read()),</span><br><span class="line">                           datetime.now(),</span><br><span class="line">                           args.message)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Update HEAD so our commit is now the tip of the active branch.</span></span><br><span class="line">    active_branch = branch_get_active(repo)</span><br><span class="line">    <span class="keyword">if</span> active_branch: <span class="comment"># If we&#x27;re on a branch, we update refs/heads/BRANCH</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(repo_file(repo, os.path.join(<span class="string">&quot;refs/heads&quot;</span>, active_branch)), <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> fd:</span><br><span class="line">            fd.write(commit + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>: <span class="comment"># Otherwise, we update HEAD itself.</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(repo_file(repo, <span class="string">&quot;HEAD&quot;</span>), <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> fd:</span><br><span class="line">            fd.write(<span class="string">&quot;\n&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>And we’re done!</p>
<h2 id="10-Final-words"><a href="#10-Final-words" class="headerlink" title="10. Final words"></a>10. Final words</h2><h3 id="10-1-Comments-feedback-and-issues"><a href="#10-1-Comments-feedback-and-issues" class="headerlink" title="10.1. Comments, feedback and issues"></a>10.1. Comments, feedback and issues</h3><p>此页面没有评论系统 :) 您可以通过电子邮件联系我：<a href="thibault@thb.lt">thibault@thb.lt</a>。我也可以在 Mastodon 上找到，用户名是 <a target="_blank" rel="noopener" href="https://toad.social/@thblt">@thblt@toad.social</a>，或者在 Twitter 上 <a target="_blank" rel="noopener" href="https://x.com/ThbPlg">@ThbPlg</a>，有时也会出现在 Libera 的 IRC 频道，昵称是 <code>thblt</code>。</p>
<p>本文的源码托管在 <a target="_blank" rel="noopener" href="https://github.com/thblt/write-yourself-a-git">GitHub</a> 上。欢迎通过 GitHub 直接提交问题报告和拉取请求，或者如果您愿意，也可以通过电子邮件与我联系。</p>
<h3 id="10-2-License"><a href="#10-2-License" class="headerlink" title="10.2. License"></a>10.2. License</h3><p>本文在创作共用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">BY-NC-SA 4.0 许可协议</a> 下发布。程序本身也根据 GNU 通用公共许可证 3.0 版，或根据您的选择，任何该许可证的后续版本进行许可。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="1-l33t-h4x0r"><a href="#1-l33t-h4x0r" class="headerlink" title="1. l33t h4x0r"></a>1. l33t h4x0r</h3><p><strong>“l33t h4x0r”</strong> 是一种 <strong>黑客文化（hacker culture）</strong> 里的 <strong>Leetspeak（精英语）</strong> 表达方式，它的原意是 **”leet hacker”**，即 <strong>elite hacker（精英黑客）</strong>。</p>
<p>在 Leetspeak 里：</p>
<ul>
<li><strong>l33t</strong> &#x3D; <strong>leet</strong>（elite 的变形，意为“精英”）</li>
<li><strong>h4x0r</strong> &#x3D; <strong>hacker</strong>（haxor 是 hacker 的变体，”4” 代替 “a”，”0” 代替 “o”）</li>
</ul>
<p>这个词通常用来形容那些技术高超的黑客（有时也带有一点戏谑或自嘲的意味），或者用来调侃那些<strong>自认为是黑客</strong>但实际上技术并不高的人。</p>
<h3 id="2-code-1"><a href="#2-code-1" class="headerlink" title="2. code 1"></a>2. code 1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> libwyag</span><br><span class="line">libwyag.main()</span><br></pre></td></tr></table></figure>

<p>这段代码是 <strong>wyag</strong> 可执行文件的内容。我们可以逐行解释：</p>
<ol>
<li><p><code>#!/usr/bin/env python3</code><br>这一行是 <strong>shebang</strong>（或称作 hashbang），它告诉操作系统应该使用哪个解释器来运行这个文件。在这里，它指定了 <strong>python3</strong> 作为解释器，并使用 <code>env</code> 命令来确保使用系统中可用的 Python 3 版本。</p>
</li>
<li><p><code>import libwyag</code><br>这行代码导入了我们之前提到的 <strong>libwyag.py</strong> 库文件，这个文件包含了实际的逻辑和功能。导入后，<strong>wyag</strong> 可以调用库中的函数和类。</p>
</li>
<li><p><code>libwyag.main()</code><br>这一行调用了 <strong>libwyag.py</strong> 中的 <code>main()</code> 函数。通常，<code>main()</code> 函数是程序的入口点，它会处理主要的任务和逻辑。在这里，它可能会启动执行 Git 核心命令的相关功能。</p>
</li>
</ol>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/">上一页</a></div><div class="pagination-next"><a href="/page/3/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link is-current" href="/page/2/">2</a></li><li><a class="pagination-link" href="/page/3/">3</a></li><li><a class="pagination-link" href="/page/4/">4</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.jpg" alt="Rossignol"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Rossignol</p><p class="is-size-6 is-block">NaN</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Mars</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives/"><p class="title">34</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories/"><p class="title">18</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags/"><p class="title">17</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/0xRossignol" target="_blank" rel="me noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/0xRossignol"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Golang/"><span class="level-start"><span class="level-item">Golang</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/Golang/basics/"><span class="level-start"><span class="level-item">basics</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/Java/basics/"><span class="level-start"><span class="level-item">basics</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/Java/basics/Thinking-in-Java/"><span class="level-start"><span class="level-item">Thinking in Java</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/Linux/Arch-Linux/"><span class="level-start"><span class="level-item">Arch Linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/OS/"><span class="level-start"><span class="level-item">OS</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Rust/"><span class="level-start"><span class="level-item">Rust</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">Rust程序设计语言</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Software-Construction/"><span class="level-start"><span class="level-item">Software Construction</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul><li><a class="level is-mobile" href="/categories/Software-Construction/MIT6-031/"><span class="level-start"><span class="level-item">MIT6.031</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/TypeScript/"><span class="level-start"><span class="level-item">TypeScript</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/test/"><span class="level-start"><span class="level-item">test</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/toy-projects/"><span class="level-start"><span class="level-item">toy projects</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%85%AB%E8%82%A1/"><span class="level-start"><span class="level-item">八股</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%85%AB%E8%82%A1/JavaSE/"><span class="level-start"><span class="level-item">JavaSE</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%85%AB%E8%82%A1/Java%E9%9B%86%E5%90%88/"><span class="level-start"><span class="level-item">Java集合</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-05-16T14:42:26.000Z">2025-05-16</time></p><p class="title"><a href="/2025/05/16/Rust/The%20Rust%20Programming%20Language/01.3%20Hello%20Cargo/">1.3 Hello,Cargo!</a></p><p class="categories"><a href="/categories/Rust/">Rust</a> / <a href="/categories/Rust/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/">Rust程序设计语言</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-05-16T08:53:03.326Z">2025-05-16</time></p><p class="title"><a href="/2025/05/16/Rust/The%20Rust%20Programming%20Language/02%20%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E7%8C%9C%E6%95%B0%E6%B8%B8%E6%88%8F/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-05-16T08:38:25.809Z">2025-05-16</time></p><p class="title"><a href="/2025/05/16/Rust/The%20Rust%20Programming%20Language/22.5%20E/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-05-15T14:39:59.117Z">2025-05-15</time></p><p class="title"><a href="/2025/05/15/%E5%85%AB%E8%82%A1/Java/%E9%9B%86%E5%90%88/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/LinkedHashMap%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-05-15T14:39:59.117Z">2025-05-15</time></p><p class="title"><a href="/2025/05/15/%E5%85%AB%E8%82%A1/Java/%E9%9B%86%E5%90%88/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/HashMap%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"> </a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2025/05/"><span class="level-start"><span class="level-item">五月 2025</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/04/"><span class="level-start"><span class="level-item">四月 2025</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/03/"><span class="level-start"><span class="level-item">三月 2025</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/02/"><span class="level-start"><span class="level-item">二月 2025</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/01/"><span class="level-start"><span class="level-item">一月 2025</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/12/"><span class="level-start"><span class="level-item">十二月 2024</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Arch-Linux/"><span class="tag">Arch Linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/English/"><span class="tag">English</span><span class="tag">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Golang/"><span class="tag">Golang</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OS/"><span class="tag">OS</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Rust/"><span class="tag">Rust</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Software-Construction/"><span class="tag">Software Construction</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TypeScript/"><span class="tag">TypeScript</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/git/"><span class="tag">git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/python/"><span class="tag">python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/test/"><span class="tag">test</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/toy-projects/"><span class="tag">toy projects</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%B8%AD%E6%96%87/"><span class="tag">中文</span><span class="tag">13</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%85%AB%E8%82%A1/"><span class="tag">八股</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B1%87%E7%BC%96/"><span class="tag">汇编</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BF%BB%E8%AF%91/"><span class="tag">翻译</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="MyBlog" height="28"></a><p class="is-size-7"><span>&copy; 2025 Rossignol</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>